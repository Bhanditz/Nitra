using N2;
using N2.Internal;

using Nemerle;
using Nemerle.Collections;
using Nemerle.Imperative;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Threading;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;

namespace N2.VisualStudio
{
  class N2Interface
  {
    //static standardAssemblies = HashSet(["Nemerle.dll", "Nemerdsle.Compiler.dll", "N2.dll", "N2.Compiler.dll"]);

    mutable _modules : list[string];
    _ruleDescriptor : RuleDescriptor;
    _parserHost     : ParserHost;

    public this(language : Language)
    {
      _modules = language.Modules;

      def assemblyScope = List();
      assemblyScope.Add(typeof(Whitespaces).Assembly); // add N2.Core reference
      def startGrammar = language.Grammar;
      def startRule    = language.StartRule;
      foreach (file in _modules)
      {
        def assembly = Assembly.LoadFrom(file);
        assemblyScope.Add(assembly);

        // TODO: FIXME: Могут существовать StaticDescriptor-ы с одинаковым полным именем.
        // В мапе нужно хранить их список, а не конекретные экзепляры.
        when (_ruleDescriptor == null)
          foreach (grammar when grammar.FullName == startGrammar in GrammarDescriptor.GetDescriptors(assembly))
            foreach (rule when rule.Name == startRule in grammar.Rules)
              _ruleDescriptor = rule;
      }
      _parserHost = ParserHost(() => assemblyScope);
    }

    public Parse(sourceSnapshot : SourceSnapshot, token : CancellationToken) : Parser
    {
      assert(_ruleDescriptor != null);
      
      match (_ruleDescriptor)
      {
        | SimpleRuleDescriptor     as rd => _parserHost.DoParsing(sourceSnapshot, rd, token)
        | ExtensibleRuleDescriptor as rd => _parserHost.DoParsing(sourceSnapshot, rd, token)
        | _ => assert(false)
      }
    }
  }
}
