using N2;
using N2.Internal;

using Nemerle;
using Nemerle.Collections;
using Nemerle.Imperative;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Threading;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;

namespace N2.VisualStudio
{
  class N2Interface
  {
    //static standardAssemblies = HashSet(["Nemerle.dll", "Nemerdsle.Compiler.dll", "N2.dll", "N2.Compiler.dll"]);

    mutable _modules : list[string];
    _ruleDescriptor : RuleDescriptor;
    _parserHost     : ParserHost;

    public this(language : Language)
    {
      _modules = language.Modules;
      _parserHost = ParserHost();

      def startGrammar = language.Grammar;
      def startRule    = language.StartRule;

      foreach (file in _modules)
      {
        def assembly = Assembly.LoadFrom(file);
        // TODO: FIXME: Могут существовать StaticDescriptor-ы с одинаковым полным именем.
        // В мапе нужно хранить их список, а не конекретные экзепляры.
        foreach (grammar when grammar.FullName == startGrammar in GrammarDescriptor.GetDescriptors(assembly))
          foreach (rule when rule.Name == startRule in grammar.Rules)
          {
            _ruleDescriptor = rule;
            return;
          }
      }
    }

    public Parse(sourceSnapshot : SourceSnapshot, token : CancellationToken) : Parser
    {
      assert(_ruleDescriptor != null);

      match (_ruleDescriptor)
      {
        | SimpleRuleDescriptor     as rd => _parserHost.DoParsing(sourceSnapshot, rd, token)
        | ExtensibleRuleDescriptor as rd => _parserHost.DoParsing(sourceSnapshot, rd, token)
        | _ => assert(false)
      }
    }
  }
}
