using N2;
using N2.Internal;
using N2.Runtime;

using Nemerle;
using Nemerle.Imperative;
using Nemerle.Assertions;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;

using Microsoft.VisualStudio.Text;
using Microsoft.VisualStudio.Text.Classification;

namespace N2.VisualStudio.Coloring
{
  internal sealed class ClassificationCache
  {
    private         _linesToCache : int;
    private mutable _cachedSpan   : NToken;
    private         _cacheIndex   : array[int * int]; // array of tuple (StartPos, Index in _spanCache)
    private         _cache        : List[SpanInfo];

    public this(linesToCache : int)
      requires linesToCache > 0
    {
      _linesToCache = linesToCache;
      _cachedSpan   = NToken();
      _cacheIndex   = array(10);
      _cache        = List(linesToCache * 4);
    }

    public Predict([NotNull] eventArgs : TextContentChangedEventArgs) : void
    {
      _cachedSpan = NToken();
    }

    public GetSpans(span : SnapshotSpan, [NotNull] parseResult : Parser) : List[SpanInfo]
    {
      unless (IsCacheContainsSpan(span))
        FillCache(span, parseResult);
      GetSpansFromCache(span)
    }

    private IsCacheContainsSpan(span : SnapshotSpan) : bool
    {
      _cachedSpan.StartPos <= span.Start.Position && span.End.Position <= _cachedSpan.EndPos
    }

    private GetSpansFromCache(span : SnapshotSpan) : List[SpanInfo]
    {
      def startPos = span.Start.Position;
      def endPos   = span.End.Position;

      def result = List();
      mutable index = FindSpanCacheIndex(span);
      while (index < _cache.Count && _cache[index].Location.EndPos < startPos)
        ++index;
      while (index < _cache.Count && _cache[index].Location.StartPos < endPos)
      {
        result.Add(_cache[index]);
        ++index;
      }
      result
    }

    private FindSpanCacheIndex(span : SnapshotSpan) : int
    {
      mutable index = _cacheIndex[0][1];
      for(mutable i = 1; i < _cacheIndex.Length; ++i)
      {
        def (startPos, nextIndex) = _cacheIndex[i];
        when (span.Start.Position < startPos)
          return index;
        index = nextIndex;
      }
      index
    }

    private FillCache(span : SnapshotSpan, parseResult : Parser) : void
    {
      _cache.Clear();
      _cachedSpan = GetCacheWindow(span);
      parseResult.GetSpans(_cachedSpan.StartPos, _cachedSpan.EndPos, _cache);
      _cache.Sort(
        fun (a : SpanInfo, b : SpanInfo)
        {
          def startPos1 = a.Location.StartPos;
          def startPos2 = b.Location.StartPos;
          if (startPos1 < startPos2) -1
          else if (startPos1 > startPos2) +1
          else
          {
            def endPos1 = a.Location.EndPos;
            def endPos2 = b.Location.EndPos;
            if (endPos1 < endPos2) -1
            else if (endPos1 > endPos2) +1
            else 0
          }
        });
      FillCacheIndex();
    }

    private FillCacheIndex() : void
    {
      for(mutable i = 0; i < _cacheIndex.Length; ++i)
      {
        def index = _cache.Count * i / _cacheIndex.Length;
        _cacheIndex[i] = (_cache[index].Location.StartPos, index);
      }
    }

    private GetCacheWindow(span : SnapshotSpan) : NToken
    {
      def (startLineNumber, _) = span.Start.GetLineAndColumn();
      def endLineNumber        = Math.Min(startLineNumber + _linesToCache, span.Snapshot.LineCount) - 1;
      def startLine            = span.Snapshot.GetLineFromLineNumber(startLineNumber);
      def endLine              = span.Snapshot.GetLineFromLineNumber(endLineNumber);
      NToken(startLine.Start.Position, endLine.End.Position)
    }
  }
}
