using Microsoft.VisualStudio.Text.Adornments;
using Microsoft.VisualStudio.Text.Tagging;
using N2;
using N2.Internal;

using Nemerle;
using Nemerle.Imperative;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using Microsoft.VisualStudio.Shell;
using Microsoft.VisualStudio.Shell.Interop;
using Microsoft.VisualStudio.Text;

using System;
using System.Diagnostics;
using System.IO;
using System.Collections.Generic;
using System.Linq;

namespace N2.VisualStudio
{
  public enum MessageType
  {
    | Info = 0
    | Hint = 1
    | Warning = 2
    | Error = 3
  }

  public partial module Utils
  {
    public GetLineAndColumn(this snapshot : ITextSnapshot, position : int) : int * int
    {
      def line = snapshot.GetLineFromPosition(position);

      (line.LineNumber, position - line.Start.Position)
    }

    public GetLineAndColumn(this point : SnapshotPoint) : int * int
    {
      point.Snapshot.GetLineAndColumn(point.Position)
    }

    public static GetPosition(this snapshot : ITextSnapshot, lineNumber : int, columnIndex : int) : int
    {
      snapshot.GetLineFromLineNumber(lineNumber).Start.Position + columnIndex;
    }

    public ShowMessage(this serviceProvider : IServiceProvider, message : string, messageType : MessageType) : void
    {
      def icon =
        match (messageType)
        {
          | MessageType.Hint    => OLEMSGICON.OLEMSGICON_INFO
          | MessageType.Info    => OLEMSGICON.OLEMSGICON_INFO
          | MessageType.Warning => OLEMSGICON.OLEMSGICON_WARNING
          | MessageType.Error
          | _                   => OLEMSGICON.OLEMSGICON_CRITICAL
        };
      def buttons = OLEMSGBUTTON.OLEMSGBUTTON_OK;
      def defaultButton = OLEMSGDEFBUTTON.OLEMSGDEFBUTTON_FIRST;
      _ = VsShellUtilities.ShowMessageBox(serviceProvider, message, Constants.ProductName, icon, buttons, defaultButton);
    }

    public GetLanguageForTextBuffer(this globalConfig : IN2GlobalConfig, buffer : ITextBuffer, errorProviderFactory : IErrorProviderFactory) : ValueOption[Language]
    {
      def path = buffer.GetFilePath();
      when (string.IsNullOrEmpty(path))
        return VNone();

      def ext = Path.GetExtension(path);
      when (string.IsNullOrEmpty(ext))
        return VNone();

      def language = globalConfig.GetLanguageByExtension(ext);

      when (language is VSome(language))
      {
        unless (buffer.ContentType.Equals(language.ContentType))
          buffer.ChangeContentType(language.ContentType, null);

        unless (buffer.Properties.ContainsProperty(typeof(Language)))
        {
          buffer.Properties.AddProperty(typeof(Language), language);

          def getText(snapshot : ITextSnapshot) : string
          {
            def timer = System.Diagnostics.Stopwatch.StartNew();
            def text = snapshot.GetText();
            Trace.WriteLine("snapshot.GetText() took: " + timer.Elapsed);
            text
          }

          buffer.Changed +=
            fun (_ : object, a : TextContentChangedEventArgs) : void
            {
              Reparse(language, buffer, getText(a.After), errorProviderFactory);
            };
          Reparse(language, buffer, getText(buffer.CurrentSnapshot), errorProviderFactory);
        }
      }

      language
    }

    Reparse(language : Language, buffer : ITextBuffer,  code : string, errorProviderFactory : IErrorProviderFactory) : void
    {
      def timer = System.Diagnostics.Stopwatch.StartNew();
      def path = buffer.GetFilePath();
      def parseResult = language.Parse(SourceSnapshot(code, 0, path));
      timer.Stop();
      def info = "Parsing took: " + timer.Elapsed + "   Mb/sec:" + (code.Length / 1024.0 / 1024.0 / timer.Elapsed.TotalSeconds);
      N2Package.Instance.SetStatusBarText(info);
      Trace.WriteLine(info);

      buffer.Properties[typeof(Parser)] = parseResult;
      
      def errorListHelper =
        if (buffer.Properties.ContainsProperty(typeof(ErrorListHelper)))
          buffer.Properties[typeof(ErrorListHelper)] :> ErrorListHelper
        else
        {
          def result = ErrorListHelper();
          buffer.Properties[typeof(ErrorListHelper)] = result;
          result
        };
      def errorListProvider = errorListHelper.GetErrorListProvider();
        
      errorListProvider.Tasks.Clear();
      def errors = parseResult.GetErrors();
      
      errorListProvider.SuspendRefresh();
      try
      {
        def tasks = errorListProvider.Tasks;
        def snapshot = buffer.CurrentSnapshot;
        def squiggles = errorProviderFactory.GetErrorTagger(buffer);
        _ = squiggles.RemoveTagSpans(_ => true);

        foreach (e in errors)
        {
          def error = ErrorTask();
          def loc = e.Location;
          error.ErrorCategory = TaskErrorCategory.Message;
          error.Category = TaskCategory.CodeSense;
          error.Text = e.Message;
          error.ErrorCategory = TaskErrorCategory.Error;
          def (line, col) = loc.StartLineColumn;
          error.Line = line - 1;
          error.Column = col - 1;
          assert2(IO.File.Exists(loc.Source.FileName));
          error.Document = loc.Source.FileName;
          error.Navigate += errorListHelper.NavigateDocument;
          _ = tasks.Add(error);
          
          def tspan = snapshot.CreateTrackingSpan(Span(loc.StartPos, loc.Length), SpanTrackingMode.EdgeInclusive);
          _ = squiggles.CreateTagSpan(tspan, ErrorTag(PredefinedErrorTypeNames.SyntaxError, e.Message));
        }
      }
      finally errorListProvider.ResumeRefresh();
    }
  }
}
