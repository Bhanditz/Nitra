using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Parser;
using Nemerle.Imperative;

using System;
using System.Collections.Generic;
using SCG = System.Collections.Generic;
using System.Console;
using System.Linq;

[ParserGrammar(Options = EmitDebugSources,
  parsergrammar
  {
  }
)]
public abstract class EmptyParser
{
}

// L<I?,I?,I?,I?,I?,I?,D?>((y,m,d,h,i,s) => 
[ParserGrammar(Options = EmitDebugSources,
  parsergrammar
  {
    any = ['\u0000'..'\uFFFF'];

    [StartRule, Ast(Body)]
    Start : Ast = s Body !any;
    
    [Ast(t1, t2, types, t4, t5, t6, idents, t8, t9)]
    Body : Ast = "L"s "<"s (Type, ","s)* ">"s "("s "("s (Identifier, ","s)* ")"s "=>"s;
    
    [Ast(ident, nullable)]
    Type : Ast = Identifier s "?"? s;
    
    
    #region Identifier
    
    IdentifierFirst = ['A'..'Z', 'a'..'z', '_'..'_'];
    IdentifierNext  = IdentifierFirst | ['0'..'9'];
    IdentifierBody  = IdentifierFirst IdentifierNext*;
    Identifier : NToken = IdentifierBody s;

    #endregion
    
    #region Line terminators

    newLineCharacter   = '\n'
                       | '\r'
                       | '\u2028'    /*  line separator       */
                       | '\u2029';   /*  paragraph separator  */
    newLine   = "\r\n" | newLineCharacter;

    #endregion

    #region White space

    whitespace = [Zs]
              | '\t'
              | '\v'        /*  vertial tab          */
              | '\f';       /*  form feed            */

    #endregion

    #region Spacer

    space = whitespace | newLine;

    s : void = space*;                      /* optional spacer          */
    S : void = !IdentifierNext s; /* identifier break spacer  */
    #endregion
  }
)]
public abstract class LambdaParser
{
}

[assembly: Nemerle.Parser.N2Source("CalcGrammar.n2")]

module Program
{
  Main() : void
  {
    def print(text)
    {
      def parser = CalcGrammar.GrammarImpl();
      match (parser.ParseStart(text))
      {
        | None      =>
          WriteLine($"Fail: \"$text\"");
          def (pos, tokens) = parser.Parser.GetErrors();
          def (line, pos) = parser.ParsingSource.PositionToLineColumn(pos);
          foreach (token in tokens)
            WriteLine($"  $line:$pos expected \"$(token.Name)\" in rule $(token.Rule.Grammar.Name).$(token.Rule.Name)");

        | Some(CalcGrammar.Start.Ast(ast)) =>
          def printAst(ast : CalcGrammar.Expr)
          {
            match (ast)
            {
              | CalcGrammar.Rounds.Ast(_, ast, _) => $"( $(printAst(ast)) )"
              | CalcGrammar.Seq.Ast(_, asts, _)   => $<#{ ..$(asts; " ; "; printAst(_)) }#>
              | CalcGrammar.Num.Ast(num)          => $"$(num.GetText((num :> NumParser.Number.Ast).number))"
              | CalcGrammar.Neg.Ast(_, v)         => $"[ - $(printAst(v)) ]"
              | CalcGrammar.PrefixDec.Ast(_, v)   => $"[ -- $(printAst(v)) ]"
              | CalcGrammar.PostfixDec.Ast(v, _)  => $"[ $(printAst(v)) -- ]"
              | CalcGrammar.Add.Ast(l, _, r)      => $"[ $(printAst(l)) + $(printAst(r)) ]"
              | CalcGrammar.Sub.Ast(l, _, r)      => $"[ $(printAst(l)) - $(printAst(r)) ]"
              | CalcGrammar.Mul.Ast(l, _, r)      => $"[ $(printAst(l)) * $(printAst(r)) ]"
              | CalcGrammar.Div.Ast(l, _, r)      => $"[ $(printAst(l)) / $(printAst(r)) ]"
              | CalcGrammar.Mod.Ast(l, _, r)      => $"[ $(printAst(l)) % $(printAst(r)) ]"
              | CalcGrammar.Pow.Ast(l, _, r)      => $"[ $(printAst(l)) ^ $(printAst(r)) ]"
              | CalcGrammar.Coalescing.Ast(l, _, r) => $"[ $(printAst(l)) ?? $(printAst(r)) ]"
              | CalcGrammar.Cond.Ast(cond, _, l, _, r)      => $"[ $(printAst(cond)) ? $(printAst(l)) : $(printAst(r)) ]"

              | IncGrammar.Plus.Ast(_, v)         => $"[ + $(printAst(v)) ]"
              | IncGrammar.PrefixInc.Ast(_, v)    => $"[ ++ $(printAst(v)) ]"
              | IncGrammar.PostfixInc.Ast(v, _)   => $"[ $(printAst(v)) ++ ]"
              | _ => assert(false);
            }
          }
          WriteLine($"Ok:   \"$text\" AST: $(printAst(ast))");
        | _ => assert(false);
      }
    }
    print("1+2+3");
    print("1+2*3");
    print("1*2-3");
    print("1^2^3");
    print("1*2^3");
    print("1^2*3");
    print("-1+2+3");
    print("1+-2*3");
    print("1*2--3");
    print("1*(2--3)");
    print("1*2- -3");
    print("1*(2- -3)");
    print("1^2^-3");
    print("1*-2^3");
    print("1*-(2^3)");
    print("(1*-2)^3");
    print("-1^2*3");

    print("1-----3");
    print("1----3");
    print("1---3");
    print("1--3");
    print("1-3");
    print("1+2-----3");
    print("1+2----3");
    print("1+2---3");
    print("1+2--3");
    print("1+2-3");

    print("---3");
    print("----3");

    print("+3");
    print("++3");
    print("+++3");
    print("++++3");
    print("+++++3");
    print("1+3");
    print("1++3");
    print("1+++3");
    print("1++++3");
    print("1+++++3");
    print("1.23-4.3");
    print("a+3");
    print("{1+3 2+3 {4 1-2}}");
    print("1?2:3");
    print("1?2:3?4:5");
    print("1?2?3:4:5");
    print("1?2?3:4:5+6");
    print("1?2?3+0:4+0:5+6");

    _ = ReadKey();
  }
}