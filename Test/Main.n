using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Parser;
using Nemerle.Imperative;

using System;
using System.Collections.Generic;
using SCG = System.Collections.Generic;
using System.Console;
using System.Linq;

variant Ast : Located
{
  | UOp    { name : string; v : Ast; }
  | Num    { n : string; }
  | Rounds { ast : Ast; }
  | Op     { l : Ast; name : string; r : Ast; }
}

[ParserGrammar(Options = EmitDebugSources,
  grammar
  {
    any = ['\u0000'..'\uFFFF'];
    s : void = ' '*;

    [StartRule]
    start : Ast = s expr !any;

    [Export, StartRule]
    expr : Ast;

    rounds is expr = '('s expr ')'s;

    d = ['0'..'9'];
    num is expr = d+ s;

    neg is expr = '-'s expr : 100;

    prefixDec is expr = "--"s expr : 200;
    postfixDec is expr = expr : 200 "--"s;

    add is expr = expr : 10 '+'s expr : 10;
    sub is expr = expr : 10 '-'s expr : 10;

    mul is expr = expr : 20 '*'s expr : 20;
    div is expr = expr : 20 '/'s expr : 20;
    mod is expr = expr : 20 '%'s expr : 20;

    pow is expr = expr : 31 '^'s expr : 30;
  }
)]
abstract class CalcParser
{
  rounds(_ : NToken, f : Ast, _ : NToken) : Ast { Ast.Rounds(f) }

  num(n : NToken) : Ast { Ast.Num(GetText(n)) }

  neg(op : NToken, v : Ast) : Ast { Ast.UOp(GetText(op), v) }
  prefixDec(op : NToken, v : Ast) : Ast { Ast.UOp(GetText(op), v) }
  postfixDec(v : Ast, op : NToken) : Ast { Ast.UOp(GetText(op), v) }

  add(l : Ast, op : NToken, r : Ast) : Ast { Ast.Op(l, GetText(op), r) }
  sub(l : Ast, op : NToken, r : Ast) : Ast { Ast.Op(l, GetText(op), r) }
  mul(l : Ast, op : NToken, r : Ast) : Ast { Ast.Op(l, GetText(op), r) }
  div(l : Ast, op : NToken, r : Ast) : Ast { Ast.Op(l, GetText(op), r) }
  mod(l : Ast, op : NToken, r : Ast) : Ast { Ast.Op(l, GetText(op), r) }
  pow(l : Ast, op : NToken, r : Ast) : Ast { Ast.Op(l, GetText(op), r) }
}

[ParserGrammar(Options = EmitDebugSources,
  grammar
  {
    using CalcParser;
    using cp = CalcParser;

    expr : Ast; s : void = ' '*;
    prefixInc is expr = "++"s expr : 200;
    postfixInc is expr = expr : 200 "++"s;
  }
)]
abstract class IncParser
{
  prefixInc(op : NToken, v : Ast) : Ast { Ast.UOp(GetText(op), v) }
  postfixInc(v : Ast, op : NToken) : Ast { Ast.UOp(GetText(op), v) }
}

module Program
{
  Main() : void
  {
    def print(text)
    {
      match (CalcParser.Grammar().ParseStart(text))
      {
        | None      => WriteLine($"Can't parse: $text");
        | Some(ast) =>
          def printAst(ast, indent)
          {
            match (ast : Ast)
            {
              | Rounds(ast) =>
                WriteLine($"$indent(");
                printAst(ast, indent + "  ");
                WriteLine($"$indent)");

              | Num(num) =>
                WriteLine($"$indent$num");

              | UOp(op, v) =>
                WriteLine($"$indent$op");
                printAst(v, indent + "  ");

              | Op(l, op, r) =>
                WriteLine($"$indent$op");
                printAst(l, indent + "  ");
                printAst(r, indent + "  ");
            }
          }
          WriteLine($"Ast of \"$text\" is:");
          printAst(ast, "")
      }
      WriteLine();
    }
    print("1+2+3");
    print("1+2*3");
    print("1*2-3");
    print("1^2^3");
    print("1*2^3");
    print("1^2*3");
    print("-1+2+3");
    print("1+-2*3");
    print("1*2--3");
    print("1*2- -3");
    print("1^2^-3");
    print("1*-2^3");
    print("-1^2*3");

    print("1---3");

    _ = ReadKey();
  }
}