using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Parser;
using Nemerle.Imperative;

using System;
using System.Collections.Generic;
using SCG = System.Collections.Generic;
using System.Console;
using System.Linq;

[ParserGrammar(Options = EmitDebugSources,
  grammar
  {
    using IncParser;
    using NumParser;

    any = ['\u0000'..'\uFFFF'];
    s : void = ' '*;

    [StartRule, Ast(expr)]
    start : Ast = s expr !any;

    [StartRule, Ast()]
    expr : Ast;

    [Ast(l, expr, r)] rounds is expr = '('s expr ')'s;
    [Ast(l, expr, r)] seq is expr = '{'s expr* '}'s;

    [Ast(num)]        num is expr = number s;

    [Ast(op, expr)]   neg is expr = '-'s expr : 100;

    [Ast(op, expr)]   prefixDec is expr = "--"s expr : 200;
    [Ast(expr, op)]   postfixDec is expr = expr : 200 "--"s;

    [Ast(l, op, r)]   add is expr = expr : 10 '+'s expr : 10;
    [Ast(l, op, r)]   sub is expr = expr : 10 '-'s expr : 10;
    [Ast(l, op, r)]   mul is expr = expr : 20 '*'s expr : 20;
    [Ast(l, op, r)]   div is expr = expr : 20 '/'s expr : 20;
    [Ast(l, op, r)]   mod is expr = expr : 20 '%'s expr : 20;
    [Ast(l, op, r)]   pow is expr = expr : 31 '^'s expr : 30;

    [Ast(cond, q, l, colon, r)]   cond is expr = expr : 301 '?'s expr ':'s expr;
  }
)]
public abstract class CalcParser
{}

[ParserGrammar(Options = EmitDebugSources,
  grammar
  {
    //using CalcParser;
    using cp = CalcParser;

    [Ast(op, expr)] plus is cp.expr = '+'cp.s cp.expr : 100;
    [Ast(op, expr)] prefixInc is cp.expr = "++"cp.s cp.expr : 200;
    [Ast(expr, op)] postfixInc is cp.expr = cp.expr : 200 "++"cp.s;
  }
)]
public abstract class IncParser
{
}

[ParserGrammar(Options = EmitDebugSources,
  grammar
  {
  }
)]
public abstract class EmptyParser
{
}

// L<I?,I?,I?,I?,I?,I?,D?>((y,m,d,h,i,s) => 
[ParserGrammar(Options = EmitDebugSources,
  grammar
  {
    any = ['\u0000'..'\uFFFF'];

    [StartRule, Ast(Body)]
    Start : Ast = s Body !any;
    
    [Ast(t1, t2, types, t4, t5, t6, idents, t8, t9)]
    Body : Ast = "L"s "<"s (Type, ","s)* ">"s "("s "("s (Identifier, ","s)* ")"s "=>"s;
    
    [Ast(ident, nullable)]
    Type : Ast = Identifier s "?"? s;
    
    
    #region Identifier
    
    IdentifierFirst = ['A'..'Z', 'a'..'z', '_'..'_'];
    IdentifierNext  = IdentifierFirst | ['0'..'9'];
    IdentifierBody  = IdentifierFirst IdentifierNext*;
    Identifier : NToken = IdentifierBody s;

    #endregion
    
    #region Line terminators

    newLineCharacter   = '\n'
                       | '\r'
                       | '\u2028'    /*  line separator       */
                       | '\u2029';   /*  paragraph separator  */
    newLine   = "\r\n" | newLineCharacter;

    #endregion

    #region White space

    whitespace = [Zs]
              | '\t'
              | '\v'        /*  vertial tab          */
              | '\f';       /*  form feed            */

    #endregion

    #region Spacer

    space = whitespace | newLine;

    s : void = space*;                      /* optional spacer          */
    S : void = !IdentifierNext s; /* identifier break spacer  */
    #endregion
  }
)]
public abstract class LambdaParser
{
}

module Program
{
  Main() : void
  {
    def print(text)
    {
      def parser = CalcParser.GrammarImpl();
      match (parser.ParseStart(text))
      {
        | None      =>
          WriteLine($"Fail: \"$text\"");
          def (pos, tokens) = parser.Parser.GetErrors();
          def (line, pos) = parser.ParsingSource.PositionToLineColumn(pos);
          foreach (token in tokens)
            WriteLine($"  $line:$pos expected \"$(token.Name)\" in rule $(token.Rule.Grammar.Name).$(token.Rule.Name)");

        | Some(CalcParser.Start.Ast(ast)) =>
          def printAst(ast : CalcParser.Expr)
          {
            match (ast)
            {
              | CalcParser.Rounds.Ast(_, ast, _) => $"( $(printAst(ast)) )"
              | CalcParser.Seq.Ast(_, asts, _)   => $<#{ ..$(asts; " ; "; printAst(_)) }#>
              | CalcParser.Num.Ast(num)          => $"$(num.GetText((num :> NumParser.Number.Ast).number))"
              | CalcParser.Neg.Ast(_, v)         => $"[ - $(printAst(v)) ]"
              | CalcParser.PrefixDec.Ast(_, v)   => $"[ -- $(printAst(v)) ]"
              | CalcParser.PostfixDec.Ast(v, _)  => $"[ $(printAst(v)) -- ]"
              | CalcParser.Add.Ast(l, _, r)      => $"[ $(printAst(l)) + $(printAst(r)) ]"
              | CalcParser.Sub.Ast(l, _, r)      => $"[ $(printAst(l)) - $(printAst(r)) ]"
              | CalcParser.Mul.Ast(l, _, r)      => $"[ $(printAst(l)) * $(printAst(r)) ]"
              | CalcParser.Div.Ast(l, _, r)      => $"[ $(printAst(l)) / $(printAst(r)) ]"
              | CalcParser.Mod.Ast(l, _, r)      => $"[ $(printAst(l)) % $(printAst(r)) ]"
              | CalcParser.Pow.Ast(l, _, r)      => $"[ $(printAst(l)) ^ $(printAst(r)) ]"
              | CalcParser.Cond.Ast(cond, _, l, _, r)      => $"[ $(printAst(cond)) ? $(printAst(l)) : $(printAst(r)) ]"

              | IncParser.Plus.Ast(_, v)         => $"[ + $(printAst(v)) ]"
              | IncParser.PrefixInc.Ast(_, v)    => $"[ ++ $(printAst(v)) ]"
              | IncParser.PostfixInc.Ast(v, _)   => $"[ $(printAst(v)) ++ ]"
              | _ => assert(false);
            }
          }
          WriteLine($"Ok:   \"$text\" AST: $(printAst(ast))");
        | _ => assert(false);
      }
    }
    print("1+2+3");
    print("1+2*3");
    print("1*2-3");
    print("1^2^3");
    print("1*2^3");
    print("1^2*3");
    print("-1+2+3");
    print("1+-2*3");
    print("1*2--3");
    print("1*(2--3)");
    print("1*2- -3");
    print("1*(2- -3)");
    print("1^2^-3");
    print("1*-2^3");
    print("1*-(2^3)");
    print("(1*-2)^3");
    print("-1^2*3");

    print("1-----3");
    print("1----3");
    print("1---3");
    print("1--3");
    print("1-3");
    print("1+2-----3");
    print("1+2----3");
    print("1+2---3");
    print("1+2--3");
    print("1+2-3");

    print("---3");
    print("----3");

    print("+3");
    print("++3");
    print("+++3");
    print("++++3");
    print("+++++3");
    print("1+3");
    print("1++3");
    print("1+++3");
    print("1++++3");
    print("1+++++3");
    print("1.23-4.3");
    print("a+3");
    print("{1+3 2+3 {4 1-2}}");
    print("1?2:3");
    print("1?2:3?4:5");
    print("1?2?3:4:5");
    print("1?2?3:4:5+6");
    print("1?2?3+0:4+0:5+6");

    _ = ReadKey();
  }
}