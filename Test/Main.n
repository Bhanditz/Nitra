using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Parser;
using Nemerle.Imperative;

using System;
using System.Collections.Generic;
using SCG = System.Collections.Generic;
using System.Console;
using System.Linq;

variant Ast
{
  | Num    { n : string; }
  | Rounds { ast : Ast; }
  | Op     { l : Ast; name : string; r : Ast; }
}

[ParserGrammar(Options = EmitDebugSources,
  start,
  grammar
  {
    any = ['\u0000'..'\uFFFF'];
    s : void = ' '*;

    start : Ast = s expr !any;

    expr : Ast;

    rounds is expr = '('s expr ')'s;

    d = ['0'..'9'];
    num is expr = d+ s;

    add is expr = expr : 10 '+'s expr : 10;
    sub is expr = expr : 10 '-'s expr : 10;

    mul is expr = expr : 20 '*'s expr : 20;
    div is expr = expr : 20 '/'s expr : 20;
    mod is expr = expr : 20 '%'s expr : 20;

    pow is expr = expr : 31 '^'s expr : 30;
  }
)]
class CalcParser
{
  rounds(_ : NToken, f : Ast, _ : NToken) : Ast { Ast.Rounds(f) }

  num(n : NToken) : Ast { Ast.Num(GetText(n)) }

  add(l : Ast, op : NToken, r : Ast) : Ast { Ast.Op(l, GetText(op), r) }
  sub(l : Ast, op : NToken, r : Ast) : Ast { Ast.Op(l, GetText(op), r) }
  mul(l : Ast, op : NToken, r : Ast) : Ast { Ast.Op(l, GetText(op), r) }
  div(l : Ast, op : NToken, r : Ast) : Ast { Ast.Op(l, GetText(op), r) }
  mod(l : Ast, op : NToken, r : Ast) : Ast { Ast.Op(l, GetText(op), r) }
  pow(l : Ast, op : NToken, r : Ast) : Ast { Ast.Op(l, GetText(op), r) }
}

module Program
{
  TestRule[T](pos : int, text : string, bindingPower : int, curResult : ref T) : int
  {
    // Данные класса реализующего грамматику
    mutable TestRule_BindingPower;
    mutable TestRule_StartPos;
    mutable TestRule_EndPos;
    mutable TestRule_Result;
    mutable TestRule_PrefixEndPos;
    mutable TestRule_PrefixResult;

    def prefixRules : array[ExtensionLeftPrefixBase[T]] = null;
    def postfixRules : array[ExtensionPostfixRuleBase[T]] = null;

    // Реализация правила

    mutable curEndPos = -1; // вместе с параметром curResult содержит конечный результат разбора правила

    mutable c; // временная переменная для отсечения правил по первой букве

    mutable newResult; // содержит вновь полученное значение из вызываемого правила
    mutable newEndPos;

    if (TestRule_StartPos == pos)
    {
      when (TestRule_EndPos < 0)
        return -1; // обнаружена левая рекурсия в префиксном правиле
                   // или не смогли разобрать префикс
                   // все остальное не важно

      if (TestRule_BindingPower == bindingPower) // если сила связывания совпадает возвращаем результат из кеша
      {
        curResult = TestRule_Result;
        return TestRule_EndPos;
      }
      else // если сила связывания не совпадает то из кеша можно достать только префикс
      {
        TestRule_BindingPower = bindingPower;
        //TestRule_StartPos   = pos;
        TestRule_EndPos       = -1; // защита от левой рекурсии

        // достаем префикс из кеша
        curResult = TestRule_PrefixResult;
        curEndPos = TestRule_PrefixEndPos;
      }
    }
    else // стартовая позиция не совпадает
    {    // парсим префикс
      TestRule_BindingPower = bindingPower;
      TestRule_StartPos     = pos;
      TestRule_EndPos       = -1; // защита от левой рекурсии

      if (pos < text.Length)
      {
        c = text[pos];
        foreach (prefixRule in prefixRules)
        {
          when (prefixRule.LowerBound <= c && c <= prefixRule.UpperBound)
          {
            newEndPos = prefixRule.Parse(pos, text, ref newResult);
            when (curEndPos < newEndPos)
            {
              curResult = newResult;
              curEndPos = newEndPos;
            }
          }
        }
      }
      else
      {
        // правило может захотеть сматчить конец строки
        // сомневаюсь что этот код будет хоть раз выполнени в реальной задаче
        // но для корректности он должен быть
        foreach (prefixRule in prefixRules)
        {
          newEndPos = prefixRule.Parse(pos, text, ref newResult);
          when (curEndPos < newEndPos)
          {
            curResult = newResult;
            curEndPos = newEndPos;
          }
        }
      }

      TestRule_PrefixResult = curResult;
      TestRule_PrefixEndPos = curEndPos;
    }

    when (curEndPos < 0)// не смогли разобрать префикс
      return -1;

    mutable bestResult = curResult;
    mutable bestEndPos = curEndPos;

    while (true)
    {
      if (curEndPos < text.Length)
        c = text[curEndPos];
      else
        break; // постфиксное правило которое не съело ни одного символа игнорируется
               // при достижении конца строки есть нечего

      foreach (postfixRule in postfixRules)
        when (postfixRule.LowerBound <= c && c <= postfixRule.UpperBound && bindingPower < postfixRule.BindingPower)
        {
          newResult = curResult;
          newEndPos = postfixRule.Parse(pos, curEndPos, text, ref newResult);
          when (bestEndPos < newEndPos)
          {
            bestEndPos = newEndPos;
            bestResult = newResult;
          }
        }

      when (bestEndPos == curEndPos)
        break; // если нам не удалось продвинутся то заканчиваем разбор

      curResult = bestResult;
      curEndPos = bestEndPos;
    }

    TestRule_Result = curResult;
    TestRule_EndPos = curEndPos;
    curEndPos
  }

  Main() : void
  {
    def print(text)
    {
      match (CalcParser().Parse(text))
      {
        | None      => WriteLine($"Can't parse: $text");
        | Some(ast) =>
          def printAst(ast, indent)
          {
            match (ast : Ast)
            {
              | Rounds(ast) =>
                WriteLine($"$indent(");
                printAst(ast, indent + "  ");
                WriteLine($"$indent)");

              | Num(num) =>
                WriteLine($"$indent$num");

              | Op(l, op, r) =>
                WriteLine($"$indent$op");
                printAst(l, indent + "  ");
                printAst(r, indent + "  ");
            }
          }
          WriteLine($"Ast of \"$text\" is:");
          printAst(ast, "")
      }
      WriteLine();
    }
    print("1+2+3");
    print("1+2*3");
    print("1*2-3");
    print("1^2^3");
    print("1*2^3");
    print("1^2*3");
  }
}