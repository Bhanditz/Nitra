using Nemerle.Parser;

syntax module CalcGrammar
{
  option EmitDebugSources = true;

  using IncGrammar;
  using NumParser;

  token any = ['\u0000'..'\uFFFF'];
  rule s : void = ' '*;

  [StartRule, Ast(expr)]
  rule start : Ast = s expr !any;

  [StartRule, Ast()]
  rule expr : Ast;

  [Ast(l, expr, r)] rule rounds is expr = '('s expr ')'s;
  [Ast(l, expr, r)] rule seq is expr = '{'s expr* '}'s;

  [Ast(num)]        rule num is expr = number s;

  [Ast(op, expr)]   rule neg is expr = '-'s expr : 100;

  [Ast(op, expr)]   rule prefixDec is expr = "--"s expr : 200;
  [Ast(expr, op)]   rule postfixDec is expr = expr : 200 "--"s;

  [Ast(l, op, r)]   rule add is expr = expr : 10 '+'s expr : 10;
  [Ast(l, op, r)]   rule sub is expr = expr : 10 '-'s expr : 10;
  [Ast(l, op, r)]   rule mul is expr = expr : 20 '*'s expr : 20;
  [Ast(l, op, r)]   rule div is expr = expr : 20 '/'s expr : 20;
  [Ast(l, op, r)]   rule mod is expr = expr : 20 '%'s expr : 20;
  [Ast(l, op, r)]   rule pow is expr = expr : 31 '^'s expr : 30;

  [Ast(cond, q, l, colon, r)]   rule cond is expr = expr : 301 '?'s expr ':'s expr;

  [Ast(l, CoalescingOp, r)]     rule coalescing  is expr = expr : 401 "??"s expr : 400;
}

syntax module IncGrammar
{
  using cp = CalcGrammar;

  [Ast(op, expr)] rule plus is cp.expr = '+'cp.s cp.expr : 100;
  [Ast(op, expr)] rule prefixInc is cp.expr = "++"cp.s cp.expr : 200;
  [Ast(expr, op)] rule postfixInc is cp.expr = cp.expr : 200 "++"cp.s;
}
