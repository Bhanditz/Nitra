using Nemerle;
using Nemerle.Collections;
using Nemerle.Compiler;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.IO;
using System.Collections.Generic;
using System.Linq;

namespace Nitra.Ide.Macros
{
  [MacroUsage(MacroPhase.BeforeInheritance, MacroTargets.Class, Inherited = false, AllowMultiple = false)]
  public macro NitraMessage(ty: TypeBuilder)
  {
    NitraMessageImpl.Transform(Macros.ImplicitCTX(), ty)
  }
  
  module NitraMessageImpl 
  {
    public Transform(typer: Typer, tb: TypeBuilder): void 
    {
       when (IsSupportedType(tb))
       {
         if (typer.Env.CurrentNamespace.LookupType(["INitraMessage"], 0) is Some(messageInterface))
         {
           tb.AddImplementedInterface (<[ $(messageInterface.Name: usesite) ]>);
           
           tb.Define(
           <[decl: 
             public Serialize(writer: BinaryWriter): void 
             {
             }
           ]>);
           
           tb.Define(
           <[decl: 
             public Deserialize(reader: BinaryReader): $(tb.Name: usesite)
             {
               throw NotImplementedException()
             }
           ]>);
         }
         else 
           Message.Error(tb.Location, "Current project must contain INitraMessage interface definition");
       }
    }
    
    IsSupportedType(tb: TypeBuilder): bool {
      match (tb) {
      | _ when tb.IsDelegate with n = "delegates"
      | _ when tb.IsInterface with n = "interfaces"
      | _ when tb.IsModule with n = "modules" => 
          Message.Error(tb.Location, $"$n are not supported."); 
          false
      | _ => true
      }
    }
  }
}
