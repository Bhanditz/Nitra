using Microsoft.VisualStudio.Text;
using Microsoft.VisualStudio.TextManager.Interop;
using Nitra.Runtime.Highlighting;
using Nitra.VisualStudio.Parsing;

using Nemerle;
using Nemerle.Collections;
using Nemerle.Imperative;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.InteropServices;

using Microsoft.VisualStudio.OLE.Interop;
using Microsoft.VisualStudio;
using Microsoft.VisualStudio.Text.Editor;

namespace Nitra.VisualStudio.KeyBinding
{
  public class KeyBindingCommandFilter : IOleCommandTarget
  {
    public IsAdded : bool { get; private set; }

    private         _textView   : ITextView;
    private mutable _nextTarget : IOleCommandTarget;
    private         _parseAgent : ParseAgent;

    public this(textViewAdapter : IVsTextView, textDocumentFactoryService : ITextDocumentFactoryService)
    {
      _textView = textViewAdapter.ToITextView();
      _parseAgent = Utils.TryGetOrCreateParseAgent(_textView.TextBuffer, textDocumentFactoryService, NitraPackage.Instance.Language);
      AddCommandFilter(textViewAdapter);
    }

    private AddCommandFilter(viewAdapter : IVsTextView) : void
    {
      when (IsAdded)
        return;
        
      //get the view adapter from the editor factory
      mutable next;
      def hr = viewAdapter.AddCommandFilter(this, out next);

      when (hr == VSConstants.S_OK)
      {
        IsAdded = true;
        //you'll need the next target for Exec and QueryStatus
        when (next != null)
          _nextTarget = next;
      }
    }

    public QueryStatus(pguidCmdGroup : ref Guid, cCmds : uint, prgCmds : array[OLECMD], pCmdText : IntPtr) : int
    {
      _nextTarget.QueryStatus(ref pguidCmdGroup, cCmds, prgCmds, pCmdText)
    }

    public Exec(pguidCmdGroup : ref Guid, nCmdID : uint, nCmdexecopt : uint, pvaIn : IntPtr, pvaOut : IntPtr) : int
    {
      when (pguidCmdGroup == VSConstants.VSStd2K)
      {
        match (nCmdID :> VSConstants.VSStd2KCmdID)
        {
          | VSConstants.VSStd2KCmdID.GOTOBRACE => OnGoToBrace(); return VSConstants.S_OK;
          | _ => assert2(true);
        }

      }

      //mutable typedChar = char.MinValue;
      //when (pguidCmdGroup == VSConstants.VSStd2K && nCmdID == VSConstants.VSStd2KCmdID.TYPECHAR :> uint)
      //{
      //  typedChar = Marshal.GetObjectForNativeVariant(pvaIn) :> char;
      //  when (typedChar.Equals('+'))
      //  {
      //  }
      //}

      _nextTarget.Exec(ref pguidCmdGroup, nCmdID, nCmdexecopt, pvaIn, pvaOut);
    }

    OnGoToBrace() : void
    {
      when (_parseAgent.LastResult == null)
        return;

      def walker = MatchBracketsWalker();
      def pos = _textView.Caret.Position.BufferPosition.Position;
      def context = MatchBracketsWalker.Context(_textView.Caret.Position.BufferPosition.Position);
      _ = walker.Walk(_parseAgent.LastResult, context);
      foreach (brackets in context.Brackets)
      {
        def newPos =
          if (brackets.CloseBracket.IntersectsWith(pos))
            brackets.OpenBracket.StartPos
          else if (brackets.OpenBracket.IntersectsWith(pos))
            brackets.CloseBracket.StartPos
          else
            pos;

        def point = SnapshotPoint(_textView.TextBuffer.CurrentSnapshot, newPos);
        _ = _textView.Caret.MoveTo(point);
        _textView.Caret.EnsureVisible();
        break;
      }
    }
  }
}
