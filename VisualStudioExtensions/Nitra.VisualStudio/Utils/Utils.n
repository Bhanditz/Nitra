using Nitra;
using Nitra.Internal;
using Nitra.VisualStudio.Parsing;

using Nemerle;
using Nemerle.Extensions;
using Nemerle.Imperative;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using Microsoft.VisualStudio.Shell;
using Microsoft.VisualStudio.Shell.Interop;
using Microsoft.VisualStudio.Text;
using Microsoft.VisualStudio.Text.Adornments;
using Microsoft.VisualStudio.Text.Tagging;

using System;
using System.Diagnostics;
using System.IO;
using System.Collections.Generic;
using System.Linq;

namespace Nitra.VisualStudio
{
  public enum MessageType
  {
    | Info = 0
    | Hint = 1
    | Warning = 2
    | Error = 3
  }

  public enum SpanArrangement
  {
    | Equal = 0
    | Preced = 1
    | Succed = -1
    | Wrap = 2
    | Include = -2
    | LeftOverlap = 3
    | RightOverlap = -3
  }

  public partial module Utils
  {
    public GetSpanArrangement(aStart : int, aEnd : int, bStart : int, bEnd : int) : SpanArrangement
    {
      when (bStart < aStart)
        return -(GetSpanArrangement(bStart, bEnd, aStart, bEnd) :> int) :> SpanArrangement;

      if (aStart == bStart)
        if (aEnd < bEnd)
          SpanArrangement.Include;
        else if (aEnd > bEnd)
          SpanArrangement.Wrap;
        else
          SpanArrangement.Equal;
      else
        if (bStart < aEnd)
          if (bEnd <= aEnd)
            SpanArrangement.Wrap;
          else
            SpanArrangement.LeftOverlap;
        else
          SpanArrangement.Preced;
    }

    public GetLineAndColumn(this snapshot : ITextSnapshot, position : int) : int * int
    {
      def line = snapshot.GetLineFromPosition(position);
      (line.LineNumber, position - line.Start.Position)
    }

    public GetLineAndColumn(this point : SnapshotPoint) : int * int
    {
      point.Snapshot.GetLineAndColumn(point.Position)
    }

    public GetPosition(this snapshot : ITextSnapshot, lineNumber : int, columnIndex : int) : int
    {
      snapshot.GetLineFromLineNumber(lineNumber).Start.Position + columnIndex;
    }

    public ShowMessage(this serviceProvider : IServiceProvider, message : string, messageType : MessageType) : void
    {
      def icon =
        match (messageType)
        {
          | MessageType.Hint    => OLEMSGICON.OLEMSGICON_INFO
          | MessageType.Info    => OLEMSGICON.OLEMSGICON_INFO
          | MessageType.Warning => OLEMSGICON.OLEMSGICON_WARNING
          | MessageType.Error
          | _                   => OLEMSGICON.OLEMSGICON_CRITICAL
        };
      def buttons = OLEMSGBUTTON.OLEMSGBUTTON_OK;
      def defaultButton = OLEMSGDEFBUTTON.OLEMSGDEFBUTTON_FIRST;
      _ = VsShellUtilities.ShowMessageBox(serviceProvider, message, Constants.ProductName, icon, buttons, defaultButton);
    }

    public CreateParseAgent(language : Language, buffer : ITextBuffer) : ParseAgent
    {
      def parseAgent = ParseAgent(language) <-
      {
        ParseFailed   += (_, a) => TryErrorListManager(buffer)?.ReportParseExeption(a.Exception);
        ParseComplete += (_, a) => TryErrorListManager(buffer)?.ReportParseErrors(a.Result);
      };
      buffer.Properties.AddProperty(TextBufferProperties.ParseAgent, parseAgent);
      buffer.Changed += (_, a) => parseAgent.EnqueueParse(a.After, buffer.GetFilePath());
      parseAgent.EnqueueParse(buffer.CurrentSnapshot, buffer.GetFilePath());
      parseAgent
    }

    public CreateErrorListManager(errorProviderFactory : IErrorProviderFactory, buffer : ITextBuffer) : ErrorListManager
    {
      def errorListManager = ErrorListManager(errorProviderFactory, buffer);
      buffer.Properties.AddProperty(TextBufferProperties.ErrorListManager, errorListManager);
      errorListManager
    }

    public TryErrorListManager(buffer : ITextBuffer) : ErrorListManager
    {
      if (buffer.Properties.ContainsProperty(TextBufferProperties.ErrorListManager))
        buffer.Properties[TextBufferProperties.ErrorListManager] :> ErrorListManager
      else
        null
    }

    public DisposeErrorListManager(buffer : ITextBuffer) : void
    {
      when (buffer.Properties.ContainsProperty(TextBufferProperties.ErrorListManager))
      {
        def errorListManager = buffer.Properties[TextBufferProperties.ErrorListManager] :> ErrorListManager;
        errorListManager.Dispose();
        _ = buffer.Properties.RemoveProperty(TextBufferProperties.ErrorListManager);
      }
    }
  }
}
