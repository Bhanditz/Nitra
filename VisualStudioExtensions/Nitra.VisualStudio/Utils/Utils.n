using Microsoft.VisualStudio.Data.Core;
using Microsoft.VisualStudio.Shell;
using Microsoft.VisualStudio.Shell.Interop;
using Microsoft.VisualStudio.Text;
using Microsoft.VisualStudio.Text.Adornments;
using Microsoft.VisualStudio.Text.Tagging;

using Nemerle;
using Nemerle.Assertions;
using Nemerle.Extensions;
using Nemerle.Imperative;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using Nitra;
using Nitra.Internal;
using Nitra.VisualStudio.Parsing;

using System;
using System.Diagnostics;
using System.IO;
using System.Collections.Generic;
using System.Threading;
using System.Linq;

using IOleServiceProvider = Microsoft.VisualStudio.OLE.Interop.IServiceProvider;

namespace Nitra.VisualStudio
{
  public enum MessageType
  {
    | Info = 0
    | Hint = 1
    | Warning = 2
    | Error = 3
  }

  public enum SpanArrangement
  {
    | Equal = 0
    | Preced = 1
    | Succed = -1
    | Wrap = 2
    | Include = -2
    | LeftOverlap = 3
    | RightOverlap = -3
  }

  public partial module NitraVsUtils
  {
    public GetSpanArrangement(aStart : int, aEnd : int, bStart : int, bEnd : int) : SpanArrangement
    {
      when (bStart < aStart)
        return -(GetSpanArrangement(bStart, bEnd, aStart, bEnd) :> int) :> SpanArrangement;

      if (aStart == bStart)
        if (aEnd < bEnd)
          SpanArrangement.Include;
        else if (aEnd > bEnd)
          SpanArrangement.Wrap;
        else
          SpanArrangement.Equal;
      else
        if (bStart < aEnd)
          if (bEnd <= aEnd)
            SpanArrangement.Wrap;
          else
            SpanArrangement.LeftOverlap;
        else
          SpanArrangement.Preced;
    }

    public GetLineAndColumn(this snapshot : ITextSnapshot, position : int) : int * int
    {
      def line = snapshot.GetLineFromPosition(position);
      (line.LineNumber, position - line.Start.Position)
    }

    public GetLineAndColumn(this point : SnapshotPoint) : int * int
    {
      point.Snapshot.GetLineAndColumn(point.Position)
    }

    public GetPosition(this snapshot : ITextSnapshot, lineNumber : int, columnIndex : int) : int
    {
      snapshot.GetLineFromLineNumber(lineNumber).Start.Position + columnIndex;
    }

    public ShowMessage(this serviceProvider : IServiceProvider, message : string, messageType : MessageType) : void
    {
      def icon =
        match (messageType)
        {
          | MessageType.Hint    => OLEMSGICON.OLEMSGICON_INFO
          | MessageType.Info    => OLEMSGICON.OLEMSGICON_INFO
          | MessageType.Warning => OLEMSGICON.OLEMSGICON_WARNING
          | MessageType.Error
          | _                   => OLEMSGICON.OLEMSGICON_CRITICAL
        };
      def buttons = OLEMSGBUTTON.OLEMSGBUTTON_OK;
      def defaultButton = OLEMSGDEFBUTTON.OLEMSGDEFBUTTON_FIRST;
      _ = VsShellUtilities.ShowMessageBox(serviceProvider, message, Constants.ProductName, icon, buttons, defaultButton);
    }

    public TryGetOrCreateParseAgent(
      [NotNull] buffer                     : ITextBuffer,
      [NotNull] textDocumentFactoryService : ITextDocumentFactoryService,
                dataHostService            : IVsDataHostService, 
      [NotNull] language                   : Language) : ParseAgent
    {
      mutable parseAgent : ParseAgent;
      
      when (buffer.Properties.TryGetProperty(TextBufferProperties.ParseAgent, out parseAgent))
        return parseAgent;
      
      def onTextDocumentDisposed(_sender : object, args : TextDocumentEventArgs) : void
      {
        def buffer = buffer;
        when (args.TextDocument.TextBuffer : object == buffer)
        {
          mutable errorsReporter : IErrorsReporter;
          
          when (buffer.Properties.TryGetProperty(TextBufferProperties.ErrorsReporter, out errorsReporter))
          {
            errorsReporter.Dispose();
            _ = buffer.Properties.RemoveProperty(TextBufferProperties.ErrorsReporter);
          }

          when (buffer.Properties.RemoveProperty(TextBufferProperties.ParseAgent))
            buffer.Changed -= OnTextBufferChanged;
        }
      }
      textDocumentFactoryService.TextDocumentDisposed += onTextDocumentDisposed;
        
      def newParseAgent = ParseAgent(language);
      newParseAgent.ParseFailed += 
        fun (_, arg)
        {
          mutable errorListManager : IErrorsReporter;
          when (buffer.Properties.TryGetProperty(TextBufferProperties.ErrorsReporter, out errorListManager))
          {
            if (Thread.CurrentThread == dataHostService.UIThread : object)
              errorListManager.ReportParseException(arg);
            else
              _ = dataHostService.BeginInvokeOnUIThread(Action.[_](errorListManager.ReportParseException), arg);
          }
        };
      newParseAgent.ParseComplete += 
        fun (_, a)
        {
          mutable errorListManager : IErrorsReporter;
          when (buffer.Properties.TryGetProperty(TextBufferProperties.ErrorsReporter, out errorListManager))
          {
            if (Thread.CurrentThread == dataHostService.UIThread : object)
              errorListManager.ReportParseErrors(a.Result, a.Snapshot);
            else
              _ = dataHostService.BeginInvokeOnUIThread(Action.[_, _](errorListManager.ReportParseErrors), a.Result, a.Snapshot);
          }
        };
      buffer.Properties.AddProperty(TextBufferProperties.ParseAgent, newParseAgent);
      buffer.Changed += OnTextBufferChanged;
      newParseAgent.EnqueueParse(buffer.CurrentSnapshot, buffer.GetFilePath());

      newParseAgent
    }

    OnTextBufferChanged(_sender : object, args : TextContentChangedEventArgs) : void
    {
      def textBuffer = args.After.TextBuffer;
      mutable parseAgent : ParseAgent;
      
      if (textBuffer.Properties.TryGetProperty(TextBufferProperties.ParseAgent, out parseAgent))
        parseAgent.EnqueueParse(args.After, textBuffer.GetFilePath());
      else
        assert2(false);
    }
    
    public GetGlobalProvider[T]() : T
    {
      def globalProvider = Microsoft.VisualStudio.Shell.ServiceProvider.GlobalProvider;
      globalProvider.GetService(typeof(T)) :> T;
    }
  }
}
