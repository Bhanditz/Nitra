using Nitra;
using Nitra.Internal;

using Nemerle;
using Nemerle.Collections;
using Nemerle.Imperative;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Reflection;
using System.Threading;

namespace Nitra.VisualStudio
{
  public class ParserWrapper
  {
    mutable _modules : list[string];
    _ruleDescriptor : RuleDescriptor;

    public this(language : Language)
    {
      _modules = language.Modules;

      def startGrammar = language.Grammar;
      def startRule    = language.StartRule;
      foreach (file in _modules)
      {
        def assembly =
          try Assembly.LoadFrom(file)
          catch
          { e =>
            Trace.WriteLine($"Failed to load assembly '$file' for '$language' language\r\n$e");
            throw;
          }

        // TODO: FIXME: Могут существовать StaticDescriptor-ы с одинаковым полным именем.
        // В мапе нужно хранить их список, а не конекретные экзепляры.
        when (_ruleDescriptor == null)
        {
          def descriptors = GrammarDescriptor.GetDescriptors(assembly);
          foreach (grammar when grammar.FullName == startGrammar in descriptors)
            foreach (rule when rule.Name == startRule in grammar.Rules)
              _ruleDescriptor = rule;
        }
      }
      when (_ruleDescriptor == null)
        Trace.WriteLine($"Start rule '$startRule' not found for '$language' language");
    }

    public Parse(sourceSnapshot : SourceSnapshot, token : CancellationToken, completionStartPos : int, completionPrefix : string) : IParseResult
    {
      assert(_ruleDescriptor != null);
      if (_ruleDescriptor is StartRuleDescriptor as rd)
      {
        def parseSession = ParseSession(rd, cancellationToken=token, completionStartPos=completionStartPos, completionPrefix=completionPrefix);
        def parseResult = parseSession.Parse(sourceSnapshot);
        parseResult
      }
      else
        assert(false);
    }
  }
}
