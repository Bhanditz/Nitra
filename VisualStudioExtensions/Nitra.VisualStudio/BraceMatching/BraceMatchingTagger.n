using Nitra.Runtime.Highlighting;
using Nitra.VisualStudio.Parsing;

using Nemerle.Imperative;

using System;
using System.Linq;
using System.Collections.Generic;
using System.ComponentModel.Composition;

using Microsoft.VisualStudio.Text;
using Microsoft.VisualStudio.Text.Editor;
using Microsoft.VisualStudio.Text.Tagging;
using Microsoft.VisualStudio.Utilities;

namespace Nitra.VisualStudio
{
  internal class BraceMatchingTagger : ITagger[TextMarkerTag]
  {
    public  Language    : Language { get; }
    private _braceList  : Dictionary[char, char];
    private _parseAgent : ParseAgent;

    internal this (language : Language, view : ITextView, sourceBuffer : ITextBuffer)
    {
      Language = language;
        //here the keys are the open braces, and the values are the close braces
      _braceList = Dictionary();
      _braceList.Add('{', '}');
      _braceList.Add('[', ']');
      _braceList.Add('(', ')');
      this.View = view;
      this.SourceBuffer = sourceBuffer;
      this.CaretPos = null;

      this.View.Caret.PositionChanged += CaretPositionChanged;
      this.View.LayoutChanged += ViewLayoutChanged;
      
      _ = Utils.TryGetOrCreateParseAgent(sourceBuffer, out _parseAgent);
    }

    View         : ITextView      { get; set; }
    SourceBuffer : ITextBuffer    { get; set; }
    CaretPos     : SnapshotPoint? { get; set; }

    public event TagsChanged : EventHandler [SnapshotSpanEventArgs];

    ViewLayoutChanged(_ : object, e : TextViewLayoutChangedEventArgs) : void
    {
      unless (e.NewSnapshot == e.OldSnapshot : object) //make sure that there has really been a change
        UpdateAtCaretPosition(View.Caret.Position);
    }

    CaretPositionChanged(_ : object, e : CaretPositionChangedEventArgs) : void
    {
      UpdateAtCaretPosition(e.NewPosition);
    }

    UpdateAtCaretPosition(caretPosition : CaretPosition) : void
    {
      CaretPos = caretPosition.Point.GetPoint(SourceBuffer, caretPosition.Affinity);

      when (CaretPos.HasValue)
      {
        def tempEvent = TagsChanged;
        when (tempEvent != null)
          tempEvent(this, SnapshotSpanEventArgs(SnapshotSpan(SourceBuffer.CurrentSnapshot, 0, SourceBuffer.CurrentSnapshot.Length)));
      }
    }

    public GetTags(spans : NormalizedSnapshotSpanCollection) : IEnumerable[ITagSpan[TextMarkerTag]]
    {
      when (spans.Count == 0)   //there is no content in the buffer
        return;

      //don't do anything if the current SnapshotPoint is not initialized or at the end of the buffer
      when (!CaretPos.HasValue || CaretPos.Value.Position >= CaretPos.Value.Snapshot.Length)
        return;

      //hold on to a snapshot of the current character
      mutable currentCaretPos = CaretPos.Value;

      //if the requested snapshot isn't the same as the one the brace is on, translate our spans to the expected snapshot
      when (spans[0].Snapshot != currentCaretPos.Snapshot : object)
        currentCaretPos = currentCaretPos.TranslateTo(spans [0].Snapshot, PointTrackingMode.Positive);
        
      def pos    = currentCaretPos.Position;
      def span   = NSpan(pos, pos);
      def walker = MatchBracketsWalker(span);
      

      //get the current char and the previous char
      def currentText = currentCaretPos.GetChar();
      def lastChar = if (currentCaretPos == 0) currentCaretPos else currentCaretPos - 1; //if currentChar is 0 (beginning of buffer), don't move it back
      def lastText = lastChar.GetChar();
      mutable pairSpan = SnapshotSpan();

      if (_braceList.ContainsKey(currentText))   //the key is the open brace
      {
        mutable closeChar;
        _ = _braceList.TryGetValue(currentText, out closeChar);
        when (BraceMatchingTagger.FindMatchingCloseChar(currentCaretPos, currentText, closeChar, View.TextViewLines.Count, out pairSpan))
        {
          yield TagSpan(SnapshotSpan(currentCaretPos, 1), TextMarkerTag("blue"));
          yield TagSpan(pairSpan, TextMarkerTag("blue"));
        }
      }
      else when (_braceList.ContainsValue(lastText))    //the value is the close brace, which is the *previous* character
      {
        def open = _braceList.Where(a => a.Value.Equals(lastText)).Select(a => a.Key);
        when (BraceMatchingTagger.FindMatchingOpenChar(lastChar, open.ElementAt(0), lastText, View.TextViewLines.Count, out pairSpan))
        {
          yield TagSpan(SnapshotSpan(lastChar, 1), TextMarkerTag("blue"));
          yield TagSpan(pairSpan, TextMarkerTag("blue"));
        }
      }
    }

    private static FindMatchingCloseChar(startPoint : SnapshotPoint, open : char, close : char, maxLines : int, pairSpan : out SnapshotSpan) : bool
    {
      pairSpan = SnapshotSpan(startPoint.Snapshot, 1, 1);
      mutable line = startPoint.GetContainingLine();
      mutable lineText = line.GetText();
      mutable lineNumber = line.LineNumber;
      mutable offset = startPoint.Position - line.Start.Position + 1;

      mutable stopLineNumber = startPoint.Snapshot.LineCount - 1;

      when (maxLines > 0)
        stopLineNumber = Math.Min(stopLineNumber, lineNumber + maxLines);

      mutable openCount = 0;
      mutable founded = false;
      while (true)
      {
        //walk the entire line
        while (offset < line.Length && !founded)
        {
          mutable currentChar = lineText[offset];
          if (currentChar == close) //found the close character
          {
            if (openCount > 0)
            {
              openCount--;
            }
            else    //found the matching close
            {
              pairSpan = SnapshotSpan(startPoint.Snapshot, line.Start + offset, 1);
              founded = true;
            }
          }
          else when (currentChar == open) // this is another open
                 openCount++;
          offset++;
        }

        if (!founded)
        {
        //move on to the next line
          lineNumber++;
          when (lineNumber > stopLineNumber)
            break;

          line = line.Snapshot.GetLineFromLineNumber(lineNumber);
          lineText = line.GetText();
          offset = 0;
        }
        else
          break;
      }

      founded;
    }

    private static FindMatchingOpenChar(startPoint : SnapshotPoint, open : char, close : char, maxLines : int, pairSpan : out SnapshotSpan) : bool
    {
      pairSpan = SnapshotSpan(startPoint, startPoint);

      mutable line = startPoint.GetContainingLine();

      mutable lineNumber = line.LineNumber;
      mutable offset = startPoint - line.Start - 1; //move the offset to the character before this one

    //if the offset is negative, move to the previous line
      when (offset < 0)
      {
        lineNumber--;
        line = line.Snapshot.GetLineFromLineNumber(lineNumber);
        offset = line.Length - 1;
      }

      mutable lineText = line.GetText();

      mutable stopLineNumber = 0;
      when (maxLines > 0)
        stopLineNumber = Math.Max(stopLineNumber, lineNumber - maxLines);

      mutable closeCount = 0;
      mutable founded = false;

      while (true)
      {
        // Walk the entire line
        while (offset >= 0 && !founded)
        {
          mutable currentChar = lineText[offset];

          if (currentChar == open)
          {
            if (closeCount > 0)
              closeCount--;
            else // We've found the open character
            {
              pairSpan = SnapshotSpan(line.Start + offset, 1); //we just want the character itself
              founded = true;
            }
          }
            else when (currentChar == close)
                   closeCount++;
          offset--;
        }

        if (!founded)
        {
          lineNumber--;

          // Move to the previous line
          when (lineNumber < stopLineNumber)
            break;

          line = line.Snapshot.GetLineFromLineNumber(lineNumber);
          lineText = line.GetText();
          offset = line.Length - 1;
        }
        else
          break;
      }
      founded;
    }
  }
}
