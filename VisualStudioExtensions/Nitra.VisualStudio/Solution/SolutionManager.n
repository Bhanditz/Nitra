using Nitra.VisualStudio.ErrorHelper;

using Nemerle;
using Nemerle.Assertions;
using Nemerle.Collections;
using Nemerle.Imperative;
using Nemerle.Text;
using Nemerle.Utility;

using Microsoft.VisualStudio;
using Microsoft.VisualStudio.Shell.Interop;

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;

using ShellConstants = Microsoft.VisualStudio.Shell.Interop.Constants;

namespace Nitra.VisualStudio.Solution
{
  class SolutionManager : IVsSolutionEvents3, IVsSolutionEvents4//,  IVsSolutionLoadEvents
  {
		#region fields
		
		private mutable eventsCookie : uint;
		private mutable solution : IVsSolution;
		private mutable serviceProvider : IServiceProvider;
		private mutable isDisposed : bool;
		
		private static Mutex : object = object();

		#endregion

		#region ctors

    public this([NotNull] serviceProviderParameter : IServiceProvider)
		{

      this.serviceProvider = serviceProviderParameter;
      this.solution = this.serviceProvider.GetService(typeof(SVsSolution)) :> IVsSolution;

			assert3(this.solution != null, "Could not get the IVsSolution object from the services exposed by this project");
		}

		#endregion

		#region properties

		protected EventsCookie    : uint             { get { this.eventsCookie } }
		protected Solution        : IVsSolution      { get { this.solution } }
		protected ServiceProvider : IServiceProvider { get { this.serviceProvider } }

		#endregion
		
		#region methods
		
		public Init() : void
		{
			when (this.solution != null)
				_ = ThrowOnFailure(this.solution.AdviseSolutionEvents(this, out this.eventsCookie));
		}

		/// <summary>
		/// The method that does the cleanup.
		/// </summary>
		/// <param name="disposing"></param>
		[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA1806:DoNotIgnoreMethodResults", MessageId = "Microsoft.VisualStudio.Shell.Interop.IVsSolution.UnadviseSolutionEvents(System.UInt32)")]
		protected virtual Dispose(disposing : bool) : void
		{
			// Everybody can go here.
			when (!this.isDisposed)
			{
				// Synchronize calls to the Dispose simulteniously.
				lock (Mutex)
				{
					when (disposing && this.eventsCookie != (ShellConstants.VSCOOKIE_NIL :> uint) && this.solution != null)
					{
						_ = this.solution.UnadviseSolutionEvents(this.eventsCookie);
						this.eventsCookie = ShellConstants.VSCOOKIE_NIL :> uint;
					}

					this.isDisposed = true;
				}
			}
		}

		#endregion
		
		#region Dispose

		/// <summary>
		/// The IDispose interface Dispose method for disposing the object determinastically.
		/// </summary>
		public Dispose() : void
		{
			this.Dispose(true);
			GC.SuppressFinalize(this);
		}

		#endregion
		
    #region IVsSolutionEvents3, IVsSolutionEvents4   Members
    
    public OnAfterAsynchOpenProject(pHierarchy : Microsoft.VisualStudio.Shell.Interop.IVsHierarchy, fAdded : int) : int
    {
      _ = pHierarchy; _ = fAdded;
      VSConstants.E_NOTIMPL
    }
    
    public OnAfterChangeProjectParent(pHierarchy : Microsoft.VisualStudio.Shell.Interop.IVsHierarchy) : int
    {
      _ = pHierarchy;
      VSConstants.E_NOTIMPL
    }
    
    public OnAfterRenameProject(pHierarchy : Microsoft.VisualStudio.Shell.Interop.IVsHierarchy) : int
    {
      _ = pHierarchy;
      VSConstants.E_NOTIMPL
    }
    
    public OnQueryChangeProjectParent(pHierarchy : Microsoft.VisualStudio.Shell.Interop.IVsHierarchy, pNewParentHier : Microsoft.VisualStudio.Shell.Interop.IVsHierarchy, pfCancel : out int) : int
    {
      _ = pHierarchy; _ = pNewParentHier; _ = pfCancel;
      VSConstants.E_NOTIMPL
    }
    
    public OnAfterCloseSolution(pUnkReserved : object) : int
    {
      _ = pUnkReserved;
      VSConstants.E_NOTIMPL
    }
    
    public OnAfterClosingChildren(pHierarchy : Microsoft.VisualStudio.Shell.Interop.IVsHierarchy) : int
    {
      _ = pHierarchy;
      VSConstants.E_NOTIMPL
    }
    
    public OnAfterLoadProject(pStubHierarchy : Microsoft.VisualStudio.Shell.Interop.IVsHierarchy, pRealHierarchy : Microsoft.VisualStudio.Shell.Interop.IVsHierarchy) : int
    {
      _ = pStubHierarchy; _ = pRealHierarchy;
      VSConstants.E_NOTIMPL
    }
    
    public OnAfterMergeSolution(pUnkReserved : object) : int
    {
      _ = pUnkReserved;
      VSConstants.E_NOTIMPL
    }
    
    public OnAfterOpeningChildren(pHierarchy : Microsoft.VisualStudio.Shell.Interop.IVsHierarchy) : int
    {
      _ = pHierarchy;
      VSConstants.E_NOTIMPL
    }
    
    public OnAfterOpenProject(pHierarchy : Microsoft.VisualStudio.Shell.Interop.IVsHierarchy, fAdded : int) : int
    {
      _ = pHierarchy; _ = fAdded;
      VSConstants.E_NOTIMPL
    }
    
    public OnAfterOpenSolution(pUnkReserved : object, fNewSolution : int) : int
    {
      _ = pUnkReserved; _ = fNewSolution;
      VSConstants.E_NOTIMPL
    }
    
    public OnBeforeCloseProject(pHierarchy : Microsoft.VisualStudio.Shell.Interop.IVsHierarchy, fRemoved : int) : int
    {
      _ = pHierarchy; _ = fRemoved;
      VSConstants.E_NOTIMPL
    }
    
    public OnBeforeCloseSolution(pUnkReserved : object) : int
    {
      _ = pUnkReserved;
      VSConstants.E_NOTIMPL
    }
    
    public OnBeforeClosingChildren(pHierarchy : Microsoft.VisualStudio.Shell.Interop.IVsHierarchy) : int
    {
      _ = pHierarchy;
      VSConstants.E_NOTIMPL
    }
    
    public OnBeforeOpeningChildren(pHierarchy : Microsoft.VisualStudio.Shell.Interop.IVsHierarchy) : int
    {
      _ = pHierarchy;
      VSConstants.E_NOTIMPL
    }
    
    public OnBeforeUnloadProject(pRealHierarchy : Microsoft.VisualStudio.Shell.Interop.IVsHierarchy, pStubHierarchy : Microsoft.VisualStudio.Shell.Interop.IVsHierarchy) : int
    {
      _ = pRealHierarchy; _ = pStubHierarchy;
      VSConstants.E_NOTIMPL
    }
    
    public OnQueryCloseProject(pHierarchy : Microsoft.VisualStudio.Shell.Interop.IVsHierarchy, fRemoving : int, pfCancel : out int) : int
    {
      _ = pHierarchy; _ = fRemoving; _ = pfCancel;
      VSConstants.E_NOTIMPL
    }
    
    public OnQueryCloseSolution(pUnkReserved : object, pfCancel : out int) : int
    {
      _ = pUnkReserved; _ = pfCancel;
      VSConstants.E_NOTIMPL
    }
    
    public OnQueryUnloadProject(pRealHierarchy : Microsoft.VisualStudio.Shell.Interop.IVsHierarchy, pfCancel : out int) : int
    {
      _ = pRealHierarchy; _ = pfCancel;
      VSConstants.E_NOTIMPL
    }
    
    #endregion
/*
    #region Microsoft.VisualStudio.Shell.Interop.IVsSolutionLoadEvents  Members
    
    public OnAfterBackgroundSolutionLoadComplete() : int
    {
      VSConstants.E_NOTIMPL
    }
    
    public OnAfterLoadProjectBatch(fIsBackgroundIdleBatch : bool) : int
    {
      _ = fIsBackgroundIdleBatch;
      VSConstants.E_NOTIMPL
    }
    
    public OnBeforeBackgroundSolutionLoadBegins() : int{ throw System.NotImplementedException() }
    
    public OnBeforeLoadProjectBatch(fIsBackgroundIdleBatch : bool) : int
    {
      _ = fIsBackgroundIdleBatch;
      VSConstants.E_NOTIMPL
    }
    
    public OnBeforeOpenSolution(pszSolutionFilename : string) : int
    {
      _ = pszSolutionFilename;
      VSConstants.E_NOTIMPL
    }
    
    public OnQueryBackgroundLoadProjectBatch(pfShouldDelayLoadToNextIdle : out bool) : int
    {
      _ = pfShouldDelayLoadToNextIdle;
      VSConstants.E_NOTIMPL
    }
    
    #endregion
*/    
  }
}
