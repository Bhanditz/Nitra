using N2;

// L<I?,I?,I?,I?,I?,I?,D?>((y,m,d,h,i,s) => 
syntax module LambdaParser
{
  token any = ['\u0000'..'\uFFFF'];

  keyword regex ['A'..'Z', 'a'..'z', '_'..'_']+ rule S;

  [StartRule, Ast(Body), ExplicitSpaces]
  syntax Start       = s Body !any;

  [Ast(t1, t2, types, t4, t5, t6, idents, t8, t9)]
  syntax Body       = "L" "<" (Type; ",")* ">" "(" "(" (Identifier; ",")* ")" "=>";

  [Ast(ident, nullable)]
  syntax Type       = Identifier "?"?;

  token IdentifierFirst = ['A'..'Z', 'a'..'z', '_'..'_'];
  token IdentifierNext  = IdentifierFirst | ['0'..'9'];
  token IdentifierBody  = IdentifierFirst IdentifierNext*;
  [Ast(Name)]
  syntax Identifier       = IdentifierBody;

  token newLineCharacter   = '\n'
                      | '\r'
                      | '\u2028'    /*  line separator       */
                      | '\u2029';   /*  paragraph separator  */
  token newLine   = "\r\n" | newLineCharacter;

  token whitespace = [Zs]
            | '\t'
            | '\v'        /*  vertial tab          */
            | '\f';       /*  form feed            */


  token space = whitespace | newLine;

  [ExplicitSpaces] void s = space*;                      /* optional spacer          */
  [ExplicitSpaces] void S = !IdentifierNext s; /* identifier break spacer  */
}
