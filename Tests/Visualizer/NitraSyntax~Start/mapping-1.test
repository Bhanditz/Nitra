
syntax module M
{
  syntax Foo
  {
    | X = "X"
    | Y = Z*
  }
  
  syntax Z = Str="Z";
}

abstract ast Foo
{
  | X { }
  | Y { }
  | OneY   { Member : Z; }
}

ast ManyY : Foo
{
  Members : Z*;
}

ast Z
{
  Text : string;
  F    : Fake?;
}

map syntax M.Foo -> Foo
{
  | X {}
  | Y ->
    match (Zs)
    {
      | []    -> Y {}
      | [one] -> OneY  { one(None())  -> Member; }
      | many  -> ManyY { many -> Members; }
    }
}

map syntax M.Z(f : Fake?) -> Z
{
  Text = ParsedValue(Str, GetText(Str));
  f -> F;
}

map syntax M.Z -> Z
{
  Text = ParsedValue(Str, GetText(Str));
  None() -> F;
}

ast Fake {}
