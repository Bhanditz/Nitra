
syntax module M
{
  syntax Foo
  {
    | X = "X"
    | Y = Z*
  }
  
  syntax Z = "Z";
}

abstract ast Foo
{
  | X { }
  | Y { }
  | OneY   { Member : Z; }
}

ast ManyY : Foo
{
  Members : Z*;
}

ast Z
{
}

map syntax M.Foo -> Foo
{
  | X {}
  | Y ->
    match (Zs)
    {
      | []    -> Y {}
      | [one] -> OneY { one  -> Member; }
      | many  -> ManyY  { many -> Members; }
    }
}

map syntax M.Z -> Z
{
}
