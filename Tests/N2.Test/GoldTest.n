
using Nemerle;
using Nemerle.Assertions;
using Nemerle.Collections;
using Nemerle.Diff;
using Nemerle.Imperative;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Test.Framework;

using System;
using System.IO;
using System.Collections.Generic;
using System.Text;
using System.Linq;

using N2.Test.Utils;

namespace N2.Test
{
  /// <summary>
  /// Description of GoldTest.
  /// </summary>
  public sealed class GoldTest : Test
  {
    public this(filePath : string, createGoldFile : bool, showDiff : bool, canDebug : bool)
      requires !string.IsNullOrEmpty(filePath)
    {
      _filePath = filePath;
      _createGoldFile = createGoldFile;
      _showDiff = showDiff;
      _canDebug = canDebug;
      Name = Path.GetFileNameWithoutExtension(filePath);
    }

    public override Name : string { get }

    public override Run() : Result
    {
      unless(File.Exists(_filePath))
        return Result.Skipped("File not found");

      def originalTestSource = N2.SourceSnapshot(File.ReadAllText(_filePath), fileName = _filePath);
      def originalParserHost = ParserHost();
      def originalParseResult = originalParserHost.DoParsing(originalTestSource, TestParser.GrammarImpl.StartRuleDescriptor);

      unless (originalParseResult.IsSuccess)
        return Result.Skipped("Failed to parse test source");

      def originalAst = originalParseResult.CreateAst.[TestParser.Start.Ast]();

      match(GrammarLoader.Load(Path.GetDirectoryName(_filePath), originalAst))
      {
        | Success(rule, grammars) =>
          def testText = originalTestSource.Text.Substring(originalAst.TestBody.StartPos, originalAst.TestBody.EndPos - originalAst.TestBody.StartPos);
          def testSource = originalTestSource.WithText(testText, originalAst.TestBody.StartPos);
          when (_canDebug && originalAst.TopDeclarations.Any(_ is TestParser.Debugger))
            _ = Diagnostics.Debugger.Launch();
          def parseResult = ParseTestSource(testSource, rule, grammars);
          def dumpString = using(def writer = StringWriter())
          {
            def astDump = parseResult.GetDump();
            astDump.WriteTo(writer, " ");
            writer.ToString()
          }
          def dumpName = Path.ChangeExtension(_filePath, "out");
          when(File.Exists(dumpName))
            File.Delete(dumpName);
          def goldDumpName = Path.ChangeExtension(_filePath, "gold");
          if(File.Exists(goldDumpName))
          {
            def split(s) : array[_] { s.Split(array["\r\n", "\n", "\r"], StringSplitOptions.None) }
            def output = split(dumpString);
            def gold   = split(File.ReadAllText(goldDumpName));
            match(DumpComparer.Compare(output, gold, StringComparison.Ordinal))
            {
              | Success => Result.Passed("Passed")
              | Fail(lineNumber, expectedText, foundText) =>
                File.WriteAllText(dumpName, dumpString);
                def message = $"Dump differs with gold on line $lineNumber. Expected '$expectedText' found '$foundText'";
                def details = if(_showDiff) diff(gold, output) else [];
                Result.Failed(message, details)
            }
          }
          else if(_createGoldFile)
          {
            File.WriteAllText(goldDumpName, dumpString);
            Result.Skipped("Gold file created");
          }
          else
          {
            File.WriteAllText(dumpName, dumpString);
            Result.Skipped("Gold file not found");
          }
        | Fail(message) => Result.Failed(message)
      }
    }

    private static diff(textA : array[string], textB : array[string], rangeToShow : int = 3) : list[string]
    {
      def output = List();
      output.Add("BEGIN-DIFF");
      def writeSeparator()
      {
        output.Add("...");
      }
      def writeOriginal(line : string) : void
      {
        output.Add("  " + line);
      }
      def writeRemoved(line : string) : void
      {
        output.Add(" -" + line);
      }
      def writeInserted(line : string) : void
      {
        output.Add(" +" + line);
      }
      mutable indexA = 0;
      foreach(diffItem in textA.Diff(textB))
      {
        // определяем нужно ли выводить разделитель
        def nextIndexA = Math.Max(indexA, diffItem.Index - rangeToShow);
        when(nextIndexA > indexA + 1)
          writeSeparator();

        // показваем не боле rangeToShow предыдущих строк
        indexA = nextIndexA;
        while(indexA < diffItem.Index)
        {
          writeOriginal(textA[indexA]);
          ++indexA;
        }

        // показываем удаленные строки
        for(mutable i = 0; i < diffItem.Deleted; ++i)
        {
          writeRemoved(textA[indexA]);
          ++indexA;
        }

        // показываем добавленные строки
        foreach(insertedItem in diffItem.Inserted)
          writeInserted(insertedItem);

        // показываем не более rangeToShow последующих строк
        def tailLinesToShow = Math.Min(rangeToShow, textA.Length - indexA);
        for(mutable i = 0; i < tailLinesToShow; ++i)
        {
          writeOriginal(textA[indexA]);
          ++indexA;
        }
      }
      when(indexA < textA.Length)
        writeSeparator();
      output.Add("END-DIFF");
      output.ToNList()
    }

    private _filePath : string;
    private _createGoldFile : bool;
    private _showDiff : bool;
    private _canDebug : bool;

    public static ParseTestSource(source : SourceSnapshot, rule : RuleDescriptor, grammars : IEnumerable[GrammarDescriptor]) : N2.Ast
    {
      try
      {
        AppDomain.CurrentDomain.SetData("ExternalGrammars", grammars);
        def parserHost = ParserHost();
        def parseResult = match (rule)
        {
          | SimpleRuleDescriptor     as rule => parserHost.DoParsing(source, rule);
          | ExtensibleRuleDescriptor as rule => parserHost.DoParsing(source, rule);
          | _ => assert(false)
        }
        if (parseResult.IsSuccess)
          parseResult.CreateAst.[N2.Ast]()
        else
          N2.Ast(Location(source, 0, 0), [ErrorInfo(Location(source, 0, 0), [])]) // TODO: add error reporting
      }
      finally
      {
        AppDomain.CurrentDomain.SetData("ExternalGrammars", null);
      }
    }
  }
}
