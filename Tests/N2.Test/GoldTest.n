using Nemerle;
using Nemerle.Assertions;
using Nemerle.Collections;
using Nemerle.Diff;
using Nemerle.Imperative;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Test.Framework;

using System;
using System.IO;
using System.Collections.Generic;
using System.Text;
using System.Linq;

using N2.Test.Utils;

namespace N2.Test
{
  /// <summary>
  /// Description of GoldTest.
  /// </summary>
  public sealed class GoldTest : Test
  {
    public this(filePath : string, createGoldFile : bool, showDiff : bool)
      requires !string.IsNullOrEmpty(filePath)
    {
      _filePath = filePath;
      _createGoldFile = createGoldFile;
      _showDiff = showDiff;
      Name = Path.GetFileNameWithoutExtension(filePath);
    }

    public override Name : string { get }

    public override Run() : Result
    {
      unless(File.Exists(_filePath))
        return Result.Skipped("File not found");

      def originalTestSource = N2.SourceSnapshot(File.ReadAllText(_filePath), fileName = _filePath);
      def parser = TestParser.GrammarImpl();
      def (pos, ast) = parser.TryParseStart(originalTestSource);

      unless (pos >= 0)
        return Result.Skipped("Failed to parse test source");

      match(GrammarLoader.Load(Path.GetDirectoryName(_filePath), ast))
      {
        | Success(rule, grammars) =>
          match(ast)
          {
            | TestParser.Start.Ast(TestBody = testBody) =>
              def testText = originalTestSource.Text.Substring(testBody.StartPos, testBody.EndPos - testBody.StartPos);
              def testSource = originalTestSource.WithText(testText, testBody.StartPos);
              def parseResult =
                try
                {
                  AppDomain.CurrentDomain.SetData("ExternalGrammars", grammars);
                  rule.Parse(testSource);
                }
                finally
                {
                  AppDomain.CurrentDomain.SetData("ExternalGrammars", null);
                }
              def dumpString = using(def writer = StringWriter())
              {
                def astDump = parseResult.GetDump();
                astDump.WriteTo(writer, " ");
                writer.ToString()
              }
              def dumpName = Path.ChangeExtension(_filePath, "out");
              when(File.Exists(dumpName))
                File.Delete(dumpName);
              def goldDumpName = Path.ChangeExtension(_filePath, "gold");
              if(File.Exists(goldDumpName))
              {
                def split(s) : array[_] { s.Split(array["\r\n", "\n", "\r"], StringSplitOptions.None) }
                def output = split(dumpString);
                def gold   = split(File.ReadAllText(goldDumpName));
                match(DumpComparer.Compare(output, gold, StringComparison.Ordinal))
                {
                  | Success => Result.Passed("Passed")
                  | Fail(lineNumber, expectedText, foundText) =>
                    File.WriteAllText(dumpName, dumpString);
                    def message = $"Dump differs with gold on line $lineNumber. Expected '$expectedText' found '$foundText'";
                    def details = if(_showDiff) diff(gold, output) else [];
                    Result.Failed(message, details)
                }
              }
              else if(_createGoldFile)
              {
                File.WriteAllText(goldDumpName, dumpString);
                Result.Skipped("Gold file created");
              }
              else
              {
                File.WriteAllText(dumpName, dumpString);
                Result.Skipped("Gold file not found");
              }
            | _ => assert(false)
          }
        | Fail(message) => Result.Failed(message)
      }
    }

    private static diff(textA : array[string], textB : array[string], rangeToShow : int = 3) : list[string]
    {
      def output = List();
      output.Add("BEGIN-DIFF");
      def writeSeparator()
      {
        output.Add("...");
      }
      def writeOriginal(line : string) : void
      {
        output.Add("  " + line);
      }
      def writeRemoved(line : string) : void
      {
        output.Add(" -" + line);
      }
      def writeInserted(line : string) : void
      {
        output.Add(" +" + line);
      }
      mutable indexA = 0;
      foreach(diffItem in textA.Diff(textB))
      {
        // определяем нужно ли выводить разделитель
        def nextIndexA = Math.Max(indexA, diffItem.Index - rangeToShow);
        when(nextIndexA > indexA + 1)
          writeSeparator();

        // показваем не боле rangeToShow предыдущих строк
        indexA = nextIndexA;
        while(indexA < diffItem.Index)
        {
          writeOriginal(textA[indexA]);
          ++indexA;
        }

        // показываем удаленные строки
        for(mutable i = 0; i < diffItem.Deleted; ++i)
        {
          writeRemoved(textA[indexA]);
          ++indexA;
        }

        // показываем добавленные строки
        foreach(insertedItem in diffItem.Inserted)
          writeInserted(insertedItem);

        // показываем не более rangeToShow последующих строк
        def tailLinesToShow = Math.Min(rangeToShow, textA.Length - indexA);
        for(mutable i = 0; i < tailLinesToShow; ++i)
        {
          writeOriginal(textA[indexA]);
          ++indexA;
        }
      }
      when(indexA < textA.Length)
        writeSeparator();
      output.Add("END-DIFF");
      output.ToNList()
    }

    private _filePath : string;
    private _createGoldFile : bool;
    private _showDiff : bool;
  }
}
