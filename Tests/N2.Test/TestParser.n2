using N2;

syntax module TestParser
{
  token field Quote               = "\"";
  token field Colon               = ":";
  token field Comma               = ",";
  token field OpenBrace           = "{";
  token field CloseBrace          = "}";
  token field Quote               = "\"";
  token field Comma               = ",";
  token field Prefix              = "\\u";

  span class String;
  span class Keyword      = ['a'..'z']['a'..'z']+;
  span class Operator     = ['+', '-', '/', '*', '^', '?', ':']+;
  span class OpenBrace    = "(" | "{" | "[";
  span class CloseBrace   = ")" | "}" | "]";

  braces "{", "}";

  keyword regex ['A'..'Z', 'a'..'z', '_'..'_']+ rule S;

  token Any = ['\u0000'..'\uFFFF'];
  token NewLineCharacter  = '\n'
                    | '\r'
                    | '\u2028'    /*  line separator       */
                    | '\u2029';   /*  paragraph separator  */
  token NewLine  = "\r\n" | NewLineCharacter;
  token Whitespace = [Zs]
              | '\t'
              | '\v'        /*  vertial tab          */
              | '\f';       /*  form feed            */
  token Space = Whitespace | NewLine;
  token Spaces = Space+;

  syntax IgnoreToken;
  extend syntax IgnoreToken
  {
    SingleLineComment = "//" as Start (!NewLine Any)* as Body NewLine? as End;
    MultiLineComment  = "/*" as Start (!"*/" Any)*    as Body  "*/"    as End;
    SpaceToken        = Spaces;
  }

  [ExplicitSpaces] void s = IgnoreToken*;                /* optional spacer          */
  [ExplicitSpaces] void S = !IdentifierPartCharacters s; /* identifier break spacer  */

  token LetterCharacter       = ['A'..'Z', 'a'..'z', 'а'..'я', 'А'..'Я'];//[Lu, Ll, Lt, Lm, Lo, Nl];
  token CombiningCharacter    = [Mn, Mc];
  token DecimalDigitCharacter = [Nd];
  token ConnectingCharacter   = [Pc];
  token FormattingCharacter   = [Cf];
  token IdentifierStartCharacter  = LetterCharacter | "_";
  token IdentifierPartCharacters  = LetterCharacter | DecimalDigitCharacter | ConnectingCharacter | CombiningCharacter | FormattingCharacter;
  token IdentifierBody            = IdentifierStartCharacter IdentifierPartCharacters*;
  token HexDigit           = ['0'..'9', 'a'..'f', 'A'..'F'];
  token ReservedStringChar = "\"" | "\\";
  token ReservedCharChar   = "\'" | "\\";

  token Char = Any;

  syntax StringPart;
  extend syntax StringPart
  {
    [ExplicitSpaces] SimpleStringPart                 =  (!ReservedStringChar Char)+;
    [ExplicitSpaces] UnicodeEscapeSequenceStringPart  = "\\u"   HexDigit HexDigit HexDigit HexDigit;
    [ExplicitSpaces] EscapeSequenceStringPart         = "\\" as Backslash  Char;
  }

  [SpanClass(String), ExplicitSpaces]
  syntax StringLiteral                    = "\""  StringPart* "\""s;

  /////////////////////////////////////////////////////////////////////////////

  syntax Identifier  = IdentifierBody;

  syntax QIdentifier = Names { alias Names = (Identifier; ".")+; }

  [StartRule]
  syntax GrammarReference = "grammar" QIdentifier as GrammarName StartRuleReference?;

  [StartRule]
  syntax StartRuleReference =  "start" "rule" QIdentifier as RuleName;

  [StartRule]
  syntax TopDeclaration;
  extend syntax TopDeclaration
  {
    AssemblyReference = "reference" StringLiteral as FilePath GrammarReference*;
    Debugger          = "debugger";
  }

  [ExplicitSpaces]
  syntax Terminator = "test"S ":" Whitespace* NewLine?;

  token TestBody = Any*;

  [StartRule, ExplicitSpaces]
  syntax Start                = s TopDeclaration* Terminator TestBody;
}
