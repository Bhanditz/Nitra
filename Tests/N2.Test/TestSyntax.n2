using N2;

syntax module TestSyntax
{
  using PrettyPrint;
  using TokenNames;
  using Identifiers;
  using Whitespaces;
  using CStyleComments;

  token field Prefix              = "\\u";

  span class String;
  span class Keyword      = ['a'..'z']['a'..'z']+;
  span class Operator     = ['+', '-', '/', '*', '^', '?', ':']+;
  span class OpenBrace    = "(" | "{" | "[";
  span class CloseBrace   = ")" | "}" | "]";

  braces "{", "}";

  keyword regex IdentifierStartCharacter IdentifierPartCharacters* rule S;

  extend syntax IgnoreToken
  {
    | SingleLineComment;
    | MultiLineComment;
  }

  token HexDigit           = ['0'..'9', 'a'..'f', 'A'..'F'];
  token ReservedStringChar = "\"" | "\\";
  token ReservedCharChar   = "\'" | "\\";

  token Char = Any;

  [ExplicitSpaces]
  syntax StringPart
  {
    | Simple                 =  (!ReservedStringChar Char)+;
    | UnicodeEscapeSequence  = "\\u" HexDigit HexDigit HexDigit HexDigit;
    | EscapeSequence         = "\\"  Char;
  }

  [SpanClass(String), ExplicitSpaces]
  syntax StringLiteral                    = "\""  StringPart* "\""s;

  /////////////////////////////////////////////////////////////////////////////

  [ExplicitSpaces]
  syntax Identifier  = IdentifierBody;

  syntax QIdentifier = Names { alias Names = (Identifier; ".")+; }

  syntax GrammarReference = "grammar" QIdentifier as GrammarName StartRuleReference?;

  syntax StartRuleReference =  "start" "rule" QIdentifier as RuleName;

  syntax TopDeclaration
  {
    | AssemblyReference = "reference" StringLiteral as FilePath GrammarReference*;
    | Debugger          = "debugger";
  }

  [ExplicitSpaces]
  syntax Terminator = "test"S ":" Whitespace* NewLine?;

  token TestBody = Any*;

  [StartRule, ExplicitSpaces]
  syntax Start                = s TopDeclaration* Terminator TestBody;
}
