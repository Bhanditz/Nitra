using Nitra.LanguageCompiler.Utils;
using Nitra.ProjectSystem;

using WpfColor = System.Windows.Media.Color;

namespace Nitra
{
  syntax module LangSpec
  {
    using Core;
    using CStyleComments;

    [StartRule]
    syntax Language = "language" Name "{" Properties=LanguageProperty* "}";

    syntax LanguageProperty
    {
      | Style                     = "style" sm Name sm "{" sm Format+ sm "}";
      | SpanClassDefinitionStyle  = "span" sm "class" sm Name sm "=" sm Style=Reference ";";
      | SpanClassDefinitionInline = "span" sm "class" sm Name sm "{" sm Format+ sm "}";
      | FileExtension             = "extension" sm "=" sm Ext=FileExtension ";";
      | SyntaxModule              = "syntax" sm "module" sm Module=QualifiedIdentifier RuleOpt=(sm "start" sm "rule" sm QualifiedIdentifier)? ";";
      | Company                   = "company"       sm "=" sm Name=(!";" Any)* ";";
      | Description               = "description"   sm "=" sm Text=(!";" Any)* ";";
      | Authors                   = "authors"       sm "=" sm Text=(!";" Any)* ";";
      | Copyright                 = "copyright"     sm "=" sm Text=(!";" Any)* ";";
      | LicenseUrl                = "license" "url" sm "=" sm Text=(!";" Any)* ";";
      | RequireLicenseAcceptance  = "require" "license" "acceptance" ";";
    }

    syntax Format
    {
      | ForegroundColor = "ForegroundColor" sm "=" sm Color ";"
    }


    syntax Color
    {
      Value(_compilerMessages : ICompilerMessages) : WpfColor;

      | Hex=HexColor { override Value = HexColor.Value(); }
      | Named = Identifier { override Value = StringToColor(Identifier, _compilerMessages); }
    }

    token HexColor = "#" R=Hex G=Hex B=Hex
    {
      regex Hex = ['0'..'9', 'A'..'F', 'a'..'f']{2};

      Value() : WpfColor = WpfColor.FromRgb(ParseHex(GetText(R)), ParseHex(GetText(G)), ParseHex(GetText(B)));
    }

    regex FileExtension = "." IdentifierPartCharacters+;

    token Identifier = !Keyword IdentifierBody;

    [Reference]
    token Reference = !Keyword IdentifierBody;

    [Name]
    token Name = !Keyword IdentifierBody;

    [ExplicitSpaces]
    syntax QualifiedIdentifier = Parts=(Identifier; s "." s)+;

    regex KeywordToken = "language" | "span" | "class" | "extention" | "start" | "syntax" | "rule";

    [Keyword]
    token Keyword = Name=KeywordToken !IdentifierPartCharacters;

    extend token IgnoreToken
    {
      | [SpanClass(Comment)] SingleLineComment;
      | [SpanClass(Comment)] MultiLineComment;
    }
  }
}
