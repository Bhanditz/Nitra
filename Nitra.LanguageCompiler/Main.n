using CSharp.TopDeclarationsParseTree;
using CSharp.StatementsParseTree;
using CSharp.ExpressionsParseTree;

using Microsoft.VisualBasic.FileIO;

using Nitra.Quote;

using Nemerle.Collections;
using Nemerle.Imperative;
using Nemerle.Text;
using Nemerle.Utility;

using Nitra;
using Nitra.Declarations;
using Nitra.LanguageCompiler.Utils;

using System;
using System.Console;
using System.Diagnostics;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;

[assembly: ImportRules(Grammar = "CSharp.SplicableTopDeclarations")]
[assembly: ImportRules(Grammar = "CSharp.SplicableExpressions")]

namespace Nitra.LanguageCompiler
{
  module Program
  {
    public VsPackageTemplatePath : string = TemplatePath(@"Templates\XXLanguageXXVsPackage");

    Main() : void
    {
      Start();
      //_ = ReadLine();
    }

    Start() : void
    {
      def config = CommandPromptReader();

      unless (config.Success)
        return;

      def langSpecFile = config.LangSpecFile;
      def spec         = File.ReadAllText(langSpecFile);
    
      def source      = SourceSnapshot(spec, 0, langSpecFile);
      def lang = Parse(source, config);
      when (lang == null)
        return;

      def (success, _stratRuleDescriptor) = Check(lang, config);

      unless (success)
        return;

      def vars = GetVars(lang, config);

      foreach ((var, value) in vars)
        WriteLine($"$var = $value");

      CopyBinaries(lang, config);
      CopyGrammars(lang, config);

      GenerateFileAndContentTypeDefinitions(lang, config);

      GenerateSpanClasses(lang, config);

      when (config.GenerateProject)
        GenerateProject(lang, config, vars);

      WriteLine("Output Path: " + config.OutputPath);
    }

    CopyBinaries(lang : Language, config : CommandPromptReader) : void
    {
      ExternalDependences(lang, config, config.Binaries);
    }

    CopyGrammars(lang : Language, config : CommandPromptReader) : void
    {
      ExternalDependences(lang, config, config.AssemblyReferences);
    }

    ExternalDependences(lang : Language, config : CommandPromptReader, paths : list[string]) : void
    {
      def binPath = Path.Combine(config.OutputPath, lang.ProjectName, "ExternalDependences");
      foreach (path in paths)
      {
        if (Directory.Exists(path))
          FileSystem.CopyDirectory(path, binPath, UIOption.OnlyErrorDialogs);
        else if (File.Exists(path))
        {
          def fileName = Path.GetFileName(path);
          def outPath = Path.Combine(binPath, fileName);
          File.Copy(path, outPath, overwrite=true);
        }
        else 
          config.CompilerMessages.Error(Location.Default, "File or directory '" + path + "' does not exists.");
      }
    }

    GenerateFileAndContentTypeDefinitions(lang : Language, config : CommandPromptReader) : void
    {
      def prjName        = lang.ProjectName;
      def vars           = DefaultVars(lang, config);
      def fileExtensions = List();

      foreach (fileExtension in lang.FileExtensions)
      {
        def ext     = fileExtension.Ext.Value;
        def extName = ExtensionToName(ext);
        ExpandTemplate(@"Templates\FileAndContentTypeDefinitions\FileExtensionToContentTypeDefinition.cs",  $@"$prjName\FileAndContentTypeDefinitions\$(extName)FileExtensionToContentTypeDefinition.Generated.cs", 
          ("XXFileExtensionNameXX", extName) ::
          ("XXFileExtensionXX",     ext) ::
          vars,
          config);

        fileExtensions.Add(ext);
      }

      def fileExtensionsReplacement = (<#"FileExtensions"#>, $<#..$(fileExtensions; ", "; e => "\"" + e + "\"")#>);

      ExpandTemplate(@"Templates\FileAndContentTypeDefinitions\NitraContentTypeDefinition.cs",  $@"$prjName\FileAndContentTypeDefinitions\NitraContentTypeDefinition.Generated.cs", 
        fileExtensionsReplacement :: vars,
        config);
    }

    public DefaultVars(lang : Language, config : CommandPromptReader) : list[string * string]
    {
      def startSyntaxModule  = lang.StartSyntaxModule;
      def assemblyReferences = config.AssemblyReferences.Map(Path.GetFileName);

      [
        ("XXNamespaceXX",         config.DefaultNamespace),
        ("XXLanguageXX",          lang.Name.ToString()),
        ("XXCompanyXX",           lang.Company.Name.Value.Trim()),
        ("XXParserAssembliesXX",  $<#..$(assemblyReferences; ", "; a => <#path + @"#> + a + <#"#>)#>),
        ("XXStartSyntaxModuleXX", <#@"#> + startSyntaxModule.Module + <#"#>),
        ("XXStartRuleXX",         <#@"#> + startSyntaxModule.StartRule + <#"#>),
      ]
    }

    public GetVars(lang : Language, config : CommandPromptReader) : list[string * string]
    {
      def vars              = DefaultVars(lang, config);
      def guidsFileName     = "Guids.cs";
      def templateGuidsPath = Path.Combine(VsPackageTemplatePath, guidsFileName);
      def name              = lang.Name.ToString();
      def prjName           = name + "VsPackage";
      def guidsPath         = Path.Combine(config.OutputPath, prjName, guidsFileName);
      def templateGuids     = ReadGuids(templateGuidsPath);
      def guids             = if (config.NewGuids || !File.Exists(guidsPath)) Hashtable() else ReadGuids(guidsPath);

      mutable replaces = vars;

      foreach ((templateConstName, templateGuid) in templateGuids.KeyValuePairs)
      {
        def constName = ExpandTemplateText(templateConstName, vars);
        mutable guid;
        if (guids.TryGetValue(constName, out guid))
          unless (string.Equals(templateGuid, guid, StringComparison.InvariantCulture))
            replaces ::= (templateGuid, guid);
        else
          replaces ::= (templateGuid, Guid.NewGuid().ToString("D").ToUpperInvariant());
      }

      replaces
    }

    internal sealed class CSharpCollectConstVisitor : ParseTreeVisitor
    {
      public Result : Hashtable[string, string] = Hashtable();
      //private mutable _inStringGuidConst : bool;
      //private mutable _name : string;

      public override Visit(ast : ParseTree) : ParseTree
      {
        quote match (ast)
        {
          | <# TypeMemberDeclaration: $Attributes(_) $Modifiers(_)
            const string $Name(name) = $ConstantExpression(str is Expression.RegularStringLiteral); #> =>
            def text = str.RegularStringLiteral.RegularStringLiteralParts.GetText();
            Result[name.ToString()] = text;
            ast.Apply(this)
          //| c is TypeMemberDeclaration.Constant when c.AnyType.GetText().Trim() == "string" => 
          //  _inStringGuidConst = true;
          //  try c.Apply(this) finally _inStringGuidConst = false;
          //    
          //| c is ConstantDeclarator when _inStringGuidConst => 
          //  def name = c.Name.GetText().Trim();
          //  _inStringGuidConst = name.StartsWith("Guid", StringComparison.InvariantCultureIgnoreCase);
          //
          //  when (_inStringGuidConst)
          //    _name = name;
          //  
          //  try c.Apply(this) 
          //  finally { _inStringGuidConst = false; _name = null; }
          | _ => ast.Apply(this)
        }
      }
    }

    public ReadGuids(sourcePath : string) : Hashtable[string, string]
    {
      def text         = File.ReadAllText(sourcePath);
      def source       = SourceSnapshot(text, 0, sourcePath);
      def parseResult  = CSharp.Main.CompilationUnit(source);
      def parseTree    = CSharp.MainParseTree.CompilationUnit.Create(parseResult);
      def visitor      = CSharpCollectConstVisitor();

      _ = parseTree.Apply(visitor);

      visitor.Result
    }

    GenerateProject(lang : Language, config : CommandPromptReader, vars : Seq[string * string]) : void
    {
      def name = lang.Name.ToString();
      def prjName = name + "VsPackage";
      ExpandTemplates(VsPackageTemplatePath,  Path.Combine(config.OutputPath, prjName), vars, config);
          
      def snkPath = Path.Combine(config.OutputPath, prjName, "Key.snk");
      unless (File.Exists(snkPath))
        CreateSnk(snkPath);
    }

    GenerateSpanClasses(lang : Language, config : CommandPromptReader) : void
    {
      def prjName = lang.ProjectName;
      
      foreach (spanClasse in lang.SpanClasses)
      {
        def color = spanClasse.DefaultForegroundColor.Value;
        def name = spanClasse.Name.ToString();
        ExpandTemplate(@"Templates\Highlighting\ClassificationDefinition.cs",  $@"$prjName\Highlighting\$(name)ClassificationDefinition.Generated.cs", 
          [("XXNamespaceXX",     config.DefaultNamespace),
           ("XXDisplay nameXX",  lang.Name + " " + name),
           ("XXSpanClassNameXX", lang.Name + name),
           ("Colors.Red",        ColorToString(color, "Colors.")),
           ("Red",               ColorToString(color)),
           ],
          config);
      }
    }

    Parse(source : SourceSnapshot, config : CommandPromptReader) : Language
    {
      def parseResult = LangSpec.Language(source);
      unless (parseResult.IsSuccess)
      {
        foreach(error in parseResult.GetErrors())
          config.CompilerMessages.Error(error.Location, error.Message);
        return null;
      }

      def parseTree = LangSpecParseTree.Language.CreateParseTree(parseResult);
      def file      = Nitra.ProjectSystem.FakeFile(source);
      def ast       = AstRoot.Create(file, parseTree, config.CompilerMessages);
      ast.EvalProperties();
      ast.Content
    }

    Check(lang : Language, config : CommandPromptReader) : bool * RuleDescriptor
    {
      when (config.CompilerMessages.ErrorCount > 0)
        return (false, null);

      def descriptors    = config.ModuleDescriptors;
      def definedModules = Dictionary();

      def bindSyntaxModule(qid : QualifiedIdentifier) : GrammarDescriptor
      {
        def name = qid.ToString();
        mutable descriptor;
        if (descriptors.TryGetValue(name, out descriptor))
        {
          mutable exisingModule;
          if (definedModules.TryGetValue(name, out exisingModule))
          {
            using (root = config.CompilerMessages.RootError(qid, $<#Multiple definition of syntax module '$name'.#>))
              root.Hint(exisingModule, "First defined here.");
          }
          else
            definedModules.Add(name, qid);
        }
        else
          config.CompilerMessages.Error(qid, $<#Syntax module '$name' not found.#>);

        descriptor
      }

      def bindRule(grammarDescriptor : GrammarDescriptor, qid : QualifiedIdentifier) : RuleDescriptor
      {
        def name = qid.ToString();
        if (grammarDescriptor.LookupRule(name) is Some(ruleDescriptor))
          ruleDescriptor
        else
        {
          config.CompilerMessages.Error(qid, $<#Rule '$name' not found in '$(grammarDescriptor.FullName)' syntax module.#>);
          null
        }
      }

      mutable startRuleDescriptor;
      def startModule     = lang.StartSyntaxModule;
      def startDescriptor = bindSyntaxModule(startModule.Module);
      when (startDescriptor != null)
        startRuleDescriptor = bindRule(startDescriptor, startModule.StartRule);

      foreach (m in lang.AdditionalSyntaxModules)
        _ = bindSyntaxModule(m.Module);

      foreach (fileExtension in lang.FileExtensions)
        unless (fileExtension.Ext.HasValue)
          config.CompilerMessages.Error(fileExtension, "Bad file extension.");

      (config.CompilerMessages.ErrorCount == 0, startRuleDescriptor)
    }
 
    ExpandTemplates(templateRootPath : string, outputPath : string, vars : Seq[string * string], config : CommandPromptReader) : void
    {
      unless (Directory.Exists(outputPath))
      {
        _ = Directory.CreateDirectory(outputPath);
        assert(true);
      }

      foreach (file in Directory.EnumerateFiles(templateRootPath))
      {
        def fileName = Path.GetFileName(file);
        def outFile = Path.Combine(outputPath, ExpandTemplateText(fileName, vars));
        ExpandTemplate(file, outFile, vars, config);
      }

      foreach (dir in Directory.EnumerateDirectories(templateRootPath))
      {
        def dirName = Path.GetFileName(dir);
        def outDir = Path.Combine(outputPath, ExpandTemplateText(dirName, vars));
        ExpandTemplates(Path.Combine(templateRootPath, dirName), outDir, vars, config);
      }
    }

    ExpandTemplateText(templateText : string, vars : Seq[string * string]) : string
    {
      def templateBuilder = StringBuilder(templateText, templateText.Length + templateText.Length / 10);

      foreach ((name, value) in vars)
        _ = templateBuilder.Replace(name, value);

      def result = templateBuilder.ToString();
      result
    }

    ExpandTemplate(templatePath : string, outputPath : string, vars : Seq[string * string], config : CommandPromptReader) : void
    {
      def templatePath = TemplatePath(templatePath);
      def outputPath2  = Path.GetFullPath(Path.Combine(config.OutputPath, outputPath));
      def outputDir    = Path.GetDirectoryName(outputPath2);

      unless (Directory.Exists(outputDir))
        _ = Directory.CreateDirectory(outputDir);

      unless (IsUtf8File(templatePath))
      {
        File.Copy(templatePath, outputPath2, overwrite=true);
        return;
      }

      def templateText    = File.ReadAllText(templatePath, Encoding.UTF8);
      def result          = ExpandTemplateText(templateText, vars);

      File.WriteAllText(outputPath2, result, Encoding.UTF8);

      def index = result.IndexOf("XX");
      when (index >= 0)
      {
        def loc = Location(SourceSnapshot(File.ReadAllText(templatePath), 0, templatePath), index, index + 2);
        config.CompilerMessages.Error(loc, "The template contains unreplaced placeholders.");
      }
    }
  }
}

namespace Nitra
{
  public abstract partial class Language : AstBase[IAst]
  {
    public ProjectName : string { get { Name + "VsPackage"} }
  }

  public abstract partial class QualifiedIdentifier : AstBase[IAst]
  {
    public sealed partial class Concrete : QualifiedIdentifier
    {
      public override ToString() : string
      {
        $<#..$(this.Parts; ".")#>
      }
    }
  }
}
