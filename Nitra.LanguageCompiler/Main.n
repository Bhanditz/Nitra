using CSharp.TopDeclarationsParseTree;
using CSharp.StatementsParseTree;
using CSharp.ExpressionsParseTree;

using Microsoft.VisualBasic.FileIO;

using Nemerle.Collections;
using Nemerle.Imperative;
using Nemerle.Text;
using Nemerle.Utility;

using Nitra;
using Nitra.Declarations;
using Nitra.LanguageCompiler.Utils;
using Nitra.ProjectSystem;

using System;
using System.Console;
using System.Diagnostics;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;

namespace Nitra.LanguageCompiler
{
  module Program
  {
    public VsPackageTemplatePath : string = TemplatePath(@"Templates\XXLanguageXXVsPackage");

    Main() : void
    {
      Threading.Thread.CurrentThread.CurrentCulture = CultureInfo.InvariantCulture;
      Start();
      //_ = ReadLine();
    }

    Start() : void
    {
      def config = CommandPromptReader();

      unless (config.Success)
        return;

      def lang = Parse(config);
      when (lang == null)
        return;

      def (success, _stratRuleDescriptor) = Check(lang, config);

      unless (success)
        return;

      //assert2(false);
        
      def vars = GetVars(lang, config);

      foreach ((var, value) in vars)
        WriteLine($"$var = $value");

      CopyBinaries(lang, config);
      CopyGrammars(lang, config);
      GenerateFileAndContentTypeDefinitions(lang, config);
      GenerateSpanClasses(lang, config);
      GenerateProject(lang, config, vars);

      WriteLine("Output Path: " + config.OutputPath);
    }

    MakeXXFilesXXVar(lang : Language, config : CommandPromptReader) : string * string
    {
      def binPath = GetExternalDependencesOutputPath(lang, config);
      def files = List();

      foreach (file in Enumerable.Concat(config.AssemblyReferences, config.Binaries))
      {
        def path = Path.Combine(binPath, Path.GetFileName(file));
        def pathWithWildcards = Path.ChangeExtension(path, ".???");
        files.Add($<#    <file src="$(pathWithWildcards)" target="lib\net45\" />#>);
      }
      
      def filesContent  = $<#..$(files; "\r\n")#>;
      ("XXFilesXX", filesContent)
    }
    
    CopyBinaries(lang : Language, config : CommandPromptReader) : void
    {
      ExternalDependences(lang, config, config.Binaries);
    }

    CopyGrammars(lang : Language, config : CommandPromptReader) : void
    {
      ExternalDependences(lang, config, config.AssemblyReferences);
    }

    GetExternalDependencesOutputPath(lang : Language, config : CommandPromptReader) : string
    {
      Path.Combine(config.OutputPath, lang.ProjectName, "ExternalDependences")
    }
    
    ExternalDependences(lang : Language, config : CommandPromptReader, paths : list[string]) : void
    {
      def binPath = GetExternalDependencesOutputPath(lang, config);
      
      unless (Directory.Exists(binPath))
        _ = Directory.CreateDirectory(binPath);
        
      foreach (path1 in paths)
      {
        def path = Path.GetFullPath(path1);
        if (Directory.Exists(path))
          FileSystem.CopyDirectory(path, binPath, UIOption.OnlyErrorDialogs);
        else if (File.Exists(path))
        {
          def fileName = Path.GetFileName(path);
          def outPath = Path.Combine(binPath, fileName);
          File.Copy(path, outPath, overwrite=true);
          def pdbPath = Path.ChangeExtension(path, ".pdb");
          when (File.Exists(pdbPath))
          {
            def pdbFileName = Path.GetFileName(pdbPath);
            def pdbOutPath = Path.Combine(binPath, pdbFileName);
            File.Copy(pdbPath, pdbOutPath, overwrite=true);
          }
        }
        else 
          config.CompilerMessages.Error(Location.Default, "File or directory '" + path + "' does not exists.");
      }
    }

    GenerateFileAndContentTypeDefinitions(lang : Language, config : CommandPromptReader) : void
    {
      def prjName        = lang.ProjectName;
      def vars           = DefaultVars(lang, config);
      def fileExtensions = List();

      foreach (fileExtension in lang.FileExtensions)
      {
        def ext     = fileExtension.Ext.Value;
        def extName = ExtensionToName(ext);
        ExpandTemplate(@"Templates\FileAndContentTypeDefinitions\FileExtensionToContentTypeDefinition.cs",  $@"$prjName\FileAndContentTypeDefinitions\$(extName)FileExtensionToContentTypeDefinition.Generated.cs", 
          ("XXFileExtensionNameXX", extName) ::
          ("XXFileExtensionXX",     ext) ::
          vars,
          config);

        fileExtensions.Add(ext);
      }

      def fileExtensionsReplacement = (<#"XXFileExtensionsXX"#>, $<#..$(fileExtensions; ", "; e => "\"" + e + "\"")#>);

      ExpandTemplate(@"Templates\FileAndContentTypeDefinitions\NitraContentTypeDefinition.cs",  $@"$prjName\FileAndContentTypeDefinitions\NitraContentTypeDefinition.Generated.cs", 
        fileExtensionsReplacement :: vars,
        config);
    }

    public DefaultVars(lang : Language, config : CommandPromptReader) : list[string * string]
    {
      def startSyntaxModule  = lang.StartSyntaxModule;
      def assemblyReferences = config.AssemblyReferences.Map(Path.GetFileName);

      [
        ("XXNamespaceXX",                config.DefaultNamespace),
        ("XXLanguageXX",                 lang.Name.ToString()),
        ("XXCompanyXX",                  lang.Company.Name.Value.Trim()),
        ("XXCompanyIdXX",                lang.Company.Name.Value.Trim().Replace("   ", "").Replace("  ", "").Replace(" ", "")),
        ("XXDescriptionXX",              lang.Description.Text.Value.Trim()),
        ("XXAuthorsXX",                  lang.Authors.Text.Value.Trim()),
        ("XXCopyrightXX",                lang.Copyright.Text.Value.Trim()),
        ("XXLicenseUrlXX",               lang.LicenseUrl.Text.Value.Trim()),
        ("XXRequireLicenseAcceptanceXX", lang.RequireLicenseAcceptance.HasValue.ToString().ToLower()),
        ("XXParserAssembliesXX",         $<#..$(assemblyReferences; ", "; a => <#path + @"#> + a + <#"#>)#>),
        ("XXStartSyntaxModuleXX",        <#@"#> + startSyntaxModule.Module + <#"#>),
        ("XXStartRuleXX",                <#@"#> + startSyntaxModule.StartRule + <#"#>),
        MakeXXFilesXXVar(lang, config),
      ]
    }

    public GetVars(lang : Language, config : CommandPromptReader) : list[string * string]
    {
      def vars              = DefaultVars(lang, config);
      def guidsFileName     = "Guids.cs";
      def templateGuidsPath = Path.Combine(VsPackageTemplatePath, guidsFileName);
      def name              = lang.Name.ToString();
      def prjName           = name + "VsPackage";
      def guidsPath         = Path.Combine(config.OutputPath, prjName, guidsFileName);
      def templateGuids     = ReadGuids(templateGuidsPath);
      def guids             = if (config.NewGuids || !File.Exists(guidsPath)) Hashtable() else ReadGuids(guidsPath);
      mutable replaces = vars;
      //assert2(false);
      def pkgConfigPath     = Path.Combine(VsPackageTemplatePath, "packages.config");
      def pkgConfig         = File.ReadAllText(pkgConfigPath);
      def versionRegex      = Text.RegularExpressions.Regex(<#.+id="Nitra.Core"\s+version="([^"]+)"#>);
      def result            = versionRegex.Match(pkgConfig);
      if (result.Success)
      {
        def oldVersion         = result.Groups[1].Value;
        def newVersion         = typeof(NSpan).Assembly.GetName().Version.ToString();
        replaces ::= (oldVersion, newVersion);
      }
      else
      {
        def configSnapshot = SourceSnapshot("", pkgConfigPath);
        def loc = Location(configSnapshot, 0);
        config.CompilerMessages.Error(loc, <#Version for Nitra.Core not found.#>);
      }

      foreach ((templateConstName, templateGuid) in templateGuids.KeyValuePairs)
      {
        def constName = ExpandTemplateText(templateConstName, vars);
        mutable guid;
        if (guids.TryGetValue(constName, out guid))
          unless (string.Equals(templateGuid, guid, StringComparison.InvariantCulture))
            replaces ::= (templateGuid, guid);
        else
          replaces ::= (templateGuid, Guid.NewGuid().ToString("D").ToUpperInvariant());
      }

      replaces
    }

    internal sealed class CSharpCollectConstVisitor : ParseTreeVisitor
    {
      public Result : Hashtable[string, string] = Hashtable();
      //private mutable _inStringGuidConst : bool;
      //private mutable _name : string;

      public override Visit(ast : ParseTree) : ParseTree
      {
        //| <# TypeMemberDeclaration: $Attributes(_) $Modifiers(_)
        //  const string $Name(name) = $ConstantExpression(str is Expression.RegularStringLiteral); #> =>
        when (ast is TypeMemberDeclaration.Constant as constant)
        when (constant.AnyType.ToString() == "string")
        when (constant.ConstantDeclarators.ConstantDeclaratorsData is ([declarator], _))
        when (declarator.ConstantExpression is Expression.RegularStringLiteral as str)
        {
          def text = str.RegularStringLiteral.RegularStringLiteralParts.GetText();
          Result[declarator.Name.ToString()] = text;
        }
        ast.Apply(this);
      }
    }

    public ReadGuids(sourcePath : string) : Hashtable[string, string]
    {
      def text         = File.ReadAllText(sourcePath);
      def source       = SourceSnapshot(text, sourcePath);
      def parseResult  = CSharp.Main.CompilationUnit.Parse(source);
      def parseTree    = CSharp.MainParseTree.CompilationUnit.CreateParseTree(parseResult);
      def visitor      = CSharpCollectConstVisitor();

      _ = parseTree.Apply(visitor);

      visitor.Result
    }

    GenerateProject(lang : Language, config : CommandPromptReader, vars : Seq[string * string]) : void
    {
      def name = lang.Name.ToString();
      def prjName = name + "VsPackage";
      ExpandTemplates(VsPackageTemplatePath,  Path.Combine(config.OutputPath, prjName), vars, config);
          
      def snkPath = Path.Combine(config.OutputPath, prjName, "Key.snk");
      unless (File.Exists(snkPath))
        CreateSnk(snkPath);
    }

    GenerateSpanClasses(lang : Language, config : CommandPromptReader) : void
    {
      def spanClassMap = Dictionary();
      def spanClasses = lang.SpanClassDefinitionStyles.Select(s => (s, s.Name, s.StyleDef.ForegroundColor)).ToList();
      spanClasses.AddRange(lang.SpanClassesInlines.Select(s => (s, s.Name, s.ForegroundColor)));
      
      foreach ((ast, name, _) in spanClasses)
      {
        mutable prev;
        if (spanClassMap.TryGetValue(name.Id, out prev))
          using (root = config.CompilerMessages.RootError(ast, "Duplicate span class '$(spanClass.Name.Text)'"))
            root.Error(prev, "previous definition");
        else
          spanClassMap.Add(name.Id, ast);
      }
          
      when (config.CompilerMessages.ErrorCount > 0)
        return;
          
      def prjName = lang.ProjectName;
      foreach ((_, name, foregroundColor) in spanClasses)
      {
        def color = foregroundColor.Color.Value;
        def name = name.ToString();
        ExpandTemplate(@"Templates\Highlighting\ClassificationDefinition.cs",  $@"$prjName\Highlighting\$(name)ClassificationDefinition.Generated.cs", 
          [("XXNamespaceXX",     config.DefaultNamespace),
           ("XXDisplay nameXX",  lang.Name + " " + name),
           ("XXSpanClassNameXX", lang.Name + name),
           ("Colors.Red",        ColorToString(color, "Colors.")),
           ("Red",               ColorToString(color)),
           ],
          config);
      }
    }

    Parse(config : CommandPromptReader) : Language
    {
      def solution  = FsSolution();
      def project   = FsProject(solution);
      def file      = FsFile(config.LangSpecFile, LangSpec.Language, project);
      solution.EvalProperties(DependentPropertyEvalContext(), null, 0);
      file.Ast :> Language
    }

    Check(lang : Language, config : CommandPromptReader) : bool * RuleDescriptor
    {
      when (config.CompilerMessages.ErrorCount > 0)
        return (false, null);

      def descriptors    = config.ModuleDescriptors;
      def definedModules = Dictionary();

      def bindSyntaxModule(qid : QualifiedIdentifier) : GrammarDescriptor
      {
        def name = qid.ToString();
        mutable descriptor;
        if (descriptors.TryGetValue(name, out descriptor))
        {
          mutable exisingModule;
          if (definedModules.TryGetValue(name, out exisingModule))
          {
            using (root = config.CompilerMessages.RootError(qid, $<#Multiple definition of syntax module '$name'.#>))
              root.Hint(exisingModule, "First defined here.");
          }
          else
            definedModules.Add(name, qid);
        }
        else
          config.CompilerMessages.Error(qid, $<#Syntax module '$name' not found.#>);

        descriptor
      }

      def bindRule(grammarDescriptor : GrammarDescriptor, qid : QualifiedIdentifier) : RuleDescriptor
      {
        def name = qid.ToString();
        if (grammarDescriptor.LookupRule(name) is Some(ruleDescriptor))
          ruleDescriptor
        else
        {
          config.CompilerMessages.Error(qid, $<#Rule '$name' not found in '$(grammarDescriptor.FullName)' syntax module.#>);
          null
        }
      }

      mutable startRuleDescriptor;
      def startModule     = lang.StartSyntaxModule;
      def startDescriptor = bindSyntaxModule(startModule.Module);
      when (startDescriptor != null)
        startRuleDescriptor = bindRule(startDescriptor, startModule.StartRule);

      foreach (m in lang.AdditionalSyntaxModules)
        _ = bindSyntaxModule(m.Module);

      foreach (fileExtension in lang.FileExtensions)
        unless (fileExtension.Ext.HasValue)
          config.CompilerMessages.Error(fileExtension, "Bad file extension.");

      (config.CompilerMessages.ErrorCount == 0, startRuleDescriptor)
    }
 
    ExpandTemplates(templateRootPath : string, outputPath : string, vars : Seq[string * string], config : CommandPromptReader) : void
    {
      unless (Directory.Exists(outputPath))
      {
        _ = Directory.CreateDirectory(outputPath);
        assert(true);
      }

      foreach (file in Directory.EnumerateFiles(templateRootPath))
      {
        def fileName = Path.GetFileName(file);
        def outFile = Path.Combine(outputPath, ExpandTemplateText(fileName, vars));
        ExpandTemplate(file, outFile, vars, config);
      }

      foreach (dir in Directory.EnumerateDirectories(templateRootPath))
      {
        def dirName = Path.GetFileName(dir);
        when (dirName == "packages")
          continue;
        def outDir = Path.Combine(outputPath, ExpandTemplateText(dirName, vars));
        ExpandTemplates(Path.Combine(templateRootPath, dirName), outDir, vars, config);
      }
    }

    ExpandTemplateText(templateText : string, vars : Seq[string * string]) : string
    {
      def templateBuilder = StringBuilder(templateText, templateText.Length + templateText.Length / 10);

      foreach ((name, value) in vars)
        _ = templateBuilder.Replace(name, value);

      def result = templateBuilder.ToString();
      result
    }

    ExpandTemplate(templatePath : string, outputPath : string, vars : Seq[string * string], config : CommandPromptReader) : void
    {
      def templatePath = TemplatePath(templatePath);
      def outputPath2  = Path.GetFullPath(Path.Combine(config.OutputPath, outputPath));
      def outputDir    = Path.GetDirectoryName(outputPath2);

      unless (Directory.Exists(outputDir))
        _ = Directory.CreateDirectory(outputDir);

      when (IsBinary(templatePath))
      {
        File.Copy(templatePath, outputPath2, overwrite=true);
        return;
      }

      def encoding = if (IsUtf8File(templatePath)) Encoding.UTF8 else Encoding.ASCII;
      def templateText    = File.ReadAllText(templatePath, encoding);
      def result          = ExpandTemplateText(templateText, vars);

      File.WriteAllText(outputPath2, result, encoding);

      def index = result.IndexOf("XX");
      when (index >= 0)
      {
        def loc = Location(SourceSnapshot(File.ReadAllText(templatePath), templatePath), index, index + 2);
        config.CompilerMessages.Error(loc, "The template contains unreplaced placeholders.");
      }
    }
  }
}

namespace Nitra
{
  public abstract partial class Language : AstBase
  {
    public ProjectName : string { get { Name + "VsPackage"} }
  }

  public partial class QualifiedIdentifier : AstBase
  {
    public override ToString() : string
    {
      $<#..$(this.Parts; "."; x => x.Text.ValueOrDefault)#>
    }
  }
}
