using Nemerle.Collections;
using Nitra;
using Nemerle.Text;
using Nemerle.Utility;

using Nitra.Internal;
using Nitra.Runtime;
using Nitra.Runtime.Reflection;
using System;
using System.Collections.Generic;
using System.IO;
using System.Reflection;
using System.Console;
using System.Linq;

using SCG = System.Collections.Generic;

public partial abstract class N2Parser
{
  private class UsingImportDeclarationWalker : WalkerBase[int]
  {
    public Name : SCG.List[string] = SCG.List();

    private static IdentifierDescriptor : object = N2Parser.GrammarDescriptorImpl.StaticDescriptor.Rules.First(r => r.Name == "Identifier");

    public override OnRegularCall(ruleInfo : SubruleInfo.RegularCall, startPos : int, endPos : int, parseResult : IParseResult, context : int) : void
    {
      IgnoreParams();
      when (ruleInfo.Descriptor : object == IdentifierDescriptor)
      {
        Name.Add(parseResult.ParseSession.SourceSnapshot.Text.Substring(startPos, endPos - startPos))
      }
    }

    public override OnSimpleCall(ruleInfo : SubruleInfo.SimpleCall, startPos : int, endPos : int, parseResult : IParseResult, context : int) : void
    {
      WalkSimple(startPos, endPos, ruleInfo.RuleParser, parseResult, context);
    }
  }

  UsingImportDeclarationHandler(rawTreePtr : int, startPos : int, endPos : int, ruleParser : ExtensionRuleParser, parseResult : IParseResult, grammar : CompositeGrammar) : CompositeGrammar
  {
    def walker = UsingImportDeclarationWalker();
    walker.WalkPrefix(rawTreePtr, startPos, endPos, ruleParser, parseResult, 0);
    grammar
  }

  // FIXME: currently does not work
  NamespaceScopeBegin() : void
  {
    //Parser.PushState();
  }

  // FIXME: currently does not work
  NamespaceScopeEnd(_ : bool) : void
  {
    //Parser.PopState();
  }
}

public partial module N2ParserParseTree
{
  public partial class QualifiedIdentifier : Nitra.ParseTree
  {
    public Path : string
    {
      get
      {
        $<#..$(Identifiers.Item1; "."; GetText)#>
      }
    }
  }
}


module Program
{
  Main() : void
  {
    def test(code : string) : void
    {
      def parserHost = ParserHost();
      def source = SourceSnapshot(code);
      def parseResult = N2Parser.CompilationUnit(source, parserHost);
      if (parseResult.IsSuccess)
      {
        def parseTree = N2ParserParseTree.CompilationUnit.Create(parseResult);
        WriteLine("OK:");
        Console.BackgroundColor = ConsoleColor.DarkGray;
        Console.ForegroundColor = ConsoleColor.White;
        WriteLine(parseTree);
        Console.ResetColor();
      }
      else
      {
        Console.ForegroundColor = ConsoleColor.Red;
        foreach(error in parseResult.GetErrors())
        {
          def (line, col) = error.Location.StartLineColumn;
          WriteLine($<#($line, $col): $(error.Message)#>);
        }
        Console.ResetColor();
      }
      WriteLine();
    }

    test(<#
namespace Ns1
{
  using NitraParserExtension1;
  type X =
    A.
    B;

  namespace Ns2
  {
    namespace Ns2 { type X = C; }
    using Ns3;
  }
}
    #>);

    test(<#
namespace Ns1
{
  using NitraParserExtensions.N2ParserExtension1
  type X - A.B;
}
    #>);

    test(<#
namespace Ns1
{
  using NitraParserExtensions.N2ParserExtension1;
  type X - A.B;
}
    #>);

    test(<#
namespace Ns1
{
  namespace Ns2
  {
    using NitraParserExtensions.N2ParserExtension1;
    type X = A.B;
  }
using Y;
    #>);
    _ = ReadKey();
  }
}
