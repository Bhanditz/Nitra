using Nemerle.Collections;
using Nitra;
using Nitra.ProjectSystem;
using Nemerle.Text;
using Nemerle.Utility;

using Nitra.Internal;
using Nitra.Runtime;
using Nitra.Runtime.Reflection;
using System;
using System.Collections.Generic;
using System.IO;
using System.Reflection;
using System.Console;
using System.Linq;

using System.Text;
using SCG = System.Collections.Generic;

public partial abstract class N2Parser
{
  private class UsingImportDeclarationWalker : WalkerBase[int]
  {
    public Name : StringBuilder = StringBuilder();

    private static IdentifierDescriptor : object = N2Parser.StaticDescriptor.Rules.First(r => r.Name == "Identifier");
    private static QualifiedIdentifierDescriptor : object = N2Parser.StaticDescriptor.Rules.First(r => r.Name == "QualifiedIdentifier");

    public override OnRegularCall(ruleInfo : SubruleInfo.RegularCall, startPos : int, endPos : int, parseResult : IParseResult, context : int) : void
    {
      IgnoreParams();
      when (ruleInfo.Descriptor : object == IdentifierDescriptor)
      {
        _ = Name.Append(parseResult.ParseSession.SourceSnapshot.Text, startPos, endPos - startPos).Append(".")
      }
    }

    public override OnSimpleCall(ruleInfo : SubruleInfo.SimpleCall, startPos : int, endPos : int, parseResult : IParseResult, context : int) : void
    {
      if (ruleInfo.RuleParser.Descriptor : object == QualifiedIdentifierDescriptor)
      {
        _ = Name.Clear();
        WalkSimple(startPos, endPos, ruleInfo.RuleParser, parseResult, context);
        Name.Length = Name.Length - 1;
      }
      else
        WalkSimple(startPos, endPos, ruleInfo.RuleParser, parseResult, context);
    }
  }

  UsingImportDeclarationHandler(rawTreePtr : int, startPos : int, endPos : int, ruleParser : ExtensionRuleParser, parseResult : IParseResult, grammar : CompositeGrammar) : CompositeGrammar
  {
    def walker = UsingImportDeclarationWalker();
    walker.WalkPrefix(rawTreePtr, startPos, endPos, ruleParser, parseResult, 0);
    mutable descriptor;
    if (_grammarDescriptors.TryGetValue(walker.Name.ToString(), out descriptor))
      grammar.Add(descriptor);
    else
      grammar
  }

  // FIXME: currently does not work
  NamespaceScopeBegin() : void
  {
    //Parser.PushState();
  }

  // FIXME: currently does not work
  NamespaceScopeEnd(_ : bool) : void
  {
    //Parser.PopState();
  }

  _grammarDescriptors : Dictionary[string, GrammarDescriptor] = InitGrammars();
  public InitGrammars() : Dictionary[string, GrammarDescriptor]
  {
    def globalGrammarDescriptors = Hashtable();

    def path               = Path.GetDirectoryName(Uri(Assembly.GetExecutingAssembly().CodeBase).LocalPath);
    def files              = Directory.GetFiles(path, "*.dll");
    def standardAssemblies = HashSet(array["Nemerle.dll", "Nemerle.Compiler.dll", "Nitra.Runtime.dll", "Boot.Nitra.Runtime.dll", "Boot.Nitra.Core.dll", "Nitra.Compiler.dll"]);

    // Обрабатываем файлы не входящие в список сборок самого немерла (стандратные сборки).
    // В них точно не может быть парсеров.
    foreach (file when !standardAssemblies.Contains(file) in files)
    {
      def assembly = Assembly.LoadFrom(file);
      foreach (grammar in GrammarDescriptor.GetDescriptors(assembly))
      {
        // throws exception
        // globalGrammarDescriptors.Add(grammar.FullName, grammar);
        globalGrammarDescriptors[grammar.FullName] = grammar;
      }
    }

    globalGrammarDescriptors;
  }
}

public partial module N2ParserParseTree
{
  public partial class QualifiedIdentifier : Nitra.ParseTree
  {
    public Path : string
    {
      get
      {
        $<#..$(Identifiers.Item1; "."; GetText)#>
      }
    }
  }
}


module Program
{
  Main() : void
  {
    def messages = ConsoleCompilerMessages();
    def test(code : string) : void
    {
      try
      {
        def source = SourceSnapshot(code);
        def parseResult = N2Parser.CompilationUnit(source);
        if (parseResult.IsSuccess)
        {
          def parseTree = N2ParserParseTree.CompilationUnit.Create(parseResult);
          WriteLine("OK:");
          Console.BackgroundColor = ConsoleColor.DarkGray;
          Console.ForegroundColor = ConsoleColor.White;
          WriteLine(parseTree);
          Console.ResetColor();
        }
        else
        {
          foreach (error in parseResult.GetErrors())
            messages.Error(error.Location, error.Message);
        }
        WriteLine();
      }
      catch
      {
        | e is Exception =>
          Console.ForegroundColor = ConsoleColor.Red;
          WriteLine(e);
          Console.ResetColor();
          WriteLine();
      }
    }

    test(<#
namespace Ns1
{
  using N2ParserExtension1;
  type X =
    A.
    B;

  namespace Ns2
  {
    namespace Ns2 { type X = C; }
    using Ns3;
  }
}
    #>);

    test(<#
namespace Ns1
{
  using N2ParserExtension1
  type X - A.B;
}
    #>);

    test(<#
namespace Ns1
{
  using N2ParserExtension1;
  type X - A.B;
}
    #>);

    test(<#
namespace Ns1
{
  namespace Ns2
  {
    using N2ParserExtension1;
    type X = A.B;
  }
using Y;
    #>);
    _ = ReadKey();
  }
}
