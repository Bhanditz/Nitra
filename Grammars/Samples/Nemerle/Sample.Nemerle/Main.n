using Nemerle.Collections;
using Nitra;
using Nitra.ProjectSystem;
using Nemerle.Text;
using Nemerle.Utility;

using Nitra.Internal;
using Nitra.Runtime;
using Nitra.Runtime.Reflection;
using System;
using System.Collections.Generic;
using System.IO;
using System.Reflection;
using System.Console;
using System.Linq;

using System.Text;
using SCG = System.Collections.Generic;

public partial abstract class N2Parser
{
  private class UsingImportDeclarationWalker : WalkerBase[int]
  {
    public Name : StringBuilder = StringBuilder();

    private static IdentifierDescriptor : object = N2Parser.StaticDescriptor.Rules.First(r => r.Name == "Identifier");
    private static QualifiedIdentifierDescriptor : object = N2Parser.StaticDescriptor.Rules.First(r => r.Name == "QualifiedIdentifier");

    public override OnRegularCall(ruleInfo : SubruleInfo.RegularCall, startPos : int, endPos : int, parseResult : IParseResult, context : int) : void
    {
      IgnoreParams();
      when (ruleInfo.Descriptor : object == IdentifierDescriptor)
      {
        _ = Name.Append(parseResult.ParseSession.SourceSnapshot.Text, startPos, endPos - startPos).Append(".")
      }
    }

    public override OnSimpleCall(ruleInfo : SubruleInfo.SimpleCall, startPos : int, endPos : int, parseResult : IParseResult, context : int) : void
    {
      if (ruleInfo.RuleParser.Descriptor : object == QualifiedIdentifierDescriptor)
      {
        _ = Name.Clear();
        WalkSimple(startPos, endPos, ruleInfo.RuleParser, parseResult, context);
        Name.Length = Name.Length - 1;
      }
      else
        WalkSimple(startPos, endPos, ruleInfo.RuleParser, parseResult, context);
    }
  }

  UsingImportDeclarationHandler(rawTreePtr : int, startPos : int, endPos : int, ruleParser : ExtensionRuleParser, parseResult : IParseResult, grammar : CompositeGrammar) : CompositeGrammar
  {
    def walker = UsingImportDeclarationWalker();
    walker.WalkPrefix(rawTreePtr, startPos, endPos, ruleParser, parseResult, 0);
    
    def descriptor = (parseResult :> ParseResult).TryGetDynamicSyntaxExtension(walker.Name.ToString());
    if (descriptor != null)
      grammar.Add(descriptor);
    else
      grammar
  }
}

public partial module N2ParserParseTree
{
  public partial class QualifiedIdentifier : Nitra.ParseTree
  {
    public Path : string
    {
      get
      {
        $<#..$(Identifiers.Item1; "."; GetText)#>
      }
    }
  }
}


module Program
{
  LoadDynamicExtentionGrammars() : Seq[GrammarDescriptor]
  {
    def dynamicExtentionGrammars = List();

    def path               = Path.GetDirectoryName(Uri(Assembly.GetExecutingAssembly().CodeBase).LocalPath);
    def files              = Directory.GetFiles(path, "*.dll");
    def standardAssemblies = HashSet(array["Nemerle.dll", "Nemerle.Compiler.dll", "Nitra.Runtime.dll", "Boot.Nitra.Runtime.dll", "Boot.Nitra.Core.dll", "Nitra.Compiler.dll"]);

    // Обрабатываем файлы не входящие в список сборок самого немерла (стандратные сборки).
    // В них точно не может быть парсеров.
    foreach (file when !standardAssemblies.Contains(file) in files)
    {
      def assembly = Assembly.LoadFrom(file);
      foreach (grammar in GrammarDescriptor.GetDescriptors(assembly))
        dynamicExtentionGrammars.Add(grammar);
    }

    dynamicExtentionGrammars
  }

  Main() : void
  {
    def messages                   = ConsoleCompilerMessages();
    def prettyPrintOpt             = PrettyPrintOptions.DebugIndent %| PrettyPrintOptions.MissingNodes;
    def parseSession               = ParseSession(null, N2Parser.CompilationUnit);
    parseSession.DynamicExtensions = LoadDynamicExtentionGrammars();
    def test(code : string) : void
    {
      try
      {
        parseSession.SourceText = code;
        def parseResult = parseSession.Parse();
        if (parseResult.IsSuccess)
          WriteLine("OK:");
        else
        {
          WriteLine("Error:");
          foreach (error in parseResult.GetErrors())
            messages.Error(error.Location, error.Message);
        }
        def parseTree = N2ParserParseTree.CompilationUnit.CreateParseTree(parseResult);
        Console.BackgroundColor = ConsoleColor.DarkGray;
        Console.ForegroundColor = ConsoleColor.White;
        WriteLine(parseTree.ToString(prettyPrintOpt));
        Console.ResetColor();
        WriteLine();
      }
      catch
      {
        | e is Exception =>
          Console.ForegroundColor = ConsoleColor.Red;
          WriteLine(e);
          Console.ResetColor();
          WriteLine();
      }
    }

    test(<#
namespace Ns1
{
  using N2ParserExtension1;
  type X =
    A.
    B;

  namespace Ns2
  {
    -
  }
}
    #>);

    test(<#
namespace Ns1
{
  using N2ParserExtension1;
  type X =
    A.
    B;

  namespace Ns2
  {
    namespace Ns3 { type X  C; }
    using Ns3;
  }
}
    #>);

    test(<#
namespace Ns1
{
  using N2ParserExtension1;
  type X - A.B;
}
    #>);

    test(<#
namespace Ns1
{
  using N2ParserExtension1
  type X - A.B;
}
    #>);

    test(<#
namespace Ns1
{
  namespace Ns2
  {
    using N2ParserExtension1;
    type X = A.B;
  }
using Y;
    #>);

    test(<#
namespace Ns1
{
  [Asd]
  !test test!
  class Asd
  {
  }
  namespace Ns2
  {
    using N2ParserExtension1;
    [Asd]
    !test test!
    class Asd
    {
    }
  }
  [Asd]
  !test test!
  class Asd
  {
  }
}
    #>);
    _ = ReadKey();
  }
}
