using N2;
using N2.Runtime;
using System.Collections.Generic;

visitor type TestVisitor
{
  //default return type string;
  default parameter param1 : int;
  default parameter param2 : string;
  default parameter param3 : float;
}

visitor TestVisitor for CalcGrammar
{
  map start : int;
  map sm : int;
  map any : int;
  map s : int;
  map expr : int;
  map expr_rounds : int;
  map expr_num : int;
  map expr_neg : int;
  map expr_add : int;
  map expr_sub : int;
  map expr_mul : int;
  map expr_div : int;
  map expr_mod : int;
  map expr_pow : int;
  map expr_prefixDec : int;
  map expr_postfixDec : int;
  map expr_cond : int;
  map expr_coalescing : int;
  map expr_test : int;
}

syntax module CalcGrammar
{
  using PrettyPrint;
  using IncGrammar;
  using NumParser;

  token field OpenBrace    = "(";
  token field CloseBrace   = ")";
  token field OpenBrace    = "{";
  token field CloseBrace   = "}";
  token field Op           = "+", "++", "-", "--", "*", "/", "?", ":", "^", "%", "??";

  span class Number;
  span class Operator     = ['+', '-', '/', '*', '^', '?', ':', '%']+;
  span class OpenBrace  = "(" | "{";
  span class CloseBrace = ")" | "}";

  braces "(", ")";
  braces "{", "}";

  token any = ['\u0000'..'\uFFFF'];

  [ExplicitSpaces] void s = ' '*;

  [StartRule, ExplicitSpaces]
  syntax start       = s (expr s; ','s; ?)+ !any { [Cached] Value() : list[double] = Exprs[0].Map(_.Value()); }

  // We can redefine names for fields in any time.
  token field Operator = "+", "++", "-", "--", "*", "/", "?", ":", "^", "%", "??";

  alias Condition = expr ^ 301;

  [StartRule]
  syntax expr
  {
    Value() : double; /*missing Value = double.NaN;*/

    | [SpanClass(Number)]
      num        = number               {                 override Value = Number.Value(); }
    | rounds     = '(' expr ')'         {                 override Value = Expr.Value(); }
    | add        = expr sm '+' sm expr  { precedence 10;  override Value = Expr1.Value() + Expr2.Value(); }
    | sub        = expr sm '-' sm expr  { precedence 10;  override Value = Expr1.Value() - Expr2.Value(); }
    | mul        = expr sm '*' sm expr  { precedence 20;  override Value = Expr1.Value() * Expr2.Value(); }
    | div        = expr sm '/' sm expr  { precedence 20;  override Value = Expr1.Value() / Expr2.Value(); }
    | mod        = expr sm '%' sm expr  { precedence 20;  override Value = Expr1.Value() % Expr2.Value(); }
    | pow        = expr sm '^' sm expr  { precedence 30 right-associative;  
                                                          override Value = System.Math.Pow(Expr1.Value(), Expr2.Value()); }
    | neg        = '-' expr             { precedence 100; override Value = -Expr.Value(); }
    | prefixDec  = "--" expr            { precedence 200; override Value = Expr.Value() - 1.0; }
    | postfixDec = expr "--"            { precedence 200; override Value = Expr.Value() - 1.0; }

    | cond       = Condition sm '?' sm  expr sm  Colon=':' sm expr 
      { override Value = if (Condition.Value() != 0.0) Expr1.Value() else Expr2.Value(); }
    | coalescing = expr ^ 401 sm "??" sm expr ^ 400
      { override Value = if (Expr1.Value() != 0.0) Expr1.Value() else Expr2.Value(); }
    | test       = "test" number "test" number { override Value = 42; }
  }
}
  
syntax module IncGrammar
{
  using cp = CalcGrammar;
  using CalcGrammar;

  extend syntax cp.expr
  {
    plus       = '+'  cp.expr ^ 100  { override Value = Expr.Value(); }
    prefixInc  = "++" cp.expr ^ 200  { override Value = Expr.Value() + 1; }
    postfixInc = cp.expr ^ 200 "++"  { override Value = Expr.Value() + 1; }
  }
}
