using Nitra;
using Nitra.Runtime;
using Nitra.Declarations;
using Nitra.Runtime.Binding;

ast Top
{
  in Scope : TableScope;

  Variables.ContainingScope = Scope;

  Variables  : Variable*;
}

declaration Variable
{
  symbol
  {
    Kind = "var";
  stage 1:
    in Result : double;
  }

  Expression.Scope = ContainingScope;
  Symbol.Result    = Expression.Result;

  Expression : Expression;
}

abstract ast Expression
{
stage 1:
  in  Scope  : Scope;
  out Result : double;

  | Number
    {
      Result = Value.ValueOrDefault;

      Value : double;
    }

  | Binary
    {
      Expression1.Scope = Scope;
      Expression2.Scope = Scope;
      Result            = Operator.ValueOrDefault.Invoke(Expression1.Result, Expression2.Result);

      Operator    : BinaryOperator;
      Expression1 : Expression;
      Expression2 : Expression;
    }

  | Unary
    {
      Expression.Scope = Scope;
      Result           = Operator.ValueOrDefault.Invoke(Expression.Result);

      Operator   : UnaryOperator;
      Expression : Expression;
    }

  | VariableRef
    {
      out Ref : Ref[VariableSymbol] = Name.Ref.TryResolve();

      Name.Scope = Scope;
      Result	 = Ref.Symbol.Result;

      Name : Reference;
    }
}
