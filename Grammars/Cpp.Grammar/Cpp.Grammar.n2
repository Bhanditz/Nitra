//using N2;

syntax module CppGrammar
{
  token field Less                = "<";
  token field Greater             = ">";
  token field OpenBrace           = "(";
  token field CloseBrace          = ")";
  token field OpenBrace           = "{";
  token field CloseBrace          = "}";
  token field OpenSquareBrace     = "[";
  token field CloseSquareBrace    = "]";
  token field SingleQuote         = "\'";
  token field Quote               = "\"";
  token field Semicolon           = ";";
  token field Comma               = ",";
  token field Dot                 = ".";
  token field Colon               = ":";
  token field Question            = "?";
  token field At                  = "@";
  token field AliasSeparator      = "::";
  token field Assign              = "=";
  token field Prefix              = "\\u";
  token field DodDot              = "..";
  token field Op                  = "=>", "=", "*=", "/=", "%=", "+=", "-=", "<<=", ">>=", "&=", "^=", "|=", "??",
                                    "||", "&&", "|", "^", "&", "==", "!=", "<=", ">=", "<<", ">>", "+", "-", "!", "~", "++", "--", "*", "/", "%", "->";
  token field Backslash           = "\\";
  token field Epsilon             = "";
  
  span class Char;
  span class String;
  span class Number;
  span class Keyword      = ['a'..'z']['a'..'z']+;
  span class Operator     = ['+', '-', '/', '*', '^', '?', ':']+;
  span class OpenBrace    = "(" | "{" | "[";
  span class CloseBrace   = ")" | "}" | "]";

  braces "(", ")";
  braces "{", "}";
  braces "[", "]";

  token Any = ['\u0000'..'\uFFFF'];

  [StartRule, ExplicitSpaces]
  syntax CompilationUnit = s Expression !Any;

  /////////////////////////////////////////////////////////
  // Spacing

  token NewLineCharacter  = '\n' | '\r' | '\u2028' /*  line separator */ | '\u2029' /*  paragraph separator */;
  token NewLine  = "\r\n" | NewLineCharacter;
  token Whitespace = [Zs] | '\t' | '\v' | '\f' | '\uFEFF' | '\u0000';
  token Space = Whitespace | NewLine;
  token Spaces = Space+;

  [ExplicitSpaces] void s   = Spaces*;                     // optional spacer
  [ExplicitSpaces] void S   = !IdentifierPartCharacters s; // identifier break spacer

  marker i;     // increase a indent
  marker d;     // decrease a indent
  marker nl;    // optional spacer and plase for \n while pretty printing
  marker inl;   // i + nl
  marker sm;    // optional spacer and prefer to print space while pretty printing

  keyword regex ['A'..'Z', 'a'..'z', '_'..'_']+ rule S;

  alias Name                = Identifier;
  alias QualifiedName       = QualifiedIdentifier;
  alias Char                = Any;
  alias Comma               = ","?;
  
  // Spacing
  /////////////////////////////////////////////////////////

  /////////////////////////////////////////////////////////
  // Identifiers

  [ExplicitSpaces, SuppressTrailingSpaces]
  syntax Identifier           = IdentifierBody s;
  syntax QualifiedIdentifier  = (Identifier; "::")+;

  token LetterCharacter           = [Lu, Ll, Lt, Lm, Lo, Nl];//['A'..'Z', 'a'..'z', 'а'..'я', 'А'..'Я', 'і'];//
  token CombiningCharacter        = [Mn, Mc];
  token DecimalDigitCharacter     = [Nd];
  token ConnectingCharacter       = [Pc];
  token FormattingCharacter       = [Cf];

  token IdentifierStartCharacter  = LetterCharacter | "_";
  token IdentifierPartCharacters  = LetterCharacter | DecimalDigitCharacter | ConnectingCharacter | CombiningCharacter | FormattingCharacter;
  token IdentifierBody            = IdentifierStartCharacter IdentifierPartCharacters*;

  // Identifiers
  /////////////////////////////////////////////////////////
 
  /////////////////////////////////////////////////////////
  // Literals

  token DecimalDigit                        = ['0'..'9'];
  token HexDigit                            = ['0'..'9', 'a'..'f', 'A'..'F'];
  token IntegerTypeSuffixTerminal           = ('U' | 'u') ('l' | 'L')? | ('l' | 'L') ('U' | 'u')?;
  token IntegerTypeSuffix                   = IntegerTypeSuffixTerminal; // "UL" | "ul" | "uL" | "Ul" | "LU" | "lu" | "Lu" | "lU" | "U" | "u" | "L" | "l";
  token DecimalIntegerLiteral               = DecimalDigit+ IntegerTypeSuffix?;
  token HexadecimalIntegerLiteral           = ("0x" | "0X") HexDigit+ IntegerTypeSuffix?;
  token IntegerLiteral                      = HexadecimalIntegerLiteral | DecimalIntegerLiteral;

  ////////////////////////////////////////////////////////////////////////////////////
  // Type

  syntax Type;

  extend syntax Type
  {
    QualifiedTypeName = QualifiedName;
    FunctionType      = Type ^ 10 "(" (Type; ",")* ")";
  }

  ////////////////////////////////////////////////////////////////////////////////////
  // Expressions

  syntax Expression;

  extend syntax Expression
  {
    IdentifierExpression             = QualifiedName;
    IntegerLiteralExpression         = IntegerLiteral;

    QualifiedNameExpression          = QualifiedName; // simple-name || member-access
    ParenthesizedExpression          = "(" Expression ")"; // parenthesized-expression
    Cast                             = "(" Type ")" Expression;
    Invocation                       = Expression ^ 150 "(" (Expression; ",")* ")";
  }
}