using Nitra;
using Nitra.Runtime.Binding;
using Nitra.Staging;

using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;

namespace CSharp
{
  public sealed class TypeReferenceSet : IStaged, IEquatable[TypeReferenceSet], IEnumerable[TypeReference]
  {
    public this(creationStage : int)
    {
      CreationStage = creationStage;
      _types        = HashSet();
    }

    public CreationStage  : int  { get; }
    public IsEmpty        : bool { get { _types.Count == 0 } }
    public Count          : int  { get { _types.Count } }

    private _types : HashSet[TypeReference];

    [StagedInit]
    public Add(type : TypeReference) : void
    {
      _ = _types.Add(type);
    }

    [StagedInit]
    public Add(set : Seq[TypeReference]) : void
    {
      _types.UnionWith(set);
    }

    public Contains(type : TypeReference) : bool
    {
      _types.Contains(type)
    }

    public override ToString() : string
    {
      $"$CreationStage: ..$_types"
    }

    public Equals(other : TypeReferenceSet) : bool
      implements IEquatable[TypeReferenceSet].Equals
    {
      | null => false
      | _ => this._types.Count == other._types.Count && this._types.SetEquals(other._types)
    }

    public override Equals(other : object) : bool
    {
      | TypeReferenceSet as other => Equals(other)
      | _ => false
    }

    public override GetHashCode() : int
    {
      _types.Count
    }

    public GetEnumerator() : IEnumerator[TypeReference]
    {
      _types.GetEnumerator()
    }
  }
}
