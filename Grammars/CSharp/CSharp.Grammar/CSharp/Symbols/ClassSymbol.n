using Nitra;
using Nitra.Runtime.Binding;
using Nitra.Declarations;

using Nemerle;
using Nemerle.Collections;
using Nemerle.Imperative;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;

namespace CSharp.Symbols
{
  public abstract class ClassSymbol : GenericTypeSymbol
  {
    public static Create(declaration : Type.Class, typeParameters : list[TypeParameterSymbol], isPartial : bool) : ClassSymbol
    {
      def err(loc : IAst, str : string) : void { AstContext.CompilerMessages.Error(loc, str); }
      def name = declaration.Name;
      def parent = declaration.Parent;
      def typeParametersCount = typeParameters.Length;
      
      assert2(!declaration.TypeParameters.IsMissing);
      
      def ambiguous = List();
      
      mutable symbol = parent.NestedScope.TryGetSymbol(name);
      match (symbol)
      {
        | null => ()
        | overloads is OverloadSymbol => 
          foreach (overload in overloads.Overloads)
            ambiguous.Add(overload);

        | ambig is IAmbiguousSymbol => 
          foreach (ambiguousSymbol in ambig.Ambiguous)
            ambiguous.Add(ambiguousSymbol);
          
        | _ => ambiguous.Add(symbol);
      }
      
      def candidates = List();
      
      // TODO: заменить ClassSymbol на параметр типа
      foreach (candidate in ambiguous)
        when (candidate is ClassSymbol as genericType) // is class?
          when (genericType.TypeParameters.Count == typeParametersCount)
            candidates.Add(genericType);
            
      def define()
      {
        def typeParametersArray = typeParameters.ToArray();
        Array.Reverse(typeParametersArray);
        
        def classSymbol =
            if (declaration.Parent is NamespaceSymbol as p)
              TopClassSymbol(name, p, typeParametersArray, isPartial)
            else
              NestedClassSymbol(name, declaration.Parent, typeParametersArray, isPartial);

        parent.DefineNestedSymbol(classSymbol);
        classSymbol
      }
            
      def classSymbol =
      if (candidates.Count() == 1 && candidates[0].IsPartial && declaration.IsPartial)
        candidates[0] // merge
      else
        define();

      name.Symbol = classSymbol;
      classSymbol.Declarations ::= declaration;
      classSymbol
    }
    
    protected this(name : IName, parent : HierarchicalSymbol, typeParameters : array[TypeParameterSymbol], isPartial : bool)
    {
      base(name, parent, typeParameters, isPartial);
    }    
  }
  
  [Record]
  public class TopClassSymbol : ClassSymbol
  {
    public new Parent : NamespaceSymbol { get { (this : NamespaceOrTypeSymbol).Parent :> NamespaceSymbol } }
    
    public override Kind : string { get { "class" } }
  }

  [Record]
  public class NestedClassSymbol : ClassSymbol
  {
    public new Parent : TypeSymbol { get { (this : NamespaceOrTypeSymbol).Parent :> TypeSymbol } }
    
    public override Kind : string { get { "nested class" } }
  }
}
