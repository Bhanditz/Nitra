using Nitra;
using Nitra.Runtime.Binding;
using Nitra.Declarations;

using Nemerle;
using Nemerle.Collections;
using Nemerle.Imperative;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;

namespace CSharp.Symbols
{
  public abstract class ClassSymbol : GenericTypeSymbol
  {
    public static Create(declaration : Type.Class, typeParameters : list[TypeParameterSymbol]) : ClassSymbol
    {
      def name = declaration.Name;
      def parent = declaration.Parent;
      
      assert2(!declaration.TypeParameters.IsMissing);
      
      mutable symbol = parent.NestedScope.TryGetSymbol(name);

      when (symbol is AmbiguousHierarchicalSymbol as ambiguous)
      {
        symbol = null;
        foreach (type is ClassSymbol in ambiguous.Ambiguous)
        {
          symbol = type;
          break;
        }
      }
      def err(loc, str) { AstContext.CompilerMessages.Error(loc, str); }
      mutable classSymbol;
      when (symbol is ClassSymbol as firstDefenition) // is partial class?
      {
        when (firstDefenition.TypeParameters.Count == declaration.TypeParameters.Count)
        {
          mutable i = 0;
          firstDefenition.TypeParameters.Iter2(declaration.TypeParameters, 
            fun (sym, par)
            {
              when (sym.Name.Id != par.Name.Id)
              {
                err(par.Name, $<#Type parameter name '$(par.Name)' differs from '$(sym.Name)' declared in oter parts.#>);
                when (sym.Declarations is [_])
                  err(par.Name, $<#Type parameter name '$(sym.Name)' differs from '$(par.Name)' declared in oter parts.#>);
              }
              
              when (sym.Variance.ValueOrDefault != par.Variance.ValueOrDefault)
              {
                err(par.Name, <#Type parameter variance differs from declared in oter parts.#>);
                when (sym.Declarations is [_])
                  err(sym.Name, <#Type parameter variance differs from declared in oter parts.#>);
              }
              
              i++;
            });
          classSymbol = firstDefenition;
        }
      }

      when (classSymbol == null)
      {
        def typeParametersArray = typeParameters.ToArray();
        Array.Reverse(typeParametersArray);
        
        classSymbol =
            if (declaration.Parent is NamespaceSymbol as p)
              TopClassSymbol(name, p, typeParametersArray)
            else
              NestedClassSymbol(name, declaration.Parent, typeParametersArray);

        parent.DefineNestedSymbol(classSymbol);
      }
      
      name.Symbol = classSymbol;
      classSymbol.Declarations ::= declaration;
      classSymbol
    }
    
    protected this(name : IName, parent : HierarchicalSymbol, typeParameters : array[TypeParameterSymbol])
    {
      base(name, parent, typeParameters);
    }    
  }
  
  [Record]
  public class TopClassSymbol : ClassSymbol
  {
    public new Parent : NamespaceSymbol { get { (this : NamespaceOrTypeSymbol).Parent :> NamespaceSymbol } }
    
    public override Kind : string { get { "class" } }
  }

  [Record]
  public class NestedClassSymbol : ClassSymbol
  {
    public new Parent : TypeSymbol { get { (this : NamespaceOrTypeSymbol).Parent :> TypeSymbol } }
    
    public override Kind : string { get { "nested class" } }
  }
}
