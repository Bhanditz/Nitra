using Nitra;
using Nitra.Runtime.Binding;
using Nitra.Declarations;

using Nemerle;
using Nemerle.Collections;
using Nemerle.Imperative;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;

namespace CSharp.Symbols
{
  public abstract class ClassSymbol : GenericTypeSymbol
  {
    public static Create(declaration : Type.Class, typeParameters : array[TypeParameterSymbol]) : ClassSymbol
    {
      //def aSymbol = null : Symbol2;
      //_ = aSymbol.TryResolve(x => x.Ambiguous.OfType.[GenericTypeSymbol]().Where(s => s.TypeParameters.Count == Arguments.Count));

      //def err(loc : IAst, str : string) : void { AstContext.CompilerMessages.Error(loc, str); }
      def name = declaration.Name;
      def parent = declaration.Parent;
      def typeParametersCount = typeParameters.Length;
      def isPartial = declaration.IsPartial.ValueOrDefault;
      
      assert2(!declaration.TypeParameters.IsMissing);
      
      def ambiguous = List();
      
      mutable symbol = parent.NestedScope.TryGetSymbol(name);
      match (symbol)
      {
        | null => ()
        | ambig is IAmbiguousSymbol => 
          foreach (ambiguousSymbol in ambig.Ambiguous)
            ambiguous.Add(ambiguousSymbol);
          
        | _ => ambiguous.Add(symbol);
      }
      
      def candidates = List();
      
      // TODO: заменить ClassSymbol на параметр типа
      foreach (candidate in ambiguous)
        when (candidate is ClassSymbol as genericType) // is class?
          when (genericType.TypeParameters.Count == typeParametersCount)
            candidates.Add(genericType);
            
      def define()
      {
        def classSymbol =
            if (declaration.Parent is NamespaceSymbol as p)
              TopClassSymbol(name, p, typeParameters, isPartial)
            else
              NestedClassSymbol(name, declaration.Parent, typeParameters, isPartial);

        def realAmbiguous = ambiguous.OfType.[GenericTypeSymbol]().Where(s => s.TypeParameters.Count == typeParametersCount).ToList();
        when (realAmbiguous.Count > 0)
        {
          def cm = AstContext.CompilerMessages;
          using (nested = cm.RootError(name, $"The $(parent.Kind) '$(parent.FullName)' already contains a declaration for '$name'"))
            foreach (a in realAmbiguous)
              foreach (d in a.Declarations)
                nested.Hint(d.Name, "previous definition.");
        }     
        parent.DefineNestedSymbol(classSymbol, reportErrors=false);
        classSymbol
      }
            
      def classSymbol =
      if (candidates.Count() == 1 && candidates[0].IsPartial && isPartial)
        candidates[0] // merge
      else
        define();

      name.Symbol = classSymbol;
      classSymbol.Declarations ::= declaration;
      classSymbol
    }
    
    protected this(name : IName, parent : HierarchicalSymbol, typeParameters : array[TypeParameterSymbol], isPartial : bool)
    {
      base(name, parent, typeParameters, isPartial);
    }    
  }
  
  [Record]
  public class TopClassSymbol : ClassSymbol
  {
    public new Parent : NamespaceSymbol { get { (this : NamespaceOrTypeSymbol).Parent :> NamespaceSymbol } }
    
    public override Kind : string { get { "class" } }
  }

  [Record]
  public class NestedClassSymbol : ClassSymbol
  {
    public new Parent : TypeSymbol { get { (this : NamespaceOrTypeSymbol).Parent :> TypeSymbol } }
    
    public override Kind : string { get { "nested class" } }
  }
}
