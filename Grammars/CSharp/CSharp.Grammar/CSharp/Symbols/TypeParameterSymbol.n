using Nitra;
using Nitra.Runtime.Binding;
using Nitra.Declarations;

using Nemerle;
using Nemerle.Collections;
using Nemerle.Imperative;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;

namespace CSharp.Symbols
{
  public class TypeParameterSymbol : Symbol2
  {
    public static Create(typeParameterAst : TypeParameter, index : int, prevTypeParameters : IList[TypeParameterSymbol]) : TypeParameterSymbol
    {
      mutable prevSymbol;
      if (prevTypeParameters == null)
        prevSymbol = TypeParameterSymbol(typeParameterAst)
      else
      {
        prevSymbol = prevTypeParameters[index];
        when (prevSymbol.Name.Id != typeParameterAst.Name.Id)
          using (root = AstContext.CompilerMessages.RootError(typeParameterAst.Name, $"Type parameter name '$(typeParameterAst.Name)' differs from declared in other parts."))
            foreach (dec in prevSymbol.Declarations)
              root.Error(dec.Name, "Previous declaration.");
      }
      
      prevSymbol.Declarations ::= typeParameterAst;
      prevSymbol
    }
    
    public this(typeParameter : TypeParameter)
    {
      base(typeParameter.Name);
      this.Variance = typeParameter.Variance;
    }
    
    public override FullName        : string                { get { Name.Text } }
    public override Kind            : string                { get { "type parameter" } }
    public override SpanClass       : string                { get { "NitraCSharpType" } }
    public          Variance        : ParsedValue[Variance] { get; }
    
    public HasCtorConstraint     : bool                                    { get; private set; }
    public HasClassConstraint    : bool                                    { get; private set; }
    public HasDefaultConstructor : bool                                    { get; private set; }
    public BaseClass             : ReadOnlyCollection[ClassSymbol]         { get; private set; }
    public BaseTypeParameters    : ReadOnlyCollection[TypeParameterSymbol] { get; private set; }
    public Implements            : ReadOnlyCollection[InterfaceSymbol]     { get; private set; }
    
    public UpdateConstraints(constraintsClauses : IList[TypeParameterConstraintsClause]) : void
    {
      def err(ast : IAst,  msg : string) : void { AstContext.CompilerMessages.Error(ast, msg); }
      mutable hasCtorConstraint     = false;
      mutable hasClassConstraint    = false;
      mutable hasDefaultConstructor = false;

      def baseClass = HashSet();
      def baseTypeParameters = HashSet();
      def impls = HashSet();
      
      foreach (constraintsClause in constraintsClauses)
      {
        foreach (constraint in constraintsClause.Constraints)
        {
          | Ctor   => hasCtorConstraint   = true;
          | Class  => hasClassConstraint  = true;
          | Struct => hasDefaultConstructor = true;
          | Base(Symbol=ClassSymbol         as x) => _ = baseClass.Add(x);
          | Base(Symbol=TypeParameterSymbol as x) => _ = baseTypeParameters.Add(x);
          | Base(Symbol=InterfaceSymbol     as x) => _ = impls.Add(x);
          | Base(Symbol=baseSymbol) => err(constraint, $"Constraint '$constraint' has unsupported type '$(baseSymbol.Kind)'.");
          | _ => assert(false);
        }
      }
      
      BaseClass          = ReadOnlyCollection(baseClass.ToArray());
      BaseTypeParameters = ReadOnlyCollection(baseTypeParameters.ToArray());
      Implements         = ReadOnlyCollection(impls.ToArray());
      
      HasClassConstraint    = hasClassConstraint;
      HasDefaultConstructor = hasDefaultConstructor;
      HasDefaultConstructor = hasDefaultConstructor;
    }
  }
}
