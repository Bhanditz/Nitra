using Nitra;
using Nitra.Runtime.Binding;
using Nitra.Staging;

using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;

namespace CSharp
{
  [Flags]
  public enum TypeConstraint : byte
  {
    | None   = 0
    | Class  = 1
    | Struct = 2
    | Ctor   = 4
  }

  public sealed class TypeConstraintSet : IStaged, IEquatable[TypeConstraintSet]
  {
    public this(creationStage : int)
    {
      CreationStage = creationStage;
      _baseTypes    = HashSet();
    }

    public CreationStage  : int  { get; }
    public IsEmpty        : bool { get { _flags == TypeConstraint.None && _baseTypes.Count == 0 } }

    private         _baseTypes : HashSet[TypeReference];
    private mutable _flags     : TypeConstraint;

    [StagedInit]
    public Add(baseType : TypeReference) : void
    {
      _ = _baseTypes.Add(baseType);
    }

    [StagedInit]
    public Add(flag : TypeConstraint) : void
    {
      _flags |= flag;
    }

    [StagedInit]
    public Add(set : TypeConstraintSet) : void
    {
      _baseTypes.UnionWith(set._baseTypes);
      _flags |= set._flags;
    }

    public override ToString() : string
    {
      $"$CreationStage: $_flags, ..$_baseTypes"
    }

    public Equals(other : TypeConstraintSet) : bool
      implements IEquatable[TypeConstraintSet].Equals
    {
      | null => false
      | _ => this._flags == other._flags
        && this._baseTypes.Count == other._baseTypes.Count
        && this._baseTypes.SetEquals(other._baseTypes)
    }

    public override Equals(other : object) : bool
    {
      | TypeConstraintSet as other => Equals(other)
      | _ => false
    }

    public override GetHashCode() : int
    {
      (this._baseTypes.Count << 4) | (this._flags :> int)
    }
  }
}
