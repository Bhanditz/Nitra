using Nitra;
using Nitra.Runtime.Binding;
using System.Linq;

namespace CSharp
{
  asts QualifiedReference
  {
  stage 1:
    in Arity : int = 0;
    in Scope   : Scope;
    out Symbol : ISymbol2;

    | Simple
      {
        Name.Scope = Scope;
        Symbol     = Name.Symbol.TryResolve(Name, Utils.TypeOverloadResolution(Arity));

        Name : Reference;
      }

    | Aliased 
      {
        Name.Scope = Scope;
        Symbol     = Name.Symbol.TryResolve(Name, Utils.TypeOverloadResolution(Arity));

        Alias : Reference;
        Name  : Reference;
      }

    | Qualified
      {
        Qualifier.Arity = 0;
        Qualifier.Scope = Scope;
        Name.Scope      = Qualifier.Symbol.Scope;
        Symbol          = Name.Symbol.TryResolve(Name, Utils.TypeOverloadResolution(Arity));

        Qualifier : QualifiedReference;
        Name      : Reference;
      }

    | Generic
      {
        Arguments.Arity     = 0;
        QualifiedName.Arity = Arguments.Count;
        QualifiedName.Scope = Scope;
        Arguments.Scope     = Scope;
        Symbol              = QualifiedName.Symbol;

        QualifiedName : QualifiedReference;
        Arguments     : QualifiedReference*; // TODO: change to  QualifiedReference+
      }
  }

  map syntax CsIdentifiers.QualifiedIdentifier -> QualifiedReference
  {
    | (None,    (first :: other, _)) -> fold (item in other; acc = first();    acc = item(acc))
    | (Some(a), (first :: other, _)) -> fold (item in other; acc = first(a()); acc = item(acc))
    | (_,       ([],             _)) = IntrinsicUtils.CreateMissingQualifiedReference(QualifiedIdentifierParts.File, QualifiedIdentifierParts.Span);
  }

  map syntax CsIdentifiers.QualifiedIdentifierPartTypeArguments -> QualifiedReference*
  {
    | TypeArgumentList -> AnyTypes.Item1
    | OpenTypeArguments =
      {
        def args = array(RankSeparators.Count + 1);
        args[0] = IntrinsicUtils.CreateOpenTypeArgument(this.File, NSpan(OpenBrace.EndPos));
        foreach (rs in RankSeparators with index)
          args[index + 1] = IntrinsicUtils.CreateOpenTypeArgument(this.File, NSpan(rs.EndPos));
        QualifiedReference.AstList(this, args)
      }
  }

  map syntax CsIdentifiers.QualifiedIdentifierPart -> QualifiedReference
  {
    let qid : QualifiedReference = Simple { Reference -> Name; } in
    match (QualifiedIdentifierPartTypeArgumentsOpt)
    {
      | None -> qid
      | Some(typeArgs) -> Generic { qid -> QualifiedName; typeArgs -> Arguments; }
    }
  }

  map syntax CsIdentifiers.QualifiedIdentifierPart(aliasAst : Nitra.Runtime.Binding.Reference) -> QualifiedReference
  {
    let qid : QualifiedReference = Aliased { Reference -> Name; aliasAst -> Alias; } in
    match (QualifiedIdentifierPartTypeArgumentsOpt)
    {
      | None -> qid
      | Some(typeArgs) -> Generic { qid -> QualifiedName; typeArgs -> Arguments; }
    }
  }

  map syntax CsIdentifiers.QualifiedIdentifierPart(qualifier : QualifiedReference) -> QualifiedReference
  {
    let qid : QualifiedReference = Qualified { Reference -> Name; qualifier -> Qualifier; } in
    match (QualifiedIdentifierPartTypeArgumentsOpt)
    {
      | None -> qid
      | Some(typeArgs) -> Generic { qid -> QualifiedName; typeArgs -> Arguments; }
    }
  }

  map syntax CsIdentifiers.InterfaceType -> QualifiedReference
  {
    | (None,    (first, _) :: other) -> fold (item in other; acc = first();    acc = item(acc))
    | (Some(a), (first, _) :: other) -> fold (item in other; acc = first(a()); acc = item(acc))
    | (_,       []                 ) = IntrinsicUtils.CreateMissingQualifiedReference(InterfaceTypeParts.File, InterfaceTypeParts.Span);
  }

  map syntax CsIdentifiers.InterfaceTypePart -> QualifiedReference
  {
    let qid : QualifiedReference = Simple { Reference -> Name; } in
    match (QualifiedIdentifierPartTypeArgumentsOpt)
    {
      | None -> qid
      | Some(typeArgs) -> Generic { qid -> QualifiedName; typeArgs -> Arguments; }
    }
  }

  map syntax CsIdentifiers.InterfaceTypePart(aliasAst : Nitra.Runtime.Binding.Reference) -> QualifiedReference
  {
    let qid : QualifiedReference = Aliased { Reference -> Name; aliasAst -> Alias; } in
    match (QualifiedIdentifierPartTypeArgumentsOpt)
    {
      | None -> qid
      | Some(typeArgs) -> Generic { qid -> QualifiedName; typeArgs -> Arguments; }
    }
  }

  map syntax CsIdentifiers.InterfaceTypePart(qualifier : QualifiedReference) -> QualifiedReference
  {
    let qid : QualifiedReference = Qualified { Reference -> Name; qualifier -> Qualifier; } in
    match (QualifiedIdentifierPartTypeArgumentsOpt)
    {
      | None -> qid
      | Some(typeArgs) -> Generic { qid -> QualifiedName; typeArgs -> Arguments; }
    }
  }

  map syntax Types.TypeName -> QualifiedReference
  {
    | QualifiedName  -> QualifiedIdentifier
    | PredefinedType = IntrinsicUtils.CreatePredefinedTypeReference(this.File, this.PredefinedType, GetText(PredefinedType));
  }

  map syntax Types.AnyNonArrayType -> QualifiedReference
  {
    | (typeName, None) -> typeName
    | (typeName, Some) -> Generic
      {
        Qualified
        {
          Simple { Name = Reference(this.File, this.Span, "System"); } -> Qualifier;
          Name = Reference(this.File, this.Span, "Nullable");
        } -> QualifiedName;
        [ typeName ] -> Arguments;
      }
  }

  map syntax Types.TypeSpecifier(qualifiedName : QualifiedReference) -> QualifiedReference
  {
    | PointerSpecifier -> Generic
      {
        Simple { Name = Reference(this.File, this.Span, "#Pointer"); } -> QualifiedName;
        [qualifiedName] -> Arguments;
      }
    | RankSpecifier -> Generic
      {
        Simple { Name = Reference(this.File, this.Span, "#Array" + (RankSpecifier.RankSeparators.Count + 1).ToString()); } -> QualifiedName;
        [qualifiedName] -> Arguments;
      }
  }

  map syntax Types.AnyType -> QualifiedReference
  {
    fold (ts in TypeSpecifiers; acc = AnyNonArrayType; acc = ts(acc))
  }
}
