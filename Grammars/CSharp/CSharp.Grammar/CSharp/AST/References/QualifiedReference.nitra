using CSharp.Symbols;
using Nitra.Runtime.Binding;
using System.Linq;

namespace CSharp
{
  asts QualifiedReference
  {
    in Arity : int = 0;
    in Scope   : Scope;
    out Symbol : Symbol2;

    | Simple
      {
        Name.Scope = Scope;
        Symbol     = Utils.TryResolveTypeOverload(Name.Symbol, Arity);

        Name : Reference;
      }

    | Aliased 
      {
        Name.Scope = Scope;
        Symbol     = Utils.TryResolveTypeOverload(Name.Symbol, Arity);

        Alias : Reference;
        Name  : Reference;
      }

    | Qualified
      {
        Qualifier.Arity = 0;
        Qualifier.Scope = Scope;
        Name.Scope      = Qualifier.Symbol.Scope;
        Symbol          = Utils.TryResolveTypeOverload(Name.Symbol, Arity);

        Qualifier : QualifiedReference;
        Name      : Reference;
      }

    | Generic
      {
        Arguments.Arity     = 0;
        QualifiedName.Arity = Arguments.Count;
        QualifiedName.Scope = Scope;
        Arguments.Scope     = Scope;
        Symbol              = QualifiedName.Symbol;

        QualifiedName : QualifiedReference;
        Arguments     : QualifiedReference+;
      }
  }

  map syntax CsIdentifiers.QualifiedIdentifier -> QualifiedReference
  {
    | (None,    (first :: other, _)) = other.Aggregate(first.CreateSimple(),            (acc, item) => item.CreateQualified(acc));
    | (Some(a), (first :: other, _)) = other.Aggregate(first.CreateAliased(a.GetAst()), (acc, item) => item.CreateQualified(acc));
    | (_,       ([],             _)) = IntrinsicUtils.CreateMissingQualifiedReference(QualifiedIdentifierParts.File, QualifiedIdentifierParts.Span);
  }

  map syntax CsIdentifiers.InterfaceType -> QualifiedReference
  {
    | (None,    (first, _) :: other) = other.Aggregate(first.CreateSimple(),            (acc, item) => item.Item1.CreateQualified(acc));
    | (Some(a), (first, _) :: other) = other.Aggregate(first.CreateAliased(a.GetAst()), (acc, item) => item.Item1.CreateQualified(acc));
    | (_,       []                 ) = IntrinsicUtils.CreateMissingQualifiedReference(InterfaceTypeParts.File, InterfaceTypeParts.Span);
  }

  map syntax Types.TypeName -> QualifiedReference
  {
    | QualifiedName  -> QualifiedIdentifier
    | PredefinedType = IntrinsicUtils.CreatePredefinedTypeReference(this.File, this.PredefinedType, GetText(PredefinedType));
  }

  map syntax Types.AnyNonArrayType -> QualifiedReference
  {
    | (typeName, None) -> typeName
    | (typeName, Some) -> Generic
      {
        QualifiedName = IntrinsicUtils.CreateQualifiedReference(this.File, this.Span, "System", "Nullable");
        [ typeName ] -> Arguments;
      }
  }

  map syntax Types.TypeSpecifier -> QualifiedReference
  {
    | PointerSpecifier = IntrinsicUtils.CreateQualifiedReference(this.File, this.Span, "#Pointer");
    | RankSpecifier =
      {
        def rank = RankSpecifier.RankSeparators.Count + 1;
        IntrinsicUtils.CreateQualifiedReference(this.File, this.Span, "#Array" + rank.ToString())
      };
  }

  map syntax Types.AnyType -> QualifiedReference =
  {
    mutable acc = AnyNonArrayType.GetAst();

    foreach (ts in TypeSpecifiers)
    {
      acc = QualifiedReference.Generic(
        File          = acc.File,
        Span          = acc.Span + ts.Span,
        QualifiedName = ts.GetAst(),
        Arguments     = QualifiedReference.AstList(this.File, acc.Span, acc))
    }

    acc
  };
}
