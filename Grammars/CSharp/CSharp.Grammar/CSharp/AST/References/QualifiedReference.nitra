using CSharp.Symbols;
using Nitra;
using Nitra.Runtime.Binding;
using System.Linq;

namespace CSharp
{
  asts QualifiedReference
  {
    in Arity : int = 0;
    in Scope   : Scope;
    out Symbol : Symbol2;

    | Simple
      {
        Name.Scope = Scope;
        Symbol     = Utils.TryResolveTypeOverload(Name.Symbol, Arity);

        Name : Reference;
      }

    | Aliased 
      {
        Name.Scope = Scope;
        Symbol     = Utils.TryResolveTypeOverload(Name.Symbol, Arity);

        Alias : Reference;
        Name  : Reference;
      }

    | Qualified
      {
        Qualifier.Arity = 0;
        Qualifier.Scope = Scope;
        Name.Scope      = Qualifier.Symbol.Scope;
        Symbol          = Utils.TryResolveTypeOverload(Name.Symbol, Arity);

        Qualifier : QualifiedReference;
        Name      : Reference;
      }

    | Generic
      {
        Arguments.Arity     = 0;
        QualifiedName.Arity = Arguments.Count;
        QualifiedName.Scope = Scope;
        Arguments.Scope     = Scope;
        Symbol              = QualifiedName.Symbol;

        QualifiedName : QualifiedReference;
        Arguments     : QualifiedReference*; // TODO: change to  QualifiedReference+
      }
  }

  map syntax CsIdentifiers.QualifiedIdentifier -> QualifiedReference
  {
    | (None,    (first :: other, _)) = other.Aggregate(first.GetAst(),           (acc, item) => item.GetAst(acc));
    | (Some(a), (first :: other, _)) = other.Aggregate(first.GetAst(a.GetAst()), (acc, item) => item.GetAst(acc));
    | (_,       ([],             _)) = IntrinsicUtils.CreateMissingQualifiedReference(QualifiedIdentifierParts.File, QualifiedIdentifierParts.Span);
  }

  map syntax CsIdentifiers.QualifiedIdentifierPartTypeArguments -> QualifiedReference*
  {
    | TypeArgumentList -> AnyTypes.Item1
    | OpenTypeArguments =
      {
        def args = array(RankSeparators.Count + 1);
        args[0] = IntrinsicUtils.CreateOpenTypeArgument(this.File, NSpan(OpenBrace.EndPos));
        foreach (rs in RankSeparators with index)
          args[index + 1] = IntrinsicUtils.CreateOpenTypeArgument(this.File, NSpan(rs.EndPos));
        QualifiedReference.AstList(this, args)
      }
  }

  map syntax CsIdentifiers.QualifiedIdentifierPart -> QualifiedReference
  {
    | (r, None)           -> QualifiedReference.Simple { r -> Name; }
    | (r, Some(typeArgs)) -> QualifiedReference.Generic
      {
        QualifiedReference.Simple { r -> Name; } -> QualifiedName;
        typeArgs -> Arguments;
      }
  }

  map syntax CsIdentifiers.QualifiedIdentifierPart(aliasAst : Nitra.Runtime.Binding.Reference) -> QualifiedReference
  {
    | (r, None)           -> QualifiedReference.Aliased { aliasAst -> Alias; r -> Name; }
    | (r, Some(typeArgs)) -> QualifiedReference.Generic
      {
        QualifiedReference.Aliased { aliasAst -> Alias; r -> Name; } -> QualifiedName;
        typeArgs -> Arguments;
      }
  }

  map syntax CsIdentifiers.QualifiedIdentifierPart(qualifier : QualifiedReference) -> QualifiedReference
  {
    | (r, None)           -> QualifiedReference.Qualified { qualifier -> Qualifier; r -> Name; }
    | (r, Some(typeArgs)) -> QualifiedReference.Generic
      {
        QualifiedReference.Qualified { qualifier -> Qualifier; r -> Name; } -> QualifiedName;
        typeArgs -> Arguments;
      }
  }

  map syntax CsIdentifiers.InterfaceType -> QualifiedReference
  {
    | (None,    (first, _) :: other) = other.Aggregate(first.GetAst(),           (acc, item) => item.Item1.GetAst(acc));
    | (Some(a), (first, _) :: other) = other.Aggregate(first.GetAst(a.GetAst()), (acc, item) => item.Item1.GetAst(acc));
    | (_,       []                 ) = IntrinsicUtils.CreateMissingQualifiedReference(InterfaceTypeParts.File, InterfaceTypeParts.Span);
  }

  map syntax CsIdentifiers.InterfaceTypePart -> QualifiedReference
  {
    | (r, None)           -> QualifiedReference.Simple { r -> Name; }
    | (r, Some(typeArgs)) -> QualifiedReference.Generic
      {
        QualifiedReference.Simple { r -> Name; } -> QualifiedName;
        typeArgs -> Arguments;
      }
  }

  map syntax CsIdentifiers.InterfaceTypePart(aliasAst : Nitra.Runtime.Binding.Reference) -> QualifiedReference
  {
    | (r, None)           -> QualifiedReference.Aliased { aliasAst -> Alias; r -> Name; }
    | (r, Some(typeArgs)) -> QualifiedReference.Generic
      {
        QualifiedReference.Aliased { aliasAst -> Alias; r -> Name; } -> QualifiedName;
        typeArgs -> Arguments;
      }
  }

  map syntax CsIdentifiers.InterfaceTypePart(qualifier : QualifiedReference) -> QualifiedReference
  {
    | (r, None)           -> QualifiedReference.Qualified { qualifier -> Qualifier; r -> Name; }
    | (r, Some(typeArgs)) -> QualifiedReference.Generic
      {
        QualifiedReference.Qualified { qualifier -> Qualifier; r -> Name; } -> QualifiedName;
        typeArgs -> Arguments;
      }
  }

  map syntax Types.TypeName -> QualifiedReference
  {
    | QualifiedName  -> QualifiedIdentifier
    | PredefinedType = IntrinsicUtils.CreatePredefinedTypeReference(this.File, this.PredefinedType, GetText(PredefinedType));
  }

  map syntax Types.AnyNonArrayType -> QualifiedReference
  {
    | (typeName, None) -> typeName
    | (typeName, Some) -> Generic
      {
        QualifiedReference.Qualified
        {
          QualifiedReference.Simple { Name = Reference(this.File, this.Span, "System"); } -> Qualifier;
          Name = Reference(this.File, this.Span, "Nullable");
        } -> QualifiedName;
        [ typeName ] -> Arguments;
      }
  }

  map syntax Types.TypeSpecifier(qualifiedName : QualifiedReference) -> QualifiedReference
  {
    | PointerSpecifier -> QualifiedReference.Generic
      {
        QualifiedReference.Simple { Name = Reference(this.File, this.Span, "#Pointer"); } -> QualifiedName;
        [qualifiedName] -> Arguments;
      }
    | RankSpecifier -> QualifiedReference.Generic
      {
        QualifiedReference.Simple { Name = Reference(this.File, this.Span, "#Array" + (RankSpecifier.RankSeparators.Count + 1).ToString()); } -> QualifiedName;
        [qualifiedName] -> Arguments;
      }
  }

  map syntax Types.AnyType -> QualifiedReference =
  {
    // TODO: folding list mapping!
    mutable acc = AnyNonArrayType.GetAst();
    foreach (ts in TypeSpecifiers)
      acc = ts.GetAst(acc);
    acc
  };
}
