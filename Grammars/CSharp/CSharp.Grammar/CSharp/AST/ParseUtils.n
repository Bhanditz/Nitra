using Nemerle;
using Nemerle.Collections;
using Nemerle.Imperative;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;

namespace Nitra
{
  public module ParseUtils
  {
    public MakeLiteral(parseTree : Nitra.ParseTree, digits : NSpan, suffixOpt : NSpan, radix : int) : ParsedValue[IntegerLiteralValue]
    {
      def value =
        if (digits.IsEmpty)
          IntegerLiteralValue(0UL, false, false, false, radix)
        else
        {
          mutable isOverflow;
          def value = 
            try StrToInt(parseTree, digits, radix)
            catch
            { _ is OverflowException =>
              isOverflow = true;
              0UL
            };
          mutable isLong;
          mutable isUnsigned;
          when (!suffixOpt.IsEmpty)
          {
            def suffix = parseTree.GetText(suffixOpt);
            isLong = suffix.IndexOf('L') >= 0 || suffix.IndexOf('l') >= 0;
            isUnsigned = suffix.IndexOf('U') >= 0 || suffix.IndexOf('u') >= 0;
          }
          IntegerLiteralValue(value, isUnsigned, isLong, isOverflow, radix)
        };
        
      ParsedValue(parseTree.Span, value)
    }
    
    public StrToInt(parseTree : Nitra.ParseTree, span : NSpan, radix : int) : ulong
    {
      StrToInt(parseTree, span.StartPos, span.EndPos, radix)
    }
    
    public StrToInt(parseTree : Nitra.ParseTree, startPos : int, endPos : int, radix : int) : ulong
    {
      assert2(startPos < endPos);

      def text = parseTree.Location.Source.OriginalText;
      mutable result = CharToDigit(text[startPos]) : ulong;
      
      for (mutable i = startPos + 1; i < endPos; i++)
      {
        def ch = CharToDigit(text[i]);
        
        when (ch == 0)
          continue;
          
        checked result = (result * (radix :> ulong)) + CharToDigit(text[i]);
      }
      
      result
    }
    
    private CharToDigit(c : char) : uint
    {
      | c when '0' <= c && c <= '9' => c : uint - '0' : uint
      | c when 'a' <= c && c <= 'f' => c : uint - 'a' : uint + 10
      | c when 'A' <= c && c <= 'F' => c : uint - 'A' : uint + 10
      | _ => 0U
    }
  }
}
