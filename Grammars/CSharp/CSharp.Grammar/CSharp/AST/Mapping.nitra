using Nitra;
using Nitra.Runtime.Binding;
using Nemerle.Collections;

namespace CSharp
{
  map syntax Types.TypeParameter -> TypeParameter
  {
    Name -> Name;
    Variance = 
      if (VarianceAnnotationOpt.HasValue)
        ParsedValue(VarianceAnnotationOpt.Value.Annotation, if (VarianceAnnotationOpt.Value.Annotation.Length == 2) Variance.Covariant else Variance.Contravariant)
      else ParsedValue(VarianceAnnotationOpt.Span, Variance.None);
    Attributes -> Attributes;
  }

  map syntax Types.TypeParameters -> TypeParameter*
  {
    TypeParameters.Item1
  }

  map syntax Types.TypeParameterConstraint -> TypeParameterConstraint
  {
    | Ctor   {}
    | Class  {}
    | Struct {}
    | Base { AnyType -> Type; }
  }

  map syntax Types.TypeParameterConstraints -> TypeParameterConstraint*
  {
    TypeParameterConstraints.Item1
  }

  map syntax Types.TypeParameterConstraintsClause -> TypeParameterConstraintsClause
  {
    Reference                -> ParameterName;
    TypeParameterConstraints -> Constraints;
  }

  map syntax Types.TypeParameterConstraintsClauses -> TypeParameterConstraintsClause*
  {
    TypeParameterConstraintsClauses
  }

  map syntax TopDeclarations.TypeDeclaration -> NamespaceMember
  {
    | Class -> TopClass
      {
        Name                            -> Name;
        TypeBody.TypeMemberDeclarations -> Members;
        match(TypeBaseOpt)       { Some(value) -> value | None() -> [] } -> TypeBase;
        match(TypeParametersOpt) { Some(value) -> value | None() -> [] } -> TypeParameters;
        TypeParameterConstraintsClauses -> TypeParameterConstraints;
        IsPartial = ParsedValue(PartialOpt.Span, PartialOpt.HasValue);
        Attributes -> Attributes;
        Modifiers  -> Modifiers;
      }
    | Struct -> TopStruct
      {
        Name                            -> Name;
        TypeBody.TypeMemberDeclarations -> Members;
        match(TypeBaseOpt)       { Some(value) -> value | None() -> [] } -> TypeBase;
        match(TypeParametersOpt) { Some(value) -> value | None() -> [] } -> TypeParameters;
        TypeParameterConstraintsClauses -> TypeParameterConstraints;
        IsPartial = ParsedValue(PartialOpt.Span, PartialOpt.HasValue);
        Attributes -> Attributes;
        Modifiers  -> Modifiers;
      }
    | Interface -> TopInterface
      {
        Name                            -> Name;
        TypeBody.TypeMemberDeclarations -> Members;
        match(TypeBaseOpt)       { Some(value) -> value | None() -> [] } -> TypeBase;
        match(TypeParametersOpt) { Some(value) -> value | None() -> [] } -> TypeParameters;
        TypeParameterConstraintsClauses -> TypeParameterConstraints;
        IsPartial = ParsedValue(PartialOpt.Span, PartialOpt.HasValue);
        Attributes -> Attributes;
        Modifiers  -> Modifiers;
      }
    | Enum -> TopEnum
      {
        Name        -> Name;
        EnumBaseOpt -> EnumBase;
        EnumBody.EnumMemberDeclarations -> Members;
        Attributes -> Attributes;
        Modifiers  -> Modifiers;
      }
    | Delegate -> TopDelegate
      {
        Name             -> Name;
        AnyType          -> ReturnType;
        FormalParameters -> Parameters;
        match(TypeParametersOpt) { Some(value) -> value | None() -> [] } -> TypeParameters;
        TypeParameterConstraintsClauses -> TypeParameterConstraints;
        Attributes -> Attributes;
        Modifiers  -> Modifiers;
      }
  }

  map syntax TopDeclarations.TypeDeclaration(_tag : NestedTypeTag) -> TypeMember
  {
    | Class -> NestedClass
      {
        Name                            -> Name;
        TypeBody.TypeMemberDeclarations -> Members;
        match(TypeBaseOpt)       { Some(value) -> value | None() -> [] } -> TypeBase;
        match(TypeParametersOpt) { Some(value) -> value | None() -> [] } -> TypeParameters;
        TypeParameterConstraintsClauses -> TypeParameterConstraints;
        IsPartial = ParsedValue(PartialOpt.Span, PartialOpt.HasValue);
        Attributes -> Attributes;
        Modifiers  -> Modifiers;
      }
    | Struct -> NestedStruct
      {
        Name                            -> Name;
        TypeBody.TypeMemberDeclarations -> Members;
        match(TypeBaseOpt)       { Some(value) -> value | None() -> [] } -> TypeBase;
        match(TypeParametersOpt) { Some(value) -> value | None() -> [] } -> TypeParameters;
        TypeParameterConstraintsClauses -> TypeParameterConstraints;
        IsPartial = ParsedValue(PartialOpt.Span, PartialOpt.HasValue);
        Attributes -> Attributes;
        Modifiers  -> Modifiers;
      }
    | Interface -> NestedInterface
      {
        Name                            -> Name;
        TypeBody.TypeMemberDeclarations -> Members;
        match(TypeBaseOpt)       { Some(value) -> value | None() -> [] } -> TypeBase;
        match(TypeParametersOpt) { Some(value) -> value | None() -> [] } -> TypeParameters;
        TypeParameterConstraintsClauses -> TypeParameterConstraints;
        IsPartial = ParsedValue(PartialOpt.Span, PartialOpt.HasValue);
        Attributes -> Attributes;
        Modifiers  -> Modifiers;
      }
    | Enum -> NestedEnum
      {
        Name        -> Name;
        EnumBaseOpt -> EnumBase;
        EnumBody.EnumMemberDeclarations -> Members;
        Attributes -> Attributes;
        Modifiers  -> Modifiers;
      }
    | Delegate -> NestedDelegate
      {
        Name             -> Name;
        AnyType          -> ReturnType;
        FormalParameters -> Parameters;
        match(TypeParametersOpt) { Some(value) -> value | None() -> [] } -> TypeParameters;
        TypeParameterConstraintsClauses -> TypeParameterConstraints;
        Attributes -> Attributes;
        Modifiers  -> Modifiers;
      }
  }

  map syntax TopDeclarations.TypeBase -> QualifiedReference*
  {
    AnyTypes.Item1
  }

  map syntax TopDeclarations.TypeMemberDeclaration -> TypeMember*
  {
    | NestedType      -> [TypeDeclaration(NestedTypeTag {})]
    | Constructor     -> [Member.Constructor
      {
        Name                      -> Name;
        FormalParameters          -> Parameters;
        Attributes                -> Attributes;
        Modifiers                 -> Modifiers;
        ConstructorInitializerOpt -> Initializer;
      }]
    | Destructor      -> [Member.Destructor
      {
        Name             -> Name;
        FormalParameters -> Parameters;
        Attributes       -> Attributes;
        Modifiers        -> Modifiers;
      }]
    | Method          -> [Member.Method
      {
        MethodHeader.Name             -> Name;
        MethodHeader.InterfaceTypeOpt -> InterfaceType;
        match(MethodHeader.TypeParametersOpt) { Some(value) -> value | None() -> [] } -> TypeParameters;
        MethodHeader.TypeParameterConstraintsClauses -> TypeParameterConstraints;
        IsPartial = ParsedValue(PartialOpt.Span, PartialOpt.HasValue);
        MethodHeader.AnyType          -> ReturnType;
        MethodHeader.FormalParameters -> Parameters;
        Attributes                    -> Attributes;
        Modifiers                     -> Modifiers;
      }]
    | Property        -> [Member.Property
      {
        Name             -> Name;
        AnyType          -> Type;
        InterfaceTypeOpt -> InterfaceType;
        PropertyBody.AccessorDeclarations -> Accessors;
        Attributes       -> Attributes;
        Modifiers        -> Modifiers;
      }]
    | Event           -> [Member.Event
      {
        Name             -> Name;
        InterfaceTypeOpt -> InterfaceType;
        EventHeader { AnyType -> Type; Attributes -> Attributes; Modifiers -> Modifiers; } -> Header;
        EventAccessorDeclarations -> Accessors;
      }]
    | Indexer         -> [Member.Indexer
      {
        Name = Name(this.File, this.KwThis, "#Item");
        FormalParameters -> Parameters;
        AnyType          -> Type;
        InterfaceTypeOpt -> InterfaceType;
        PropertyBody.AccessorDeclarations -> Accessors;
        Attributes       -> Attributes;
        Modifiers        -> Modifiers;
      }]
    | SimpleEvent     -> VariableDeclarators.VariableDeclarators.Item1(EventHeader    { AnyType -> Type; Attributes -> Attributes; Modifiers -> Modifiers; })
    | Field           -> VariableDeclarators.VariableDeclarators.Item1(FieldHeader    { AnyType -> Type; Attributes -> Attributes; Modifiers -> Modifiers; })
    | Constant        -> ConstantDeclarators.ConstantDeclarators.Item1(ConstantHeader { AnyType -> Type; Attributes -> Attributes; Modifiers -> Modifiers; })
    | FixedSizeBuffer -> FixedSizeBufferDeclarators.Item1(FixedSizeBufferHeader       { AnyType -> Type; Attributes -> Attributes; Modifiers -> Modifiers; })
    | OperatorUnary   -> [Member.OperatorUnary
      {
        Name = Name(this.File, this.OverloadableUnaryOperator, this.GetText(OverloadableUnaryOperator));
        FormalParameter -> Parameter;
        AnyType         -> ReturnType;
        Attributes      -> Attributes;
        Modifiers       -> Modifiers;
      }]
    | OperatorBinary  -> [Member.OperatorBinary
      {
        Name = Name(this.File, this.OverloadableBinaryOperator, this.GetText(OverloadableBinaryOperator));
        FormalParameter1 -> Parameter1;
        FormalParameter2 -> Parameter2;
        AnyType          -> ReturnType;
        Attributes       -> Attributes;
        Modifiers        -> Modifiers;
      }]
    | ImplicitOperator   -> [Member.OperatorCnv
      {
        Name = Name(this.File, this.KwImplicit, "#Implicit");
        FormalParameter -> Parameter;
        AnyType         -> ReturnType;
        Kind = ParsedValue(this.KwImplicit, OperatorKind.Implicit);
        Attributes      -> Attributes;
        Modifiers       -> Modifiers;
      }]
    | ExplicitOperator   -> [Member.OperatorCnv
      {
        Name = Name(this.File, this.KwExplicit, "#Explicit");
        FormalParameter -> Parameter;
        AnyType         -> ReturnType;
        Kind = ParsedValue(this.KwExplicit, OperatorKind.Explicit);
        Attributes      -> Attributes;
        Modifiers       -> Modifiers;
      }]
  }

  map syntax Statements.VariableDeclarator(header : FieldHeader) -> Member.Field
  {
    Name   -> Name;
    header -> Header;
  }

  map syntax Statements.VariableDeclarator(header : EventHeader) -> Member.Event
  {
    Name   -> Name;
    header -> Header;
    None() -> InterfaceType;
    []     -> Accessors;
  }

  map syntax TopDeclarations.EnumBase -> QualifiedReference
  {
    AnyType
  }

  map syntax TopDeclarations.EnumMemberDeclaration -> EnumMember
  {
    Name       -> Name;
    Attributes -> Attributes;
  }

  map syntax TopDeclarations.EnumMemberDeclarations -> EnumMember*
  {
    EnumMemberDeclarations.Item1
  }
}
