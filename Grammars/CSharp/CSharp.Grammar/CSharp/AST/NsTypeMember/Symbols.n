using Nitra.Runtime.Binding;

using Nemerle;
using Nemerle.Collections;
using Nemerle.Imperative;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;

namespace CSharp
{
  public partial class UsingAliasDirectiveSymbol : DeclaredSymbol
  {
    public override Kind             : string             { get { "namespace" } }
    public override SpanClass        : string             { get { "NitraCSharpNamespace" } }
  }
  
  public partial interface NamespaceMemberSymbol : ISymbol2
  {
  }

  public partial class NamespaceSymbol : DeclaredSymbol, NamespaceMemberSymbol
  {
    public override Scope       : Scope           { get { MemberScope } }

    public override IsSameIdentity(candidate : Declaration) : bool { SymbolUtils.IsSameIdentity(0, candidate) }
    public override CanMerge(candidate : Declaration) : bool { candidate is Namespace }
    public override Kind             : string             { get { "namespace" } }
    public override SpanClass        : string             { get { "NitraCSharpNamespace" } }
  }

  public partial interface TypeMemberSymbol : ISymbol2
  {
  }

  public partial interface TypeSymbol : ISymbol2
  {
  }

  public partial interface GenericTypeSymbol : TypeSymbol
  {
    TypeParametersCount : int { get; }
  }

  public partial interface EnumSymbol : TypeSymbol
  {
  }

  public partial class TopEnumSymbol : DeclaredSymbol, EnumSymbol, NamespaceMemberSymbol
  {
    public override IsSameIdentity(candidate : Declaration) : bool { SymbolUtils.IsSameIdentity(0, candidate) }
    public override CanMerge(candidate : Declaration) : bool { candidate is TopEnum }
    public override Kind             : string             { get { "enum" } }
    public override SpanClass        : string             { get { "NitraCSharpType" } }
  }

  public partial class NestedEnumSymbol : DeclaredSymbol, EnumSymbol, TypeMemberSymbol
  {
    public override IsSameIdentity(candidate : Declaration) : bool { SymbolUtils.IsSameIdentity(0, candidate) }
    public override CanMerge(candidate : Declaration) : bool { candidate is NestedEnum }
    public override Kind             : string             { get { "enum" } }
    public override SpanClass        : string             { get { "NitraCSharpType" } }
  }

  public partial interface DelegateSymbol : GenericTypeSymbol
  {
  }

  public partial class TopDelegateSymbol : DeclaredSymbol, DelegateSymbol, NamespaceMemberSymbol
  {
    public TypeParametersCount : int                        { get { (Declarations.Head :> GenericType).TypeParameters.Count } }

    public override IsSameIdentity(candidate : Declaration) : bool { SymbolUtils.IsSameIdentity(TypeParametersCount, candidate) }
    public override CanMerge(candidate : Declaration) : bool { SymbolUtils.CanMerge.[CSharp.TopDelegate](TypeParametersCount, candidate) }
    public override Kind             : string             { get { "declared" } }
    public override SpanClass        : string             { get { "NitraCSharpType" } }
  }

  public partial class NestedDelegateSymbol : DeclaredSymbol, DelegateSymbol, TypeMemberSymbol
  {
    public TypeParametersCount : int                        { get { (Declarations.Head :> GenericType).TypeParameters.Count } }

    public override IsSameIdentity(candidate : Declaration) : bool { SymbolUtils.IsSameIdentity(TypeParametersCount, candidate) }
    public override CanMerge(candidate : Declaration) : bool { SymbolUtils.CanMerge.[CSharp.NestedDelegate](TypeParametersCount, candidate) }
    public override Kind             : string             { get { "declared" } }
    public override SpanClass        : string             { get { "NitraCSharpType" } }
  }

  public partial interface GenericContainerTypeSymbol : GenericTypeSymbol
  {
  }

  public partial class TopClassSymbol : DeclaredSymbol, GenericContainerTypeSymbol, NamespaceMemberSymbol
  {
    public TypeParametersCount : int                        { get { (Declarations.Head :> GenericType).TypeParameters.Count } }

    public override IsSameIdentity(candidate : Declaration) : bool { SymbolUtils.IsSameIdentity(TypeParametersCount, candidate) }
    public override CanMerge(candidate : Declaration) : bool { SymbolUtils.CanMerge.[CSharp.TopClass](this, candidate) }
    public override Kind             : string             { get { "class" } }
    public override SpanClass        : string             { get { "NitraCSharpType" } }
  }

  public partial class NestedClassSymbol : DeclaredSymbol, GenericContainerTypeSymbol, TypeMemberSymbol
  {
    public TypeParametersCount : int                        { get { (Declarations.Head :> GenericType).TypeParameters.Count } }

    public override IsSameIdentity(candidate : Declaration) : bool { SymbolUtils.IsSameIdentity(TypeParametersCount, candidate) }
    public override CanMerge(candidate : Declaration) : bool { SymbolUtils.CanMerge.[CSharp.NestedClass](this, candidate) }
    public override Kind             : string             { get { "class" } }
    public override SpanClass        : string             { get { "NitraCSharpType" } }
  }

  public partial class TopStructSymbol : DeclaredSymbol, GenericContainerTypeSymbol, NamespaceMemberSymbol
  {
    public TypeParametersCount : int                        { get { (Declarations.Head :> GenericType).TypeParameters.Count } }

    public override IsSameIdentity(candidate : Declaration) : bool { SymbolUtils.IsSameIdentity(TypeParametersCount, candidate) }
    public override CanMerge(candidate : Declaration) : bool { SymbolUtils.CanMerge.[CSharp.TopStruct](this, candidate) }
    public override Kind             : string             { get { "struct" } }
    public override SpanClass        : string             { get { "NitraCSharpType" } }
  }

  public partial class NestedStructSymbol : DeclaredSymbol, GenericContainerTypeSymbol, TypeMemberSymbol
  {
    public TypeParametersCount : int                        { get { (Declarations.Head :> GenericType).TypeParameters.Count } }

    public override IsSameIdentity(candidate : Declaration) : bool { SymbolUtils.IsSameIdentity(TypeParametersCount, candidate) }
    public override CanMerge(candidate : Declaration) : bool { SymbolUtils.CanMerge.[CSharp.NestedStruct](this, candidate) }
    public override Kind             : string             { get { "struct" } }
    public override SpanClass        : string             { get { "NitraCSharpType" } }
  }

  public partial class TopInterfaceSymbol : DeclaredSymbol, GenericContainerTypeSymbol, NamespaceMemberSymbol
  {
    public TypeParametersCount : int                        { get { (Declarations.Head :> GenericType).TypeParameters.Count } }

    public override IsSameIdentity(candidate : Declaration) : bool { SymbolUtils.IsSameIdentity(TypeParametersCount, candidate) }
    public override CanMerge(candidate : Declaration) : bool { SymbolUtils.CanMerge.[CSharp.TopInterface](this, candidate) }
    public override Kind             : string             { get { "interface" } }
    public override SpanClass        : string             { get { "NitraCSharpType" } }
  }
  
  public partial class NestedInterfaceSymbol : DeclaredSymbol, GenericContainerTypeSymbol, TypeMemberSymbol
  {
    public TypeParametersCount : int                        { get { (Declarations.Head :> GenericType).TypeParameters.Count } }

    public override IsSameIdentity(candidate : Declaration) : bool { SymbolUtils.IsSameIdentity(TypeParametersCount, candidate) }
    public override CanMerge(candidate : Declaration) : bool { SymbolUtils.CanMerge.[CSharp.NestedInterface](this, candidate) }
    public override Kind             : string             { get { "interface" } }
    public override SpanClass        : string             { get { "NitraCSharpType" } }
  }

  public partial interface MemberSymbol : ISymbol2, TypeMemberSymbol
  {
  }

  public partial class TypeParameterSymbol : DeclaredSymbol
  {
  }

  public class TypeParameterAliasSymbol : TypeParameterSymbol
  {
    public this(target : TypeParameterSymbol)
    {
      Target = target;
    }

    public           Target           : TypeParameterSymbol { get; }
    public override  ResolutionResult : ISymbol2            { get { Target } }
  }

  module SymbolUtils
  {
    public IsPartial(symbol : GenericContainerTypeSymbol) : bool
    {
      (symbol.Declarations.Head :> GenericContainerType).IsPartial.ValueOrDefault
    }

    public IsSameIdentity(typeParametersCount : int, candidate : Declaration) : bool
    {
      match (candidate)
      {
        | CSharp.GenericType as t => t.TypeParameters.Count == typeParametersCount
        | CSharp.Namespace
        | CSharp.Type             => typeParametersCount == 0
        | _                       => false
      }
    }

    public CanMerge[T](typeParametersCount : int, candidate : Declaration) : bool
      where T : GenericType
    {
      match (candidate)
      {
        | genericType is T => genericType.TypeParameters.Count == typeParametersCount
        | _ => false
      }
    }

    public CanMerge[T](symbol : GenericContainerTypeSymbol, candidate : Declaration) : bool
      where T : GenericContainerType
    {
      match (candidate)
      {
        | genericType is T => genericType.TypeParameters.Count == symbol.TypeParametersCount && symbol.IsPartial && genericType.IsPartial.ValueOrDefault
        | _ => false
      }
    }
  }
}
