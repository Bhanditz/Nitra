using CSharp.Symbols;
using Nemerle.Collections;

using Nitra;
using Nitra.Declarations;
using Nitra.Runtime.Binding;
using Nitra.Internal;

using System.Linq;
using SCG = System.Collections.Generic;

namespace CSharp
{
  abstract declaration TypeMember : NamespaceOrType
  {
  }

  map syntax TopDeclarations.TypeMemberDeclaration -> TypeMember*
  {
    | NestedType      -> [TypeDeclaration]
    | Constructor     -> [Member.Constructor { Name -> Name; }]
    | Destructor      -> [Member.Destructor  { Name -> Name; }]
    | Method          -> [Member.Method      { MethodHeader.Name -> Name; MethodHeader.InterfaceTypeOpt -> InterfaceType; }]
    | Property        -> [Member.Property    { Name -> Name;              InterfaceTypeOpt -> InterfaceType; }]
    | Event           -> [Member.Event       { Name -> Name;              InterfaceTypeOpt -> InterfaceType; }]
    | Indexer         -> [Member.Indexer     { Name = Reference(this.File, this.KwThis, "#Item"); }]
    | SimpleEvent     -> [Member.Other       { Name = Reference(this.File, this.Span, "#NotImplemented"); }]
    | Field           =
      {
        def header = FieldHeader(this.File, this.Attributes.Span + this.AnyType.Span, this.AnyType.GetAst());
        def items  = SCG.List();
        foreach (item in this.VariableDeclarators.VariableDeclarators.Item1)
          items.Add(item.GetAst(header));
        TypeMember.AstList(this.File, this.Span, items.ToArray())
      };
    | Constant        -> ConstantDeclarators.ConstantDeclarators.Item1
    | FixedSizeBuffer -> [Member.Other       { Name = Reference(this.File, this.Span, "#NotImplemented"); }]
    | OperatorUnary   -> [Member.Other       { Name = Reference(this.File, this.Span, "#NotImplemented"); }]
    | OperatorBinary  -> [Member.Other       { Name = Reference(this.File, this.Span, "#NotImplemented"); }]
    | OperatorCnv     -> [Member.Other       { Name = Reference(this.File, this.Span, "#NotImplemented"); }]
  }

  ast FieldHeader
  {
    Type : QualifiedReference;
  }

  map syntax Statements.VariableDeclarator(header : FieldHeader) -> Member.Field
  {
    Name -> Name;
    Header = header;
  }
}
