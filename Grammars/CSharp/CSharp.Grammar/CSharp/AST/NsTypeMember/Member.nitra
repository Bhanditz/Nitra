using Nitra;
using Nitra.Runtime.Binding;

namespace CSharp
{
  declarations Member : TypeMember
  {
    | Constructor
      {
        Parameters  : FormalParameter*;
        Attributes  : AttributeSection*;
        Modifiers   : Modifier*;
        Initializer : ConstructorInitializer?;
      }
    | Destructor
      {
        Parameters : FormalParameter*;
        Attributes : AttributeSection*;
        Modifiers  : Modifier*;
      }
    | Method
      {
        InterfaceType            : QualifiedReference?;
        TypeParameters           : TypeParameter*;
        TypeParameterConstraints : TypeParameterConstraintsClause*;
        IsPartial                : bool;
        Parameters               : FormalParameter*;
        ReturnType               : QualifiedReference;
        Attributes               : AttributeSection*;
        Modifiers                : Modifier*;
      }
    | Property
      {
        InterfaceType : QualifiedReference?;
        Type          : QualifiedReference;
        Accessors     : PropertyAccessor*;
        Attributes    : AttributeSection*;
        Modifiers     : Modifier*;
      }
    | Event
      {
        InterfaceType : QualifiedReference?;
        Header        : EventHeader;
        Accessors     : EventAccessor*;
      }
    | Indexer
      {
        Parameters    : FormalParameter*;
        Type          : QualifiedReference;
        InterfaceType : QualifiedReference?;
        Accessors     : PropertyAccessor*;
        Attributes    : AttributeSection*;
        Modifiers     : Modifier*;
      }
    | Constant        { Header : ConstantHeader; }
    | Field           { Header : FieldHeader; }
    | FixedSizeBuffer { Header : FixedSizeBufferHeader; }
    | OperatorUnary
      {
        ReturnType : QualifiedReference;
        Parameter  : FormalParameter;
        Attributes : AttributeSection*;
        Modifiers  : Modifier*;
      }
    | OperatorBinary
      {
        ReturnType : QualifiedReference;
        Parameter1 : FormalParameter;
        Parameter2 : FormalParameter;
        Attributes : AttributeSection*;
        Modifiers  : Modifier*;
      }
    | OperatorCnv
      {
        ReturnType : QualifiedReference;
        Parameter  : FormalParameter;
        Attributes : AttributeSection*;
        Modifiers  : Modifier*;
        Kind       : OperatorKind;
      }
    | EnumMember
      {
        Attributes : AttributeSection*;
      }
  }

  asts ConstructorInitializer
  {
    // TODO: Map arguments
    | This
    | Base
  }

  ast FieldHeader
  {
    Type       : QualifiedReference;
    Attributes : AttributeSection*;
    Modifiers  : Modifier*;
  }

  ast ConstantHeader
  {
    Type       : QualifiedReference;
    Attributes : AttributeSection*;
    Modifiers  : Modifier*;
  }

  ast EventHeader
  {
    Type       : QualifiedReference;
    Attributes : AttributeSection*;
    Modifiers  : Modifier*;
  }

  ast FixedSizeBufferHeader
  {
    Type       : QualifiedReference;
    Attributes : AttributeSection*;
    Modifiers  : Modifier*;
  }

  declaration FormalParameter
  {
    Type       : QualifiedReference;
    Attributes : AttributeSection*;
    Modifier   : ParameterModifier;
  }

  declarations PropertyAccessor
  {
    Attributes : AttributeSection*;
    Modifiers  : Modifier*;
    // TODO: Map body
    | Get
    | Set
  }

  declarations EventAccessor
  {
    Attributes : AttributeSection*;
    // TODO: Map body
    | Add
    | Remove
  }

  map syntax TopDeclarations.ConstructorInitializer -> ConstructorInitializer
  {
    | This {}
    | Base {}
  }

  map syntax TopDeclarations.FormalParameter -> FormalParameter
  {
    Name       -> Name;
    AnyType    -> Type;
    Attributes -> Attributes;
    Modifier =
      if (this.ParameterModifierOpt.HasValue)
      {
        def result =
          match (this.GetText(this.ParameterModifierOpt.Value))
          {
            | "ref"    => ParameterModifier.Ref
            | "out"    => ParameterModifier.Out
            | "this"   => ParameterModifier.This
            | "params" => ParameterModifier.Params
            | _        => assert2(false, "Unknown parameter modifier value"); ParameterModifier.None
          };
        ParsedValue(this.ParameterModifierOpt.Value, result)
      }
      else
        ParsedValue(this.ParameterModifierOpt.Span, ParameterModifier.None);
  }

  map syntax TopDeclarations.FormalParameters -> FormalParameter*
  {
    FormalParameters.Item1
  }

  map syntax Statements.ConstantDeclarator(header : ConstantHeader) -> Member.Constant
  {
    Name -> Name;
    header -> Header;
  }

  map syntax TopDeclarations.FixedSizeBufferDeclarator(header : FixedSizeBufferHeader) -> Member.FixedSizeBuffer
  {
    Name   -> Name;
    header -> Header;
  }

  map syntax TopDeclarations.GetAccessorDeclaration -> PropertyAccessor.Get
  {
    Name = Name(this.File, this.KwGet, "#Get");
    Attributes -> Attributes;
    Modifiers  -> Modifiers;
  }

  map syntax TopDeclarations.SetAccessorDeclaration -> PropertyAccessor.Set
  {
    Name = Name(this.File, this.KwSet, "#Set");
    Attributes -> Attributes;
    Modifiers  -> Modifiers;
  }

  map syntax TopDeclarations.AccessorDeclarations -> PropertyAccessor*
  {
    | GetSet(g, Some(s)) -> [g, s]
    | GetSet(g, None)    -> [g]
    | SetGet(s, Some(g)) -> [s, g]
    | SetGet(s, None)    -> [s]
    | None               -> []
  }

  map syntax TopDeclarations.AddAccessorDeclaration -> EventAccessor.Add
  {
    Name = Name(this.File, this.KwAdd, "#Add");
    Attributes -> Attributes;
  }

  map syntax TopDeclarations.RemoveAccessorDeclaration -> EventAccessor.Remove
  {
    Name = Name(this.File, this.KwRemove, "#Remove");
    Attributes -> Attributes;
  }

  map syntax TopDeclarations.EventAccessorDeclarations -> EventAccessor*
  {
    | AddRemove(a, r) -> [a, r]
    | RemoveAdd(r, a) -> [r, a]
  }
}
