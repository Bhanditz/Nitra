using Nitra;
using Nitra.Runtime.Binding;

namespace CSharp
{
  abstract declaration Member : TypeMember
  {
    symbol
    {
      in Flags : ModifierSet;
    }

    | Constructor
      {
        symbol
        {
          Kind      = "constructor";
          SpanClass = "Method";
          FullName  = SymbolUtils.MakeFullName(this);

          out ParameterScope : TableScope = TableScope("parameters");
        }

        Symbol.Flags              |= Modifiers.Flags;
        Modifiers.Flags            = ModifierSet(context);
        Parameters.ContainingScope = Symbol.ParameterScope;
        Parameters.CurrentScope    = Scope;
        Attributes.NameScope       = AttributeLookupScope(Scope);

        Parameters  : FormalParameter*;
        Attributes  : Attribute*;
        Modifiers   : Modifier*;
        Initializer : ConstructorInitializer?;
      }
    | Destructor
      {
        symbol
        {
          Kind      = "destructor";
          SpanClass = "Method";
          FullName  = SymbolUtils.MakeFullName(this);

          out ParameterScope : TableScope = TableScope("parameters");
        }

        Symbol.Flags              |= Modifiers.Flags;
        Modifiers.Flags            = ModifierSet(context);
        Parameters.ContainingScope = Symbol.ParameterScope;
        Parameters.CurrentScope    = Scope;
        Attributes.NameScope       = AttributeLookupScope(Scope);

        Parameters : FormalParameter*;
        Attributes : Attribute*;
        Modifiers  : Modifier*;
      }
    | Method : GenericEntity
      {
        symbol
        {
          Kind      = "method";
          SpanClass = "Method";
          FullName  = SymbolUtils.MakeFullName(this);

          out ParameterScope : TableScope = TableScope("parameters");
          in  ReturnType     : TypeReference;
        }

        Symbol.Flags              |= Modifiers.Flags;
        Modifiers.Flags            = ModifierSet(context);
        InterfaceType.Scope        = Scope;
        ReturnType.Scope           = TypeParameterConstraints.Scope;
        Parameters.ContainingScope = Symbol.ParameterScope;
        Parameters.CurrentScope    = TypeParameterConstraints.Scope;
        Symbol.ReturnType          = ReturnType.Type;
        Attributes.NameScope       = AttributeLookupScope(Scope);

        InterfaceType            : QualifiedReference?;
        IsPartial                : bool;
        Parameters               : FormalParameter*;
        ReturnType               : QualifiedReference;
        Attributes               : Attribute*;
        Modifiers                : Modifier*;
      }
    | Property
      {
        symbol
        {
          Kind      = "property";
          SpanClass = "Property";
          FullName  = SymbolUtils.MakeFullName(this);

          in Type : TypeReference;
        }

        Symbol.Flags        |= Modifiers.Flags;
        Modifiers.Flags      = ModifierSet(context);
        InterfaceType.Scope  = Scope;
        Type.Scope           = Scope;
        Symbol.Type          = Type.Type;
        Accessors.Scope      = Scope;
        Attributes.NameScope = AttributeLookupScope(Scope);

        InterfaceType : QualifiedReference?;
        Type          : QualifiedReference;
        Accessors     : PropertyAccessor*;
        Attributes    : Attribute*;
        Modifiers     : Modifier*;
      }
    | Event
      {
        symbol
        {
          Kind      = "event";
          SpanClass = "Property";
          FullName  = SymbolUtils.MakeFullName(this);

          in Type : TypeReference;
        }

        Symbol.Flags               |= Header.Modifiers.Flags;
        Header.Modifiers.Flags      = ModifierSet(context);
        InterfaceType.Scope         = Scope;
        Header.Type.Scope           = Scope;
        Symbol.Type                 = Header.Type.Type;
        Accessors.Scope             = Scope;
        Header.Attributes.NameScope = AttributeLookupScope(Scope);

        InterfaceType : QualifiedReference?;
        Header        : EventHeader;
        Accessors     : EventAccessor*;
      }
    | Indexer
      {
        symbol
        {
          Kind      = "indexer";
          SpanClass = "Property";
          FullName  = SymbolUtils.MakeFullName(this);

          out ParameterScope : TableScope = TableScope("parameters");
          in  Type           : TypeReference;
        }

        Symbol.Flags              |= Modifiers.Flags;
        Modifiers.Flags            = ModifierSet(context);
        InterfaceType.Scope        = Scope;
        Type.Scope                 = Scope;
        Parameters.ContainingScope = Symbol.ParameterScope;
        Parameters.CurrentScope    = Scope;
        Symbol.Type                = Type.Type;
        Accessors.Scope            = Scope;
        Attributes.NameScope       = AttributeLookupScope(Scope);

        Parameters    : FormalParameter*;
        Type          : QualifiedReference;
        InterfaceType : QualifiedReference?;
        Accessors     : PropertyAccessor*;
        Attributes    : Attribute*;
        Modifiers     : Modifier*;
      }
    | Constant
      {
        symbol
        {
          Kind      = "constant";
          SpanClass = "Constant";
          FullName  = SymbolUtils.MakeFullName(this);

          in Type : TypeReference;
        }

        Symbol.Flags               |= Header.Modifiers.Flags;
        Header.Modifiers.Flags      = ModifierSet(context);
        Header.Type.Scope           = Scope;
        Symbol.Type                 = Header.Type.Type;
        Header.Attributes.NameScope = AttributeLookupScope(Scope);

        Header : ConstantHeader;
      }
    | Field
      {
        symbol
        {
          Kind      = "field";
          SpanClass = "Field";
          FullName  = SymbolUtils.MakeFullName(this);

          in Type : TypeReference;
        }

        Symbol.Flags               |= Header.Modifiers.Flags;
        Header.Modifiers.Flags      = ModifierSet(context);
        Header.Type.Scope           = Scope;
        Symbol.Type                 = Header.Type.Type;
        Header.Attributes.NameScope = AttributeLookupScope(Scope);

        Header : FieldHeader;
      }
    | FixedSizeBuffer
      {
        symbol
        {
          Kind      = "fixed size buffer";
          SpanClass = "Field";
          FullName  = SymbolUtils.MakeFullName(this);

          in Type : TypeReference;
        }

        Symbol.Flags               |= Header.Modifiers.Flags;
        Header.Modifiers.Flags      = ModifierSet(context);
        Header.Type.Scope           = Scope;
        Symbol.Type                 = Header.Type.Type;
        Header.Attributes.NameScope = AttributeLookupScope(Scope);

        Header : FixedSizeBufferHeader;
      }
    | OperatorUnary
      {
        symbol
        {
          Kind      = "operator";
          SpanClass = "Operator";
          FullName  = SymbolUtils.MakeFullName(this);

          out ParameterScope : TableScope = TableScope("parameters");
          in  ReturnType     : TypeReference;
        }

        Symbol.Flags             |= Modifiers.Flags;
        Modifiers.Flags           = ModifierSet(context);
        ReturnType.Scope          = Scope;
        Parameter.ContainingScope = Symbol.ParameterScope;
        Parameter.CurrentScope    = Scope;
        Symbol.ReturnType         = ReturnType.Type;
        Attributes.NameScope      = AttributeLookupScope(Scope);

        ReturnType : QualifiedReference;
        Parameter  : FormalParameter;
        Attributes : Attribute*;
        Modifiers  : Modifier*;
      }
    | OperatorBinary
      {
        symbol
        {
          Kind      = "operator";
          SpanClass = "Operator";
          FullName  = SymbolUtils.MakeFullName(this);

          out ParameterScope : TableScope = TableScope("parameters");
          in  ReturnType     : TypeReference;
        }

        Symbol.Flags              |= Modifiers.Flags;
        Modifiers.Flags            = ModifierSet(context);
        ReturnType.Scope           = Scope;
        Parameter1.ContainingScope = Symbol.ParameterScope;
        Parameter1.CurrentScope    = Scope;
        Parameter2.ContainingScope = Symbol.ParameterScope;
        Parameter2.CurrentScope    = Scope;
        Symbol.ReturnType          = ReturnType.Type;
        Attributes.NameScope       = AttributeLookupScope(Scope);

        ReturnType : QualifiedReference;
        Parameter1 : FormalParameter;
        Parameter2 : FormalParameter;
        Attributes : Attribute*;
        Modifiers  : Modifier*;
      }
    | OperatorCnv
      {
        symbol
        {
          Kind      = "operator";
          SpanClass = "Operator";
          FullName  = SymbolUtils.MakeFullName(this);

          out ParameterScope : TableScope = TableScope("parameters");
          in  ReturnType     : TypeReference;
        }

        Symbol.Flags             |= Modifiers.Flags;
        Modifiers.Flags           = ModifierSet(context);
        ReturnType.Scope          = Scope;
        Parameter.ContainingScope = Symbol.ParameterScope;
        Parameter.CurrentScope    = Scope;
        Symbol.ReturnType         = ReturnType.Type;
        Attributes.NameScope      = AttributeLookupScope(Scope);

        ReturnType : QualifiedReference;
        Parameter  : FormalParameter;
        Attributes : Attribute*;
        Modifiers  : Modifier*;
        Kind       : OperatorKind;
      }
  }

  declaration EnumMember
  {
    in Parent : EnumSymbol;
    in Scope  : Scope;

    Attributes.NameScope = AttributeLookupScope(Scope);

    Attributes : Attribute*;
  }

  abstract ast ConstructorInitializer
  {
    // TODO: Map arguments
    | This
    | Base
  }

  ast FieldHeader
  {
    Type       : QualifiedReference;
    Attributes : Attribute*;
    Modifiers  : Modifier*;
  }

  ast ConstantHeader
  {
    Type       : QualifiedReference;
    Attributes : Attribute*;
    Modifiers  : Modifier*;
  }

  ast EventHeader
  {
    Type       : QualifiedReference;
    Attributes : Attribute*;
    Modifiers  : Modifier*;
  }

  ast FixedSizeBufferHeader
  {
    Type       : QualifiedReference;
    Attributes : Attribute*;
    Modifiers  : Modifier*;
  }

  declaration FormalParameter
  {
    symbol
    {
      Kind      = "parameter";
      SpanClass = "Parameter";
      FullName  = SymbolUtils.MakeFullName(this);

      in Type     : TypeReference;
      in Modifier : ParameterModifier;
    }

    in CurrentScope : Scope;

    Type.Scope           = CurrentScope;
    Symbol.Type          = Type.Type;
    Symbol.Modifier      = Modifier.ValueOrDefault;
    Attributes.NameScope = AttributeLookupScope(CurrentScope);

    Type       : QualifiedReference;
    Attributes : Attribute*;
    Modifier   : ParameterModifier;
  }

  abstract declaration PropertyAccessor
  {
    in Scope : Scope;

    Attributes.NameScope = AttributeLookupScope(Scope);

    Attributes : Attribute*;
    Modifiers  : Modifier*;
    // TODO: Map body
    | Get
    | Set
  }

  abstract declaration EventAccessor
  {
    in Scope : Scope;

    Attributes.NameScope = AttributeLookupScope(Scope);

    Attributes : Attribute*;
    // TODO: Map body
    | Add
    | Remove
  }
}
