using Nitra;
using Nitra.Runtime.Binding;
using Nemerle.Collections;

namespace CSharp
{
  abstract ast TypeParameterConstraint
  {
  stage 1:
    in    Scope                    : Scope;
    in    TypeConstraints          : TypeConstraintSet;
    inout ConstraintIndex          : int;
    in    ConstraintCount          : int;
    inout IsClassOrStructSpecified : bool;

    ConstraintIndexOut          = ConstraintIndexIn + 1;
    IsClassOrStructSpecifiedOut = IsClassOrStructSpecifiedIn;

    | Ctor
      {
        TypeConstraints |= TypeConstraint.Ctor;

        ReportMessage(CompilerMessageType.Error,
          ConstraintIndexOut == ConstraintCount,
          "The 'new()' constraint must be the last constraint specified.");
      }
    | Class
      {
        IsClassOrStructSpecifiedOut = true;
        TypeConstraints |= TypeConstraint.Class;

        ReportMessage(CompilerMessageType.Error,
          ConstraintIndexIn == 0,
          "The 'class' constraint must come before any other constraints.");
      }
    | Struct
      {
        IsClassOrStructSpecifiedOut = true;
        TypeConstraints |= TypeConstraint.Struct;

        ReportMessage(CompilerMessageType.Error,
          ConstraintIndexIn == 0,
          "The 'struct' constraint must come before any other constraints.");
      }
    | Base
      {
        Type.Scope = Scope;
        TypeConstraints |= Type.Type;

        // TODO: add non-sealed check
        out IsValid : bool = Type.Type.IsClass || Type.Type.IsInterface || Type.Type.IsTypeParameter;

        Type : QualifiedReference;

        ReportMessage(CompilerMessageType.Error,
          (Type.Type.IsClass && !IsClassOrStructSpecifiedIn) || !Type.Type.IsClass,
          $"'$(Type.Type)': cannot specify both a constraint class and the 'class' or 'struct' constraint.");

        // TODO: don't report this message if previous one is reported
        ReportMessage(CompilerMessageType.Error,
          (Type.Type.IsClass && ConstraintIndexIn == 0) || !Type.Type.IsClass,
          $"The class type constraint '$(Type.Type)' must come before any other constraints.");

        ReportMessage(CompilerMessageType.Error,
          IsValid,
          $"'$(Type.Type)' is not a valid constraint. A type used as a constraint must be an interface, a non-sealed class or a type parameter.");
      }
  }
}
