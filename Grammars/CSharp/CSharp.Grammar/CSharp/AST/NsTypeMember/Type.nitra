using CSharp.Symbols;
using Nitra;
using Nitra.Runtime.Binding;
using Nemerle.Collections;

namespace CSharp
{
  declaration TypeParameter
  {
    Variance : Variance;
    // TODO: Attributes
  }

  declarations Type : NamespaceMember, TypeMember
  {
    | Class
      {
        out Symbol : ClassSymbol = ClassSymbol.Create(this);

        TypeBase.Scope = Scope.Hide(this.Symbol.Scope, this.Scope);
        Members.Parent = Symbol;

        TypeBase : QualifiedReference*;
        Members : TypeMember*;
        TypeParameters : TypeParameter*;
      }

    | Struct
      {
        out Symbol : StructSymbol = StructSymbol.Create(this);
        
        Members.Parent        = Symbol;

        Members : TypeMember*;
      }

    | Interface
      {
        out Symbol : InterfaceSymbol = InterfaceSymbol.Create(this);

        Members.Parent        = Symbol;

        Members : TypeMember*;
      }

    | Delegate
      {
        out Symbol : DelegateSymbol = null;
      }

    | Enum
      {
        out Symbol : EnumSymbol = null;
      }
  }

  map syntax Types.TypeParameter -> TypeParameter
  {
    Name -> Name;
    Variance = 
      if (VarianceAnnotationOpt.HasValue)
        ParsedValue(VarianceAnnotationOpt.Value.Annotation, if (VarianceAnnotationOpt.Value.Annotation.Length == 2) Variance.Covariant else Variance.Contravariant)
      else ParsedValue(VarianceAnnotationOpt.Span, Variance.None);
  }

  map syntax TopDeclarations.TypeDeclaration -> Type
  {
    | Class
      {
        Name                            -> Name;
        match(TypeBaseOpt) { Some(types) -> types | None() -> [] } -> TypeBase;
        TypeBody.TypeMemberDeclarations -> Members;

        //TypeParameters = 
        //  if (TypeParametersOpt.HasValue)
        //    QualifiedReference.AstList(TypeParametersOpt.Value.AnyTypes, TypeParametersOpt.Value.AnyTypes.Item1.MapToArray(_.GetAst()))
        //  else
        //    QualifiedReference.AstList(TypeParametersOpt, array(0));
      }
    | Struct
      {
        Name                            -> Name;
        TypeBody.TypeMemberDeclarations -> Members;
      }
    | Interface
      {
        Name -> Name;
        TypeBody.TypeMemberDeclarations -> Members;
      }
    | Enum
      {
        Name                                                         -> Name;
        //EnumBody.EnumMemberDeclarations.EnumMemberDeclarations.Item1 -> Members;
      }
    | Delegate
      {
        Name -> Name;
      }
  }

  map syntax TopDeclarations.TypeBase -> QualifiedReference*
  {
    AnyTypes.Item1
  }
}
