using Nitra;
using Nitra.Runtime.Binding;
using Nemerle.Collections;

namespace CSharp
{

  //  out Symbol : GenericTypeSymbol;
  //stage 1:
  //  out BodyScope : Scope;
  //
  //  Modifiers.FlagsIn                 = Modifiers.None;
  //  TypeParameters.IndexIn            = 0;
  //  TypeParameters.PrevTypeParameters = Utils.TryGetPrevTypeParameters(this);
  //  Members.Parent                    = Symbol;
  //  BodyScope                         = Symbol.MakeBaseTypesScope(this.Scope);
  //  TypeBase.Scope                    = BodyScope;
  //  TypeParameterConstraints.Scope    = BodyScope;
  //  Members.TypeScope                 = BodyScope/*Symbol.MakeInheritedScope(BodyScope)*/;
  //
  //  TypeBase                 : QualifiedReference*;
  //  Members                  : TypeMember*;
  //  TypeParameters           : TypeParameter*;
  //  TypeParameterConstraints : TypeParameterConstraintsClause*;
  //  IsPartial                : bool;
  //
  //  | Class
  //    {
  //      symbol
  //      {
  //      }
  //      Symbol = ClassSymbol.Create(this, TypeParameters.Symbol, Parent);
  //    }
  //
  //  | Struct
  //    {
  //      Symbol = StructSymbol.Create(this, TypeParameters.Symbol, Parent);
  //    }
  //
  //  | Interface
  //    {
  //      Symbol = InterfaceSymbol.Create(this, TypeParameters.Symbol, Parent);
  //    }
  //}
  //
  //declaration Delegate : Type
  //{
  //  out Symbol : DelegateSymbol = null;
  //  ReturnType               : QualifiedReference;
  //  Parameters               : FormalParameter*;
  //  TypeParameters           : TypeParameter*;
  //  TypeParameterConstraints : TypeParameterConstraintsClause*;
  //}
  //
  //declaration Enum : Type
  //{
  //  out Symbol : EnumSymbol = null;
  //  EnumBase  : QualifiedReference?;
  //  Members   : Member.EnumMember*;
  //}

  map syntax Types.TypeParameter -> TypeParameter
  {
    Name -> Name;
    Variance = 
      if (VarianceAnnotationOpt.HasValue)
        ParsedValue(VarianceAnnotationOpt.Value.Annotation, if (VarianceAnnotationOpt.Value.Annotation.Length == 2) Variance.Covariant else Variance.Contravariant)
      else ParsedValue(VarianceAnnotationOpt.Span, Variance.None);
    Attributes -> Attributes;
  }

  map syntax Types.TypeParameters -> TypeParameter*
  {
    TypeParameters.Item1
  }

  map syntax Types.TypeParameterConstraint -> TypeParameterConstraint
  {
    | Ctor   {}
    | Class  {}
    | Struct {}
    | Base { AnyType -> Type; }
  }

  map syntax Types.TypeParameterConstraints -> TypeParameterConstraint*
  {
    TypeParameterConstraints.Item1
  }

  map syntax Types.TypeParameterConstraintsClause -> TypeParameterConstraintsClause
  {
    Reference                -> ParameterName;
    TypeParameterConstraints -> Constraints;
  }

  map syntax Types.TypeParameterConstraintsClauses -> TypeParameterConstraintsClause*
  {
    TypeParameterConstraintsClauses
  }

  map syntax TopDeclarations.TypeDeclaration -> NamespaceMember
  {
    | Class -> TopClass
      {
        Name                            -> Name;
        TypeBody.TypeMemberDeclarations -> Members;
        match(TypeBaseOpt)       { Some(value) -> value | None() -> [] } -> TypeBase;
        match(TypeParametersOpt) { Some(value) -> value | None() -> [] } -> TypeParameters;
        TypeParameterConstraintsClauses -> TypeParameterConstraints;
        IsPartial = ParsedValue(PartialOpt.Span, PartialOpt.HasValue);
        Attributes -> Attributes;
        Modifiers  -> Modifiers;
      }
    | Struct -> TopStruct
      {
        Name                            -> Name;
        TypeBody.TypeMemberDeclarations -> Members;
        match(TypeBaseOpt)       { Some(value) -> value | None() -> [] } -> TypeBase;
        match(TypeParametersOpt) { Some(value) -> value | None() -> [] } -> TypeParameters;
        TypeParameterConstraintsClauses -> TypeParameterConstraints;
        IsPartial = ParsedValue(PartialOpt.Span, PartialOpt.HasValue);
        Attributes -> Attributes;
        Modifiers  -> Modifiers;
      }
    | Interface -> TopInterface
      {
        Name                            -> Name;
        TypeBody.TypeMemberDeclarations -> Members;
        match(TypeBaseOpt)       { Some(value) -> value | None() -> [] } -> TypeBase;
        match(TypeParametersOpt) { Some(value) -> value | None() -> [] } -> TypeParameters;
        TypeParameterConstraintsClauses -> TypeParameterConstraints;
        IsPartial = ParsedValue(PartialOpt.Span, PartialOpt.HasValue);
        Attributes -> Attributes;
        Modifiers  -> Modifiers;
      }
    | Enum -> TopEnum
      {
        Name        -> Name;
        EnumBaseOpt -> EnumBase;
        EnumBody.EnumMemberDeclarations -> Members;
        Attributes -> Attributes;
        Modifiers  -> Modifiers;
      }
    | Delegate -> TopDelegate
      {
        Name             -> Name;
        AnyType          -> ReturnType;
        FormalParameters -> Parameters;
        match(TypeParametersOpt) { Some(value) -> value | None() -> [] } -> TypeParameters;
        TypeParameterConstraintsClauses -> TypeParameterConstraints;
        Attributes -> Attributes;
        Modifiers  -> Modifiers;
      }
  }

  map syntax TopDeclarations.TypeDeclaration(_tag : NestedTypeTag) -> TypeMember
  {
    | Class -> NestedClass
      {
        Name                            -> Name;
        TypeBody.TypeMemberDeclarations -> Members;
        match(TypeBaseOpt)       { Some(value) -> value | None() -> [] } -> TypeBase;
        match(TypeParametersOpt) { Some(value) -> value | None() -> [] } -> TypeParameters;
        TypeParameterConstraintsClauses -> TypeParameterConstraints;
        IsPartial = ParsedValue(PartialOpt.Span, PartialOpt.HasValue);
        Attributes -> Attributes;
        Modifiers  -> Modifiers;
      }
    | Struct -> NestedStruct
      {
        Name                            -> Name;
        TypeBody.TypeMemberDeclarations -> Members;
        match(TypeBaseOpt)       { Some(value) -> value | None() -> [] } -> TypeBase;
        match(TypeParametersOpt) { Some(value) -> value | None() -> [] } -> TypeParameters;
        TypeParameterConstraintsClauses -> TypeParameterConstraints;
        IsPartial = ParsedValue(PartialOpt.Span, PartialOpt.HasValue);
        Attributes -> Attributes;
        Modifiers  -> Modifiers;
      }
    | Interface -> NestedInterface
      {
        Name                            -> Name;
        TypeBody.TypeMemberDeclarations -> Members;
        match(TypeBaseOpt)       { Some(value) -> value | None() -> [] } -> TypeBase;
        match(TypeParametersOpt) { Some(value) -> value | None() -> [] } -> TypeParameters;
        TypeParameterConstraintsClauses -> TypeParameterConstraints;
        IsPartial = ParsedValue(PartialOpt.Span, PartialOpt.HasValue);
        Attributes -> Attributes;
        Modifiers  -> Modifiers;
      }
    | Enum -> NestedEnum
      {
        Name        -> Name;
        EnumBaseOpt -> EnumBase;
        EnumBody.EnumMemberDeclarations -> Members;
        Attributes -> Attributes;
        Modifiers  -> Modifiers;
      }
    | Delegate -> NestedDelegate
      {
        Name             -> Name;
        AnyType          -> ReturnType;
        FormalParameters -> Parameters;
        match(TypeParametersOpt) { Some(value) -> value | None() -> [] } -> TypeParameters;
        TypeParameterConstraintsClauses -> TypeParameterConstraints;
        Attributes -> Attributes;
        Modifiers  -> Modifiers;
      }
  }

  map syntax TopDeclarations.TypeBase -> QualifiedReference*
  {
    AnyTypes.Item1
  }
}
