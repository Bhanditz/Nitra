using CSharp.Symbols;
using Nitra;
using Nitra.Runtime.Binding;
using Nemerle.Collections;

namespace CSharp
{
  declaration TypeParameter
  {
    inout TypeParameters : list[TypeParameterSymbol];

    TypeParametersOut = Symbol :: TypeParametersIn;

    out Symbol : TypeParameterSymbol = TypeParameterSymbol(this);
    Name.Symbol = this.Symbol;

    Variance : Variance;
    // TODO: Attributes
  }

  asts TypeParameterConstraint
  {
    | Ctor
    | Class
    | Struct
    | Base
      {
        Type : QualifiedReference;
      }
  }

  ast TypeParameterConstraintsClause
  {
    ParameterName : Reference;
    Constraints   : TypeParameterConstraint*; // TODO: make TypeParameterConstraint+
  }

  declarations Type : NamespaceMember, TypeMember
  {
    | Class
      {
        out BodyScope : Scope;
        out Symbol : ClassSymbol = ClassSymbol.Create(this, TypeParameters.TypeParametersOut);

        Members.Parent                  = Symbol;
        TypeParameters.TypeParametersIn = [];
        BodyScope                       = Symbol.MakeBaseTypesScope(this.Scope);
        TypeBase.Scope                  = BodyScope;
      //Members.Scope                   = TypeBase.что-то там вычисляем для эмуляции наследования;

        TypeBase                 : QualifiedReference*;
        Members                  : TypeMember*;
        TypeParameters           : TypeParameter*;
        TypeParameterConstraints : TypeParameterConstraintsClause*;
        IsPartial                : bool;
      }

    | Struct
      {
        out Symbol : StructSymbol = StructSymbol.Create(this);

        Members.Parent        = Symbol;

        TypeBase                 : QualifiedReference*;
        Members                  : TypeMember*;
        TypeParameters           : TypeParameter*;
        TypeParameterConstraints : TypeParameterConstraintsClause*;
        IsPartial                : bool;
      }

    | Interface
      {
        out Symbol : InterfaceSymbol = InterfaceSymbol.Create(this);

        Members.Parent        = Symbol;

        TypeBase                 : QualifiedReference*;
        Members                  : TypeMember*;
        TypeParameters           : TypeParameter*;
        TypeParameterConstraints : TypeParameterConstraintsClause*;
        IsPartial                : bool;
      }

    | Delegate
      {
        out Symbol : DelegateSymbol = null;
        ReturnType               : QualifiedReference;
        Parameters               : FormalParameter*;
        TypeParameters           : TypeParameter*;
        TypeParameterConstraints : TypeParameterConstraintsClause*;
      }

    | Enum
      {
        out Symbol : EnumSymbol = null;
        EnumBase  : QualifiedReference?;
        Members   : Member.EnumMember*;
      }
  }

  map syntax Types.TypeParameter -> TypeParameter
  {
    Name -> Name;
    Variance = 
      if (VarianceAnnotationOpt.HasValue)
        ParsedValue(VarianceAnnotationOpt.Value.Annotation, if (VarianceAnnotationOpt.Value.Annotation.Length == 2) Variance.Covariant else Variance.Contravariant)
      else ParsedValue(VarianceAnnotationOpt.Span, Variance.None);
  }

  map syntax Types.TypeParameters -> TypeParameter*
  {
    TypeParameters.Item1
  }

  map syntax Types.TypeParameterConstraint -> TypeParameterConstraint
  {
    | Ctor   {}
    | Class  {}
    | Struct {}
    | Base
      {
        AnyType -> Type;
      }
  }

  map syntax Types.TypeParameterConstraints -> TypeParameterConstraint*
  {
    TypeParameterConstraints.Item1
  }

  map syntax Types.TypeParameterConstraintsClause -> TypeParameterConstraintsClause
  {
    Reference                -> ParameterName;
    TypeParameterConstraints -> Constraints;
  }

  map syntax Types.TypeParameterConstraintsClauses -> TypeParameterConstraintsClause*
  {
    TypeParameterConstraintsClauses
  }

  map syntax TopDeclarations.TypeDeclaration -> Type
  {
    | Class
      {
        Name                            -> Name;
        TypeBody.TypeMemberDeclarations -> Members;
        match(TypeBaseOpt)       { Some(value) -> value | None() -> [] } -> TypeBase;
        match(TypeParametersOpt) { Some(value) -> value | None() -> [] } -> TypeParameters;
        TypeParameterConstraintsClauses -> TypeParameterConstraints;
        IsPartial = ParsedValue(PartialOpt.Span, PartialOpt.HasValue);
      }
    | Struct
      {
        Name                            -> Name;
        TypeBody.TypeMemberDeclarations -> Members;
        match(TypeBaseOpt)       { Some(value) -> value | None() -> [] } -> TypeBase;
        match(TypeParametersOpt) { Some(value) -> value | None() -> [] } -> TypeParameters;
        TypeParameterConstraintsClauses -> TypeParameterConstraints;
        IsPartial = ParsedValue(PartialOpt.Span, PartialOpt.HasValue);
      }
    | Interface
      {
        Name                            -> Name;
        TypeBody.TypeMemberDeclarations -> Members;
        match(TypeBaseOpt)       { Some(value) -> value | None() -> [] } -> TypeBase;
        match(TypeParametersOpt) { Some(value) -> value | None() -> [] } -> TypeParameters;
        TypeParameterConstraintsClauses -> TypeParameterConstraints;
        IsPartial = ParsedValue(PartialOpt.Span, PartialOpt.HasValue);
      }
    | Enum
      {
        Name        -> Name;
        EnumBaseOpt -> EnumBase;
        EnumBody.EnumMemberDeclarations -> Members;
      }
    | Delegate
      {
        Name             -> Name;
        AnyType          -> ReturnType;
        FormalParameters -> Parameters;
        match(TypeParametersOpt) { Some(value) -> value | None() -> [] } -> TypeParameters;
        TypeParameterConstraintsClauses -> TypeParameterConstraints;
      }
  }

  map syntax TopDeclarations.TypeBase -> QualifiedReference*
  {
    AnyTypes.Item1
  }
}
