using Nitra;
using Nitra.Runtime.Binding;
using Nemerle;
using System;
using System.Linq;

namespace CSharp
{
  syntax module CsIdentifiers
  {
    using Outline;
    using PrettyPrint;
    using StandardSpanClasses;
    using Identifiers;
    using Whitespaces;

    using CSharp.TokenNames;
    using Literals;
    using Types;

    keyword regex ['A'..'Z', 'a'..'z', '_'..'_']+ rule S;

  // Contextual keywords:
  // "add" | "alias" | "ascending" | "assembly" | "by" | "descending" | "dynamic" | "equals" | "field" | "from" | "get" | "global"!!! | "group" |
  // "into" | "join" | "let" | "method" | "module" | "on" | "orderby" | "param" | "partial" | "property" | "remove" | "select" | "set" | "type" |
  // "typevar"!!! | "value" | "var" | "where" | "yield"

    regex KeywordToken
                  =   "abstract" | "as"         | "base"      | "bool"      | "break"     | "byte"     | "case"   | "catch"       | "char"      | "checked"
                    | "class"    | "const"      | "continue"  | "decimal"   | "default"   | "delegate" | "do"     | "double"      | "else"      | "enum"
                    | "event"    | "explicit"   | "extern"    | "false"     | "finally"   | "fixed"    | "float"  | "for"         | "foreach"   | "goto"
                    | "if"       | "implicit"   | "in"        | "int"       | "interface" | "internal" | "is"     | "lock"        | "long"      | "namespace"
                    | "new"      | "null"       | "object"    | "operator"  | "out"       | "override" | "params" | "private"     | "protected" | "public"
                    | "readonly" | "ref"        | "return"    | "sbyte"     | "sealed"    | "short"    | "sizeof" | "stackalloc"  | "static"    | "string"
                    | "struct"   | "switch"     | "this"      | "throw"     | "true"      | "try"      | "typeof" | "uint"        | "ulong"     | "unchecked"
                    | "unsafe"   | "ushort"     | "using"     | "virtual"   | "void"      | "volatile" | "while"
                    | "__arglist";

    alias Reference           = Identifier;
    alias Name                = DeclarationName;
    alias QualifiedName       = QualifiedIdentifier;
    alias Char                = Any;

    [Keyword]
    token Keyword = Name=KeywordToken !IdentifierPartCharacters;

    /////////////////////////////////////////////////////////
    // Identifiers

    [Reference]
    token Identifier = !Keyword At="@"? IdentifierBody;

    [Name]
    token DeclarationName = !Keyword At="@"? IdentifierBody;

    [ExplicitSpaces]
    syntax QualifiedIdentifier  = QualifiedAlias? (QualifiedIdentifierPart; s "." s)+; // TODO: In C# spec. it's "namespace-or-type-name". Rename it!

    [ExplicitSpaces]
    syntax QualifiedIdentifierContinuation = (QualifiedIdentifierPart; s "." s)+;

    [ExplicitSpaces]
    syntax NamespaceName        = (Name; s "." s)+;

    [ExplicitSpaces]
    syntax QualifiedIdentifierPartTypeArguments
    {
      [SpanClass(OpenBrace)]
      regex OpenBrace = "<";

      [SpanClass(CloseBrace)]
      regex CloseBrace = ">";

      CreateTypeArguments() : QualifiedReference.IAstList;

      | TypeArgumentList  = OpenBrace s (AnyType; s "," s sm)+ s CloseBrace
        {
          override CreateTypeArguments
          {
            def args = array(AnyTypes.Item1.Count);
            foreach (anyType in AnyTypes.Item1 with index)
              args[index] = anyType.GetAst();
            QualifiedReference.AstList(this, args)
          }
        }

      | OpenTypeArguments = OpenBrace s RankSeparators=(RankSeparator s)* CloseBrace
        {
          override CreateTypeArguments
          {
            def args = array(RankSeparators.Count + 1);
            args[0] = IntrinsicUtils.CreateOpenTypeArgument(this.File, NSpan(OpenBrace.EndPos));
            foreach (rs in RankSeparators with index)
              args[index + 1] = IntrinsicUtils.CreateOpenTypeArgument(this.File, NSpan(rs.EndPos));
            QualifiedReference.AstList(this, args)
          }
        }
    }

    [ExplicitSpaces]
    syntax QualifiedIdentifierPart = Identifier (s QualifiedIdentifierPartTypeArguments)?
    {
      CreateSimple() : QualifiedReference
      {
        QualifiedReference.Simple(
          File = Identifier.File,
          Span = Identifier.Span,
          Name = Identifier.GetAst()) |> TryCreateGeneric
      }

      CreateAliased(aliasAst : Reference) : QualifiedReference
      {
        QualifiedReference.Aliased(
          File  = aliasAst.File,
          Span  = aliasAst.Span + Identifier.Span,
          Alias = aliasAst,
          Name  = Identifier.GetAst()) |> TryCreateGeneric
      }

      CreateQualified(qualifier : QualifiedReference) : QualifiedReference
      {
        QualifiedReference.Qualified(
          File      = qualifier.File,
          Span      = qualifier.Span + Identifier.Span,
          Qualifier = qualifier,
          Name      = Identifier.GetAst()) |> TryCreateGeneric
      }

      missing CreateQualified
      {
        QualifiedReference.Qualified(
          File      = qualifier.File,
          Span      = qualifier.Span + Span,
          Qualifier = qualifier,
          Name      = Reference.AmbiguousOrMissing(this.File, this.Span)) |> TryCreateGeneric
      }

      TryCreateGeneric(name : QualifiedReference) : QualifiedReference
      {
        if (QualifiedIdentifierPartTypeArgumentsOpt.HasValue)
          QualifiedReference.Generic(
            File          = name.File,
            Span          = name.Span + QualifiedIdentifierPartTypeArgumentsOpt.Span,
            QualifiedName = name,
            Arguments     = QualifiedIdentifierPartTypeArgumentsOpt.Value.CreateTypeArguments())
        else
          name
      }

      missing TryCreateGeneric = name;
    }

    syntax QualifiedAlias = Alias=Identifier "::";

    // same as 'QualifiedIdentifierPart' but avoids capturing type arguments of method name
    [ExplicitSpaces]
    syntax InterfaceTypePart        = Identifier (s QualifiedIdentifierPartTypeArguments)? !"("
    {
      CreateSimple() : QualifiedReference
      {
        QualifiedReference.Simple(
          File = Identifier.File,
          Span = Identifier.Span,
          Name = Identifier.GetAst()) |> TryCreateGeneric
      }

      CreateAliased(aliasAst : Reference) : QualifiedReference
      {
        QualifiedReference.Aliased(
          File  = aliasAst.File,
          Span  = aliasAst.Span + Identifier.Span,
          Alias = aliasAst,
          Name  = Identifier.GetAst()) |> TryCreateGeneric
      }

      CreateQualified(qualifier : QualifiedReference) : QualifiedReference
      {
        QualifiedReference.Qualified(
          File      = qualifier.File,
          Span      = qualifier.Span + Identifier.Span,
          Qualifier = qualifier,
          Name      = Identifier.GetAst()) |> TryCreateGeneric
      }

      missing CreateQualified = qualifier;

      TryCreateGeneric(name : QualifiedReference) : QualifiedReference
      {
        if (QualifiedIdentifierPartTypeArgumentsOpt.HasValue)
          QualifiedReference.Generic(
            File          = name.File,
            Span          = name.Span + QualifiedIdentifierPartTypeArgumentsOpt.Span,
            QualifiedName = name,
            Arguments     = QualifiedIdentifierPartTypeArgumentsOpt.Value.CreateTypeArguments())
        else
          name
      }

      missing TryCreateGeneric = name;
    }

    syntax InterfaceType            = QualifiedAlias? (InterfaceTypePart ".")+;

    regex IdentifierStartCharacter  = LetterCharacter | "_" | UnicodeEscapeSequence;
    regex IdentifierPartCharacters  = LetterCharacter | DecimalDigitCharacter | ConnectingCharacter | CombiningCharacter | FormattingCharacter | UnicodeEscapeSequence;
    regex IdentifierBody            = IdentifierStartCharacter IdentifierPartCharacters*;

    // Identifiers
    /////////////////////////////////////////////////////////
  }
}
