using Nitra;
using Nitra.Declarations;
using Nitra.Runtime.Binding;
using Nitra.Internal;
using System.Linq;

namespace CSharp
{
  declaration Project
  {
    CompilationUnits : CompilationUnit*;
  }

  declarations CompilationUnit
  {
    | CSharp
      {
        Externs         : ExternAliasDirective*;
        UsingDirectives : UsingDirective*;
      }
  }

  declarations QualifiedReference
  {
    | Simple
      {
        Name  : Reference;
      }
    | Aliased
      {
        Alias : Reference;
        Name  : Reference;
      }
    | Qualified
      {
        Qualifier : QualifiedReference;
        Name      : Reference;
      }
    | Generic
      {
        Name      : QualifiedReference;
        Arguments : QualifiedReference+;
      }
  }

  map syntax CsIdentifiers.QualifiedAlias -> Reference call Alias;

  map syntax CsIdentifiers.QualifiedIdentifier -> QualifiedReference =
  {
    assert(QualifiedIdentifierParts.Item1.Count > 0);

    def makeSpan(pt)
    {
      NSpan(Location.StartPos, pt.Location.EndPos)
    }

    def handleSimple(index, qidPart, parent)
    {
      def span = makeSpan(qidPart.Identifier);
      if (index > 0)
      {
        def qid = QualifiedReference.Qualified(parent, span);
        qid.Initialize(
          Qualifier = handleGeneric(index - 1, qid),
          Name      = qidPart.Identifier.GetAst(qid));
        qid
      }
      else if (QualifiedAliasOpt.HasValue)
      {
        def qid = QualifiedReference.Aliased(parent, span);
        qid.Initialize(
          Alias = QualifiedAliasOpt.Value.GetAst(qid),
          Name  = qidPart.Identifier.GetAst(qid));
        qid
      }
      else
      {
        def qid = QualifiedReference.Simple(parent, span);
        qid.Initialize(Name = qidPart.Identifier.GetAst(qid));
        qid
      }
    }

    and handleGeneric(index, parent)
    {
      def qidPart = QualifiedIdentifierParts.Item1[index];
      if (qidPart.QualifiedIdentifierPartTypeArgumentsOpt.HasValue)
      {
        match (qidPart.QualifiedIdentifierPartTypeArgumentsOpt.Value)
        {
          | CsIdentifiersParseTree.QualifiedIdentifierPartTypeArguments.TypeArgumentList as x =>
            def qid = QualifiedReference.Generic(parent, makeSpan(x));

            def args = array(x.AnyTypes.Item1.Count);
            foreach (anyType in x.AnyTypes.Item1 with index)
              args[index] = anyType.GetAst(qid);

            qid.Initialize(
              Name      = handleSimple(index, qidPart, qid),
              Arguments = QualifiedReference.AstList(qid, x.Location.Span, args));
            qid

          | CsIdentifiersParseTree.QualifiedIdentifierPartTypeArguments.OpenTypeArguments as x =>
            def qid = QualifiedReference.Generic(parent, makeSpan(x));

            def args = array(x.RankSeparators.Count + 1);
            args[0] = IntrinsicUtils.CreateOpenTypeArgument(qid, NSpan(x.OpenBrace.EndPos, x.OpenBrace.EndPos));
            foreach (rs in x.RankSeparators with index)
              args[index + 1] = IntrinsicUtils.CreateOpenTypeArgument(qid, NSpan(rs.Location.EndPos, rs.Location.EndPos));

            qid.Initialize(
              Name      = handleSimple(index, qidPart, qid),
              Arguments = QualifiedReference.AstList(qid, x.Location.Span, args));
            qid

          | _ => assert(false)
        }
      }
      else
        handleSimple(index, qidPart, parent);
    }

    handleGeneric(QualifiedIdentifierParts.Item1.Count - 1, parent);
  };

  map syntax Types.TypeName -> QualifiedReference;
  map syntax Types.TypeName.QualifiedName  -> QualifiedReference call QualifiedIdentifier;
  map syntax Types.TypeName.PredefinedType -> QualifiedReference = IntrinsicUtils.CreatePredefinedTypeReference(parent, PredefinedType, GetText(PredefinedType));

  map syntax Types.AnyNonArrayType -> QualifiedReference =
  {
    if (NullableSpecifierOpt.HasValue)
    {
      def qid = QualifiedReference.Generic(parent, Location.Span);
      qid.Initialize(
        Name      = IntrinsicUtils.CreateQualifiedReference(qid, Location.Span, array["System", "Nullable"]),
        Arguments = QualifiedReference.AstList(qid, Location.Span, array[TypeName.GetAst(qid)]));
      qid
    }
    else
      TypeName.GetAst(parent)
  };

  map syntax Types.AnyType -> QualifiedReference =
  {
    def loop(index, parent)
    {
      if (index < 0)
        AnyNonArrayType.GetAst(parent)
      else
      {
        def ts   = TypeSpecifiers[index];
        def span = NSpan(Location.StartPos, ts.Location.EndPos);
        match (ts)
        {
          | TypesParseTree.TypeSpecifier.RankSpecifier as x =>
            def rank = x.RankSpecifier.RankSeparators.Count + 1;
            def qid  = QualifiedReference.Generic(parent, span);
            qid.Initialize(
              Name      = IntrinsicUtils.CreateQualifiedReference(qid, span, array["#Array" + rank.ToString()]),
              Arguments = QualifiedReference.AstList(qid, span, array[loop(index - 1, qid)]));
            qid

          | TypesParseTree.TypeSpecifier.PointerSpecifier =>
            def qid  = QualifiedReference.Generic(parent, span);
            qid.Initialize(
              Name      = IntrinsicUtils.CreateQualifiedReference(qid, span, array["#Pointer"]),
              Arguments = QualifiedReference.AstList(qid, span, array[loop(index - 1, qid)]));
            qid

          | _ => assert(false)
        }
      }
    }
    loop(TypeSpecifiers.Count - 1, parent)
  };

  declaration ExternAliasDirective
  {
    Name   : Reference;
  }

  declarations UsingDirective
  {
    | Alias
      {
        Name                : Reference;
        NamespaceOrTypeName : QualifiedReference;
      }
    | Open
      {
        NamespaceOrTypeName : QualifiedReference;
      }
  }

  declarations Top
  {
    | Namespace
      {
        Path            : Reference*;
        name Name       : Reference;
        ExternAlias     : ExternAliasDirective*;
        UsingDirectives : UsingDirective*;
        Members         : Top*;
      }
    | Type
      {
        name Name : Reference;
        Members   : Top*;
      }
    | Member
      {
        //name Name : Reference;
      }
  }

  map syntax Main.CompilationUnit -> CompilationUnit.CSharp
  {
    ExternAliasDirectives -> Externs;
    UsingDirectives       -> UsingDirectives;
  }

  map syntax TopDeclarations.ExternAliasDirective -> ExternAliasDirective
  {
    Name -> Name;
  }

  map syntax TopDeclarations.UsingDirective -> UsingDirective
  {
    | Alias
      {
        Name          -> Name;
        QualifiedName -> NamespaceOrTypeName;
      }
    | Open
      {
        QualifiedName -> NamespaceOrTypeName;
      }
  }

  map syntax TopDeclarations.NamespaceMemberDeclaration -> Top
  {
    | Namespace
      {
        Name            = NamespaceName.Identifiers.Item1.Last().GetAst(declaration);
        Path            = null;
        ExternAliasDirectives       -> ExternAlias;
        UsingDirectives             -> UsingDirectives;
        NamespaceMemberDeclarations -> Members;
      }
    | Type call TypeDeclaration;
  }

  map syntax TopDeclarations.TypeDeclaration -> Top
  {
    | Class -> Type
      {
        Name                            -> Name;
        TypeBody.TypeMemberDeclarations -> Members;
      }
    | Struct -> Type
      {
        StructHead.Name                 -> Name;
        TypeBody.TypeMemberDeclarations -> Members;
      }
    | Interface -> Type
      {
        Name -> Name;
        TypeBody.TypeMemberDeclarations -> Members;
      }
    | Enum -> Type
      {
        Name                                                         -> Name;
        EnumBody.EnumMemberDeclarations.EnumMemberDeclarations.Item1 -> Members;
      }
    | Delegate -> Type
      {
        Name    -> Name;
        Members = Top.AstList(declaration, Location.Span, array[]);
      }
  }

  map syntax TopDeclarations.TypeMemberDeclaration -> Top
  {
    | NestedType      -> Type call TypeDeclaration;
    | Method          -> Member
    | Property        -> Member
    | Field           -> Member
    | Constant        -> Member
    | Constructor     -> Member
    | Event           -> Member
    | SimpleEvent     -> Member
    | Indexer         -> Member
    | Destructor      -> Member
    | FixedSizeBuffer -> Member
    | Operator1       -> Member
    | Operator2       -> Member
  }

  map syntax TopDeclarations.EnumMemberDeclaration -> Top.Member;
}
