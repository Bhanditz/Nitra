using Nitra;
using Nitra.Declarations;
using Nitra.Runtime.Binding;
using Nitra.Internal;
using System.Linq;

namespace CSharp
{
  declaration Project
  {
    CompilationUnits : CompilationUnit*;
  }

  declarations CompilationUnit
  {
    | CSharp
      {
        Externs         : ExternAliasDirective*;
        UsingDirectives : UsingDirective*;
      }
  }

  declaration QualifiedIdentifier
  {
    Alias : Reference?;
    Parts : QualifiedIdentifierPart+;
  }

  declarations QualifiedIdentifierPart
  {
    Name          : Reference;
    | Simple            {                                   }
    | WithTypeArguments { Arguments : QualifiedIdentifier*; }
    | WithTypeRank      { Rank      : int;                  }
  }

  map syntax CsIdentifiers.QualifiedAlias to Reference = Alias.GetAst(parent);

  map syntax CsIdentifiers.QualifiedIdentifier to QualifiedIdentifier
  {
    Alias <- QualifiedAliasOpt;
    Parts = AstUtils.GetAstList(declaration, QualifiedIdentifierParts.Item1);
  }

  map syntax CsIdentifiers.QualifiedIdentifierPart to QualifiedIdentifierPart =
  {
    if (QualifiedIdentifierPartTypeArgumentsOpt.HasValue)
    {
      match (QualifiedIdentifierPartTypeArgumentsOpt.Value)
      {
        | CsIdentifiersParseTree.QualifiedIdentifierPartTypeArguments.QualifiedIdentifierPartTypeArgumentList as x =>
          def declaration = QualifiedIdentifierPart.WithTypeArguments(parent, Location.Span);
          declaration.Initialize(Name = Identifier.GetAst(declaration), Arguments = AstList(declaration, x.TypeArguments.Location.Span, QualifiedIdentifier.DataProxy(null, null), array[]));
          declaration

        | CsIdentifiersParseTree.QualifiedIdentifierPartTypeArguments.QualifiedIdentifierPartOpenTypeArguments as x =>
          def declaration = QualifiedIdentifierPart.WithTypeRank(parent, Location.Span);
          declaration.Initialize(Name = Identifier.GetAst(declaration), Rank = x.RankSeparators.Count);
          declaration

        | _ => assert(false)
      }
    }
    else
    {
      def declaration = QualifiedIdentifierPart.Simple(parent, Location.Span);
      declaration.Initialize(Name = Identifier.GetAst(declaration));
      declaration
    }
  };

  declaration ExternAliasDirective
  {
    Name   : Reference;
  }

  declarations UsingDirective
  {
    | Alias
      {
        Name                : Reference;
        NamespaceOrTypeName : QualifiedIdentifier;
      }
    | Open
      {
        NamespaceOrTypeName : QualifiedIdentifier;
      }
  }

  declarations Top
  {
    | Namespace
      {
        Path            : Reference*;
        name Name       : Reference;
        ExternAlias     : ExternAliasDirective*;
        UsingDirectives : UsingDirective*;
        Members         : Top*;
      }
    | Type
      {
        name Name : Reference;
        Members   : Top*;
      }
    | Member
      {
        //name Name : Reference;
      }
  }

  map syntax Main.CompilationUnit to CompilationUnit.CSharp
  {
    Externs         <- ExternAliasDirectives;
    UsingDirectives <- UsingDirectives;
  }

  map syntax TopDeclarations.ExternAliasDirective to ExternAliasDirective
  {
    Name <- Name;
  }

  map syntax TopDeclarations.UsingDirective to UsingDirective
  {
    | Alias
      {
        Name                <- Name;
        NamespaceOrTypeName <- QualifiedName;
      }
    | Open
      {
        NamespaceOrTypeName <- QualifiedName;
      }
  }

  map syntax TopDeclarations.NamespaceMemberDeclaration to Top
  {
    | Namespace
      {
        Name            = NamespaceName.Identifiers.Item1.Last().GetAst(declaration);
        Path            = null;
        ExternAlias     <- ExternAliasDirectives;
        UsingDirectives <- UsingDirectives;
        Members         <- NamespaceMemberDeclarations;
      }
    | Type = TypeDeclaration.GetAst(parent);
  }

  map syntax TopDeclarations.TypeDeclaration to Top
  {
    | Type from Class
      {
        Name    <- Name;
        Members = AstUtils.GetAstList(declaration, TypeBody.TypeMemberDeclarations);
      }
    | Type from Struct
      {
        Name    = StructHead.Name.GetAst(declaration);
        Members = AstUtils.GetAstList(declaration,TypeBody.TypeMemberDeclarations);
      }
    | Type from Interface
      {
        Name    <- Name;
        Members = AstUtils.GetAstList(declaration,TypeBody.TypeMemberDeclarations);
      }
    | Type from Enum
      {
        Name    <- Name;
        Members = AstUtils.GetAstList(declaration, EnumBody.EnumMemberDeclarations.EnumMemberDeclarations.Item1);
      }
    | Type from Delegate
      {
        Name    <- Name;
        Members = AstList(declaration, Location.Span, Top.DataProxy(null, null), array[]);
      }
  }

  map syntax TopDeclarations.TypeMemberDeclaration to Top
  {
    | Type from NestedType = TypeDeclaration.GetAst(parent);
    | Member from Method          {}
    | Member from Property        {}
    | Member from Field           {}
    | Member from Constant        {}
    | Member from Constructor     {}
    | Member from Event           {}
    | Member from SimpleEvent     {}
    | Member from Indexer         {}
    | Member from Destructor      {}
    | Member from FixedSizeBuffer {}
    | Member from Operator1       {}
    | Member from Operator2       {}
  }

  map syntax TopDeclarations.EnumMemberDeclaration to Top.Member
  {
  }
}
