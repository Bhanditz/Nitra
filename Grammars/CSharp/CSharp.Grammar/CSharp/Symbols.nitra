using Nitra;
using Nitra.Declarations;
using Nitra.Runtime.Binding;
using Nitra.Internal;
using System.Linq;

namespace CSharp
{
  declaration Project
  {
    CompilationUnits : CompilationUnit*;
  }

  declarations CompilationUnit
  {
    | CSharp
      {
        Externs         : ExternAliasDirective*;
        UsingDirectives : UsingDirective*;
      }
  }

  declaration QualifiedIdentifier
  {
    Alias : Reference?;
    Parts : QualifiedIdentifierPart+;
  }

  declarations QualifiedIdentifierPart
  {
    Name          : Reference;
    | Simple            {                                   }
    | WithTypeArguments { Arguments : QualifiedIdentifier*; }
    | WithTypeRank      { Rank      : int;                  }
  }

  declare Reference from CsIdentifiers.QualifiedAlias = Alias.GetDeclaration(parent);

  declare QualifiedIdentifier from CsIdentifiers.QualifiedIdentifier
  {
    Alias <- QualifiedAliasOpt;
    Parts = QualifiedIdentifierPart.ListProxy(declaration, QualifiedIdentifierParts.Location.Span, DeclarationUtils.GetDeclarations(declaration, QualifiedIdentifierParts.Item1));
  }

  declare QualifiedIdentifierPart from CsIdentifiers.QualifiedIdentifierPart =
  {
    if (QualifiedIdentifierPartTypeArgumentsOpt.HasValue)
    {
      match (QualifiedIdentifierPartTypeArgumentsOpt.Value)
      {
        | CsIdentifiersParseTree.QualifiedIdentifierPartTypeArguments.QualifiedIdentifierPartTypeArgumentList as x =>
          def declaration = QualifiedIdentifierPart.WithTypeArguments(parent, Location.Span);
          declaration.Initialize(Name = Identifier.GetDeclaration(declaration), Arguments = QualifiedIdentifier.ListProxy(declaration, x.TypeArguments.Location.Span, array[]));
          declaration

        | CsIdentifiersParseTree.QualifiedIdentifierPartTypeArguments.QualifiedIdentifierPartOpenTypeArguments as x =>
          def declaration = QualifiedIdentifierPart.WithTypeRank(parent, Location.Span);
          declaration.Initialize(Name = Identifier.GetDeclaration(declaration), Rank = x.RankSeparators.Count);
          declaration

        | _ => assert(false)
      }
    }
    else
    {
      def declaration = QualifiedIdentifierPart.Simple(parent, Location.Span);
      declaration.Initialize(Name = Identifier.GetDeclaration(declaration));
      declaration
    }
  };

  declaration ExternAliasDirective
  {
    Name   : Reference;
  }

  declarations UsingDirective
  {
    | Alias
      {
        Name                : Reference;
        NamespaceOrTypeName : QualifiedIdentifier;
      }
    | Open
      {
        NamespaceOrTypeName : QualifiedIdentifier;
      }
  }

  declarations Top
  {
    | Namespace
      {
        Path            : Reference*;
        Name            : Reference;
        ExternAlias     : ExternAliasDirective*;
        UsingDirectives : UsingDirective*;
        Members         : Top*;
      }
    | Type
      {
        Name    : Reference;
        Members : Top*;
      }
    | Member
      {
      }
  }

  declare CompilationUnit.CSharp from Main.CompilationUnit
  {
    Externs         <- ExternAliasDirectives;
    UsingDirectives <- UsingDirectives;
  }

  declare ExternAliasDirective from TopDeclarations.ExternAliasDirective
  {
    Name <- Name;
  }

  declare UsingDirective from TopDeclarations.UsingDirective
  {
    | Alias
      {
        Name                <- Name;
        NamespaceOrTypeName <- QualifiedName;
      }
    | Open
      {
        NamespaceOrTypeName <- QualifiedName;
      }
  }

  declare Top from TopDeclarations.NamespaceMemberDeclaration
  {
    | Namespace
      {
        Name            = NamespaceName.Identifiers.Item1.Last().GetDeclaration(declaration);
        Path            = null;
        ExternAlias     <- ExternAliasDirectives;
        UsingDirectives <- UsingDirectives;
        Members         <- NamespaceMemberDeclarations;
      }
    | Type = TypeDeclaration.GetDeclaration(parent);
  }

  declare Top from TopDeclarations.TypeDeclaration
  {
    | Type from Class
      {
        Name    <- Name;
        Members = Top.ListProxy(declaration, TypeBody.TypeMemberDeclarations.Location.Span, DeclarationUtils.GetDeclarations(declaration, TypeBody.TypeMemberDeclarations));
      }
    | Type from Struct
      {
        Name    = StructHead.Name.GetDeclaration(declaration);
        Members = Top.ListProxy(declaration, TypeBody.TypeMemberDeclarations.Location.Span, DeclarationUtils.GetDeclarations(declaration, TypeBody.TypeMemberDeclarations));
      }
    | Type from Interface
      {
        Name    <- Name;
        Members = Top.ListProxy(declaration, TypeBody.TypeMemberDeclarations.Location.Span, DeclarationUtils.GetDeclarations(declaration, TypeBody.TypeMemberDeclarations));
      }
    | Type from Enum
      {
        Name    <- Name;
        Members = Top.ListProxy(declaration, EnumBody.EnumMemberDeclarations.EnumMemberDeclarations.Item1.Location.Span, DeclarationUtils.GetDeclarations(declaration, EnumBody.EnumMemberDeclarations.EnumMemberDeclarations.Item1));
      }
    | Type from Delegate
      {
        Name    <- Name;
        Members = Top.ListProxy(declaration, Location.Span, array[]);
      }
  }

  declare Top from TopDeclarations.TypeMemberDeclaration
  {
    | Type from NestedType = TypeDeclaration.GetDeclaration(parent);
    | Member from Method          {}
    | Member from Property        {}
    | Member from Field           {}
    | Member from Constant        {}
    | Member from Constructor     {}
    | Member from Event           {}
    | Member from SimpleEvent     {}
    | Member from Indexer         {}
    | Member from Destructor      {}
    | Member from FixedSizeBuffer {}
    | Member from Operator1       {}
    | Member from Operator2       {}
  }

  declare Top.Member from TopDeclarations.EnumMemberDeclaration
  {
  }
}
