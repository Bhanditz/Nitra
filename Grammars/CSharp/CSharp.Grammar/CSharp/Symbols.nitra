using Nemerle.Collections;

using Nitra;
using Nitra.Declarations;
using Nitra.Runtime.Binding;
using Nitra.Internal;

using System.Linq;

namespace CSharp
{
  ast Project
  {
    CompilationUnits : CompilationUnit*;
  }

  asts CompilationUnit
  {
    | CSharp
      {
        Externs         : ExternAliasDirective*;
        UsingDirectives : UsingDirective*;
        Members         : NamespaceMember*;
      }
  }

  asts QualifiedReference
  {
    | Simple    {                                 Name : Reference; }
    | Aliased   { Alias         : Reference;          Name : Reference; }
    | Qualified { Qualifier     : QualifiedReference; Name : Reference; }
    | Generic   { QualifiedName : QualifiedReference; Arguments : QualifiedReference+; }
  }

  map syntax CsIdentifiers.QualifiedAlias      -> Reference          { Alias }
  map syntax CsIdentifiers.QualifiedIdentifier -> QualifiedReference
  {
    | (None,    (first :: other, _)) = other.Aggregate(first.CreateSimple(),            (acc, item) => item.CreateQualified(acc));
    | (Some(a), (first :: other, _)) = other.Aggregate(first.CreateAliased(a.GetAst()), (acc, item) => item.CreateQualified(acc));
    | (_,       ([],             _)) = IntrinsicUtils.CreateMissingQualifiedReference(QualifiedIdentifierParts.Span);
  }
  map syntax CsIdentifiers.InterfaceType -> QualifiedReference
  {
    | (None,    (first, _) :: other) = other.Aggregate(first.CreateSimple(),            (acc, item) => item.Item1.CreateQualified(acc));
    | (Some(a), (first, _) :: other) = other.Aggregate(first.CreateAliased(a.GetAst()), (acc, item) => item.Item1.CreateQualified(acc));
    | (_,       []                 ) = IntrinsicUtils.CreateMissingQualifiedReference(InterfaceTypeParts.Span);
  }

  map syntax Types.TypeName -> QualifiedReference
  {
    | QualifiedName  -> QualifiedIdentifier
    | PredefinedType = IntrinsicUtils.CreatePredefinedTypeReference(PredefinedType, GetText(PredefinedType));
  }

  map syntax Types.AnyNonArrayType -> QualifiedReference
  {
    | (typeName, None) -> typeName
    | (typeName, Some) -> Generic
      {
        QualifiedName = IntrinsicUtils.CreateQualifiedReference(Span, "System", "Nullable");
        [ typeName ] -> Arguments;
      }
  }

  map syntax Types.TypeSpecifier -> QualifiedReference
  {
    | PointerSpecifier = IntrinsicUtils.CreateQualifiedReference(Span, "#Pointer");
    | RankSpecifier =
      {
        def rank = RankSpecifier.RankSeparators.Count + 1;
        IntrinsicUtils.CreateQualifiedReference(Span, "#Array" + rank.ToString())
      };
  }

  map syntax Types.AnyType -> QualifiedReference =
  {
    mutable acc = AnyNonArrayType.GetAst();

    foreach (ts in TypeSpecifiers)
    {
      acc = QualifiedReference.Generic(
        Span          = acc.Span + ts.Span,
        QualifiedName = ts.GetAst(),
        Arguments     = QualifiedReference.AstList(acc.Span, acc))
    }

    acc
  };

  ast ExternAliasDirective
  {
    Name   : Reference;
  }

  asts UsingDirective
  {
    | Alias
      {
        Name                : Reference;
        NamespaceOrTypeName : QualifiedReference;
      }
    | Open
      {
        NamespaceOrTypeName : QualifiedReference;
      }
  }

  abstract declaration NamespaceMember
  {
  }

  abstract declaration TypeMember
  {
  }

  declaration Namespace : NamespaceMember
  {
    Path            : Reference*;
    ExternAlias     : ExternAliasDirective*;
    UsingDirectives : UsingDirective*;
    Members         : NamespaceMember*;
  }

  declarations Type : NamespaceMember, TypeMember
  {
    | Struct    { Members : TypeMember*; }
    | Class     { TypeBase : QualifiedReference*; Members : TypeMember*; }
    | Interface { Members : TypeMember*; }
    | Delegate
    | Enum
  }

  declarations Member : TypeMember
  {
    | Constructor
    | Destructor
    | Method   { InterfaceType : QualifiedReference?; }
    | Property { InterfaceType : QualifiedReference?; }
    | Event    { InterfaceType : QualifiedReference?; }
    | Indexer
    | Other
  }

  // --------------------------------------------------------------------------------------

  //map syntax TopDeclarations.TypeBase -> QualifiedReference

  map syntax Main.CompilationUnit -> CompilationUnit.CSharp
  {
    ExternAliasDirectives       -> Externs;
    UsingDirectives             -> UsingDirectives;
    NamespaceMemberDeclarations -> Members;
  }

  map syntax TopDeclarations.ExternAliasDirective -> ExternAliasDirective
  {
    Name -> Name;
  }

  map syntax TopDeclarations.UsingDirective -> UsingDirective
  {
    | Alias
      {
        Name          -> Name;
        QualifiedName -> NamespaceOrTypeName;
      }
    | Open
      {
        QualifiedName -> NamespaceOrTypeName;
      }
  }

  map syntax TopDeclarations.NamespaceMemberDeclaration -> NamespaceMember
  {
    | Namespace -> Namespace
      {
        Name            = NamespaceName.Identifiers.Item1.Last().GetAst();
        Path            = Reference.AstList(NamespaceName.Identifiers.Item1.Span, NamespaceName.Identifiers.Item1.Take(NamespaceName.Identifiers.Item1.Count - 1).Select(pt => pt.GetAst()).ToArray());
        ExternAliasDirectives       -> ExternAlias;
        UsingDirectives             -> UsingDirectives;
        NamespaceMemberDeclarations -> Members;
      }
    | Type = TypeDeclaration.GetAst();
  }

  map syntax TopDeclarations.TypeDeclaration -> Type
  {
    | Class
      {
        Name                            -> Name;
        TypeBase = 
          if (TypeBaseOpt.HasValue)
            QualifiedReference.AstList(TypeBaseOpt.Value.AnyTypes.Span, TypeBaseOpt.Value.AnyTypes.Item1.MapToArray(_.GetAst()))
          else
            QualifiedReference.AstList(TypeBaseOpt.Span, array(0));
        TypeBody.TypeMemberDeclarations -> Members;
      }
    | Struct
      {
        StructHead.Name                 -> Name;
        TypeBody.TypeMemberDeclarations -> Members;
      }
    | Interface
      {
        Name -> Name;
        TypeBody.TypeMemberDeclarations -> Members;
      }
    | Enum
      {
        Name                                                         -> Name;
        //EnumBody.EnumMemberDeclarations.EnumMemberDeclarations.Item1 -> Members;
      }
    | Delegate
      {
        Name -> Name;
      }
  }

  map syntax TopDeclarations.TypeMemberDeclaration -> TypeMember*
  {
    | NestedType      -> [TypeDeclaration]
    | Constructor     -> [Member.Constructor { Name -> Name; }]
    | Destructor      -> [Member.Destructor  { Name -> Name; }]
    | Method          -> [Member.Method      { MethodHeader.Name -> Name; MethodHeader.InterfaceTypeOpt -> InterfaceType; }]
    | Property        -> [Member.Property    { Name -> Name;              InterfaceTypeOpt -> InterfaceType; }]
    | Event           -> [Member.Event       { Name -> Name;              InterfaceTypeOpt -> InterfaceType; }]
    | Indexer         -> [Member.Indexer     { Name = Reference(this.KwThis, "#Item"); }]
    | SimpleEvent     -> [Member.Other       { Name = Reference(this.Span, "#NotImplemented"); }]
    | Field           -> [Member.Other       { Name = Reference(this.Span, "#NotImplemented"); }]
    | Constant        -> [Member.Other       { Name = Reference(this.Span, "#NotImplemented"); }]
    | FixedSizeBuffer -> [Member.Other       { Name = Reference(this.Span, "#NotImplemented"); }]
    | OperatorUnary   -> [Member.Other       { Name = Reference(this.Span, "#NotImplemented"); }]
    | OperatorBinary  -> [Member.Other       { Name = Reference(this.Span, "#NotImplemented"); }]
    | OperatorCnv     -> [Member.Other       { Name = Reference(this.Span, "#NotImplemented"); }]
  }

  //map syntax TopDeclarations.EnumMemberDeclaration -> Top.Member
  //{
  //  Name = Reference(this.Span, "#NotImplemented");
  //}
}
