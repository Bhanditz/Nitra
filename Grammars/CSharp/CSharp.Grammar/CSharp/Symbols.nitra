using Nitra;
using Nitra.Declarations;
using Nitra.Runtime.Binding;
using Nitra.Internal;
using System.Linq;

namespace CSharp
{
  declaration Project
  {
    CompilationUnits : CompilationUnit*;
  }

  declarations CompilationUnit
  {
    | CSharp
      {
        Externs         : ExternAliasDirective*;
        UsingDirectives : UsingDirective*;
      }
  }

  declaration QualifiedIdentifier
  {
    Alias : Reference?;
    Parts : QualifiedIdentifierPart+;
  }

  declaration QualifiedIdentifierPart
  {
    Name          : Reference;
    TypeArguments : QualifiedIdentifier*;
  }

  declare QualifiedIdentifier from CsIdentifiers.QualifiedIdentifier
  {
    Alias = 
      if (QualifiedAliasOpt.HasValue)
        DeclarationOption.Some(parent, QualifiedAliasOpt.Location.Span, Reference.Create(QualifiedAliasOpt.Value.Alias))
      else
        DeclarationOption.None(parent, QualifiedAliasOpt.Location.Span);
    Parts <- QualifiedIdentifierPart;
  }

  declare QualifiedIdentifierPart from CsIdentifiers.QualifiedIdentifierPart
  {
    Name = Reference.Create(Identifier);
    TypeArguments <- QualifiedIdentifierPartTypeArguments; // ?
  }

  declaration ExternAliasDirective
  {
    Parent : CompilationUnit;
    Name   : Reference;
  }

  declarations UsingDirective
  {
    | Alias
      {
        Name                : Reference;
        NamespaceOrTypeName : QualifiedIdentifier;
      }
    | Open
      {
        NamespaceOrTypeName : QualifiedIdentifier;
      }
  }

  declarations Top
  {
    | Namespace
      {
        Path            : Reference*;
        Name            : Reference;
        ExternAlias     : ExternAliasDirective*;
        UsingDirectives : UsingDirective*;
        Members         : Top*;
      }
    | Type
      {
        Name    : Reference;
        Members : Top*;
      }
    | Member
      {
      }
  }

  declare CompilationUnit.CSharp from Main.CompilationUnit
  {
    Externs         <- ExternAliasDirectives;
    UsingDirectives <- UsingDirectives;
  }

  declare ExternAliasDirective from TopDeclarations.ExternAliasDirective
  {
    Name = Reference.Create(Name);
  }

  declare UsingDirective from TopDeclarations.UsingDirective
  {
    | Alias
      {
        Name                = Reference.Create(Name);
        NamespaceOrTypeName <- QualifiedName;
      }
    | Open
      {
        NamespaceOrTypeName <- QualifiedName;
      }
  }

  declare Top from TopDeclarations.NamespaceMemberDeclaration
  {
    | Namespace
      {
        Name            = Reference.Create(NamespaceName.Identifiers.Item1.Last());
        Path            = null;
        ExternAlias     <- ExternAliasDirectives;
        UsingDirectives <- UsingDirectives;
        Members         <- NamespaceMemberDeclarations;
      }
    | Type = TypeDeclaration.GetDeclaration(parent);
  }

  declare Top from TopDeclarations.TypeDeclaration
  {
    | Type from Class
      {
        Name    = Reference.Create(Name);
        Members = Top.ListProxy(parent, TypeBody.TypeMemberDeclarations.Location.Span, DeclarationUtils.GetDeclarations(parent, TypeBody.TypeMemberDeclarations));
      }
    | Type from Struct
      {
        Name    = Reference.Create(StructHead.Name);
        Members = Top.ListProxy(parent, TypeBody.TypeMemberDeclarations.Location.Span, DeclarationUtils.GetDeclarations(parent, TypeBody.TypeMemberDeclarations));
      }
    | Type from Interface
      {
        Name    = Reference.Create(Name);
        Members = Top.ListProxy(parent, TypeBody.TypeMemberDeclarations.Location.Span, DeclarationUtils.GetDeclarations(parent, TypeBody.TypeMemberDeclarations));
      }
    | Type from Enum
      {
        Name    = Reference.Create(Name);
        Members = Top.ListProxy(parent, EnumBody.EnumMemberDeclarations.EnumMemberDeclarations.Item1.Location.Span, DeclarationUtils.GetDeclarations(parent, EnumBody.EnumMemberDeclarations.EnumMemberDeclarations.Item1));
      }
    | Type from Delegate
      {
        Name    = Reference.Create(Name);
        Members = Top.ListProxy(parent, Location.Span, array[]);
      }
  }

  declare Top from TopDeclarations.TypeMemberDeclaration
  {
    | Type from NestedType = TypeDeclaration.GetDeclaration(parent);
    | Member from Method          {}
    | Member from Property        {}
    | Member from Field           {}
    | Member from Constant        {}
    | Member from Constructor     {}
    | Member from Event           {}
    | Member from SimpleEvent     {}
    | Member from Indexer         {}
    | Member from Destructor      {}
    | Member from FixedSizeBuffer {}
    | Member from Operator1       {}
    | Member from Operator2       {}
  }

  declare Top.Member from TopDeclarations.EnumMemberDeclaration
  {
  }
}
