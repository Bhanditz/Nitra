using Nitra;
using Nitra.Declarations;
using Nitra.Runtime.Binding;
using Nitra.Internal;
using System.Linq;

namespace CSharp
{
  declaration Project
  {
    CompilationUnits : CompilationUnit*;
  }

  declarations CompilationUnit
  {
    | CSharp
      {
        Externs         : ExternAliasDirective*;
        UsingDirectives : UsingDirective*;
      }
  }

  declarations QualifiedReference
  {
    | Simple
      {
        Name  : Reference;
      }
    | Aliased
      {
        Alias : Reference;
        Name  : Reference;
      }
    | Qualified
      {
        Qualifier : QualifiedReference;
        Name      : Reference;
      }
    | Generic
      {
        Name      : QualifiedReference;
        Arguments : QualifiedReference+;
      }
  }

  map syntax CsIdentifiers.QualifiedAlias      -> Reference          = Alias.GetAst(context);
  map syntax CsIdentifiers.QualifiedIdentifier -> QualifiedReference
  {
    | (None,    (first :: other, _)) = other.Aggregate(first.CreateSimple(context),                     (acc, item) => item.CreateQualified(acc, context));
    | (Some(a), (first :: other, _)) = other.Aggregate(first.CreateAliased(a.GetAst(context), context), (acc, item) => item.CreateQualified(acc, context));
    | (_,       ([],             _)) = IntrinsicUtils.CreateQualifiedReference(QualifiedIdentifierParts.Span, "#Missing");
  }

  map syntax Types.TypeName -> QualifiedReference
  {
    | QualifiedName  = QualifiedIdentifier.GetAst(context);
    | PredefinedType = IntrinsicUtils.CreatePredefinedTypeReference(PredefinedType, GetText(PredefinedType));
  }

  map syntax Types.AnyNonArrayType -> QualifiedReference
  {
    | (typeName, None) = typeName.GetAst(context);
    | (typeName, Some) -> Generic
      {
        Name      = IntrinsicUtils.CreateQualifiedReference(Span, "System", "Nullable");
        Arguments = QualifiedReference.AstList(Span, typeName.GetAst(context));
      }
  }

  map syntax Types.TypeSpecifier -> QualifiedReference
  {
    | PointerSpecifier = IntrinsicUtils.CreateQualifiedReference(Span, "#Pointer");
    | RankSpecifier =
      {
        def rank = RankSpecifier.RankSeparators.Count + 1;
        IntrinsicUtils.CreateQualifiedReference(Span, "#Array" + rank.ToString())
      };
  }

  map syntax Types.AnyType -> QualifiedReference =
  {
    mutable acc = AnyNonArrayType.GetAst(context);

    foreach (ts in TypeSpecifiers)
    {
      acc = QualifiedReference.Generic(
        Span      = acc.Span + ts.Span,
        Name      = ts.GetAst(context),
        Arguments = QualifiedReference.AstList(acc.Span, acc))
    }

    acc
  };

  declaration ExternAliasDirective
  {
    Name   : Reference;
  }

  declarations UsingDirective
  {
    | Alias
      {
        Name                : Reference;
        NamespaceOrTypeName : QualifiedReference;
      }
    | Open
      {
        NamespaceOrTypeName : QualifiedReference;
      }
  }

  declarations Top
  {
    | Namespace
      {
        Path            : Reference*;
        name Name       : Reference;
        ExternAlias     : ExternAliasDirective*;
        UsingDirectives : UsingDirective*;
        Members         : Top*;
      }
    | Type
      {
        name Name : Reference;
        Members   : Top*;
      }
    | Member
      {
        //name Name : Reference;
      }
  }

  map syntax Main.CompilationUnit -> CompilationUnit.CSharp
  {
    ExternAliasDirectives -> Externs;
    UsingDirectives       -> UsingDirectives;
  }

  map syntax TopDeclarations.ExternAliasDirective -> ExternAliasDirective
  {
    Name -> Name;
  }

  map syntax TopDeclarations.UsingDirective -> UsingDirective
  {
    | Alias
      {
        Name          -> Name;
        QualifiedName -> NamespaceOrTypeName;
      }
    | Open
      {
        QualifiedName -> NamespaceOrTypeName;
      }
  }

  map syntax TopDeclarations.NamespaceMemberDeclaration -> Top
  {
    | Namespace
      {
        Name            = NamespaceName.Identifiers.Item1.Last().GetAst(context);
        Path            = null;
        ExternAliasDirectives       -> ExternAlias;
        UsingDirectives             -> UsingDirectives;
        NamespaceMemberDeclarations -> Members;
      }
    | Type = TypeDeclaration.GetAst(context);
  }

  map syntax TopDeclarations.TypeDeclaration -> Top
  {
    | Class -> Type
      {
        Name                            -> Name;
        TypeBody.TypeMemberDeclarations -> Members;
      }
    | Struct -> Type
      {
        StructHead.Name                 -> Name;
        TypeBody.TypeMemberDeclarations -> Members;
      }
    | Interface -> Type
      {
        Name -> Name;
        TypeBody.TypeMemberDeclarations -> Members;
      }
    | Enum -> Type
      {
        Name                                                         -> Name;
        EnumBody.EnumMemberDeclarations.EnumMemberDeclarations.Item1 -> Members;
      }
    | Delegate -> Type
      {
        Name    -> Name;
        Members = Top.AstList(Location.Span);
      }
  }

  map syntax TopDeclarations.TypeMemberDeclaration -> Top
  {
    | NestedType = TypeDeclaration.GetAst(context);
    | Method          -> Member
    | Property        -> Member
    | Field           -> Member
    | Constant        -> Member
    | Constructor     -> Member
    | Event           -> Member
    | SimpleEvent     -> Member
    | Indexer         -> Member
    | Destructor      -> Member
    | FixedSizeBuffer -> Member
    | Operator1       -> Member
    | Operator2       -> Member
  }

  map syntax TopDeclarations.EnumMemberDeclaration -> Top.Member;
}
