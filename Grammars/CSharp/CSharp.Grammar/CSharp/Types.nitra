namespace CSharp
{
  syntax module Types
  {
    using Outline;
    using PrettyPrint;
    using StandardSpanClasses;
    using Whitespaces;

    using CSharp.TokenNames;
    using Literals;
    using CSharp.CsIdentifiers;
    using Expressions;
    using Attributes;

    keyword regex ['A'..'Z', 'a'..'z', '_'..'_']+ rule S;

    alias Attributes              = AttributeSection*;
    alias Name                    = Identifier;

    ////////////////////////////////////////////////////////////////////////////////////
    // TypeParameters

    regex InOrOut  = "in" | "out";
    syntax VarianceAnnotation  = Annotation=InOrOut sm;
    syntax TypeParameter       = Attributes VarianceAnnotation? Name;
    [ExplicitSpaces] 
    syntax TypeParameters   = OpenBrace s (TypeParameter; s "," s sm)+ s CloseBrace
    {
      [SpanClass(OpenBrace)]
      regex OpenBrace = "<";

      [SpanClass(CloseBrace)]
      regex CloseBrace = ">";
    }

    syntax TypeParameterConstraint
    {
      | Ctor   = "new" "(" ")";
      | Class  = "class";
      | Struct = "struct";
      | Base   = AnyType;
    }

    syntax TypeParameterConstraints        = (TypeParameterConstraint; ","sm)+;
    syntax TypeParameterConstraintsClause  =  "where"sm Name ":"sm TypeParameterConstraints nl;
    syntax TypeParameterConstraintsClauses = TypeParameterConstraintsClause*;

    //
    ////////////////////////////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////////////////////////////
    // Types

    regex EnumBaseType      = "sbyte" | "byte" | "short" | "ushort" | "int" | "uint" | "long" | "ulong";
    regex IntegralType      = EnumBaseType | "char";
    regex FloatingPointType = "float" | "double";
    regex NumericType       = IntegralType | FloatingPointType | "decimal";
    regex PredefinedType    = NumericType | "void"  | "bool" | "string" | "dynamic" | "object";

    [ExplicitSpaces]
    syntax TypeName
    {
      | PredefinedType
      | QualifiedName = !PredefinedType QualifiedIdentifier
    }

    regex Pointer = "*";
    syntax PointerSpecifiers = Pointer*;

    regex RankSeparator = ",";
    [ExplicitSpaces] syntax RankSpecifier = "[" s RankSeparators=(RankSeparator s)* "]";

    [ExplicitSpaces]
    syntax TypeSpecifier
    {
      | RankSpecifier;
      | PointerSpecifier = Pointer;
    }

    [ExplicitSpaces] syntax NullableSpecifier = "?" !"?"; // dont't collide with `??' operator
    [ExplicitSpaces] syntax AnyNonArrayType             = TypeName (s NullableSpecifier)?;
    [ExplicitSpaces] syntax AnyNonArrayTypeNullableHack = TypeName NullableSpecifier=(s NullableSpecifier !(Expression ":" Expression))?; // don't collide with ternary op ? : // BUG:
    [ExplicitSpaces] syntax AnyType                     = AnyNonArrayType (s TypeSpecifier)*;
    [ExplicitSpaces] syntax AnyTypeNullableHack         = AnyNonArrayTypeNullableHack (s TypeSpecifier)*;

    //
    ////////////////////////////////////////////////////////////////////////////////////
  }
}
