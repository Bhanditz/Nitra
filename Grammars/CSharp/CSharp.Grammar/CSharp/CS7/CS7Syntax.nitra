namespace CSharp
{
  syntax module CS7
  {
    using CSharp.CS6;
    using CS6Expression;
    using CS6Literals;

    using Nitra.Core;
    using CSharp.Core;
    using CSharp.CsIdentifiers;
    using CSharp.Types;

    using Attributes;
    using TopDeclarations;
    using Expressions;
    using Statements;
    using Literals;
    using ObjectAndCollectionInitializers;

    alias Attributes    = AttributeSection*;
    alias QualifiedName = QualifiedIdentifier;
    alias FormalParameters = (FormalParameter; ","sm)*;

    ////////////////////////////////////////////////////////////
    // out var

    extend syntax Argument
    {
      | OutVar      = ArgumentName? Modfier="out" sm LocalVariableType sm Name;
      | OutWildcard = ArgumentName? Modfier="out" sm Wildcard="*";
    }

    // out var
    ////////////////////////////////////////////////////////////

    extend syntax SwitchLabel
    {
      | PatternMatching          = "case" sm AnyType sm Name ":";
      | PatternMatchingWithGuard = "case" sm AnyType sm Name sm "when" sm "(" Condition=Expression ")" ":";
    }

    extend syntax Expression
    {
      | Tuple = !("(" Expression ")") "(" (TupleArgument; "," sm)+ ")"
      | Ref = "ref" Expression
    precedence RelationalAndTypeTesting:
      | PatternMatching = Expr1=Expression ^ RelationalAndTypeTesting sm "is" sm TypeName=AnyTypeNullableHack Name
    }

    ////////////////////////////////////////////////////////////
    // Tuple

    extend syntax LocalVariableDeclaration
    {
      | TupleDeconstruction = "var" TupleDeconstruction sm "=" sm VariableInitializer
      | VarDeconstruction   = "(" ("var" sm TupleDeconstructionField; "," sm){2,} ")" sm "=" sm VariableInitializer
    }

    [ExplicitSpaces]
    syntax TupleDeconstruction = "(" s (TupleDeconstructionField; s "," s sm){2,} s ")";

    [ExplicitSpaces]
    syntax TupleDeconstructionField
    {
      | Name
      | TupleDeconstruction
    }
    

    // [ExplicitSpaces] - inherited
    extend syntax TypeName
    {
      | Tuple = "(" s (TupleTypeField; s "," s sm)+ s ")"
    }

    [ExplicitSpaces]
    syntax TupleTypeField
    {
      | Named = AnyType s sm Name
      | Unnamed = AnyType
    }

    syntax TupleArgument
    {
      | Named   = Reference !"::" ":" sm Expression;
      | Unnamed = Expression;
    }

    // Tuple
    ////////////////////////////////////////////////////////////

    extend syntax Statement
    {
      | LocalRefVariable = "ref" sm LocalVariableType Name sm "=" sm VariableInitializer ";"nl;
    }

    extend syntax EmbeddedStatement
    {
      | RefReturn = "ref" sm "return" sm Expression ";" nl;
    }

    extend syntax TypeMemberDeclaration
    {
      | RefMethod                   = Attributes Modifiers "ref" sm MethodHeader Body;
      | RefProperty                 = Attributes Modifiers "ref" sm AnyType sm InterfaceType? Name PropertyBody;
      | RefIndexer                  = Attributes Modifiers "ref" sm AnyType sm  InterfaceType? "this" "[" FormalParameters "]" PropertyBody;
      | RefPropertyExpressionBodied = Attributes Modifiers "ref" sm AnyType sm InterfaceType? Name sm "=>" sm Expression ";" nl;
      | RefMethodExpressionBodied   = Attributes Modifiers "ref" sm MethodHeader  sm "=>" sm Expression ";" nl;
    }
  }
}
