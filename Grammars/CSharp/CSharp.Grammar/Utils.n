using CSharp.Symbols;

using Nitra;
using Nitra.Declarations;
using Nitra.Runtime.Binding;

using Nemerle;
using Nemerle.Collections;
using Nemerle.Imperative;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;
// TODO: rename Symbol2 to Symbol and remove follow line
using Symbol = Nitra.Runtime.Binding.Symbol2;

namespace CSharp
{
  module Utils
  {
    public EnterNamespace(mutable ns : NamespaceSymbol, path : Name.IAstList, namespaceDeclaration : Namespace) : NamespaceSymbol
    {
      def lastIndex = path.Count - 1;
      foreach (name in path with i)
      {
        mutable symbol = ns.MembersScope.TryGetSymbol(name);
        when (symbol is AmbiguousHierarchicalSymbol as ambiguous)
        {
          symbol = null;
          foreach (ns is NamespaceSymbol in ambiguous.Ambiguous)
          {
            symbol = ns;
            break;
          }
        }
        when (symbol == null)
        {
          def namespaceSymbol = NamespaceSymbol(name, ns);
          ns.DefineNestedSymbol(namespaceSymbol, reportErrors=true);
          symbol = namespaceSymbol;
        }
        when (i == lastIndex)
          symbol.Declarations ::= namespaceDeclaration;
          
        ns = (symbol :> NamespaceSymbol);
        name.Symbol = ns;
      }
      otherwise ns = NamespaceSymbol(namespaceDeclaration.Name, ns);
      
      ns
    }
    
    public MakeEnteredScope(parentScope : Scope, parentNs : NamespaceSymbol, enteredNs : NamespaceSymbol) : Scope
    {
      def buildEnterNsScope(ns : NamespaceSymbol) : Scope
      {
        def parent = ns.Parent;
        def scope  = ns.Scope;
        
        if (parent == parentNs)
          Scope.Hide(scope, parentScope)
        else
          Scope.Hide(scope, buildEnterNsScope(parent))
      }
      
      buildEnterNsScope(enteredNs)
    }
    
    public TryResolveTypeOverload(symbol : Symbol, argumentsCount : int) : Symbol
    {
      symbol.TryResolve(x => x.Ambiguous.OfType.[GenericTypeSymbol]().Where(s => s.TypeParameters.Count == argumentsCount));
    }
    
    public TryGetPrevTypeParameters(declaration : GenericType) : array[TypeParameterSymbol]
    {
      def isPartial = declaration.IsPartial.ValueOrDefault;
      when (!isPartial)
        return null;
        
      def typeParametersCount = declaration.TypeParameters.Count;
      def symbol = declaration.Parent.MembersScope.TryGetSymbol(declaration.Name);
      def ambiguous = List();
      match (symbol)
      {
        | null => ()
        | ambig is IAmbiguousSymbol => 
          foreach (ambiguousSymbol in ambig.Ambiguous)
            ambiguous.Add(ambiguousSymbol);
          
        | _ => ambiguous.Add(symbol);
      }
      
      def candidates = List();
      
      // TODO: заменить ClassSymbol на параметр типа
      foreach (candidate in ambiguous)
        when (candidate is ClassSymbol as genericType) // is class?
          when (genericType.TypeParameters.Count == typeParametersCount)
            candidates.Add(genericType);
      
      
      if (candidates.Count() == 1 && candidates[0].IsPartial && isPartial)
        candidates[0].TypeParameters.ToArray() // merge
      else
        null
    }
  }
}
