namespace N2.Tests
{
  syntax module JsonParser
  {
    using PrettyPrint;
    using Outline;
    using TokenNames;
    using StandardSpanClasses;
    using Whitespaces;
    using Identifiers;
    using CStyleComments;

    braces "(", ")";
    braces "{", "}";
    braces "[", "]";

    [StartRule, ExplicitSpaces]
    syntax Start = s Value !Any;

    ///////////////////////////////////////////////////////////////////////////
    // Whitespaces

    extend syntax IgnoreToken
    {
      | [SpanClass(Comment)] SingleLineComment = SingleLineComment;
      | [SpanClass(Comment)] MultiLineComment;
    }

    ///////////////////////////////////////////////////////////////////////////
    // Identifier

    // Non ambiguous
    [ExplicitSpaces] syntax Identifier = !Keyword IdentifierBody
    {
      token KeywordToken = "true" | "false" | "null";
      [ExplicitSpaces] syntax Keyword = KeywordToken !IdentifierPartCharacters;
    }

    // Non ambiguous (Keyword vs. Identifier)
    //[ExplicitSpaces] syntax Identifier = IdentifierBody;


    ///////////////////////////////////////////////////////////////////////////
    // Strings

    token EscChar                   = '\\' | '/' | 'b' | 'f' | 'n' | 'r'| 't' | 'u' HexDigit HexDigit HexDigit HexDigit
    {
      token HexDigit                  = ['0'..'9', 'a'..'f', 'A'..'F'];
    }

    [SpanClass(String), ExplicitSpaces]
    syntax StringLiteral1 = Quote StringPart* Quote
    {
      token Quote   = '\"';

      [ExplicitSpaces]
      syntax StringPart
      {
        token Esc     = '\\' (Quote | EscChar);
        token Escs    = Esc+;
        token NotEscs = ~(Quote | '\\');

        | Escs;
        | NotEscs;
      }
    }

    [SpanClass(String), ExplicitSpaces]
    syntax StringLiteral2 = Quote StringPart* Quote
    {
      token Quote   = '\'';

      [ExplicitSpaces]
      syntax StringPart
      {
        token Esc     = '\\' (Quote | EscChar);
        token Escs    = Esc+;
        token NotEscs = ~(Quote | '\\') - "";

        | Escs;
        | NotEscs;
      }
    }

    ///////////////////////////////////////////////////////////////////////////
    // Numbers

    token Digits   = ['0'..'9']+;
    token Integer  = '0' | ['1'..'9'] ['0'..'9']*;
    token Exponent = ("E" | "e") ("-" | "+")? Digits;

    //[ExplicitSpaces]
    token Fraction = "." Digits ;

    //[ExplicitSpaces]
    [SpanClass(Number)]
    token Number = "-"? Integer Fraction? Exponent?;

    ///////////////////////////////////////////////////////////////////////////
    // Value

    syntax Value
    {
      | Identifier
      | StringLiteral1
      | StringLiteral2
      | Number
      //| [ExplicitSpaces] Number = Integer Fraction? Exponent? s;
      //| [ExplicitSpaces] NumberNeg = Minus="-" Integer Fraction? Exponent? s;
      | Object = "{" outline_begin_before inl (Property; "," nl)* nl d outline_end "}";
      | Array  = "[" outline_begin_before (Value; "," sm)* outline_end "]";
      | "true"
      | "false"
      | "null"
    }

    syntax Property
    {
      | StringLiteral1 sm ":" sm Value;
      | StringLiteral2 sm ":" sm Value;
      | Identifier     sm ":" sm Value;
    }
  }
}
