//using N2;

//using Nemerle.Collections;
//using Nemerle.Imperative;
//using Nemerle.Compiler;

//using System.Collections.Generic;
//using System.Text;
//using System.Linq;

syntax module JsonParser
{
  using PrettyPrint;
  using Whitespaces;
  using Identifiers;

  token field OpenBrace           = "(";
  token field CloseBrace          = ")";
  token field OpenBrace           = "{";
  token field CloseBrace          = "}";
  token field OpenSquareBrace     = "[";
  token field CloseSquareBrace    = "]";
  token field SingleQuote         = "\'";
  token field Quote               = "\"";
  token field Semicolon           = ";";
  token field Comma               = ",";
  token field Colon               = ":";
  token field Assign              = "=";
  token field Op                  = "+", "-", "*", "/", "?", "^", "%", "&", "!", ".";
  token field Backslash           = "\\";

  span class Comment;
  span class Char;
  span class String;
  span class Number;
  span class Keyword      = ['a'..'z']['a'..'z']+;
  span class Operator     = ['+', '-', '/', '*', '^', '?', ':']+;
  span class OpenBrace    = "(" | "{" | "[";
  span class CloseBrace   = ")" | "}" | "]";

  braces "(", ")";
  braces "{", "}";
  braces "[", "]";

  //token Keyword = "as" | "syntax" | "token" | "alias" | "in" | "out" | "rule";

  [StartRule, ExplicitSpaces]
  syntax Start = s Value !Any;

  ///////////////////////////////////////////////////////////////////////////
  // Whitespaces

  extend syntax IgnoreToken
  {
    | [ExplicitSpaces, SpanClass(Comment)] SingleLineComment = Start="//" Body=(!NewLine Any)* End=NewLine?;
    | [ExplicitSpaces, SpanClass(Comment)] MultiLineComment  = Start="/*" Body=(!"*/" Any)*    End="*/";
    | [ExplicitSpaces]                     SpaceToken        = Spaces;
  }

  ///////////////////////////////////////////////////////////////////////////
  // Strings

  [ExplicitSpaces] syntax Identifier = IdentifierBody;

  token HexDigit                  = ['0'..'9', 'a'..'f', 'A'..'F'];
  token EscChar                   = '\\' | '/' | 'b' | 'f' | 'n' | 'r' | 'u' HexDigit HexDigit HexDigit HexDigit;

  token ReservedStringChar1       = '\"' | '\\';
  token EscChar1                  = '\"' | EscChar;
  token Esc1                      = '\\' EscChar1;
  [SpanClass(String), ExplicitSpaces]
  syntax StringLiteral1 = "\"" StringPart1* "\"";

  [ExplicitSpaces] syntax StringPart1;

  extend syntax StringPart1
  {
    | [ExplicitSpaces] EscStringPart   = Esc1;
    | [ExplicitSpaces] OtherStringPart = Chars=(!ReservedStringChar1 Any)+
  }

  token ReservedStringChar2       = '\'' | '\\';
  token EscChar2                  = '\'' | EscChar;
  token Esc2                      = '\\' EscChar2;

  [ExplicitSpaces] syntax StringPart2;

  extend syntax StringPart2
  {
    | [ExplicitSpaces] EscStringPart2   = Esc2;
    | [ExplicitSpaces] OtherStringPart2 = Chars=(!ReservedStringChar2 Any)+;
  }

  [SpanClass(String), ExplicitSpaces]
  syntax StringLiteral2 = "\'" StringPart2* "\'";

  ///////////////////////////////////////////////////////////////////////////
  // Numbers

  token Digits   = ['0'..'9']+;
  token Integer  = '0' | ['1'..'9'] ['0'..'9']*;
  token Exponent = ("E" | "e") ("-" | "+")? Digits;
 
  [ExplicitSpaces]
  syntax Fraction = "." Digits ;

  [ExplicitSpaces]
  syntax Number = Minus="-"? Integer Fraction? Exponent?;

  ///////////////////////////////////////////////////////////////////////////
  // Value

  syntax Value
  {
    | Identifier
    | StringLiteral1
    | StringLiteral2
    | Number
    | Object =  "{" inl Properties=(Property; "," nl)* nl d "}";
    | Array  = "[" (Value; "," sm)*  "]";
    | "true"
    | "false"
    | "null"
  }

  syntax Property
  {
    | StringLiteral1 ":" sm Value;
    | StringLiteral2 ":" sm Value;
    | Identifier     ":" sm Value;
  }
}