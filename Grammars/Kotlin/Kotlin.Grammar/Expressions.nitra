namespace Kotlin
{
  syntax module Expressions
  {
    using Nitra.Core;
    using Kotlin.Annotations;
    using Kotlin.Classes;
    using Kotlin.ClassMembers;
    using Kotlin.Types;
    using Kotlin.Modifiers;

    syntax Expression
    {
      //| CallableReference = (UserType "?"*)? "::" SimpleName TypeArguments?;
      //|                              = "(" expression ")"
      //|                              = literalConstant
      //|                              = functionLiteral
      //|                              = "this" labelReference?
      //|                              = "super" ("<" type ">")? labelReference?
      //|                              = if
      //|                              = when
      //|                              = try
      //|                              = objectLiteral
      //|                              = jump
      //|                              = loop
      //|                              = SimpleName
      //|                              = FieldName
      //|                              = "package" 
      //  ;

      | LiteralConstant

      precedence Assignment:
      | Assignment       = Expression "="  Expression
      | AssignmentAdd    = Expression "+=" Expression
      | AssignmentSub    = Expression "-=" Expression
      | AssignmentMul    = Expression "*=" Expression
      | AssignmentDiv    = Expression "/=" Expression
      | AssignmentMod    = Expression "%=" Expression

      precedence Disjunction:
      | Disjunction      = Expression "||" Expression

      precedence Conjunction:
      | Conjunction      = Expression "&&" Expression

      precedence Equality:
      | Equality         = Expression "==" Expression
      | NonEquality      = Expression "!=" Expression

      precedence Comparison:
      | Less             = Expression "<"  Expression
      | Greater          = Expression ">"  Expression
      | LessOrEqual      = Expression "<=" Expression
      | GreaterOrEqual   = Expression ">=" Expression

      precedence NamedChecks:
      | CheckIn          = Expression "in"  Expression
      | CheckNotIn       = Expression "!in" Expression
      | CheckIs          = Expression "is"  IsRHS
      | CheckNotIs       = Expression "!is" IsRHS

      precedence Elvis:
      | Elvis            = Expression "?:" Expression

      precedence InfixFunction:
      | InfixFunction    = Expression SimpleName Expression

      precedence Range:
      | Range            = Expression ".." Expression

      precedence Additive:
      | Add              = Expression "+" Expression
      | Sub              = Expression "-" Expression

      precedence Multiplicative:
      | Mul              = Expression "*" Expression
      | Div              = Expression "/" Expression
      | Mod              = Expression "%" Expression

      precedence TypeRHS:
      | asd1             = Expression ":"   Type
      | asd2             = Expression "as"  Type
      | asd3             = Expression "as?" Type

      precedence Prefix:
      | UnaryMinus       = "-"  Expression
      | UnaryPlus        = "+"  Expression
      | PrefixIncrement  = "++" Expression
      | PrefixDecrement  = "--" Expression
      | Not              = "!"  Expression
      | LabelDefinition  = LabelDefinition Expression

      precedence Postfix:
      | PostfixIncrement = Expression "++"
      | PostfixDecriment = Expression "--"
      //| MemberAccess "."//TODO:!!!!!!!
      //?.
      //?
    }
 
    [ExplicitSpaces]
    syntax LabelReference = "@" LabelName S;
    [ExplicitSpaces]
    syntax LabelDefinition = LabelName "@" s;

    syntax LiteralConstant
    {
      | True = "true"
      | False = "false"
      | StringTemplate
      | NoEscapeString
      | IntegerLiteral
      | HexadecimalLiteral
      | CharacterLiteral
      | FloatLiteral
      | Null = "null"
    }

    //TODO: Add [ExplicitSpaces]?
    syntax StringTemplate = "\"" StringTemplateElement* "\""
    {
      syntax StringTemplateElement
      {
        | RegularStringPart
        | EscapeSequence
        //| ShortTemplate = ShortTemplateEntryStart (SimpleName | "this")//TODO:!!!!!!
        | LongTemplate = "${" Expression "}"
      }
    }

    syntax IsRHS = Type;

    syntax Declaration
    {
      | Function
      | Property
      | Class
      | Object
    }

    syntax Statement
    {
      | Declaration
      | Expression
    }

    syntax CallSuffix
    {
      | TypeArguments? ValueArguments AnnotatedLambda
      | TypeArguments AnnotatedLambda
    }
    syntax AnnotatedLambda = ("@" AnnotationEntry)* LabelDefinition? FunctionLiteral;

    syntax TypeArguments = "<" (Type; ",")+ ">";

    syntax ValueArguments = "(" (SimpleName "=")? "*"? (Expression; ",")+ ")";

    syntax FunctionLiteral = "{" Parameters? Statements "}"
    {
      syntax Parameters = (Modifiers SimpleName; ",")+ "->";
    }

    syntax Statements = SEMI* (Statement; SEMI+)+ SEMI*;

    syntax ConstructorInvocation = UserType CallSuffix;
    syntax ArrayAccess   =  "[" (Expression; ",")+ "]";
    syntax ObjectLiteral = "object" (":" (DelegationSpecifier; ",")+)? ClassBody;
  }
}