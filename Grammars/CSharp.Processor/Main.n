using Nemerle.Imperative;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.IO;
using System.Console;
using SCG = System.Collections.Generic;

using Nitra;
using Nitra.Runtime;
using Nitra.Quote;

[assembly: QuotationRules("CSharp.Grammar", "SplicableCSharp",
  "CompilationUnit", "NamespaceMemberDeclaration", "TypeDeclaration", "TypeMemberDeclaration",
  "Statement", "EmbeddedStatement", "IndentedEmbeddedStatement", "Expression")]

module Program
{
  Main(fileMasks : array[string]) : int
  {
    def parserHost = ParserHost();
    def fileNames = FileSearcher.Search(fileMasks, SearchOption.TopDirectoryOnly);
    foreach (fileName in fileNames)
    {
      def text        = File.ReadAllText(fileName);
      def source      = SourceSnapshot(text, 0, fileName);
      def parseResult = CSharp.CompilationUnit(source, parserHost);
      def ast         = CSharpAst.CompilationUnit.Create(parseResult);
      def visitor     = CSharpVisitor();
      def newAst      = ast.Apply(visitor);
      def newFileName = Path.Combine(Path.GetDirectoryName(fileName), Path.GetFileNameWithoutExtension(fileName) + ".converted" + Path.GetExtension(fileName));
      def newText     = newAst.ToString();
      File.WriteAllText(newFileName, newText);
    }
    0
  }
}

internal sealed class CSharpVisitor : AstVisitor
{
  public override Visit(ast : Ast) : Ast
  {
    quote match (ast)
    {
      | <# Statement: $LocalVariableType(_) $Name(varName) = $(expr1).Where($Name(item) => $Expression(pred)); #> =>
        def result = quote <# Statement:
          {
            List<object> $Name(varName) = new List<object>();
            foreach (var $Name(item) in $Expression(expr1))
            {
              if ($BooleanExpression(pred))
              {
                $Identifier(varName).Add($Identifier(item));
              }
            }
          }
        #>;
        result.Apply(this)

      | <# Expression: 0 #> =>
        def result = quote <# Expression: 1 - 1 #>;
        result.Apply(this)

      | _ => ast.Apply(this)
    }
  }
}