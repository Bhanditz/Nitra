//using Nitra;

syntax module CSharp
{
  using Outline;
  using PrettyPrint;
  using StandardSpanClasses;
  using CStyleComments;
  using Whitespaces;

  literal Less                = "<";
  literal Greater             = ">";
  literal OpenBrace           = "(";
  literal CloseBrace          = ")";
  literal OpenBrace           = "{";
  literal CloseBrace          = "}";
  literal OpenSquareBrace     = "[";
  literal CloseSquareBrace    = "]";
  literal SingleQuote         = "\'";
  literal Quote               = "\"";
  literal Semicolon           = ";";
  literal Comma               = ",";
  literal Dot                 = ".";
  literal Colon               = ":";
  literal Question            = "?";
  literal At                  = "@";
  literal AliasSeparator      = "::";
  literal Assign              = "=";
  literal Prefix              = "\\u";
  literal DodDot              = "..";
  literal Op                  = "=>", "=", "*=", "/=", "%=", "+=", "-=", "<<=", ">>=", "&=", "^=", "|=", "??",
                                      "||", "&&", "|", "^", "&", "==", "!=", "<=", ">=", "<<", ">>", "+", "-", "!", "~", "++", "--", "*", "/", "%", "->";
  literal Backslash           = "\\";
  literal Epsilon             = "";

  span class Keyword = ['a'..'z', '_']['a'..'z', '_']+;

  braces "(", ")";
  braces "{", "}";
  braces "[", "]";

  alias Epsilon                 = "";

  [StartRule]
  syntax CompilationUnit = Bug001 ;

// Contextual keywords:
// "add" | "alias" | "ascending" | "assembly" | "by" | "descending" | "dynamic" | "equals" | "field" | "from" | "get" | "global"!!! | "group" |
// "into" | "join" | "let" | "method" | "module" | "on" | "orderby" | "param" | "partial" | "property" | "remove" | "select" | "set" | "type" |
// "typevar"!!! | "value" | "var" | "where" | "yield"

  regex KeywordToken
                =   "abstract" | "as"         | "base"      | "bool"      | "break"     | "byte"     | "case"   | "catch"       | "char"      | "checked"
                  | "class"    | "const"      | "continue"  | "decimal"   | "default"   | "delegate" | "do"     | "double"      | "else"      | "enum"
                  | "event"    | "explicit"   | "extern"    | "false"     | "finally"   | "fixed"    | "float"  | "for"         | "foreach"   | "goto"
                  | "if"       | "implicit"   | "in"        | "int"       | "interface" | "internal" | "is"     | "lock"        | "long"      | "namespace"
                  | "new"      | "null"       | "object"    | "operator"  | "out"       | "override" | "params" | "private"     | "protected" | "public"
                  | "readonly" | "ref"        | "return"    | "sbyte"     | "sealed"    | "short"    | "sizeof" | "stackalloc"  | "static"    | "string"
                  | "struct"   | "switch"     | "this"      | "throw"     | "true"      | "try"      | "typeof" | "uint"        | "ulong"     | "unchecked"
                  | "unsafe"   | "ushort"     | "using"     | "virtual"   | "void"      | "volatile" | "while"
                  | "__arglist";

  alias Name                = Identifier;
  alias QualifiedName       = QualifiedIdentifier;
  alias Char                = Any;
  alias Comma               = ","?;

  [Keyword]
  token Keyword = Name=KeywordToken !IdentifierPartCharacters;

  regex Any = ['\u0000'..'\uFFFF'];

  /////////////////////////////////////////////////////////
  // Spacing

  keyword regex ['A'..'Z', 'a'..'z', '_'..'_']+ rule S;

  // Spacing
  /////////////////////////////////////////////////////////

  /////////////////////////////////////////////////////////
  // Identifiers

  [Identifier]
  token Identifier = !Keyword At="@"? IdentifierBody;
  [ExplicitSpaces]
  syntax QualifiedIdentifier  = Identifier; // TODO: In C# spec. it's "namespace-or-type-name". Rename it!

  [ExplicitSpaces]
  syntax QualifiedIdentifierPartTypeArguments
  {
    | QualifiedIdentifierPartTypeArgumentList  = s "<" s TypeArguments ">" s;
    | QualifiedIdentifierPartOpenTypeArguments = s "<" s RankSeparator* ">" s;
  }


  regex LetterCharacter           = ['A'..'Z', 'a'..'z', 'а'..'я', 'А'..'Я', 'і'];//[Lu, Ll, Lt, Lm, Lo, Nl];//
  regex CombiningCharacter        = [Mn, Mc];
  regex DecimalDigitCharacter     = ['0'..'9'];
  regex ConnectingCharacter       = [Pc];
  regex FormattingCharacter       = [Cf];

  regex IdentifierStartCharacter  = LetterCharacter | "_";
  regex IdentifierPartCharacters  = LetterCharacter | DecimalDigitCharacter | ConnectingCharacter | CombiningCharacter | FormattingCharacter;
  regex IdentifierBody            = IdentifierStartCharacter IdentifierPartCharacters*;

  // Identifiers
  /////////////////////////////////////////////////////////


  ////////////////////////////////////////////////////////////////////////////////////
  // Types

  regex EnumBaseType      = "sbyte" | "byte" | "short" | "ushort" | "int" | "uint" | "long" | "ulong";
  regex IntegralType      = EnumBaseType | "char";
  regex FloatingPointType = "float" | "double";
  regex NumericType       = IntegralType | FloatingPointType | "decimal";
  regex PredefinedType    = NumericType | "void"  | "bool" | "string" | "dynamic" | "object";

  syntax TypeName
  {
    | PredefinedType
    | QualifiedName = !PredefinedType QualifiedIdentifier
  }

  regex Pointer = "*";
  syntax PointerSpecifiers = Pointer*;

  syntax RankSeparator = ",";
  syntax RankSpecifier = "[" RankSeparator* "]";

  syntax TypeSpecifier
  {
    | RankSpecifier;
    | PointerSpecifier = Pointer;
  }

  [ExplicitSpaces] syntax NullableSpecifier = "?" !"?"; // dont't collide with `??' operator

  syntax AnyNonArrayType             = QualifiedIdentifier;
  syntax AnyType                     = AnyNonArrayType TypeSpecifier*;
  syntax TypeArgument                = AnyType;
  syntax TypeArguments               = (TypeArgument; ","sm)+;

  //
  ////////////////////////////////////////////////////////////////////////////////////

  ////////////////////////////////////////////////////////////////////////////////////
  // Variables

  syntax VariableDeclarators = (VariableDeclarator; ","sm)+;
  syntax VariableDeclarator  = Name (sm "=" sm VariableInitializer)?;

  syntax VariableInitializer
  {
    | Array                 = "{"sm (VariableInitializer; ","sm)* sm Comma "}"; //TODO: replace with list with dangling separator
    | Expression;
  }

  //
  ////////////////////////////////////////////////////////////////////////////////////

  ////////////////////////////////////////////////////////////////////////////////////
  // Arguments

  regex ArgumentModfier = "ref" | "out";
  syntax ArgumentName    = Name ":" sm;
  syntax Argument        = ArgumentName? Modfier=(ArgumentModfier sm)? Expression;
  syntax ArgumentList    = (Argument; ","sm)*;

  //
  ////////////////////////////////////////////////////////////////////////////////////

  ////////////////////////////////////////////////////////////////////////////////////
  //  Lamdas

  regex  ExplicitAnonymousFunctionParameterModifier = "ref" | "out";
  syntax ExplicitAnonymousFunctionParameter         = ExplicitAnonymousFunctionParameterModifier? AnyType sm Name;
  syntax ExplicitAnonymousFunctionSignature         = "(" (ExplicitAnonymousFunctionParameter; ","sm)* ")";

  //
  ////////////////////////////////////////////////////////////////////////////////////

  ////////////////////////////////////////////////////////////////////////////////////
  //  Statement internals

  syntax Block    = nl "{" inl Statement* d "}" nl;

  syntax LocalVariableDeclaration = LocalVariableType sm VariableDeclarators; // local-variable-declaration

  syntax LocalVariableType
  {
    | Var = "var"
    | Type = !"var" AnyType;
  }

  syntax AnonymousFunctionBody
  {
    | Block;
    | Expression;
  }

  //  Statement internals
  ////////////////////////////////////////////////////////////////////////////////////

  ////////////////////////////////////////////////////////////////////////////////////
  //  Statements

  syntax Bug001 = "(" ;

  syntax Statement
  {
    | LocalVariable     = LocalVariableDeclaration ";"nl;
    | Bug001
  }

  syntax EmbeddedStatement
  {
  }

  //
  ////////////////////////////////////////////////////////////////////////////////////

  ////////////////////////////////////////////////////////////////////////////////////
  // Expressions

  syntax Expression
  {
    // B.1.8 Literals
    | "a";

    // Lambdas
    | Lambda_ExplicitParams1 =          ExplicitAnonymousFunctionSignature sm "=>" sm AnonymousFunctionBody;

    | Invocation             =  Expression ^ 150 "(" ArgumentList ")";

    // delegate-creation-expression || object-creation-expression || anonymous-object-creation-expression
    | NewObject_1            = "new"sm AnyNonArrayType "(" ArgumentList ")";             // delegate-creation-expression || object-creation-expression (1)
  }

  //
  ////////////////////////////////////////////////////////////////////////////////////
}
