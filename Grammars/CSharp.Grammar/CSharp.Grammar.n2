//using N2;

syntax module CSharp
{
  token field Less                = "<";
  token field Greater             = ">";
  token field OpenBrace           = "(";
  token field CloseBrace          = ")";
  token field OpenBrace           = "{";
  token field CloseBrace          = "}";
  token field OpenSquareBrace     = "[";
  token field CloseSquareBrace    = "]";
  token field SingleQuote         = "\'";
  token field Quote               = "\"";
  token field Semicolon           = ";";
  token field Comma               = ",";
  token field Dot                 = ".";
  token field Colon               = ":";
  token field Question            = "?";
  token field At                  = "@";
  token field AliasSeparator      = "::";
  token field Assign              = "=";
  token field Prefix              = "\\u";
  token field DodDot              = "..";
  token field Op                  = "=>", "=", "*=", "/=", "%=", "+=", "-=", "<<=", ">>=", "&=", "^=", "|=", "??",
                                    "||", "&&", "|", "^", "&", "==", "!=", "<=", ">=", "<<", ">>", "+", "-", "!", "~", "++", "--", "*", "/", "%", "->";
  token field Backslash           = "\\";
  token field Epsilon             = "";
  
  span class Char;
  span class String;
  span class Number;
  span class Keyword      = ['a'..'z']['a'..'z']+;
  span class Operator     = ['+', '-', '/', '*', '^', '?', ':']+;
  span class OpenBrace    = "(" | "{" | "[";
  span class CloseBrace   = ")" | "}" | "]";

  braces "(", ")";
  braces "{", "}";
  braces "[", "]";

  alias Attributes              = AttributeSection*;
  alias GlobalAttributes        = GlobalAttributeSection*;
  alias BooleanExpression       = Expression;
  alias Epsilon                 = "";

  [StartRule, ExplicitSpaces]
  syntax CompilationUnit = s ExternAliasDirective* UsingDirective* GlobalAttributes NamespaceMemberDeclaration* !Any;

// Contextual keywords:
// "add" | "alias" | "ascending" | "assembly" | "by" | "descending" | "dynamic" | "equals" | "field" | "from" | "get" | "global"!!! | "group" | 
// "into" | "join" | "let" | "method" | "module" | "on" | "orderby" | "param" | "partial" | "property" | "remove" | "select" | "set" | "type" |
// "typevar"!!! | "value" | "var" | "where" | "yield"

  token KeywordToken
                =   "abstract" | "as"         | "base"      | "bool"      | "break"     | "byte"     | "case"   | "catch"       | "char"      | "checked"
                  | "class"    | "const"      | "continue"  | "decimal"   | "default"   | "delegate" | "do"     | "double"      | "else"      | "enum"
                  | "event"    | "explicit"   | "extern"    | "false"     | "finally"   | "fixed"    | "float"  | "for"         | "foreach"   | "goto"
                  | "if"       | "implicit"   | "in"        | "int"       | "interface" | "internal" | "is"     | "lock"        | "long"      | "namespace"
                  | "new"      | "null"       | "object"    | "operator"  | "out"       | "override" | "params" | "private"     | "protected" | "public"
                  | "readonly" | "ref"        | "return"    | "sbyte"     | "sealed"    | "short"    | "sizeof" | "stackalloc"  | "static"    | "string"
                  | "struct"   | "switch"     | "this"      | "throw"     | "true"      | "try"      | "typeof" | "uint"        | "ulong"     | "unchecked"
                  | "unsafe"   | "ushort"     | "using"     | "virtual"   | "void"      | "volatile" | "while"
                  | "__arglist";

  [ExplicitSpaces] syntax Keyword = KeywordToken as Name !IdentifierPartCharacters;

  token Any = ['\u0000'..'\uFFFF'];

  /////////////////////////////////////////////////////////
  // Spacing

  token NewLineCharacter  = '\n' | '\r' | '\u2028' /*  line separator */ | '\u2029' /*  paragraph separator */;
  token NewLine  = "\r\n" | NewLineCharacter;
  token Whitespace = [Zs] | '\t' | '\v' | '\f' | '\uFEFF' | '\u0000';
  token Space = Whitespace | NewLine;
  token Spaces = Space+;

  [ExplicitSpaces] void s   = Spaces*;                     // optional spacer
  [ExplicitSpaces] void S   = !IdentifierPartCharacters s; // identifier break spacer

  marker i;     // increase a indent
  marker d;     // decrease a indent
  marker nl;    // optional spacer and plase for \n while pretty printing
  marker inl;   // i + nl
  marker sm;    // optional spacer and prefer to print space while pretty printing

  keyword regex ['A'..'Z', 'a'..'z', '_'..'_']+ rule S;

  alias Name                = Identifier;
  alias QualifiedName       = QualifiedIdentifier;
  alias Char                = Any;
  alias Comma               = ","?;
  
  // Spacing
  /////////////////////////////////////////////////////////

  /////////////////////////////////////////////////////////
  // Identifiers

  [ExplicitSpaces, SuppressTrailingSpaces] syntax Identifier           = !Keyword "@"? as At IdentifierBody s;
  syntax QualifiedIdentifier  = QualifiedAlias? (QualifiedIdentifierPart; ".")+; // TODO: In C# spec. it's "namespace-or-type-name". Rename it!
  syntax NamespaceName        = (Identifier; ".")+;

  syntax QualifiedIdentifierPartTypeArguments;

  syntax QualifiedIdentifierPartTypeArgumentList  is QualifiedIdentifierPartTypeArguments = "<" TypeArguments ">";
  syntax QualifiedIdentifierPartOpenTypeArguments is QualifiedIdentifierPartTypeArguments = "<" RankSeparator* ">";

  syntax QualifiedIdentifierPart = Identifier QualifiedIdentifierPartTypeArguments?;
  syntax QualifiedAlias = Identifier as Alias "::";

  
  // same as 'QualifiedIdentifierPart' but avoids capturing type arguments of method name
  syntax TypeMemberIdentifierPart  = Identifier (QualifiedIdentifierPartTypeArguments !"(")?;
  syntax TypeMemberIdentifier      = QualifiedAlias? (TypeMemberIdentifierPart; ".")+; // TODO: Maybe a bug. It's should end with Identifier

  token LetterCharacter           = [Lu, Ll, Lt, Lm, Lo, Nl];//['A'..'Z', 'a'..'z', 'а'..'я', 'А'..'Я', 'і'];//
  token CombiningCharacter        = [Mn, Mc];
  token DecimalDigitCharacter     = [Nd];
  token ConnectingCharacter       = [Pc];
  token FormattingCharacter       = [Cf];

  token IdentifierStartCharacter  = LetterCharacter | "_" | UnicodeEscapeSequence;
  token IdentifierPartCharacters  = LetterCharacter | DecimalDigitCharacter | ConnectingCharacter | CombiningCharacter | FormattingCharacter | UnicodeEscapeSequence;
  token IdentifierBody            = IdentifierStartCharacter IdentifierPartCharacters*;

  // Identifiers
  /////////////////////////////////////////////////////////
 
  /////////////////////////////////////////////////////////
  // Literals

  token DecimalDigit                        = ['0'..'9'];
  token HexDigit                            = ['0'..'9', 'a'..'f', 'A'..'F'];
  token IntegerTypeSuffixTerminal           = ('U' | 'u') ('l' | 'L')? | ('l' | 'L') ('U' | 'u')?;
  token IntegerTypeSuffix                   = IntegerTypeSuffixTerminal; // "UL" | "ul" | "uL" | "Ul" | "LU" | "lu" | "Lu" | "lU" | "U" | "u" | "L" | "l";
  token DecimalIntegerLiteral               = DecimalDigit+ IntegerTypeSuffix?;
  token HexadecimalIntegerLiteral           = ("0x" | "0X") HexDigit+ IntegerTypeSuffix?;
  token IntegerLiteral                      = HexadecimalIntegerLiteral | DecimalIntegerLiteral;

  token RealTypeSuffix                      = "F" | "f" | "D" | "d" | "M" | "m";
  token ExponentPart                        = ("E" | "e") ("-" | "+")? DecimalDigit+;
  token RealLiteral_1                       = DecimalDigit* "." DecimalDigit+ ExponentPart? RealTypeSuffix?;
  token RealLiteral_2                       = DecimalDigit+ ExponentPart RealTypeSuffix?;
  token RealLiteral_3                       = DecimalDigit+ RealTypeSuffix;
  token RealLiteral                         = RealLiteral_1 | RealLiteral_2 | RealLiteral_3;

  token UnicodeEscapeSequence_u             = "\\u" HexDigit HexDigit HexDigit HexDigit;
  token UnicodeEscapeSequence_U             = "\\U" HexDigit HexDigit HexDigit HexDigit HexDigit HexDigit HexDigit HexDigit;
  token UnicodeEscapeSequence               = UnicodeEscapeSequence_u | UnicodeEscapeSequence_U;
  token HexadecimalEscapeSequence           = "\\x" HexDigit HexDigit? HexDigit? HexDigit?;
  token SimpleEscapeSequence                = "\\'" | "\\\"" | "\\\\" | "\\0" | "\\a" | "\\b" | "\\f" | "\\n" | "\\r" | "\\t" | "\\v";
  token NotAllowedCharLiteralChar           = NewLineCharacter | "'" | "\\";
  [ExplicitSpaces] syntax SingleCharacter   = !NotAllowedCharLiteralChar Any;

  syntax Character;

  extend syntax Character
  {
    [ExplicitSpaces] SimpleEscapeSequenceChar      = SimpleEscapeSequence;
    [ExplicitSpaces] UnicodeEscapeSequenceChar     = UnicodeEscapeSequence;
    [ExplicitSpaces] HexadecimalEscapeSequenceChar = HexadecimalEscapeSequence;
    [ExplicitSpaces] SingleCharacterChar           = SingleCharacter;
  }

  [ExplicitSpaces] syntax CharacterLiteral = "'" Character "'";

  token NotAllowedRegularStringLiteralChar = NewLineCharacter | "\"" | "\\";

  syntax RegularStringLiteralPart;

  extend syntax RegularStringLiteralPart
  {
    [ExplicitSpaces] SimpleEscapeSequenceStrPart           = SimpleEscapeSequence;
    [ExplicitSpaces] UnicodeEscapeSequenceStrPart          = UnicodeEscapeSequence;
    [ExplicitSpaces] HexadecimalEscapeSequenceStrPart      = HexadecimalEscapeSequence;
    [ExplicitSpaces] RegularStringLiteralCharacterSequence = !NotAllowedRegularStringLiteralChar Any;
  }

  [ExplicitSpaces] syntax RegularStringLiteral = "\"" RegularStringLiteralPart* "\"";

  token DoubleQuote = "\"\"";

  syntax VerbatimStringLiteralPart;

  extend syntax VerbatimStringLiteralPart
  {
    [ExplicitSpaces] QuoteEscapeSequence                     = DoubleQuote;
    [ExplicitSpaces] VerbatimStringLiteralCharacterSequence  = (!"\"" Any)+;
  }

  [ExplicitSpaces] syntax VerbatimStringLiteral = "@\"" as OpenQuote VerbatimStringLiteralPart* "\"" as CloseQuote;
                                                     
  token BooleanLiteral = "true" | "false";

  // Literals
  /////////////////////////////////////////////////////////

  /////////////////////////////////////////////////////////
  // 

  syntax ExternAliasDirective = "extern" sm "alias" sm Name ";"nl;

  syntax UsingDirective;

  syntax UsingAliasDirective     is UsingDirective = "using"sm Name sm "=" sm QualifiedName ";" nl;
  syntax UsingNamespaceDirective is UsingDirective = "using"sm QualifiedName ";" nl;

  syntax NamespaceMemberDeclaration;

  extend syntax NamespaceMemberDeclaration
  {
    NamespaceDeclaration     = "namespace"sm NamespaceName nl "{" inl ExternAliasDirective* UsingDirective* NamespaceMemberDeclaration* d "}" ";"? nl;
    NamespaceTypeDeclaration = TypeDeclaration;
  }

  ////////////////////////////////////////////////////////////////////////////////////
  // TypeDeclaration

  syntax TypeBase = ":" (AnyType; ","sm)+;
  syntax Partial  = "partial"sm;

  // TODO: Make separate modifier lists for each kind of type declaration.

  syntax TypeDeclaration;

  extend syntax TypeDeclaration
  {
    ClassDeclaration     = Attributes Modifiers Partial? "class"     sm         Name TypeParameters? TypeBase? inl TypeParameterConstraintsClauses d TypeBody;
    StructDeclaration    = Attributes Modifiers Partial? "struct"    sm         Name TypeParameters? TypeBase? inl TypeParameterConstraintsClauses d TypeBody;
    InterfaceDeclaration = Attributes Modifiers Partial? "interface" sm         Name TypeParameters? TypeBase? inl TypeParameterConstraintsClauses d TypeBody;
    EnumDeclaration      = Attributes Modifiers          "enum"      sm         Name                 EnumBase? nl                                    EnumBody;
    DelegateDeclaration  = Attributes Modifiers          "delegate"  sm AnyType Name TypeParameters? "(" FormalParameters ")" TypeParameterConstraintsClauses? ";"nl;
  }

  syntax TypeBody = "{" inl TypeMemberDeclaration* d "}" ";"? nl;
  syntax EnumBody = "{" inl EnumMemberDeclarations d "}" ";"? nl;

  //
  ////////////////////////////////////////////////////////////////////////////////////

  ////////////////////////////////////////////////////////////////////////////////////
  // TypeMemberDeclarations

  syntax TypeMemberDeclaration;
  
  extend syntax TypeMemberDeclaration
  {
    NestedTypeDeclaration      = TypeDeclaration;
    MethodDeclaration          = Attributes Modifiers Partial? MethodHeader Body;
    PropertyDeclaration        = Attributes Modifiers AnyType sm TypeMemberIdentifier PropertyBody;
    FieldDeclaration           = Attributes Modifiers AnyType sm VariableDeclarators  ";" nl;
    ConstantDeclaration        = Attributes Modifiers "const"sm AnyType sm ConstantDeclarators ";" nl;
    ConstructorDeclaration     = Attributes Modifiers Name "(" FormalParameters ")" ConstructorInitializer? Body;
    EventDeclaration           = Attributes Modifiers "event"sm AnyType sm TypeMemberIdentifier nl "{" inl EventAccessorDeclarations d "}";
    SimpleEventDeclaration     = Attributes Modifiers "event"sm AnyType sm VariableDeclarators ";" nl;
    IndexerDeclaration         = Attributes Modifiers AnyType sm  (TypeMemberIdentifier ".")? "this" "[" FormalParameters "]" PropertyBody;
    DestructorDeclaration      = Attributes Modifiers "~" Name "(" FormalParameters ")" Body;
    FixedSizeBufferDeclaration = Attributes Modifiers "fixed"sm AnyType sm (FixedSizeBufferDeclarator; ","sm)+ ";" nl;
    OperatorDeclaration1       = Attributes Modifiers AnyType sm "operator"sm OverloadableOperator "(" FormalParameters ")" Body;
    OperatorDeclaration2       = Attributes Modifiers OperatorKind sm "operator" sm AnyType "(" FormalParameters ")" Body;
  }

  //
  ////////////////////////////////////////////////////////////////////////////////////

  ////////////////////////////////////////////////////////////////////////////////////
  // Members

  syntax Body;
  syntax BlockBody is Body = nl "{" inl Statement* d "}" ";"? nl;
  syntax EmptyBody is Body = ";" nl;

  syntax PropertyBody = nl "{" inl AccessorDeclarations d "}" nl;

  syntax FixedSizeBufferDeclarator = Identifier "[" ConstantExpression "]";

  // TODO: keyword choice detection will not work!
  token OverloadableOperator = "++" | "--" | "<<" | ">>" | "==" | "!=" | ">=" | "<=" | ">" | "<" | "true" | "false"
                              | "^" | "!" | "~" | "+" | "-" | "*" | "/" | "%" | "&" | "|";

  token OperatorKind = "implicit" | "explicit";

  syntax MethodHeader = AnyType sm TypeMemberIdentifier TypeParameters? "(" FormalParameters ")" TypeParameterConstraintsClauses?;

  syntax GetAccessorDeclaration = Attributes Modifiers "get"sm Body;
  syntax SetAccessorDeclaration = Attributes Modifiers "set"sm Body;

  syntax AccessorDeclarations;
  extend syntax AccessorDeclarations
  {
    GetSet = GetAccessorDeclaration SetAccessorDeclaration?;
    SetGet = SetAccessorDeclaration GetAccessorDeclaration?;
    None   = Epsilon; // TODO: Add error hendling here.
  }

  syntax ConstructorInitializer;

  extend syntax ConstructorInitializer
  {
    ConstructorInitializerThis = sm ":" sm "this" "(" ArgumentList ")";
    ConstructorInitializerBase = sm ":" sm "base" "(" ArgumentList ")";
  }

  syntax EnumBase               = sm ":" sm AnyType;
  syntax EnumMemberDeclaration  = Attributes Name (sm "=" sm ConstantExpression)?;
  syntax EnumMemberDeclarations = (EnumMemberDeclaration; ","nl)* Comma nl;

  syntax AddAccessorDeclaration    = Attributes "add" sm    Body;
  syntax RemoveAccessorDeclaration = Attributes "remove" sm Body;

  syntax EventAccessorDeclarations;

  extend syntax EventAccessorDeclarations
  {
    AddRemoveAccessors = AddAccessorDeclaration    RemoveAccessorDeclaration;
    RemoveAddAccessors = RemoveAccessorDeclaration AddAccessorDeclaration;
  }
  
  //
  ////////////////////////////////////////////////////////////////////////////////////

  ////////////////////////////////////////////////////////////////////////////////////
  // FormalParameters

  token ParameterModifier = "ref" | "out" | "this" | "params";
  syntax DefaultArgument  = "=" Expression;
  syntax FormalParameter  = Attributes (ParameterModifier sm)? AnyType sm Name DefaultArgument?; // TODO: Add "__arglist"
  syntax FormalParameters = (FormalParameter; ","sm)*;

  //
  ////////////////////////////////////////////////////////////////////////////////////


  ////////////////////////////////////////////////////////////////////////////////////
  // Modifiers

  syntax Modifiers = Modifier*;

  syntax Modifier;

  extend syntax Modifier
  {
    New       = "new"sm;
    Public    = "public"sm;
    Protected = "protected"sm;
    Internal  = "internal"sm;
    Private   = "private"sm;
    Virtual   = "virtual"sm;
    Volatile  = "volatile"sm;
    Static    = "static"sm;
    Readonly  = "readonly"sm;
    Sealed    = "sealed"sm;
    Override  = "override"sm;
    Abstract  = "abstract"sm;
    Extern    = "extern"sm;
    Unsafe    = "unsafe"sm;
    AsyncMod  = "async"sm; // C# 5
  }

  syntax Async = "async"sm; // C# 5

  //
  ////////////////////////////////////////////////////////////////////////////////////

  ////////////////////////////////////////////////////////////////////////////////////
  // Attributes

  syntax AttributeArguments = "(" ArgumentList ")";
  syntax Attribute          = QualifiedName AttributeArguments?;
  syntax AttributeList      = (Attribute; ","sm)* Comma;

  token GlobalAttributeTarget = "assembly" | "module";
  syntax GlobalAttributeTargetSpecifier = GlobalAttributeTarget ":";
  syntax GlobalAttributeSection         = "[" GlobalAttributeTargetSpecifier sm AttributeList "]"nl;

  token AttributeTarget = "field" | "event" | "method" | "param" | "property" | "return" | "type" | "typevar";

  syntax AttributeTargetSpecifier = AttributeTarget ":";
  syntax AttributeSection         = "[" AttributeTargetSpecifier? AttributeList "]"nl;

  //
  ////////////////////////////////////////////////////////////////////////////////////

  ////////////////////////////////////////////////////////////////////////////////////
  // Arguments

  token ArgumentModfier = "ref" | "out";
  [ExplicitSpaces] syntax ArgumentName    = Name ":" !":"; // avoid conflict with alias
  syntax Argument        = ArgumentName? (ArgumentModfier sm)? as Modfier Expression;
  syntax ArgumentList    = (Argument; ","sm)*;

  //
  ////////////////////////////////////////////////////////////////////////////////////

  ////////////////////////////////////////////////////////////////////////////////////
  // TypeParameters

  token InOrOut  = "in" | "out";
  syntax VarianceAnnotation  = InOrOut as Annotation sm;
  syntax TypeParameter       = Attributes VarianceAnnotation? Name;
  syntax TypeParameters   = "<" (TypeParameter; ","sm)+ ">";

  syntax TypeParameterConstraint;

  extend syntax TypeParameterConstraint
  {
    TypeParameterConstraint_ctor   = "new" "(" ")";
    TypeParameterConstraint_class  = "class";
    TypeParameterConstraint_struct = "struct";
    TypeParameterConstraint_base   = AnyType;
  }
  
  syntax TypeParameterConstraints        = (TypeParameterConstraint; ","sm)+;
  syntax TypeParameterConstraintsClause  =  "where"sm Name ":"sm TypeParameterConstraints nl;
  syntax TypeParameterConstraintsClauses = TypeParameterConstraintsClause*;

  //
  ////////////////////////////////////////////////////////////////////////////////////

  ////////////////////////////////////////////////////////////////////////////////////
  // Types

  token EnumBaseType      = "sbyte" | "byte" | "short" | "ushort" | "int" | "uint" | "long" | "ulong";
  token IntegralType      = EnumBaseType | "char";
  token FloatingPointType = "float" | "double";
  token NumericType       = IntegralType | FloatingPointType | "decimal";
  token PredefinedType    = NumericType | "void"  | "bool" | "string" | "dynamic" | "object";

  syntax TypeName;

  syntax PredefinedTypeName is TypeName = PredefinedType;
  syntax QualifiedTypeName  is TypeName = QualifiedName;

  token Pointer = "*";
  syntax PointerSpecifiers = Pointer*;

  syntax TypeSpecifier;
  syntax RankSpecifierTypeSpecifier is TypeSpecifier = "[" RankSeparator* "]";
  syntax PointerSpecifier           is TypeSpecifier = "*";

  syntax RankSpecifier = "[" RankSeparator* "]";

  syntax RankSeparator               = ",";
  [ExplicitSpaces] syntax NullableSpecifier = "?" !"?"; // dont't collide with `??' operator

  syntax AnyNonArrayType             = TypeName NullableSpecifier?;
  syntax AnyNonArrayTypeNullableHack = TypeName (NullableSpecifier !(Expression ":" Expression))? as NullableSpecifier; // don't collide with ternary op ? :
  syntax AnyType                     = AnyNonArrayType TypeSpecifier*;
  syntax AnyTypeNullableHack         = AnyNonArrayTypeNullableHack TypeSpecifier*;
  syntax TypeArgument                = AnyType;
  syntax TypeArguments               = (TypeArgument; ","sm)* Comma;

  syntax MayBeGenericArgumentList    = "<" TypeArguments ">" &GenericArgumentListFollow;

  token GenericArgumentListFollow    = '(' | ')' | ']' | '}' | ':' | ';' | ',' | '.' | '?' | "==" | "!=";

  syntax AnyTypeWithSpecifier;

  extend syntax AnyTypeWithSpecifier
  {
    AnyTypeWithSpecifier_1 = AnyNonArrayType TypeSpecifier+;
    AnyTypeWithSpecifier_2 = TypeName NullableSpecifier;      
  }

  //
  ////////////////////////////////////////////////////////////////////////////////////

  ////////////////////////////////////////////////////////////////////////////////////
  // Variables

  syntax VariableDeclarators = (VariableDeclarator; ","sm)+;
  syntax VariableDeclarator  = Name (sm "=" sm VariableInitializer)?;

  syntax VariableInitializer;

  extend syntax VariableInitializer
  {
    ArrayInitializer      = "{"sm (VariableInitializer; ","sm)* sm Comma "}"; //TODO: replace with list with dangling separator
    ExpressionInitializer = Expression;
    PropertyInitializer   = Name sm "=" sm ComplexInitializer;
  }

  //
  ////////////////////////////////////////////////////////////////////////////////////

  ////////////////////////////////////////////////////////////////////////////////////
  // Constants

  syntax ConstantDeclarator  = Name sm "=" sm ConstantExpression;
  syntax ConstantDeclarators = (ConstantDeclarator; ","sm)*;

  //
  ////////////////////////////////////////////////////////////////////////////////////

  ////////////////////////////////////////////////////////////////////////////////////
  //  Lamdas

  token  ExplicitAnonymousFunctionParameterModifier = "ref" | "out";
  syntax ExplicitAnonymousFunctionParameter         = ExplicitAnonymousFunctionParameterModifier? AnyType sm Name;
  syntax ExplicitAnonymousFunctionSignature         = "(" (ExplicitAnonymousFunctionParameter; ","sm)* ")";

  syntax ImplicitAnonymousFunctionSignature         = (Identifier; ","sm)* as Names;

  //
  ////////////////////////////////////////////////////////////////////////////////////

  ////////////////////////////////////////////////////////////////////////////////////
  //  object-creation-expression, array-creation-expression, delegate-creation-expression, anonymous-object-creation-expression 

  syntax ComplexInitializer = "{" (VariableInitializer; ","sm)* Comma "}";

  syntax MemberDeclarator;

  extend syntax MemberDeclarator
  {
    MemberDeclarator1  = QualifiedIdentifier;
    MemberDeclarator2  = Expression : 150 "." QualifiedIdentifier;
    MemberDeclarator3  = PredefinedType "." QualifiedIdentifier;
    MemberDeclarator4  = Name sm "=" sm Expression;
  }

  //
  ////////////////////////////////////////////////////////////////////////////////////

  ////////////////////////////////////////////////////////////////////////////////////
  //  Statement internals 

  syntax Block    = nl "{" inl Statement* d "}" nl;

  syntax IndentedEmbeddedStatement;

  extend syntax IndentedEmbeddedStatement
  {
    IndentedStatement = !"{" (inl EmbeddedStatement d); // not a block statment
    IndentedBlock     = &"{" Block;
  }

  syntax SwitchLabel; // switch-label

  extend syntax SwitchLabel
  {
    CaseSwitchLabel    = "case" sm ConstantExpression ":"nl;
    DefaultSwitchLabel = "default" ":"nl;
  }

  syntax SwitchSection = SwitchLabel+ i Statement+ d;

  syntax LocalVariableDeclaration = LocalVariableType sm VariableDeclarators; // local-variable-declaration

  syntax ForInitializer;

  extend syntax ForInitializer
  {
    ForInitializer1 = LocalVariableDeclaration;
    ForInitializer2 = (Expression; ","sm)+;
  }

  syntax ForIterator = (Expression; ","sm)+;

  syntax ForCondition            = Expression;

  syntax LocalVariableType;

  extend syntax LocalVariableType
  {
    LocalVariableType1 = "var";
    LocalVariableType2 = AnyType;
  }

  syntax CastPredicate;

  // It is pisec! :)
  extend syntax CastPredicate
  {
    [ExplicitSpaces] CastPredicate01 = '~';
    [ExplicitSpaces] CastPredicate02 = '!' !'=';
    [ExplicitSpaces] CastPredicate03 = '&' !'=';
    [ExplicitSpaces] CastPredicate04 = '&' !'&';
    [ExplicitSpaces] CastPredicate05 = '(';
    [ExplicitSpaces] CastPredicate06 = !("as"S) IdentifierStartCharacter;
    [ExplicitSpaces] CastPredicate07 = !("is"S) IdentifierStartCharacter;
    [ExplicitSpaces] CastPredicate08 = '@';
    [ExplicitSpaces] CastPredicate09 = IntegerLiteral;
    [ExplicitSpaces] CastPredicate10 = CharacterLiteral;
    [ExplicitSpaces] CastPredicate11 = BooleanLiteral S;
    [ExplicitSpaces] CastPredicate12 = RegularStringLiteral;
    [ExplicitSpaces] CastPredicate13 = "null" S;
    [ExplicitSpaces] CastPredicate14 = RealLiteral;
  }

  syntax ResourceAcquisition; // resource-acquisition

  extend syntax ResourceAcquisition
  {
    ResourceAcquisition1 = LocalVariableDeclaration /* &")" */;
    ResourceAcquisition2 = Expression;
  }

  syntax CatchExceptionFilter = "(" AnyType (sm Identifier)? as Name ")";
  syntax CatchClause   = "catch"   sm (CatchExceptionFilter sm)? Block;
  syntax FinallyClause = "finally" sm Block;

  syntax AnonymousFunctionBody;
  extend syntax AnonymousFunctionBody
  {
    AnonymousFunctionBodyBlock      = Block;
    AnonymousFunctionBodyExpression = Expression;
  }

  syntax ConstantExpression = Expression;

  //  Statement internals
  ////////////////////////////////////////////////////////////////////////////////////

  ////////////////////////////////////////////////////////////////////////////////////
  //  Linq Query

  // "from" ignored
  token LinqKeyword = "where" | "join" | "on" | "equals" | "into" | "let" | "orderby" | "ascending" | "descending" | "select" | "group" | "by";

  syntax LinqExpression  = !LinqKeyword Expression;
  syntax LinqType        = !LinqKeyword AnyType;
  syntax LinqName        = !LinqKeyword Name;

  syntax FromClause;

  extend syntax FromClause
  {
    FromClaus1 = "from" sm             LinqName sm "in" sm LinqExpression;
    FromClaus2 = "from" sm LinqType sm LinqName sm "in" sm LinqExpression;
  }

  token OrderingDirection = "ascending" | "descending";

  syntax SelectOrGroupClause;

  extend syntax SelectOrGroupClause
  {
    SelectClause = "select" sm LinqExpression;
    GroupClause  = "group"  sm LinqExpression sm "by" sm LinqExpression;
  }

  syntax QueryBody = QueryBodyClause* SelectOrGroupClause QueryContinuation?;

  syntax IntoClause = "into" sm LinqName;

  syntax Ordering = LinqExpression OrderingDirection?;

  syntax QueryBodyClause;

  extend syntax QueryBodyClause
  {
    FromClaus3    = FromClause; // from-clause
    LetClause     = "let" sm LinqName sm "=" sm LinqExpression; // let-clause
    WhereClause   = "where" sm BooleanExpression; // where-clause
    JoinClause1   = "join" sm             LinqName sm "in" sm LinqExpression sm "on" sm LinqExpression sm "equals" sm LinqExpression (sm IntoClause)?; // join-clause && join-into-clause
    JoinClause2   = "join" sm LinqType sm LinqName sm "in" sm LinqExpression sm "on" sm LinqExpression sm "equals" sm LinqExpression (sm IntoClause)?; // join-clause && join-into-clause
    OrderbyClause = "orderby" sm (Ordering; ","sm)+; // orderby-clause
  }

  syntax QueryContinuation = IntoClause sm QueryBody;

  syntax Await = "await";

  //  Linq Query
  ////////////////////////////////////////////////////////////////////////////////////

  ////////////////////////////////////////////////////////////////////////////////////
  //  Statements

  syntax Statement;
  
  extend syntax Statement
  {
    LabeledStatement                  = Name ":" sm Statement;
    LocalVariableDeclarationStatement = LocalVariableDeclaration ";"nl;
    LocalConstantDeclarationStatement = "const" sm AnyType ConstantDeclarators ";"nl;
    EmbeddedStatementStatement        = EmbeddedStatement;
  }

  syntax EmbeddedStatement;

  extend syntax EmbeddedStatement
  {
    EmptyStatement          = ";" nl;
    BlockStatement          = Block;
    ExpressionStatement     = Expression ";" nl;

    // selection-statement
    IfStatement             = "if" sm "(" BooleanExpression ")" IndentedEmbeddedStatement ("else" IndentedEmbeddedStatement)?;
    SwitchStatement         = "switch" sm "(" Expression ")"nl "{" inl SwitchSection* d "}" nl;
    // iteration-statement
    WhileStatement          = "while" sm "(" BooleanExpression ")" IndentedEmbeddedStatement;
    DoStatement             = "do" nl IndentedEmbeddedStatement "while" sm "(" BooleanExpression ")" ";" nl;
    ForStatement            = "for" "(" ForInitializer? ";"sm ForCondition? ";"sm ForIterator? ")" IndentedEmbeddedStatement;
    ForeachStatement        = "foreach" "(" LocalVariableType sm Name sm "in" sm Expression ")" IndentedEmbeddedStatement;

    CheckedStatement        = "checked"sm   Block; // checked-statement
    UncheckedStatement      = "unchecked"sm Block; // unchecked-statement
    
    LockStatement           = "lock"sm  "(" Expression ")"          IndentedEmbeddedStatement; // lock-statement
    UsingStatement          = "using"sm "(" ResourceAcquisition ")" IndentedEmbeddedStatement; // using-statement

    YieldStatement_return   = "yield" sm "return" sm Expression ";"nl; // try-statement
    YieldStatement_break    = "yield" sm "break"    ";"nl;             // try-statement

    TryStatement_catch    =  "try" sm Block CatchClause+ FinallyClause?;
    TryStatement_finally  =  "try" sm Block FinallyClause;


    // jump-statement
    BreakStatement        = "break"                                 ";" nl;
    ContinueStatement     = "continue"                              ";" nl;
    GotoStatement_case    = "goto"sm "case"sm   ConstantExpression  ";" nl;
    GotoStatement_default = "goto"sm "default"                      ";" nl;
    GotoStatement_id      = "goto"sm            Name                ";" nl;
    ReturnStatement       = "return"sm          Expression          ";" nl;
    ReturnStatementVoid   = "return"                                ";" nl;
    ThrowStatement        = "throw"sm           Expression?         ";" nl;

    // Unsafe
    UnsafeStatement       = "unsafe" Block; // unsafe
    FixedStatement        = "fixed" sm "(" LocalVariableType sm VariableDeclarators ")"nl EmbeddedStatement; // unsafe
  }

  //
  ////////////////////////////////////////////////////////////////////////////////////
 
  ////////////////////////////////////////////////////////////////////////////////////
  // Expressions

  syntax Expression;

  extend syntax Expression
  {
    // B.1.8 Literals
    BooleanLiteralExpression         = BooleanLiteral;
    RegularStringLiteralExpression   = RegularStringLiteral;
    VerbatimStringLiteralExpression  = VerbatimStringLiteral;
    RealLiteralExpression            = RealLiteral;
    IntegerLiteralExpression         = IntegerLiteral;
    CharacterLiteraExpression        = CharacterLiteral;
    NullLiteralExpression            = "null";
                                     
    QualifiedNameExpression          = QualifiedName; // simple-name || member-access
    ParenthesizedExpression          = "(" Expression ")"; // parenthesized-expression
    Cast1                            = "(" !Expression AnyType ")" Expression;
    Cast2                            = "(" AnyType ")" &CastPredicate Expression;
    ThisAccess                       = "this";
    BaseAccessMember                 = "base" "." QualifiedName;
    BaseAccessIndexer                = "base" "[" ArgumentList "]";
    //BaseError                        = "base" = Error;
                                     
    // Lambdas                       
    LambdaExpression_SingleParam1    =          Name                                        sm "=>" sm AnonymousFunctionBody;
    LambdaExpression_ExplicitParams1 =          ExplicitAnonymousFunctionSignature          sm "=>" sm AnonymousFunctionBody;
    LambdaExpression_ImplicitParams1 =          "(" ImplicitAnonymousFunctionSignature ")"  sm "=>" sm AnonymousFunctionBody;
    LambdaExpression_SingleParam2    = Async sm Name                                        sm "=>" sm AnonymousFunctionBody;
    LambdaExpression_ExplicitParams2 = Async sm ExplicitAnonymousFunctionSignature          sm "=>" sm AnonymousFunctionBody;
    LambdaExpression_ImplicitParams3 = Async sm "(" ImplicitAnonymousFunctionSignature ")"  sm "=>" sm AnonymousFunctionBody;
                                     
    QueryExpression                  = FromClause sm QueryBody;
                                     
    // Anonymous function            
    AnonymousFunction1               =       "delegate"sm ExplicitAnonymousFunctionSignature? nl "{" inl Statement* d "}";
    AnonymousFunction2               = Async "delegate"sm ExplicitAnonymousFunctionSignature? nl "{" inl Statement* d "}";
                                     
    StackallocInitializer            = "stackalloc"sm AnyType "[" Expression "]"; // unsafe

    // Group: Primary
    PointerMemberAccess        =  Expression "->" Expression                    { precedence 150; } // pointer-member-access
    MemberAccess1              =  Expression : 150 "." QualifiedName; // member-access 
    MemberAccess2              =  PredefinedType "." QualifiedName; // member-access 
    Invocation                 =  Expression : 150 "(" ArgumentList ")";
    IndexerAccess              =  Expression : 150 "[" ArgumentList "]";
    PostIncrement              =  Expression "++"                               { precedence 150; }
    PostDecrement              =  Expression "--"                               { precedence 150; }

    // delegate-creation-expression || object-creation-expression || anonymous-object-creation-expression
    NewObject_1                = "new"sm AnyNonArrayType "(" ArgumentList ")";             // delegate-creation-expression || object-creation-expression (1)
    NewObject_2                = "new"sm AnyNonArrayType "(" ArgumentList ")"sm ComplexInitializer;                          // object-creation-expression (2)
    NewObject_3                = "new"sm AnyNonArrayType sm ComplexInitializer;                                               // object-creation-expression (3)
    NewArray_1                 = "new"sm AnyNonArrayType PointerSpecifiers "[" (Expression; ","sm)+ "]" RankSpecifier*;                       // array-creation-expression  (1)
    NewArray_2                 = "new"sm AnyNonArrayType PointerSpecifiers "[" (Expression; ","sm)+ "]" RankSpecifier* sm ComplexInitializer; // array-creation-expression  (1)
    NewArray_3                 = "new"sm AnyNonArrayType RankSpecifier+ ComplexInitializer;                                   // array-creation-expression  (2)
    NewArray_4                 = "new"sm RankSpecifier ComplexInitializer;                                                    // array-creation-expression  (3)
    NewAnonymous               = "new"sm "{"sm (MemberDeclarator; ","sm)* Comma sm "}";                                            // anonymous-object-creation-expression

    TypeOf                     =  "typeof"     "(" AnyType    ")";
    Checked                    =  "checked"    "(" Expression ")";
    Unchecked                  =  "unchecked"  "(" Expression ")";
    Default                    =  "default"    "(" AnyType    ")";
    Sizeof                     =  "sizeof"     "(" AnyType    ")";


    // Group: Unary
    Identity              = "+"  Expression                                     { precedence 140; }
    Negation              = "-"  Expression                                     { precedence 140; }
    LogicalNegation       = "!"  Expression                                     { precedence 140; }
    BitwiseNegation       = "~"  Expression                                     { precedence 140; }
    PreIncrement          = "++" Expression                                     { precedence 140; }
    PreDecrement          = "--" Expression                                     { precedence 140; }
    AddressofExpression   = "&"  Expression                                     { precedence 140; } // unsafe
    //ExplicitlyCast      = (T) Expression                                      { precedence 140; }
    AwaitExpression       = Await sm Expression;//                                { precedence 140; } // C# 5

    PointerIndirection    = "*"  Expression                                     { precedence 135; } // pointer-indirection-expression

    // Group: Multiplicative
    Mul                   = Expression sm "*"  sm Expression                     { precedence 130; }
    Div                   = Expression sm "/"  sm Expression                     { precedence 130; }
    Remainder             = Expression sm "%"  sm Expression                     { precedence 130; }
    // Group: Additive
    Add                   = Expression sm "+"  sm Expression                     { precedence 120; }
    Sub                   = Expression sm "-"  sm Expression                     { precedence 120; }
    // Group: Shift
    ShiftLeft             = Expression sm "<<" sm Expression                     { precedence 110; }
    ShiftRight            = Expression sm ">>" sm Expression                     { precedence 110; }
    // Group: Relational and type testing
    LessThan              = Expression sm "<"  sm Expression                     { precedence 100; }
    GreaterThan           = Expression sm ">"  sm Expression                     { precedence 100; }
    LessThanOrEqual       = Expression sm "<=" sm Expression                     { precedence 100; }
    GreaterThanOrEqual    = Expression sm ">=" sm Expression                     { precedence 100; }
    Is                    = Expression : 100 sm "is" sm AnyTypeNullableHack;
    As                    = Expression : 100 sm "as" sm AnyTypeNullableHack;
    // Equality
    Equal                 = Expression sm "==" sm Expression                     { precedence  90; }
    NotEqual              = Expression sm "!=" sm Expression                     { precedence  90; }
    // Group: Logical AND                                                                      
    LogicalAnd            = Expression sm "&"  sm Expression                     { precedence  80; }
    // Group: Logical XOR                                                                      
    LogicalXor            = Expression sm "^"  sm Expression                     { precedence  70; }
    // Group: Logical OR                                                                       
    LogicalOr             = Expression sm "|"  sm Expression                     { precedence  60; }
    // Group: Conditional AND                                                                  
    ConditionalAnd        = Expression sm "&&" sm Expression                     { precedence  50; }
    // Group: Conditional OR                                                                   
    ConditionalOr         = Expression sm "||" sm Expression                     { precedence  40; }
    // Group: Null coalescing                                                                  
    NullCoalescing        = Expression sm "??" sm Expression                     { precedence  30; }
    // Group: Conditional                                                                      
    Conditional           = Expression : 21 sm "?" sm Expression sm ":" sm Expression; // right-associative
    // Group: Assignment or anonymous function                                                 
    Assignment            = Expression sm "="  sm Expression                     { precedence  10 right-associative; }
    MulAssignment         = Expression sm "*=" sm Expression                     { precedence  10 right-associative; }
    DivAssignment         = Expression sm "/=" sm Expression                     { precedence  10 right-associative; }
    RemainderAssignment   = Expression sm "%=" sm Expression                     { precedence  10 right-associative; }
    AddAssignment         = Expression sm "+=" sm Expression                     { precedence  10 right-associative; }
    SubAssignment         = Expression sm "-=" sm Expression                     { precedence  10 right-associative; }
    ShiftLeftAssignment   = Expression sm "<<="sm Expression                     { precedence  10 right-associative; }
    ShiftRightAssignment  = Expression sm ">>="sm Expression                     { precedence  10 right-associative; }
    AndAssignment         = Expression sm "&=" sm Expression                     { precedence  10 right-associative; }
    XorAssignment         = Expression sm "^=" sm Expression                     { precedence  10 right-associative; }
    OrAssignment          = Expression sm "|=" sm Expression                     { precedence  10 right-associative; }
  }

  //
  ////////////////////////////////////////////////////////////////////////////////////
}