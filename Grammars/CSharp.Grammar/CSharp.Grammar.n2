//using N2;

syntax module CSharp
{
  token field Less                = "<";
  token field Greater             = ">";
  token field OpenBrace           = "(";
  token field CloseBrace          = ")";
  token field OpenBrace           = "{";
  token field CloseBrace          = "}";
  token field OpenSquareBrace     = "[";
  token field CloseSquareBrace    = "]";
  token field SingleQuote         = "\'";
  token field Quote               = "\"";
  token field Semicolon           = ";";
  token field Comma               = ",";
  token field Dot                 = ".";
  token field Colon               = ":";
  token field Question            = "?";
  token field Assign              = "=";
  token field Prefix              = "\\u";
  token field DodDot              = "..";
  token field Op                  = "=", "*=", "/=", "%=", "+=", "-=", "<<=", ">>=", "&=", "^=", "|=",
                                    "||", "&&", "|", "^", "&", "==", "!=", "<=", ">=", "<<", ">>", "+", "-", "!", "~", "++", "--", "*", "/", "%";
  token field Backslash           = "\\";
  
  span class Char;
  span class String;
  span class Number;
  span class Keyword      = ['a'..'z']['a'..'z']+;
  span class Operator     = ['+', '-', '/', '*', '^', '?', ':']+;
  span class OpenBrace    = "(" | "{" | "[";
  span class CloseBrace   = ")" | "}" | "]";

  braces "(", ")";
  braces "{", "}";
  braces "[", "]";

  [StartRule]
  syntax CompilationUnit = s /*externAliasDirectives*/ UsingDirective* GlobalAttributes NamespaceMemberDeclaration* !Any;

  token KeywordToken
                =   "abstract" | "as"         | "base"      | "bool"      | "break"     | "byte"     | "case"   | "catch"       | "char"      | "checked"
                  | "class"    | "const"      | "continue"  | "decimal"   | "default"   | "delegate" | "do"     | "double"      | "else"      | "enum"
                  | "event"    | "explicit"   | "extern"    | "false"     | "finally"   | "fixed"    | "float"  | "for"         | "foreach"   | "goto"
                  | "if"       | "implicit"   | "in"        | "int"       | "interface" | "internal" | "is"     | "lock"        | "long"      | "namespace"
                  | "new"      | "null"       | "object"    | "operator"  | "out"       | "override" | "params" | "private"     | "protected" | "public"
                  | "readonly" | "ref"        | "return"    | "sbyte"     | "sealed"    | "short"    | "sizeof" | "stackalloc"  | "static"    | "string"
                  | "struct"   | "switch"     | "this"      | "throw"     | "true"      | "try"      | "typeof" | "uint"        | "ulong"     | "unchecked"
                  | "unsafe"   | "ushort"     | "using"     | "virtual"   | "void"      | "volatile" | "while";

  syntax Keyword = KeywordToken as Name !IdentifierPartCharacters;

  token Any = ['\u0000'..'\uFFFF'];
  token NewLineCharacter  = '\n'
                    | '\r'
                    | '\u2028'    /*  line separator       */
                    | '\u2029';   /*  paragraph separator  */
  token NewLine  = "\r\n" | NewLineCharacter;
  token Whitespace = [Zs]
              | '\t'
              | '\v'        /*  vertial tab          */
              | '\f';       /*  form feed            */
  token Space = Whitespace | NewLine;
	token Spaces = Space+;


  void s = Spaces*;                     // optional spacer
  void S = !IdentifierPartCharacters s; // identifier break spacer
  void i = ' '*;                        // increase a indent
  void d = ' '*;                        // decrease a indent
  void nl  = Spaces*;                   // optional spacer and plase for \n while pretty printing
  void inl = Spaces*;                   // i + nl
  void sm  = Spaces*;                   // optional spacer and prefer to print space while pretty printing


  token LetterCharacter           = ['A'..'Z', 'a'..'z', 'а'..'я', 'А'..'Я'];//[Lu, Ll, Lt, Lm, Lo, Nl];
  token CombiningCharacter        = [Mn, Mc];
  token DecimalDigitCharacter     = [Nd];
  token ConnectingCharacter       = [Pc];
  token FormattingCharacter       = [Cf];
  token IdentifierStartCharacter  = LetterCharacter | "_";
  token IdentifierPartCharacters  = LetterCharacter | DecimalDigitCharacter | ConnectingCharacter | CombiningCharacter | FormattingCharacter;
  token IdentifierBody            = IdentifierStartCharacter IdentifierPartCharacters*;
  token HexDigit                  = ['0'..'9', 'a'..'f', 'A'..'F'];
  token ReservedStringChar        = "\"" | "\\";
  token ReservedCharChar          = "\'" | "\\";

  alias Name          = Identifier;
  alias QualifiedName = QualifiedIdentifier;
  alias Char          = Any;
  alias Comma         = (","s)?;

  [SpanClass(String)]
  syntax StringLiteral                    = "\""  StringPart* "\"" s;

  syntax StringPart;

  syntax UnicodeEscapeSequenceStringPart  is StringPart = "\\u" HexDigit HexDigit HexDigit HexDigit;
  syntax EscapeSequenceStringPart         is StringPart = "\\"  Char;
  syntax SimpleStringPart                 is StringPart = Chars { alias Chars = (!ReservedStringChar Any)+; }

  [SpanClass(Char)]
  syntax CharLiteral                      = "\'"  CharPart "\'" s;
  
  syntax CharPart;

  syntax SimpleCharPart                   is CharPart = !ReservedCharChar Char;
  syntax UnicodeEscapeSequenceCharPart    is CharPart = "\\u" HexDigit HexDigit HexDigit HexDigit;
  syntax EscapeSequenceCharPart           is CharPart = "\\" Char;
  
  token Digits = ['0'..'9']+;

  [SpanClass(Number)]
  syntax Number                           = Digits s;
  syntax Identifier                       = !Keyword IdentifierBody s;
  syntax QualifiedIdentifier              = Names             { alias Names = (Identifier; "."s)+; }
  
 
  /////////////////////////////////////////////////////////

  syntax UsingDirective;

  syntax UsingAliasDirective     is UsingDirective = "using"S Name sm "=" sm QualifiedName ";" nl;
  syntax UsingNamespaceDirective is UsingDirective = "using"S QualifiedName ";" nl;

  syntax NamespaceMemberDeclaration;

  syntax NamespaceDeclaration     is NamespaceMemberDeclaration = "namespace"S QualifiedName nl "{" inl UsingDirective* NamespaceMemberDeclaration* d "}"s ";"? nl;
  syntax NamespaceTypeDeclaration is NamespaceMemberDeclaration = TypeDeclaration;

  ////////////////////////////////////////////////////////////////////////////////////
  // TypeDeclaration

  syntax TypeBase = ":"s (AnyType; ","s)+;

  syntax TypeDeclaration;

  syntax ClassDeclaration is TypeDeclaration = Attributes Modifiers "class" S Name TypeParameterList? TypeBase? TypeParameterConstraintsClauses?
                                               nl "{" inl TypeDeclaration* d "}"s ";"? nl;

  //
  ////////////////////////////////////////////////////////////////////////////////////

  ////////////////////////////////////////////////////////////////////////////////////
  // Modifiers

  syntax Modifiers = Modifier*;

  syntax Modifier;

  syntax New       is Modifier = "new"S;
  syntax Public    is Modifier = "public"S;
  syntax Protected is Modifier = "protected"S;
  syntax Internal  is Modifier = "internal"S;
  syntax Private   is Modifier = "private"S;
  syntax Partial   is Modifier = "partial"S;
  syntax Virtual   is Modifier = "virtual"S;
  syntax Volatile  is Modifier = "volatile"S;
  syntax Static    is Modifier = "static"S;
  syntax Readonly  is Modifier = "readonly"S;
  syntax Sealed    is Modifier = "sealed"S;
  syntax Override  is Modifier = "override"S;
  syntax Abstract  is Modifier = "abstract"S;
  syntax Extern    is Modifier = "extern"S;
  syntax Unsafe    is Modifier = "unsafe"S;

  //
  ////////////////////////////////////////////////////////////////////////////////////

  ////////////////////////////////////////////////////////////////////////////////////
  // Attributes

  syntax AttributeArguments = "("s ArgumentList ")"s;
  syntax Attribute          = QualifiedName AttributeArguments?;
  syntax AttributeList      = (Attribute; ","s)* Comma;

  token GlobalAttributeTarget = "assembly" | "module";
  syntax GlobalAttributeTargetSpecifier = GlobalAttributeTarget ":"s;
  syntax GlobalAttributeSection         = "["s GlobalAttributeTargetSpecifier AttributeList "]"nl;
  syntax GlobalAttributes               = GlobalAttributeSection*;

  token AttributeTarget = "field" | "event" | "method" | "param" | "property" | "return" | "type";

  syntax AttributeTargetSpecifier = AttributeTarget ":"s;
  syntax AttributeSection         = "["s AttributeTargetSpecifier? AttributeList "]"nl;
  syntax Attributes               = AttributeSection+;

  //
  ////////////////////////////////////////////////////////////////////////////////////

  ////////////////////////////////////////////////////////////////////////////////////
  // Arguments

  token ArgumentModfier = "ref" | "out";
  syntax ArgumentName    = Name ":" !":" s; // avoid conflict with alias
  syntax Argument        = ArgumentName? (ArgumentModfier S)? as Modfier Expression;
  syntax ArgumentList    = (Argument; ","s)*;

  //
  ////////////////////////////////////////////////////////////////////////////////////

  ////////////////////////////////////////////////////////////////////////////////////
  // Arguments

  syntax Expression;
  
  syntax RefExpression is Expression = QualifiedName;

  //
  ////////////////////////////////////////////////////////////////////////////////////

  ////////////////////////////////////////////////////////////////////////////////////
  // TypeParameters

  token InOrOut  = "in" | "out";
  syntax VarianceAnnotation  = InOrOut as Annotation S;
  syntax TypeParameter       = Attributes? VarianceAnnotation? Name;
  syntax TypeParameterList   = "<"s (TypeParameter; ","s)+ ">"s;

  syntax TypeParameterConstraint;

  syntax TypeParameterConstraint_ctor   is TypeParameterConstraint = "new"S "("s ")"s;
  syntax TypeParameterConstraint_class  is TypeParameterConstraint = "class"S;
  syntax TypeParameterConstraint_struct is TypeParameterConstraint = "struct"S;
  syntax TypeParameterConstraint_base   is TypeParameterConstraint = AnyType;
  
  syntax TypeParameterConstraints        = (TypeParameterConstraint; ","s)+;
  syntax TypeParameterConstraintsClause  = "where"S Name ":"s TypeParameterConstraints;
  syntax TypeParameterConstraintsClauses = TypeParameterConstraintsClause+;

  //
  ////////////////////////////////////////////////////////////////////////////////////

  ////////////////////////////////////////////////////////////////////////////////////
  // Types

  token PredefinedType = "sbyte"  | "byte"    | "short"   | "ushort"  | "int"     | "uint"
                       | "long"   | "ulong"   | "char"    | "decimal" | "void"    | "bool"
                       | "string" | "dynamic" | "object"  | "float"   | "double";

  syntax TypeName;
  
  syntax PredefinedTypeName is TypeName = PredefinedType;
  syntax QualifiedTypeName  is TypeName = QualifiedName;

  syntax TypeSpecifier;
  syntax RankSpecifier    is TypeSpecifier = "["s RankSeparator* "]"s;
  syntax PointerSpecifier is TypeSpecifier = "*"s;

  syntax RankSeparator               = "," s;
  syntax NullableSpecifier           = "?" !"?" s; // dont't collide with `??' operator

  syntax AnyNonArrayType             = TypeName NullableSpecifier?;
  syntax AnyNonArrayTypeNullableHack = TypeName (NullableSpecifier !(Expression ":"s Expression))? as NullableSpecifier; // don't collide with ternary op ? :
  syntax AnyType                     = AnyNonArrayType TypeSpecifier*;
  syntax AnyTypeNullableHack         = AnyNonArrayTypeNullableHack TypeSpecifier*;
  syntax TypeArgument                = AnyType;
  syntax TypeArguments               = (TypeArgument; ","s)* Comma;

  syntax MayBeGenericArgumentList    = "<"s TypeArguments ">"s &GenericArgumentListFollow;

  token GenericArgumentListFollow    = '(' | ')' | ']' | '}' | ':' | ';' | ',' | '.' | '?' | "==" | "!=";

  syntax AnyTypeWithSpecifier;
  syntax AnyTypeWithSpecifier_1 is AnyTypeWithSpecifier = AnyNonArrayType TypeSpecifier+;
  syntax AnyTypeWithSpecifier_2 is AnyTypeWithSpecifier = TypeName NullableSpecifier;      

  //
  ////////////////////////////////////////////////////////////////////////////////////

}