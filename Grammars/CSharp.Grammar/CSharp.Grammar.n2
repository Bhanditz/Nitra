//using N2;

syntax module CSharp
{
  token field Less                = "<";
  token field Greater             = ">";
  token field OpenBrace           = "(";
  token field CloseBrace          = ")";
  token field OpenBrace           = "{";
  token field CloseBrace          = "}";
  token field OpenSquareBrace     = "[";
  token field CloseSquareBrace    = "]";
  token field SingleQuote         = "\'";
  token field Quote               = "\"";
  token field Semicolon           = ";";
  token field Comma               = ",";
  token field Dot                 = ".";
  token field Colon               = ":";
  token field Question            = "?";
  token field At                  = "@";
  token field AliasSeparator      = "::";
  token field Assign              = "=";
  token field Prefix              = "\\u";
  token field DodDot              = "..";
  token field Op                  = "=>", "=", "*=", "/=", "%=", "+=", "-=", "<<=", ">>=", "&=", "^=", "|=", "??",
                                    "||", "&&", "|", "^", "&", "==", "!=", "<=", ">=", "<<", ">>", "+", "-", "!", "~", "++", "--", "*", "/", "%";
  token field Backslash           = "\\";
  
  span class Char;
  span class String;
  span class Number;
  span class Keyword      = ['a'..'z']['a'..'z']+;
  span class Operator     = ['+', '-', '/', '*', '^', '?', ':']+;
  span class OpenBrace    = "(" | "{" | "[";
  span class CloseBrace   = ")" | "}" | "]";

  braces "(", ")";
  braces "{", "}";
  braces "[", "]";

  alias  Attributes               = AttributeSection*;
  alias  GlobalAttributes         = GlobalAttributeSection*;

  [StartRule]
  syntax CompilationUnit = s /*externAliasDirectives*/ UsingDirective* GlobalAttributes NamespaceMemberDeclaration* !Any;

  token KeywordToken
                =   "abstract" | "as"         | "base"      | "bool"      | "break"     | "byte"     | "case"   | "catch"       | "char"      | "checked"
                  | "class"    | "const"      | "continue"  | "decimal"   | "default"   | "delegate" | "do"     | "double"      | "else"      | "enum"
                  | "event"    | "explicit"   | "extern"    | "false"     | "finally"   | "fixed"    | "float"  | "for"         | "foreach"   | "goto"
                  | "if"       | "implicit"   | "in"        | "int"       | "interface" | "internal" | "is"     | "lock"        | "long"      | "namespace"
                  | "new"      | "null"       | "object"    | "operator"  | "out"       | "override" | "params" | "private"     | "protected" | "public"
                  | "readonly" | "ref"        | "return"    | "sbyte"     | "sealed"    | "short"    | "sizeof" | "stackalloc"  | "static"    | "string"
                  | "struct"   | "switch"     | "this"      | "throw"     | "true"      | "try"      | "typeof" | "uint"        | "ulong"     | "unchecked"
                  | "unsafe"   | "ushort"     | "using"     | "virtual"   | "void"      | "volatile" | "while";

  syntax Keyword = KeywordToken as Name !IdentifierPartCharacters;

  token Any = ['\u0000'..'\uFFFF'];
  token NewLineCharacter  = '\n'
                    | '\r'
                    | '\u2028'    /*  line separator       */
                    | '\u2029';   /*  paragraph separator  */
  token NewLine  = "\r\n" | NewLineCharacter;
  token Whitespace = [Zs]
              | '\t'
              | '\v'        /*  vertial tab          */
              | '\f';       /*  form feed            */
  token Space = Whitespace | NewLine;
	token Spaces = Space+;


  void s = Spaces*;                     // optional spacer
  void S = !IdentifierPartCharacters s; // identifier break spacer
  void SM = !IdentifierPartCharacters s; // identifier break spacer
  void i = ' '*;                        // increase a indent
  void d = ' '*;                        // decrease a indent
  void nl  = Spaces*;                   // optional spacer and plase for \n while pretty printing
  void inl = Spaces*;                   // i + nl
  void sm  = Spaces*;                   // optional spacer and prefer to print space while pretty printing


  token LetterCharacter           = ['A'..'Z', 'a'..'z', 'а'..'я', 'А'..'Я'];//[Lu, Ll, Lt, Lm, Lo, Nl];
  token CombiningCharacter        = [Mn, Mc];
  token DecimalDigitCharacter     = [Nd];
  token ConnectingCharacter       = [Pc];
  token FormattingCharacter       = [Cf];
  token IdentifierStartCharacter  = LetterCharacter | "_";
  token IdentifierPartCharacters  = LetterCharacter | DecimalDigitCharacter | ConnectingCharacter | CombiningCharacter | FormattingCharacter;
  token IdentifierBody            = IdentifierStartCharacter IdentifierPartCharacters*;
  token HexDigit                  = ['0'..'9', 'a'..'f', 'A'..'F'];
  token ReservedStringChar        = "\"" | "\\";
  token ReservedCharChar          = "\'" | "\\";

  alias Name                = Identifier;
  alias QualifiedName       = QualifiedIdentifier;
  alias Char                = Any;
  alias Comma               = (","s)?;
  
  [SpanClass(String)]
  syntax StringLiteral                    = "\""  StringPart* "\"" s;

  syntax StringPart;

  syntax UnicodeEscapeSequenceStringPart  is StringPart = "\\u" HexDigit HexDigit HexDigit HexDigit;
  syntax EscapeSequenceStringPart         is StringPart = "\\"  Char;
  syntax SimpleStringPart                 is StringPart = Chars { alias Chars = (!ReservedStringChar Any)+; }

  [SpanClass(Char)]
  syntax CharLiteral                      = "\'"  CharPart "\'" s;
  
  syntax CharPart;

  syntax SimpleCharPart                   is CharPart = !ReservedCharChar Char;
  syntax UnicodeEscapeSequenceCharPart    is CharPart = "\\u" HexDigit HexDigit HexDigit HexDigit;
  syntax EscapeSequenceCharPart           is CharPart = "\\" Char;
  
  token Digits = ['0'..'9']+;

  [SpanClass(Number)]
  syntax Number                           = Digits s;
  syntax Identifier                       = !Keyword "@"? as At IdentifierBody s;
  
  syntax QualifiedIdentifierPartTypeArguments;

  syntax QualifiedIdentifierPartTypeArgumentList  is QualifiedIdentifierPartTypeArguments = "<"s TypeArguments ">"s;
  syntax QualifiedIdentifierPartOpenTypeArguments is QualifiedIdentifierPartTypeArguments = "<"s RankSeparator* ">"s;

  syntax QualifiedIdentifierPart = Identifier QualifiedIdentifierPartTypeArguments?;
  // TODO: In C# spec. it's "namespace-or-type-name". Rename it!
  syntax QualifiedAlias = Identifier as Alias "::"s;
  syntax QualifiedIdentifier     = QualifiedAlias? (QualifiedIdentifierPart; "."s)+;

  syntax NamespaceName = (Identifier; "."s)+;
  
  // same as 'QualifiedIdentifierPart' but avoids capturing type arguments of method name
  syntax TypeMemberIdentifierPart  = Identifier (QualifiedIdentifierPartTypeArguments !"(")?;
  syntax TypeMemberIdentifier      = QualifiedAlias? (TypeMemberIdentifierPart; "."s)+;

 
  /////////////////////////////////////////////////////////
  // 

  syntax UsingDirective;

  syntax UsingAliasDirective     is UsingDirective = "using"SM Name sm "=" sm QualifiedName ";" nl;
  syntax UsingNamespaceDirective is UsingDirective = "using"SM QualifiedName ";" nl;

  syntax NamespaceMemberDeclaration;

  syntax NamespaceDeclaration     is NamespaceMemberDeclaration = "namespace"SM NamespaceName nl "{" inl UsingDirective* NamespaceMemberDeclaration* d "}"s ";"? nl;
  syntax NamespaceTypeDeclaration is NamespaceMemberDeclaration = TypeDeclaration;

  ////////////////////////////////////////////////////////////////////////////////////
  // TypeDeclaration

  syntax TypeBase = ":"s (AnyType; ","sm)+;
  syntax Partial = "partial"SM;

  // TODO: Make separate modifier lists for each kind of type declaration.

  syntax TypeDeclaration;

  extend syntax TypeDeclaration
  {
    ClassDeclaration     = Attributes Modifiers Partial? "class"SM     Name TypeParameterList? TypeBase? inl TypeParameterConstraintsClauses d TypeBody;
    StructDeclaration    = Attributes Modifiers Partial? "struct"SM    Name TypeParameterList? TypeBase? inl TypeParameterConstraintsClauses d TypeBody;
    InterfaceDeclaration = Attributes Modifiers          "interface"SM Name TypeParameterList? TypeBase? inl TypeParameterConstraintsClauses d TypeBody;
    EnumDeclaration      = Attributes Modifiers          "enum"SM      Name                    EnumBase? nl                                    EnumBody;
  }

  syntax TypeBody = "{" inl TypeMemberDeclaration* d "}"s ";"? nl;
  syntax EnumBody = "{" inl EnumMemberDeclarations d "}"s ";"? nl;

  //
  ////////////////////////////////////////////////////////////////////////////////////

  ////////////////////////////////////////////////////////////////////////////////////
  // TypeMemberDeclarations

  syntax TypeMemberDeclaration;
  
  extend syntax TypeMemberDeclaration
  {
    NestedTypeDeclaration      = TypeDeclaration;
    MethodDeclaration          = MethodHeader Body;
    PropertyDeclaration        = Attributes Modifiers AnyType sm TypeMemberIdentifier PropertyBody;
    FieldDeclaration           = Attributes Modifiers AnyType sm VariableDeclarators  ";" nl;
    ConstantDeclaration        = "const"SM AnyType sm ConstantDeclarators ";" nl;
    ConstructorDeclaration     = Attributes Modifiers Name "("s FormalParameters ")"s ConstructorInitializer? Body;
    EventDeclaration           = Attributes Modifiers "event"S AnyType sm TypeMemberIdentifier nl "{"s inl EventAccessorDeclarations d "}"s;
    SimpleEventDeclaration     = Attributes Modifiers "event"S AnyType sm VariableDeclarators ";" nl;
    OperatorDeclaration        = Attributes Modifiers AnyType sm "operator"SM OverloadableOperator S "("s FormalParameters ")"s Body;
    IndexerDeclaration         = Attributes Modifiers AnyType sm  (TypeMemberIdentifier "."s)? "this"S "["s FormalParameters "]"s PropertyBody;
    DestructorDeclaration      = Attributes Modifiers "~"s Name "("s FormalParameters ")"s Body;
    FixedSizeBufferDeclaration = Attributes Modifiers "fixed"SM AnyType sm (FixedSizeBufferDeclarator; ","sm)+ ";" nl;
  }

  //
  ////////////////////////////////////////////////////////////////////////////////////

  ////////////////////////////////////////////////////////////////////////////////////
  // Members

  syntax Body;
  syntax BlockBody is Body = nl "{" inl Statement* d "}"s ";"? nl;
  syntax EmptyBody is Body = ";" nl;

  syntax PropertyBody = nl "{" inl AccessorDeclarations d "}" nl;

  syntax FixedSizeBufferDeclarator = Identifier "["s ConstantExpression "]"s;

  token OverloadableOperator = "++" | "--" | "<<" | ">>" | "==" | "!=" | ">=" | "<=" | ">" | "<" | "true" | "false"
                              | "^" | "!" | "~" | "+" | "-" | "*" | "/" | "%" | "&" | "|";


  syntax MethodHeader = Attributes Modifiers AnyType sm TypeMemberIdentifier TypeParameterList? "("s FormalParameters ")"s TypeParameterConstraintsClauses?;

  syntax GetAccessorDeclaration = Attributes Modifiers "get"S Body;
  syntax SetAccessorDeclaration = Attributes Modifiers "set"S Body;

  syntax AccessorDeclarations;
  extend syntax AccessorDeclarations
  {
    GetSet = GetAccessorDeclaration SetAccessorDeclaration?;
    SetGet = SetAccessorDeclaration GetAccessorDeclaration?;
  }

  syntax ConstructorInitializer;

  extend syntax ConstructorInitializer
  {
    ConstructorInitializerThis = sm ":" sm "this"S "("s ArgumentList ")"s;
    ConstructorInitializerBase = sm ":" sm "base"S "("s ArgumentList ")"s;
  }

  syntax EnumBase               = sm ":" sm AnyType;
  syntax EnumMemberDeclaration  = Attributes Name (sm "=" sm ConstantExpression)?;
  syntax EnumMemberDeclarations = (EnumMemberDeclaration; ","nl)* Comma nl;

  syntax AddAccessorDeclaration    = Attributes "add"S    Body;
  syntax RemoveAccessorDeclaration = Attributes "remove"S Body;

  syntax EventAccessorDeclarations;

  extend syntax EventAccessorDeclarations
  {
    AddRemoveAccessors = AddAccessorDeclaration    RemoveAccessorDeclaration;
    RemoveAddAccessors = RemoveAccessorDeclaration AddAccessorDeclaration;
  }
  
  //
  ////////////////////////////////////////////////////////////////////////////////////

  ////////////////////////////////////////////////////////////////////////////////////
  // FormalParameters

  token ParameterModifier = "ref" | "out" | "this" | "params";
  syntax DefaultArgument  = "="s Expression;
  syntax FormalParameter  = Attributes (ParameterModifier SM)? AnyType sm Name DefaultArgument?;
  syntax FormalParameters = (FormalParameter; ","sm)*;

  //
  ////////////////////////////////////////////////////////////////////////////////////


  ////////////////////////////////////////////////////////////////////////////////////
  // Modifiers

  syntax Modifiers = Modifier*;

  syntax Modifier;

  extend syntax Modifier
  {
    New       = "new"SM;
    Public    = "public"SM;
    Protected = "protected"SM;
    Internal  = "internal"SM;
    Private   = "private"SM;
    Virtual   = "virtual"SM;
    Volatile  = "volatile"SM;
    Static    = "static"SM;
    Readonly  = "readonly"SM;
    Sealed    = "sealed"SM;
    Override  = "override"SM;
    Abstract  = "abstract"SM;
    Extern    = "extern"SM;
    Unsafe    = "unsafe"SM;
  }

  //
  ////////////////////////////////////////////////////////////////////////////////////

  ////////////////////////////////////////////////////////////////////////////////////
  // Attributes

  syntax AttributeArguments = "("s ArgumentList ")"s;
  syntax Attribute          = QualifiedName AttributeArguments?;
  syntax AttributeList      = (Attribute; ","sm)* Comma;

  token GlobalAttributeTarget = "assembly" | "module";
  syntax GlobalAttributeTargetSpecifier = GlobalAttributeTarget ":"s;
  syntax GlobalAttributeSection         = "["s GlobalAttributeTargetSpecifier AttributeList "]"nl;

  token AttributeTarget = "field" | "event" | "method" | "param" | "property" | "return" | "type";

  syntax AttributeTargetSpecifier = AttributeTarget ":"s;
  syntax AttributeSection         = "["s AttributeTargetSpecifier? AttributeList "]"nl;

  //
  ////////////////////////////////////////////////////////////////////////////////////

  ////////////////////////////////////////////////////////////////////////////////////
  // Arguments

  token ArgumentModfier = "ref" | "out";
  syntax ArgumentName    = Name ":" !":" s; // avoid conflict with alias
  syntax Argument        = ArgumentName? (ArgumentModfier SM)? as Modfier Expression;
  syntax ArgumentList    = (Argument; ","sm)*;

  //
  ////////////////////////////////////////////////////////////////////////////////////

  ////////////////////////////////////////////////////////////////////////////////////
  // TypeParameters

  token InOrOut  = "in" | "out";
  syntax VarianceAnnotation  = InOrOut as Annotation SM;
  syntax TypeParameter       = Attributes VarianceAnnotation? Name;
  syntax TypeParameterList   = "<"s (TypeParameter; ","sm)+ ">"s;

  syntax TypeParameterConstraint;

  extend syntax TypeParameterConstraint
  {
    TypeParameterConstraint_ctor   = "new"S "("s ")"s;
    TypeParameterConstraint_class  = "class"S;
    TypeParameterConstraint_struct = "struct"S;
    TypeParameterConstraint_base   = AnyType;
  }
  
  syntax TypeParameterConstraints        = (TypeParameterConstraint; ","sm)+;
  syntax TypeParameterConstraintsClause  =  "where"SM Name ":"sm TypeParameterConstraints nl;
  syntax TypeParameterConstraintsClauses = TypeParameterConstraintsClause*;

  //
  ////////////////////////////////////////////////////////////////////////////////////

  ////////////////////////////////////////////////////////////////////////////////////
  // Types

  token EnumBaseType      = "sbyte" | "byte" | "short" | "ushort" | "int" | "uint" | "long" | "ulong";
  token IntegralType      = EnumBaseType | "char";
  token FloatingPointType = "float" | "double";
  token NumericType       = IntegralType | FloatingPointType | "decimal";
  token PredefinedType    = NumericType | "void"  | "bool" | "string" | "dynamic" | "object";

  syntax TypeName;
  
  syntax PredefinedTypeName is TypeName = PredefinedType S;
  syntax QualifiedTypeName  is TypeName = QualifiedName;

  syntax TypeSpecifier;
  syntax RankSpecifier    is TypeSpecifier = "["s RankSeparator* "]"s;
  syntax PointerSpecifier is TypeSpecifier = "*"s;

  syntax RankSeparator               = "," s;
  syntax NullableSpecifier           = "?" !"?" s; // dont't collide with `??' operator

  syntax AnyNonArrayType             = TypeName NullableSpecifier?;
  syntax AnyNonArrayTypeNullableHack = TypeName (NullableSpecifier !(Expression ":"s Expression))? as NullableSpecifier; // don't collide with ternary op ? :
  syntax AnyType                     = AnyNonArrayType TypeSpecifier*;
  syntax AnyTypeNullableHack         = AnyNonArrayTypeNullableHack TypeSpecifier*;
  syntax TypeArgument                = AnyType;
  syntax TypeArguments               = (TypeArgument; ","sm)* Comma;

  syntax MayBeGenericArgumentList    = "<"s TypeArguments ">"s &GenericArgumentListFollow;

  token GenericArgumentListFollow    = '(' | ')' | ']' | '}' | ':' | ';' | ',' | '.' | '?' | "==" | "!=";

  syntax AnyTypeWithSpecifier;

  extend syntax AnyTypeWithSpecifier
  {
    AnyTypeWithSpecifier_1 = AnyNonArrayType TypeSpecifier+;
    AnyTypeWithSpecifier_2 = TypeName NullableSpecifier;      
  }

  //
  ////////////////////////////////////////////////////////////////////////////////////

  ////////////////////////////////////////////////////////////////////////////////////
  // Variables

  syntax VariableDeclarators = (VariableDeclarator; ","sm)+;
  syntax VariableDeclarator  = Name (sm "=" sm VariableInitializer)?;

  syntax VariableInitializer;

  extend syntax VariableInitializer
  {
    ArrayInitializer      = "{"sm (VariableInitializer; ","sm)* sm Comma "}"s;
    ExpressionInitializer = Expression;
  }

  //
  ////////////////////////////////////////////////////////////////////////////////////

  ////////////////////////////////////////////////////////////////////////////////////
  // Constants

  syntax ConstantDeclarator  = Name sm "=" sm ConstantExpression;
  syntax ConstantDeclarators = (ConstantDeclarator; ","sm)*;

  //
  ////////////////////////////////////////////////////////////////////////////////////

  ////////////////////////////////////////////////////////////////////////////////////
  //  Lamdas

  token  ExplicitAnonymousFunctionParameterModifier = "ref" | "out";
  syntax ExplicitAnonymousFunctionParameter         = (ExplicitAnonymousFunctionParameterModifier S)? AnyType sm Name;
  syntax ExplicitAnonymousFunctionSignature         = "("s (ExplicitAnonymousFunctionParameter; ","sm)* ")"s;

  syntax ImplicitAnonymousFunctionSignature         = (Identifier; ","sm)* as Names;

  //
  ////////////////////////////////////////////////////////////////////////////////////

  ////////////////////////////////////////////////////////////////////////////////////
  //  Statements

  syntax Statement;
  
  extend syntax Statement
  {
    // EmbeddedStatement
    EmptyStatement          = ";" nl;
    BlockStatement          = nl "{" inl Statement d "}" nl;
    ExpressionStatement     = Expression ";" nl;
    // JumpStatements
    BreakStatement        = "break"S                                ";" nl;
    ContinueStatement     = "continue"S                             ";" nl;
    GotoStatement_case    = "goto"SM "case"SM   ConstantExpression  ";" nl;
    GotoStatement_default = "goto"SM "default"S                     ";" nl;
    GotoStatement_id      = "goto"SM            Name                ";" nl;
    ReturnStatement       = "return"SM          Expression          ";" nl;
    ReturnStatementVoid   = "return"S                               ";" nl;
    ThrowStatement        = "throw"SM           Expression?         ";" nl;
    // DeclarationStatement
  }

  //
  ////////////////////////////////////////////////////////////////////////////////////
 
  ////////////////////////////////////////////////////////////////////////////////////
  // Expressions

  syntax Expression;

  extend syntax Expression
  {
    NullLiteral                     = "null"S;
    IntLiteral                      = Digits+;
    RefExpression                   = QualifiedName;

    // Lambdas
    LambdaExpression_SingleParam    = Name sm                            "=>"sm AnonymousFunctionBody;
    LambdaExpression_ExplicitParams = ExplicitAnonymousFunctionSignature "=>"sm AnonymousFunctionBody;
    LambdaExpression_ImplicitParams = "("s ImplicitAnonymousFunctionSignature ")"sm          "=>"sm AnonymousFunctionBody;
    
    // Anonymous function
    AnonymousFunction               = "delegate"SM ExplicitAnonymousFunctionSignature? nl "{" inl Statement* d "}"s;

    //syntax StackallocInitializer   is VariableInitializer = "stackalloc"SM AnyType "["s Expression "]"s;

    ParenthesizedExpression         = 

    // Group: Primary
    MemberAccess               =  Expression "."s Expression                     { precedence 150; }
    Invocation                 =  Expression : 150 "("s ArgumentList ")"s;
    IndexerAccess              =  Expression : 150 "["s ArgumentList "]"s;
    PostIncrement              =  Expression "++"s                               { precedence 150; }
    PostDecrement              =  Expression "--"s                               { precedence 150; }
    //New                        =  "new"S T "("s ... ")"s                       { precedence 150; }
    //NewWithInitializer         =  "new"S T "("s ... ")"s "{"s ... "}"s         { precedence 150; }
    //AnonymousObjectInitializer =  "new"S "{"s ... "}"s                         { precedence 150; }
    //ArrayNew                   =  "new"S T"["s ... "]"s                        { precedence 150; }
    TypeOf                     =  "typeof"S "("s AnyType ")"s;
    Checked                    =  "checked"S "("s Expression ")"s;
    Unchecked                  =  "unchecked"S "("s Expression ")"s;
    Default                    =  "default"S "("s AnyType ")"s;
    Sizeof                     =  "sizeof"S  "("s AnyType ")"s;


    // Group: Unary
    Identity              = "+"s  Expression                                     { precedence 140; }
    Negation              = "-"s  Expression                                     { precedence 140; }
    LogicalNegation       = "!"s  Expression                                     { precedence 140; }
    BitwiseNegation       = "~"s  Expression                                     { precedence 140; }
    PreIncrement          = "++"s Expression                                     { precedence 140; }
    PreDecrement          = "--"s Expression                                     { precedence 140; }
    //ExplicitlyCast      = (T)s Expression                                      { precedence 140; }


    // Group: Multiplicative
    Mul                   = Expression sm "*"  sm Expression                     { precedence 130; }
    Div                   = Expression sm "/"  sm Expression                     { precedence 130; }
    Remainder             = Expression sm "%"  sm Expression                     { precedence 130; }
    // Group: Additive
    Add                   = Expression sm "+"  sm Expression                     { precedence 120; }
    Sub                   = Expression sm "-"  sm Expression                     { precedence 120; }
    // Group: Shift
    ShiftLeft             = Expression sm "<<" sm Expression                     { precedence 110; }
    ShiftRight            = Expression sm ">>" sm Expression                     { precedence 110; }
    // Group: Relational and type testing
    LessThan              = Expression sm "<"  sm Expression                     { precedence 100; }
    GreaterThan           = Expression sm ">"  sm Expression                     { precedence 100; }
    LessThanOrEqual       = Expression sm "<=" sm Expression                     { precedence 100; }
    GreaterThanOrEqual    = Expression sm ">=" sm Expression                     { precedence 100; }
    Is                    = Expression sm "is" sm Expression                     { precedence 100; }
    As                    = Expression sm "as" sm Expression                     { precedence 100; }
    // Equality
    Equal                 = Expression sm "==" sm Expression                     { precedence  90; }
    NotEqual              = Expression sm "!=" sm Expression                     { precedence  90; }
    // Group: Logical AND                                                                      
    LogicalAnd            = Expression sm "&"  sm Expression                     { precedence  80; }
    // Group: Logical XOR                                                                      
    LogicalXor            = Expression sm "^"  sm Expression                     { precedence  70; }
    // Group: Logical OR                                                                       
    LogicalOr             = Expression sm "|"  sm Expression                     { precedence  60; }
    // Group: Conditional AND                                                                  
    ConditionalAnd        = Expression sm "&&" sm Expression                     { precedence  50; }
    // Group: Conditional OR                                                                   
    ConditionalOr         = Expression sm "||" sm Expression                     { precedence  40; }
    // Group: Null coalescing                                                                  
    NullCoalescing        = Expression sm "??" sm Expression                     { precedence  30; }
    // Group: Conditional                                                                      
    Conditional           = Expression sm "?"  sm Expression ":"sm Expression    { precedence  20; }
    // Group: Assignment or anonymous function                                                 
    Assignment            = Expression sm "="  sm Expression                     { precedence  10; }
    MulAssignment         = Expression sm "*=" sm Expression                     { precedence  10; }
    DivAssignment         = Expression sm "/=" sm Expression                     { precedence  10; }
    RemainderAssignment   = Expression sm "%=" sm Expression                     { precedence  10; }
    AddAssignment         = Expression sm "+=" sm Expression                     { precedence  10; }
    SubAssignment         = Expression sm "-=" sm Expression                     { precedence  10; }
    ShiftLeftAssignment   = Expression sm "<<="sm Expression                     { precedence  10; }
    ShiftRightAssignment  = Expression sm ">>="sm Expression                     { precedence  10; }
    AndAssignment         = Expression sm "&=" sm Expression                     { precedence  10; }
    XorAssignment         = Expression sm "^=" sm Expression                     { precedence  10; }
    OrAssignment          = Expression sm "|=" sm Expression                     { precedence  10; }
  }

  syntax AnonymousFunctionBody;
  extend syntax AnonymousFunctionBody
  {
    AnonymousFunctionBodyBlock      = "{"sm Statement* "}" sm;
    AnonymousFunctionBodyExpression = Expression;
  }

  syntax ConstantExpression = Expression;

  //
  ////////////////////////////////////////////////////////////////////////////////////
}