using Nemerle;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Compiler.Typedtree;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;

namespace Nitra.Serialization
{
  public class DefaultTypeSerializationFactory : TypeSerializationFactory
  {
    public override CreateBuilder(compiler : SerializationCompiler, type : FixedType) : TypeSerializationBuilder
    {
      match (type)
      {
        | FixedType.Class(ti, _) =>
          def parseDeclaration(currentTypeInfo : TypeInfo) : TypeSerializationBuilder
          {
            match (currentTypeInfo?.GetTydecl())
            {
              | TypeDeclaration.Alias(type)      => parseDeclaration(type.TypeInfo)
              | TypeDeclaration.Enum             => EnumTypeSerializationBuilder(compiler, type, currentTypeInfo.UnderlyingType)
              | TypeDeclaration.Variant(options) => VariantTypeSerializationBuilder(compiler, type, options)
              | TypeDeclaration.VariantOption    => VariantOptionTypeSerializationBuilder(compiler, type)
              | _                                => RecordTypeSerializationBuilder(compiler, type)
            }
          }
          if (ti.IsPrimitive || ti.Equals(compiler.Manager.InternalType.String_tc))
            PrimitiveTypeSerializationBuilder(compiler, type, ti)
          else
            parseDeclaration(ti)

        | _ => Message.FatalError(type.Location, $"Type '$type' is not suppported in serialization compiler.")
      }
    }
  }
}
