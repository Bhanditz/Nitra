using Nemerle;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;

namespace Nitra.Serialization
{
  public abstract class SerializationFormatter
  {
    public abstract WriteParameters : list[SerializationParameter] { get; }
    public abstract ReadParameters  : list[SerializationParameter] { get; }

    public abstract EmitFatalError(message : PExpr) : PExpr;

    public abstract WriteTag(tag : TypeTag) : PExpr;
    public abstract ReadTag() : PExpr;

    public abstract WritePrimitive(tag : TypeTag, obj : PExpr) : PExpr;
    public abstract ReadPrimitive(tag : TypeTag) : PExpr;

    public WriteString(text : string) : PExpr
    {
      WriteString(<[ $(text : string) ]>)
    }

    public WriteString(text : PExpr) : PExpr
    {
      WritePrimitive(TypeTag.String, text)
    }

    public WriteInt32(value : PExpr) : PExpr
    {
      WritePrimitive(TypeTag.Int32, value)
    }

    public ReadString() : PExpr
    {
      ReadPrimitive(TypeTag.String)
    }

    public ReadInt32() : PExpr
    {
      ReadPrimitive(TypeTag.Int32)
    }

    public WriteEnd() : PExpr
    {
      WriteTag(TypeTag.Empty);
    }

    public TestTypeTag(memberName : PExpr, typeTag : PExpr, expectedTag : TypeTag) : PExpr
    {
      match (typeTag)
      {
        | <[ $(value : byte) ]>
        | <[ $(value : byte) :> $_ ]> =>
          assert2(value == expectedTag :> byte, $"Statically passed type tag '$value' does not match expected value '$expectedTag'.");
          <[ () ]>

        | _ =>
          <[
            when ($typeTag :> byte != $(expectedTag :> byte))
              $(EmitFatalError(<[ "Type mismatch for member '" + $memberName + "'." ]>));
          ]>
      }
    }
  }
}
