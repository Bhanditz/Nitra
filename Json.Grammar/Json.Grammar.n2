//using N2;

//using Nemerle.Collections;
//using Nemerle.Imperative;
//using Nemerle.Compiler;

//using System.Collections.Generic;
//using System.Text;
//using System.Linq;

syntax module JsonParser
{
  token field OpenBrace           = "(";
  token field CloseBrace          = ")";
  token field OpenBrace           = "{";
  token field CloseBrace          = "}";
  token field OpenSquareBrace     = "[";
  token field CloseSquareBrace    = "]";
  token field SingleQuote         = "\'";
  token field Quote               = "\"";
  token field Semicolon           = ";";
  token field Comma               = ",";
  token field Colon               = ":";
  token field Assign              = "=";
  token field Op                  = "+", "-", "*", "/", "?", "^", "%", "&", "!", ".";
  token field Backslash           = "\\";

  span class Comment;
  span class Char;
  span class String;
  span class Number;
  span class Keyword      = ['a'..'z']['a'..'z']+;
  span class Operator     = ['+', '-', '/', '*', '^', '?', ':']+;
  span class OpenBrace    = "(" | "{" | "[";
  span class CloseBrace   = ")" | "}" | "]";

  braces "(", ")";
  braces "{", "}";
  braces "[", "]";


  marker i;   // increase a indent
  marker d;   // decrease a indent
  marker nl;  // optional spacer and plase for \n while pretty printing
  marker inl; // i + nl
  marker sm;  // optional spacer and prefer to print space while pretty printing

  //token Keyword = "as" | "syntax" | "token" | "alias" | "in" | "out" | "rule";

  [StartRule, ExplicitSpaces]
  syntax Start = s Value !Any;

  token Any = ['\u0000'..'\uFFFF'];

  ///////////////////////////////////////////////////////////////////////////
  // Whitespaces

  token NewLineCharacter = '\n' | '\r' | UnicodeLineSeparator | UnicodeParagraphSeparator;
  token UnicodeLineSeparator = '\u2028';
  token UnicodeParagraphSeparator = '\u2029';
  token NewLine = "\r\n" | NewLineCharacter;

  token Whitespace = [Zs] | '\t' | '\v' | '\f';
  token Space = Whitespace | NewLineCharacter;
  token Spaces = Space+;

  [ExplicitSpaces] syntax IgnoreToken;

  extend syntax IgnoreToken
  {
    [ExplicitSpaces, SpanClass(Comment)] SingleLineComment = "//" as Start (!NewLine Any)* as Body NewLine? as End;
    [ExplicitSpaces, SpanClass(Comment)] MultiLineComment  = "/*" as Start (!"*/" Any)*    as Body "*/"     as End;
    [ExplicitSpaces]                     SpaceToken        = Spaces;
  }

  [ExplicitSpaces] void s   = IgnoreToken*;                // optional spacer

  ///////////////////////////////////////////////////////////////////////////
  // Strings

  token LetterCharacter           = ['A'..'Z', 'a'..'z', 'а'..'я', 'А'..'Я'];//[Lu, Ll, Lt, Lm, Lo, Nl];
  token IdentifierStartCharacter  = LetterCharacter | "_";
  token IdentifierPartCharacters  = LetterCharacter | [Nd, Pc, Mn, Mc, Cf];
  token IdentifierBody            = IdentifierStartCharacter IdentifierPartCharacters*;
  [ExplicitSpaces] syntax Identifier = IdentifierBody;

  token HexDigit                  = ['0'..'9', 'a'..'f', 'A'..'F'];
  token EscChar                   = '\\' | '/' | 'b' | 'f' | 'n' | 'r' | 'u' HexDigit HexDigit HexDigit HexDigit;

  token ReservedStringChar1       = '\"' | '\\';
  token EscChar1                  = '\"' | EscChar;
  token Esc1                      = '\\' EscChar1;
  [SpanClass(String), ExplicitSpaces]
  syntax StringLiteral1 = "\""  StringPart1* "\"";

  [ExplicitSpaces] syntax StringPart1;

  extend syntax StringPart1
  {
    [ExplicitSpaces] EscStringPart   = Esc1;
    [ExplicitSpaces] OtherStringPart = Chars
    {
      alias Chars = (!ReservedStringChar1 Any)+;
    }
  }

  token ReservedStringChar2       = '\'' | '\\';
  token EscChar2                  = '\'' | EscChar;
  token Esc2                      = '\\' EscChar2;

  [ExplicitSpaces] syntax StringPart2;

  extend syntax StringPart2
  {
    [ExplicitSpaces] EscStringPart2   = Esc1;
    [ExplicitSpaces] OtherStringPart2 = Chars
    {
      alias Chars = (!ReservedStringChar2 Any)+;
    }
  }

  [SpanClass(String), ExplicitSpaces]
  syntax StringLiteral2 = "\'"  StringPart2* "\'";

  ///////////////////////////////////////////////////////////////////////////
  // Numbers

  token Digits   = ['0'..'9']+;
  token Integer  = '0' | ['1'..'9'] Digits;
  token Exponent = ("E" | "e") ("-" | "+")? Digits;
 
  [ExplicitSpaces]
  syntax Fraction = "." Digits ;

  [ExplicitSpaces]
  syntax Number = "-"? as Minus Integer Fraction? Exponent?;

  ///////////////////////////////////////////////////////////////////////////
  // Value

  syntax Value;

  extend syntax Value
  {
    IdentifierValue = Identifier;
    StringValue1    = StringLiteral1;
    StringValue2    = StringLiteral2;
    NumberValue     = Number;
    ObjectValue     = "{" inl (ObjectContent; "," nl)* nl d "}";
    ArrayValue      = "[" (Value; "," sm)*  "]";
    TrueValue       = "true";
    FalseValue      = "false";
    NullValue       = "null";
  }

  syntax ObjectContent;

  extend syntax ObjectContent
  {
    ObjectContent1 = StringLiteral1 ":" sm Value;
    ObjectContent2 = StringLiteral2 ":" sm Value;
    ObjectContent3 = Identifier     ":" sm Value;
  }
}