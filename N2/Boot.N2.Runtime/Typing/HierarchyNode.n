using N2.Runtime;
using Nemerle;
using Nemerle.Assertions;
using Nemerle.Collections;
using Nemerle.Extensions;
using Nemerle.Imperative;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;

namespace N2.Typing
{
  public class HierarchyNode : IEquatable[HierarchyNode]
  {
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private mutable _children : Hashtable[string, HierarchyNode] = Hashtable();
    
    private Children : Hashtable[string, HierarchyNode]
    {
      get
      {
        when (_children == null)
          _children = Hashtable();
        _children
      }
    }
    
    public PartName : string { get; }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    mutable _symbol : N2.Typing.Symbol;
    
    public Symbol : N2.Typing.Symbol
    {
      get { _symbol }
    }
    
    public this() { this(null, null) }

    private this(parent : HierarchyNode, partName : string)
    {
      Parent   = parent;
      PartName = partName;
      
      when (parent != null)
        parent.Children.Add(partName, this);
    }

    public FullNameParts : list[string]
    {
      [Memoize]
      get
      {
        def loop(node : HierarchyNode, parts : list[string]) : list[string]
        {
          if (node.Parent == null)
            parts
          else
            loop(node.Parent, node.PartName :: parts)
            
        }
        
        loop(this, [])
      }
    }
    
    public FullName : string { [Memoize] get { $<#..$(FullNameParts; ".")#> } }

    public SetRootNamespaceSymbol([NotNull] rootNamespace : NamespaceSymbol) : void
    {
      assert2(rootNamespace.Node == null);
      assert2(_symbol == null);
      rootNamespace.Node = this;
      _symbol            = rootNamespace;
    }

    public SetSymbol([NotNull] symbol : Symbol, location : Location) : void
    {
      assert2(symbol.Name == PartName);
      assert2(symbol.Node == null);
      
      match (_symbol, symbol)
      {
        | (null, _) => _symbol = symbol;
        | (a1 is AmbiguousSymbol, a2 is AmbiguousSymbol) => _symbol = AmbiguousSymbol(a1.AmbiguousList + a2.AmbiguousList);
        | (a1 is AmbiguousSymbol, s)                     => _symbol = AmbiguousSymbol(s :: a1.AmbiguousList);
        | (_, _ is AmbiguousSymbol)                      => assert2(false);
        | (s1, s2) =>
          s2.Node = this;
          _symbol = AmbiguousSymbol([s1, s2]);
      }
        
      _symbol.Node = this;
      Project.CurrentProject.AddSymbolDef(_symbol, location);
    }
    
    public Add([NotNull] symbol : N2.Typing.Symbol, location : Location) : HierarchyNode
    {
      def node = AddNode(symbol.Name);
      node.SetSymbol(symbol, location);
      node
    }

    public AddAndReport[T]([NotNull] path : list[string], [NotNull] symbol : T, location : Location) : HierarchyNode
      where T: N2.Typing.Symbol
    {
      AddNode(path).AddAndReport(symbol, location)
    }

    public AddAndReport[T]([NotNull] symbol : T, location : Location) : HierarchyNode
      where T: N2.Typing.Symbol
    {
      def node = Add(symbol, location);
      def sym = node.Symbol;
      def project = Project.CurrentProject;
      when (sym is AmbiguousSymbol as ambiguous)
        ambiguous.ReportAlreadyDefined(symbol, project);

      node
    }

    public AddNode([NotNull] partName : string) : HierarchyNode
    {
      mutable child;
      if (_children?.TryGetValue(partName, out child))
        child
      else
      {
        def result = HierarchyNode(this, partName);
        Children[partName] = result;
        result
      }
    }

    public AddNode([NotNull] parts : list[string]) : HierarchyNode
    {
      mutable parent = this;
      foreach (part in parts)
        parent = parent.AddNode(part);
      parent
    }

    public Parent : HierarchyNode { get; }
    
    public override ToString() : string { FullName }

    public Bind[T](name : list[Location]) : option[T]
    {
      def loop(name : list[Location])
      {
        | first :: (_ :: _) as tail =>
          def res = Bind.[Symbol](first);
          if (res is Some(sym))
            sym.Node.Bind.[T](tail)
          else
            None()

        | first :: [] => Bind.[T](first)
        | [] => None()
      }
      
      loop(name)
    }

    public Bind[T](name : Location) : option[T]
      //where T: Symbol
    {
      assert2(!name.IsEmpty);
      def node = AddNode(name.GetText());
      def symbol = node._symbol;
      
      match (symbol : object)
      {
        | null => /* report ambigauty */ None()
        | sym is T => Some(sym)
        | ambiguous is AmbiguousSymbol =>
          mutable result = None();
          
          foreach (sym is Symbol in ambiguous.AmbiguousList.OfType.[T]())
          {
            if (result.IsNone)
            {
              Project.CurrentProject.AddSymbolRef(sym, name);
              result = Some(sym :> T);
            }
            else
            {
              Project.CurrentProject.AddSymbolRef(ambiguous, name);

              using (root = Project.CurrentProject.RootError(name, "Name $(name) is ambiguous.", -1))
                foreach (loc in sym.Locations with i)
                  root.Error(loc, if (i == 0) "first defenition." else "other defenition.");

              break;
            }
          }
          
          result
          
        | _ => 
          assert2(false);
          Project.CurrentProject.Error(name, $"Name $(name.GetText()) is undefined.", -1); None()
      }
    }
    
    public TryGetSymbolEx[T](name : string, symbol : out T) : bool
      where T: Symbol
    {
      mutable symbol2;
      
      when (TryGetSymbol(name, out symbol2) && symbol2 is T)
        symbol = symbol2 :> T;
      
      symbol != null
    }

    public TryGetSymbol(name : string, symbol : out Symbol) : bool
    {
      TryGetSymbol([name], out symbol)
    }

    public TryGetSymbol(name : list[string], symbol : out Symbol) : bool
    {
      assert2(!name.IsEmpty);
      mutable subNode = AddNode(name);
      def node = subNode.Parent;

      when (node == null)
        return false;

      symbol = subNode._symbol;
      symbol != null
    }

    public Path() : Seq[HierarchyNode]
    {
      mutable node = this;
      
      while (node != null)
      {
        yield node;
        node = node.Parent;
      }
    }
  }
}
