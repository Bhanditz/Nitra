using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using N2.Typing;

using System;
using System.Reflection;
using System.IO;
using System.Collections.Generic;
using System.Linq;

namespace N2.Serialization
{
  public sealed class ExportableSymbolWriter : ISymbolRefWriter
  {
    public Write(root : NamespaceSymbol, buffer : BinaryWriter) : void
    {
      _nonTreeSymbols.Clear();
      _externalSymbols.Clear();
      _nodeIds.Clear();
      _symbolIds.Clear();
      _assemblyIds.Clear();

      using(symbolBodyStream = MemoryStream())
      {
        _symbolBodyBuffer = BinaryWriter(symbolBodyStream);
        try
        {
          def exportableSymbols = CollectExportableSymbols(root);
          WriteNameTree(root.Node, exportableSymbols.Select(_.Node), buffer);
          WriteSymbols(exportableSymbols, buffer);
          WriteReferencedAssemblies(buffer);
          WriteNameTree(root.Node, _externalSymbols.Select(_.Node), buffer);
          WriteExternalSymbols(buffer);

          buffer.Write(symbolBodyStream.GetBuffer(), 0, symbolBodyStream.Length :> int);
          buffer.Write(0 : int);
        }
        finally _symbolBodyBuffer = null;
      }
    }

    private WriteNameTree(rootNode : HierarchyNode, nodes : Seq[HierarchyNode], buffer : BinaryWriter) : void
    {
      def write(node : HierarchyNode) : int
      {
        assert(node.Parent != null);

        mutable id;
        unless (_nodeIds.TryGetValue(node, out id))
        {
          def parentId = if (node.Parent : object != rootNode) write(node.Parent) else -1;
          id = _nodeIds.Count + 1;
          _nodeIds.Add(node, id);
          buffer.Write(id);
          buffer.Write(parentId);
          buffer.Write(node.PartName);
        }
        id
      }
      foreach (node in nodes)
        _ = write(node);
      buffer.Write(0 : int);
    }

    private WriteSymbols(symbols : Seq[IExportableSymbol], buffer : BinaryWriter) : void
    {
      // tree symbols
      foreach (group in symbols.GroupBy(_.SymbolTypeId))
      {
        buffer.Write(group.Key);
        foreach (symbol in group)
        {
          def symbolId = GetSymbolId(symbol);
          def nodeId   = GetNodeId(symbol);
          buffer.Write(symbolId);
          buffer.Write(nodeId);
          SerializeSymbol(symbol);
        }
        buffer.Write(0 : int);
      }

      // non tree symbols
      foreach (group in _nonTreeSymbols.GroupBy(_.SymbolTypeId))
      {
        buffer.Write(group.Key);
        foreach (symbol in group)
        {
          def symbolId = GetSymbolId(symbol);
          def name     = symbol.Name;
          buffer.Write(symbolId);
          buffer.Write(0 : int);
          buffer.Write(name);
        }
        buffer.Write(0 : int);
      }

      buffer.Write("");
    }

    private WriteReferencedAssemblies(buffer : BinaryWriter) : void
    {
      foreach (pair in _assemblyIds)
      {
        def assemblyId   = pair.Value;
        def assemblyName = pair.Key;
        buffer.Write(assemblyId);
        buffer.Write(assemblyName.FullName);
      }
      buffer.Write(0 : byte);
    }

    private WriteExternalSymbols(buffer : BinaryWriter) : void
    {
      foreach (group in _externalSymbols.GroupBy(_.SymbolTypeId))
      {
        buffer.Write(group.Key);
        foreach (symbol in group)
        {
          def symbolId   = GetSymbolId(symbol);
          def nodeId     = GetNodeId(symbol);
          def assemblyId = GetAssemblyId(symbol);
          buffer.Write(symbolId);
          buffer.Write(nodeId);
          buffer.Write(assemblyId);
        }
        buffer.Write(0 : int);
      }
      buffer.Write("");
    }

    private WriteSymbolRef(symbol : IExportableSymbol, buffer : BinaryWriter) : void implements ISymbolRefWriter.Write
    {
      if (symbol.Node == null)
      {
        unless (symbol.AssemblyId == AssemblyIds.CurrentAssembly)
          throw NotSupportedException("Serialization of referencies to external non tree symbols not supported");

        // локальный недревесный символ
        AddNonTreeSymbol(symbol);
        buffer.Write(GetSymbolId(symbol));
      }
      else if (symbol.AssemblyId == AssemblyIds.CurrentAssembly)
      {
        // локальный древесный символ
        buffer.Write(GetSymbolId(symbol));
      }
      else
      {
        // внешний древесный символ
        AddExternalSymbol(symbol);
        buffer.Write(GetSymbolId(symbol));
      }
    }

    private CollectExportableSymbols(rootNamespace : NamespaceSymbol) : List[IExportableSymbol]
    {
      def buffer = List();
      def visitNode(node)
      {
        foreach (symbol in node.GetChildren.[Symbol]())
          when (symbol.AssemblyId == AssemblyIds.CurrentAssembly && symbol is IExportableSymbol)
            buffer.Add(symbol :> IExportableSymbol);
        foreach (node in node.SubNodes)
          visitNode(node);
      }
      visitNode(rootNamespace.Node);
      buffer
    }

    private SerializeSymbol(symbol : IExportableSymbol) : void
    {
      def symbolId = GetSymbolId(symbol);
      _symbolBodyBuffer.Write(symbolId);
      symbol.Serialize(_symbolBodyBuffer, this);
    }

    private mutable _symbolBodyBuffer : BinaryWriter;
    private         _nonTreeSymbols   : HashSet[IExportableSymbol]          = HashSet();
    private         _externalSymbols  : HashSet[IExportableSymbol]          = HashSet();
    private         _nodeIds          : Dictionary[HierarchyNode,     int]  = Dictionary();
    private         _symbolIds        : Dictionary[IExportableSymbol, int]  = Dictionary();
    private         _assemblyIds      : Dictionary[AssemblyName,      byte] = Dictionary();

    private AddNonTreeSymbol(symbol : IExportableSymbol) : void
    {
      when (_nonTreeSymbols.Add(symbol))
        SerializeSymbol(symbol);
    }

    private AddExternalSymbol(symbol : IExportableSymbol) : void
    {
      when (_externalSymbols.Add(symbol))
      {
        def assemblyName = N2.Runtime.Project.CurrentProject.GetAssemblyName(symbol.AssemblyId);
        unless (_assemblyIds.ContainsKey(assemblyName))
        {
          def id = (_assemblyIds.Count + 1) :> byte;
          _assemblyIds.Add(assemblyName, id);
        }
      }
    }

    private GetNodeId(symbol : IExportableSymbol) : int
    {
      _nodeIds[symbol.Node]
    }

    private GetSymbolId(symbol : IExportableSymbol) : int
    {
      mutable id;
      unless (_symbolIds.TryGetValue(symbol, out id))
      {
        id = _symbolIds.Count + 1;
        _symbolIds.Add(symbol, id);
      }
      id
    }

    private GetAssemblyId(symbol : IExportableSymbol) : byte
    {
      assert(symbol.AssemblyId != AssemblyIds.CurrentAssembly);
      assert(symbol.AssemblyId != AssemblyIds.NoAssembly);

      def assemblyName = N2.Runtime.Project.CurrentProject.GetAssemblyName(symbol.AssemblyId);
      _assemblyIds[assemblyName]
    }
  }
}
