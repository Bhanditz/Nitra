using Nemerle.Imperative;

namespace N2.Internal
{
  public sealed partial class ExtensibleRuleParser
  {
    public override FindRecoveryPosition(mutable curTextPos : int, stack : RecoveryStackFrame, parser : N2.Internal.Parser) : void
    {
      curTextPos = FindRecoveryPositionPrefix(curTextPos, stack, parser);
      when (curTextPos > 0 && FirstPostfixRule < PostfixRules.Length)
        do curTextPos = FindRecoveryPositionPostfix(curTextPos, stack, parser) while (curTextPos > 0);
    }

    private FindRecoveryPositionPrefix(mutable curTextPos : int, stack : RecoveryStackFrame, parser : N2.Internal.Parser) : int
    {
      mutable bestResult = 0;
      mutable prefixAst = parser.TryGetAst(curTextPos, PrefixId);
      when (prefixAst > 0)
      {
        bestResult = parser.TryGetPrefix(ref curTextPos, ref prefixAst);
        if (bestResult > 0)
        {
          def state = parser.ast[bestResult + AstOfs.State];
          assert (state == Parser.AstParsedState || state >= 0);
        }
        else when (bestResult < 0)
          return -1;
      }
      def astHandle = parser.GetPrefixAstHandle(this, prefixAst, curTextPos);
      def stack = parser.NormalRecoveryStackFrame(stack, astHandle, PrefixState);
      if (bestResult == 0)
      {//0
        when (stack != null)
          if (parser.MaxFailPos == curTextPos)
            parser.RecoveryStacks.Add(stack);
          else
            foreach (prefixRule in PrefixRules)
              _ = prefixRule.FindRecoveryPosition(curTextPos, bestResult, stack, parser);
        -1;
      }
      else
      {
        mutable newPos = -1;
        while (bestResult > 0)
        {
          def prefixParser = PrefixRuleParser(bestResult, parser);
          when (stack != null)
            prefixParser.FindRecoveryPosition(curTextPos, bestResult, stack, parser);
          def state = parser.ast[bestResult + AstOfs.State];
          when (state == Parser.AstParsedState)
          {
            def pos = curTextPos + GetPrefixSize(bestResult, parser);
            assert3(newPos < 0 || newPos == pos);
            newPos = pos;
          }
          bestResult = parser.ast[bestResult + AstOfs.Next]
        }
        newPos
      }
    }

    private FindRecoveryPositionPostfix(mutable curTextPos : int, stack : RecoveryStackFrame, parser : N2.Internal.Parser) : int
    {
      mutable bestResult = 0;
      mutable postfixAst = parser.TryGetAst(curTextPos, PostfixId);
      when (postfixAst > 0)
      {
        bestResult = parser.TryGetPostfix(ref curTextPos, ref postfixAst);
        if (bestResult > 0)
        {
          def state = parser.ast[bestResult + AstOfs.State];
          assert (state == Parser.AstParsedState || state >= 0);
        }
        else when (bestResult < 0)
          return -1;
      }
      def astHandle = parser.GetPostfixAstHandle(this, postfixAst, curTextPos);
      def stack = parser.NormalRecoveryStackFrame(stack, astHandle, PostfixState);
      if (bestResult == 0)
      {//0
        when (stack != null)
          if (parser.MaxFailPos == curTextPos)
            parser.RecoveryStacks.Add(stack);
          else
            foreach (postfixRule in PostfixRules)
              _ = postfixRule.FindRecoveryPosition(curTextPos, bestResult, stack, parser);
        -1;
      }
      else
      {
        mutable newPos = -1;
        while (bestResult > 0)
        {
          def postfixParser = PostfixRuleParser(bestResult, parser);
          when (stack != null)
            postfixParser.FindRecoveryPosition(curTextPos, bestResult, stack, parser);
          def state = parser.ast[bestResult + AstOfs.State];
          when (state == Parser.AstParsedState)
          {
            def pos = curTextPos + GetPrefixSize(bestResult, parser);
            assert3(newPos < 0 || newPos == pos);
            newPos = pos;
          }
          bestResult = parser.ast[bestResult + AstOfs.Next]
        }
        newPos
      }
    }
  }
}
