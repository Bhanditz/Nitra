using Nemerle.Imperative;

namespace N2.Internal
{
  public sealed partial class ExtensibleRuleParser
  {
    public override FindRecoveryPosition(mutable curTextPos : int, parser : N2.Internal.Parser) : void
    {
      curTextPos = FindRecoveryPositionPrefix(curTextPos, parser);
      when (curTextPos > 0)
        do curTextPos = FindRecoveryPositionPostfix(curTextPos, parser) while (curTextPos > 0);
    }

    private FindRecoveryPositionPrefix(mutable curTextPos : int, parser : N2.Internal.Parser) : int
    {
      mutable bestResult = 0;
      mutable prefixAst = parser.TryGetAst(curTextPos, PrefixId);
      when (prefixAst > 0)
      {
        bestResult = parser.TryGetPrefix(ref curTextPos, prefixAst);
        if (bestResult > 0)
        {
          def state = parser.ast[bestResult + AstOfs.State];
          assert (state == Parser.AstParsedState || state >= 0);
        }
        else when (bestResult < 0)
          return -1;
      }
      mutable newPos;
      parser.RecoveryStack.Push(RecoveryStackFrame(this, prefixAst, curTextPos, PrefixState, 0, 0, 0, false, FrameInfo.None));
      if (bestResult == 0)
      {//0
        if (parser.MaxFailPos == curTextPos)
          parser.StartRecovery(curTextPos);
        else
        {
          foreach (prefixRule in PrefixRules)
          {
            _ = prefixRule.FindRecoveryPosition(curTextPos, bestResult, parser);
          }
        }
        newPos = -1;
      }
      else if (parser.ast[bestResult + AstOfs.Next] == 0)
      {//1
        def prefixParser = PrefixRuleParser(bestResult, parser);
        prefixParser.FindRecoveryPosition(curTextPos, bestResult, parser);
        def state = parser.ast[bestResult + AstOfs.State];
        if (state == Parser.AstParsedState)
          newPos = curTextPos + GetPrefixSize(bestResult, parser);
        else
          newPos = -1;
      }
      else
      {//many
        assert2(false);
        assert(false);
      }
      _ = parser.RecoveryStack.Pop();
      newPos
    }

    private FindRecoveryPositionPostfix(mutable curTextPos : int, parser : N2.Internal.Parser) : int
    {
      mutable bestResult = 0;
      mutable postfixAst = parser.TryGetAst(curTextPos, PostfixId);
      when (postfixAst > 0)
      {
        bestResult = parser.TryGetPostfix(ref curTextPos, ref postfixAst);
        if (bestResult > 0)
        {
          def state = parser.ast[bestResult + AstOfs.State];
          assert (state == Parser.AstParsedState || state >= 0);
        }
        else when (bestResult < 0)
          return -1;
      }
      mutable newPos;
      parser.RecoveryStack.Push(RecoveryStackFrame(this, postfixAst, curTextPos, PostfixState, 0, 0, 0, false, FrameInfo.None));
      if (bestResult == 0)
      {//0
        if (parser.MaxFailPos == curTextPos)
          parser.StartRecovery(curTextPos);
        else
        {
          foreach (postfixRule in PostfixRules)
          {
            _ = postfixRule.FindRecoveryPosition(curTextPos, bestResult, parser);
          }
        }
        newPos = -1;
      }
      else if (parser.ast[bestResult + AstOfs.Next] == 0)
      {//1
        def postfixParser = PostfixRuleParser(bestResult, parser);
        postfixParser.FindRecoveryPosition(curTextPos, bestResult, parser);
        def state = parser.ast[bestResult + AstOfs.State];
        if (state == Parser.AstParsedState)
          newPos = curTextPos + GetPostfixSize(bestResult, parser);
        else
          newPos = -1;
      }
      else
      {//many
        assert2(false);
        assert(false);
      }
      _ = parser.RecoveryStack.Pop();
      newPos
    }
  }
}
