using Nemerle.Imperative;

namespace N2.Internal
{
  public sealed partial class ExtensibleRuleParser
  {
    public override FindRecoveryPosition(mutable curTextPos : int, stack : RecoveryStackFrame, parser : N2.Internal.Parser) : void
    {
      def startTextPos = curTextPos;
      def prefixStack = parser.RecoveryStackFrame_Extensible(stack, startTextPos, this, PrefixState);
      curTextPos = FindRecoveryPositionPrefix(curTextPos, prefixStack, parser);
      when (curTextPos > 0 && FirstPostfixRule < PostfixRules.Length)
      {
        def postfixStack = parser.RecoveryStackFrame_Extensible(stack, startTextPos, this, PostfixState);
        do
          curTextPos = FindRecoveryPositionPostfix(curTextPos, postfixStack, parser)
        while (curTextPos > 0);
      }
    }

    private FindRecoveryPositionPrefix(mutable curTextPos : int, stack : RecoveryStackFrame, parser : N2.Internal.Parser) : int
    {
      def startTextPos = curTextPos;
      mutable bestResult = 0;
      mutable prefixAst = parser.TryGetAst(curTextPos, PrefixId);
      when (prefixAst > 0)
      {
        bestResult = parser.TryGetPrefix(ref curTextPos, ref prefixAst);
        if (bestResult > 0)
        {
          def state = parser.ast[bestResult + AstOfs.State];
          assert (state == Parser.AstParsedState || state >= 0);
        }
        else when (bestResult < 0)
          return -1;
      }
      def astHandle = parser.AstHandle_Prefix(this.ParserData, -1, curTextPos);
      def stack = parser.RecoveryStackFrame_ExtensiblePrefix(stack, startTextPos, astHandle, this);
      if (bestResult == 0)
      {//0
        when (stack != null)
          if (parser.MaxFailPos == curTextPos)
            parser.RecoveryStacks.Add(stack);
          else
            foreach (prefixRule in PrefixRules)
              _ = prefixRule.FindRecoveryPosition(curTextPos, bestResult, stack, parser);
        -1;
      }
      else
      {
        mutable newPos = -1;
        while (bestResult > 0)
        {
          def prefixParser = PrefixRuleParser(bestResult, parser);
          when (stack != null)
            prefixParser.FindRecoveryPosition(curTextPos, bestResult, stack, parser);
          def state = parser.ast[bestResult + AstOfs.State];
          when (state == Parser.AstParsedState)
          {
            def pos = curTextPos + GetPrefixSize(bestResult, parser);
            assert3(newPos < 0 || newPos == pos);
            newPos = pos;
          }
          bestResult = parser.ast[bestResult + AstOfs.Next]
        }
        newPos
      }
    }

    private FindRecoveryPositionPostfix(mutable curTextPos : int, stack : RecoveryStackFrame, parser : N2.Internal.Parser) : int
    {
      def startTextPos = curTextPos;
      mutable bestResult = 0;
      mutable postfixAst = parser.TryGetAst(curTextPos, PostfixId);
      when (postfixAst > 0)
      {
        bestResult = parser.TryGetPostfix(ref curTextPos, ref postfixAst);
        if (bestResult > 0)
        {
          def state = parser.ast[bestResult + AstOfs.State];
          assert (state == Parser.AstParsedState || state >= 0);
        }
        else when (bestResult < 0)
          return -1;
      }
      def astHandle = parser.AstHandle_Postfix(this.ParserData, -1, curTextPos);
      def stack = parser.RecoveryStackFrame_ExtensiblePostfix(stack, startTextPos, astHandle, this);
      if (bestResult == 0)
      {//0
        when (stack != null)
          if (parser.MaxFailPos == curTextPos)
            parser.RecoveryStacks.Add(stack);
          else
            foreach (postfixRule in PostfixRules)
              _ = postfixRule.FindRecoveryPosition(curTextPos, bestResult, stack, parser);
        -1;
      }
      else
      {
        mutable newPos = -1;
        while (bestResult > 0)
        {
          def postfixParser = PostfixRuleParser(bestResult, parser);
          when (stack != null)
            postfixParser.FindRecoveryPosition(curTextPos, bestResult, stack, parser);
          def state = parser.ast[bestResult + AstOfs.State];
          when (state == Parser.AstParsedState)
          {
            def pos = curTextPos + GetPostfixSize(bestResult, parser);
            assert3(newPos < 0 || newPos == pos);
            newPos = pos;
          }
          bestResult = parser.ast[bestResult + AstOfs.Next]
        }
        newPos
      }
    }
  }
}
