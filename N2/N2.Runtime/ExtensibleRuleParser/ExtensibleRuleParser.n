using Nemerle;
using Nemerle.Imperative;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;

using N2.Runtime.Reflection;

namespace N2.Internal
{
  public sealed partial class ExtensibleRuleParser : StartRuleParser, IRecoveryRuleParser
  {
    public GetParsers() : array[IRecoveryRuleParser]
    {
      (PrefixRules : object) :> array[IRecoveryRuleParser]
    }

    public Code           : string { get { Descriptor.Name } }
    public CodeWithStates : string { get Descriptor.Name }
    public RuleName       : string { get Descriptor.Name }
    public CodeForState(_state : int) : string { Descriptor.Name }

    public PrefixRuleParser(ptr : int, parser : Parser) : ExtentionRuleParser
    {
      PrefixRules[parser.ast[ptr + PrefixOfs.Id] - PrefixOffset]
    }

    public PostfixRuleParser(ptr : int, parser : Parser) : ExtentionRuleParser
    {
      PostfixRules[(parser.ast[ptr + PostfixOfs.Id] & PostfixMask.Id) - PostfixOffset]
    }

    public GetPrefixSize(bestResult : int, parser : Parser) : int
    {
      assert(parser.ast[bestResult + AstOfs.State] == Parser.AstParsedState);
      mutable size = 0;
      mutable i = bestResult + AstOfs.Sizes;
      mutable end = i + PrefixRuleParser(bestResult, parser).FieldsCount;
      for (; i < end; ++i)
        size += parser.GetSize(i);
      size;
    }

    public GetPostfixSize(bestResult : int, parser : Parser) : int
    {
      assert(parser.ast[bestResult + AstOfs.State] == Parser.AstParsedState);
      mutable size = 0;
      mutable i = bestResult + AstOfs.Sizes;
      mutable end = i + PostfixRuleParser(bestResult, parser).FieldsCount;
      for (; i < end; ++i)
        size += parser.GetSize(i);
      size;
    }

    public override GetFramesForState(startState : int, parser : Parser, parent : RecoveryStackFrame, textPos : int) : array[RecoveryStackFrame]
    {
      match (startState)
      {
        | 0 => this.PrefixRules.MapToArray(x => x.GetFrameForFirstState(parser, parent, textPos))
        | 1 => this.PostfixRules.Skip(FirstPostfixRule).MapToArray(x => x.GetFrameForFirstState(parser, parent, textPos))
        | _ => assert3(false)
      }
    }

    public override GetLoopBodyFrameForSeparatorState(state : int, parser : Parser, parent : RecoveryStackFrame, textPos : int) : RecoveryStackFrame
    {
      IgnoreParams();
      null
    }

    public override GetFrameForFirstState(parser : Parser, parent : RecoveryStackFrame, textPos : int) : RecoveryStackFrame
    {
      IgnoreParams();
      assert3(false);
    }

    public override IsStateCanParseEmptyString(state : int) : bool { state != 0 }
    public override IsVoidState         (state : int) : bool { IgnoreParams(); false }
    public override IsStartState        (state : int) : bool { state == 0 }
    public override IsLoopSeparatorStart(state : int) : bool { IgnoreParams(); false }
    public override IsLoopSeparator     (state : int) : bool { IgnoreParams(); false }
    public override IsLoopBody          (state : int) : bool { IgnoreParams(); false }

    public override IsTokenRule : bool { get { Descriptor.IsTokenRule } }

    public PatchAst(_startPos : int, _startState : int, errorIndex : int, frame : RecoveryStackFrame, parser : N2.Internal.Parser) : void
    {
      when (frame.AstHandle.AstPtr <= 0)
      {
        if (frame.FailState == PrefixState)
        {
          assert3(parser.TryGetAst(frame.AstHandle.TextPos, PrefixId) == 0);
          frame.AstHandle.AstPtr = parser.Allocate(PrefixOfs.NodeSize, PrefixId);
          parser.ast[frame.AstHandle.AstPtr + PrefixOfs.Next] = parser.memoize[frame.AstHandle.TextPos];
          parser.memoize[frame.AstHandle.TextPos] = frame.AstHandle.AstPtr;
        }
        else if (frame.FailState == PostfixState)
        {
          assert3(parser.TryGetAst(frame.AstHandle.TextPos, PostfixId) == 0);
          frame.AstHandle.AstPtr = parser.Allocate(PostfixOfs.NodeSize, PostfixId);
          parser.ast[frame.AstHandle.AstPtr + PostfixOfs.Next] = parser.memoize[frame.AstHandle.TextPos];
          parser.memoize[frame.AstHandle.TextPos] = frame.AstHandle.AstPtr;
        }
        else assert(false);
      }
      if (frame.FailState == PrefixState)
      {
        assert3(parser.ast[frame.AstHandle.AstPtr + PrefixOfs.List] == 0);
        parser.ast[frame.AstHandle.AstPtr + PrefixOfs.List] = ~errorIndex;
      }
      else if (frame.FailState == PostfixState)
      {
        assert3(parser.ast[frame.AstHandle.AstPtr + PostfixOfs.List] == 0);
        parser.ast[frame.AstHandle.AstPtr + PostfixOfs.List] = ~errorIndex;
      }
      else assert(false);
    }

    public GetNextState(state : int) : int
    {
      match (state)
      {
        | 0 =>  1
        | 1 => -1
        | _ => assert(false)
      }
    }

    public StartState : int { get { 0 } }
  }
}
