using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Imperative;
using Nemerle.Imperative.GoTo;

using System;
using System.Collections.Generic;

namespace N2.Internal
{
  public sealed partial class ExtensibleRuleParser
  {
    public ParsePrefix(mutable curTextPos : int, text : string, parser : Parser) : int
    {
      unchecked
      {
        mutable prefixAst;
        mutable newEndPos;
        mutable newResult;
        mutable bestEndPos;
        mutable bestResult;
        mutable lastResult;
        mutable i;
        mutable c; // временная переменная для отсечения правил по первой букве

        prefixAst = parser.TryGetAst(curTextPos, PrefixId);
        when (prefixAst > 0)
        {
          def maxFailPos = parser.ast[prefixAst + PrefixOfs.MaxFailPos];
          when (parser.MaxFailPos < maxFailPos)
            parser.MaxFailPos = maxFailPos;
          bestResult = parser.TryGetPrefix(ref curTextPos, ref prefixAst);
          if (bestResult > 0)
          {
            def state = parser.ast[bestResult + AstOfs.State];
            if (state == Parser.AstParsedState)
              return curTextPos + GetPrefixSize(bestResult, parser);
            else if (state < 0)
            {
              parser.ast[bestResult + PrefixOfs.Next] = 0;//FIXME. обработать неоднозначности.
              def prefixRule = PrefixRuleParser(bestResult, parser);
              newResult = bestResult;
              return prefixRule.Parse(curTextPos, text, ref newResult, parser);
            }
            else
            {
              def prefixRule = PrefixRuleParser(bestResult, parser);
              def maxFailPos = parser.ast[bestResult + AstOfs.Sizes + prefixRule.FieldsCount - 1];
              when (maxFailPos > parser.MaxFailPos)
                parser.MaxFailPos = maxFailPos;
              return -1;
            }
          }
          else if (bestResult < 0)
            return curTextPos;
          else
          {
            when (curTextPos > parser.MaxFailPos)
              parser.MaxFailPos = curTextPos;
            return -1; // облом разбора
          }
        }

        //нет мемоизации префикса
        prefixAst = parser.Allocate(PrefixOfs.NodeSize, PrefixId);
        parser.ast[prefixAst + PrefixOfs.Next] = parser.memoize[curTextPos];
        parser.memoize[curTextPos] = prefixAst;
        when (curTextPos >= text.Length)
          return -1;
        i = 0;
        c = text[curTextPos];
        bestResult = 0;
        lastResult = 0;
        for (; i < PrefixRules.Length; ++i)
        {
          def prefixRule = PrefixRules[i];
          when (prefixRule.LowerBound <= c && c <= prefixRule.UpperBound)
          {
            newResult = -1;
            newEndPos = prefixRule.Parse(curTextPos, text, ref newResult, parser);
            // выбираем лучшее правило: побеждает то правило, у которого находится поле спарсившее больше текста
            // если оба правила имеют одинаковое кол-во полей, размеры которых идентичны, ситуация считается неоднозначностью
            when (newResult > 0)
            {
              parser.ast[newResult + AstOfs.Next] = lastResult; lastResult = newResult;//добавляем в список
              if (bestResult > 0)
              {
                if (bestEndPos < 0) if   (newEndPos >= 0) goto prefix_new_better; else goto prefix_equal;
                else                when (newEndPos < 0)  goto prefix_best_better;

                def newTokens  = parser.TokenEnumerator1.Start(newResult,  curTextPos);
                def bestTokens = parser.TokenEnumerator2.Start(bestResult, curTextPos);

                while (true)
                {
                  def newSize = newTokens.NextTokenSize();
                  def bestSize = bestTokens.NextTokenSize();
                  when (newSize > bestSize) goto prefix_new_better;
                  when (newSize < bestSize) goto prefix_best_better;
                  when (newSize < 0)        goto prefix_equal;
                }
              }
              else
                goto prefix_new_better;
            label prefix_equal;//АСТ равен лучшему. Неоднозначность.
              parser.ast[newResult] = parser.ast[newResult] | AstFlags.Equal;
              assert(bestEndPos == newEndPos);
              continue;
            label prefix_new_better;//Новый АСТ лучше
              bestEndPos = newEndPos;
              bestResult = newResult;
              parser.ast[newResult] = parser.ast[newResult] | AstFlags.Best;
              continue;
            label prefix_best_better;
              continue;
            }
          }
        }

        parser.ast[prefixAst + PrefixOfs.List] = lastResult;

        when (bestResult <= 0 || bestEndPos < 0)// не смогли разобрать префикс
        {
          when (curTextPos > parser.MaxFailPos)
            parser.MaxFailPos = curTextPos;
          parser.ast[prefixAst + PrefixOfs.MaxFailPos] = parser.MaxFailPos;
          return -1;
        }
        parser.ast[prefixAst + PrefixOfs.MaxFailPos] = parser.MaxFailPos;
        bestEndPos;
      }
    }
  }
}
