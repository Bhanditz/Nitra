using N2.Runtime.Internal;
using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Imperative;
using Nemerle.Imperative.GoTo;

using System;
using System.Collections.Generic;

namespace N2.Internal
{
  public sealed partial class ExtensibleRuleParser
  {
    public BestPrefix(mutable bestResult : int, parser : Parser) : int
    {
      while (bestResult > 0 && (parser.ast[bestResult] & AstMask.Flags) != AstFlags.Best)
        bestResult = parser.ast[bestResult + AstOfs.Next];
      bestResult;
    }

    public ParsePrefix(mutable curTextPos : int, text : string, parser : Parser) : int
    {
      unchecked
      {
        mutable prefixAst;
        mutable state = ExtensionRuleParserState();
        state.parser = parser;
        state.curTextPos = curTextPos;

        prefixAst = parser.TryGetAst(curTextPos, PrefixId);
        when (prefixAst > 0)
        {
          def maxFailPos = parser.ast[prefixAst + PrefixOfs.MaxFailPos];
          when (parser.MaxFailPos < maxFailPos)
            parser.MaxFailPos = maxFailPos;
          state.bestResult = BestPrefix(parser.TryGetPrefix(ref curTextPos, ref prefixAst), parser);
          if (state.bestResult > 0)
          {
            def astState = parser.ast[state.bestResult + AstOfs.State];
            if (astState == Parser.AstParsedState)
              return curTextPos + GetPrefixSize(state.bestResult, parser);
            else if (astState < 0)
              assert3(false)
            else
            {
              def prefixRule = PrefixRuleParser(state.bestResult, parser);
              def maxFailPos = parser.ast[state.bestResult + AstOfs.Sizes + prefixRule.FieldsCount - 1];
              when (maxFailPos > parser.MaxFailPos)
                parser.MaxFailPos = maxFailPos;
              return -1;
            }
          }
          else if (state.bestResult < 0)
            return curTextPos;
          else
          {
            when (curTextPos > parser.MaxFailPos)
              parser.MaxFailPos = curTextPos;
            return -1; // облом разбора
          }
        }

        //нет мемоизации префикса
        prefixAst = parser.Allocate(PrefixOfs.NodeSize, PrefixId);
        parser.ast[prefixAst + PrefixOfs.Next] = parser.memoize[curTextPos];
        parser.memoize[curTextPos] = prefixAst;
        when (curTextPos >= text.Length)
          return -1;
        def c = text[curTextPos]; // временная переменная для отсечения правил по первой букве
        state.bestResult = 0;
        state.bestEndPos = -1;
        state.lastResult = 0;
        for (mutable i = PrefixRules.Length - 1; i >= 0; --i)
        {
          def prefixRule = PrefixRules[i];
          when (prefixRule.LowerBound <= c && c <= prefixRule.UpperBound)
          {
            state.newResult = -1;
            state.newEndPos = prefixRule.Parse(curTextPos, text, ref state.newResult, parser);
            when (state.newResult > 0)
              state.Append();
          }
        }

        parser.ast[prefixAst + PrefixOfs.List] = state.lastResult;

        when (state.bestResult <= 0 || state.bestEndPos < 0)// не смогли разобрать префикс
        {
          when (curTextPos > parser.MaxFailPos)
            parser.MaxFailPos = curTextPos;
          parser.ast[prefixAst + PrefixOfs.MaxFailPos] = parser.MaxFailPos;
          return -1;
        }
        parser.ast[prefixAst + PrefixOfs.MaxFailPos] = parser.MaxFailPos;
        state.bestEndPos;
      }
    }
  }
}
