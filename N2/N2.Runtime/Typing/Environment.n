using N2.Runtime;

using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;

namespace N2.Typing
{
  public class Environment
  {
    public Root        : HierarchyNode;
    public Project     : Project;
    public OpenNodes   : list[HierarchyNode];
    public CurrentNode : HierarchyNode;
    public Aliases     : list[string * list[string]];
    public Defines     : Map[string, bool];
    
    public this(root : HierarchyNode, project : Project)
    {
      this(root, project, [], root, [], Map())
    }

    private this(
      root        : HierarchyNode,
      project     : Project,
      openNodes   : list[HierarchyNode],
      currentNode : HierarchyNode,
      aliases     : list[string * list[string]],
      defines     : Map[string, bool])
    {
      Root        = root;
      Project     = project;
      OpenNodes   = openNodes;
      CurrentNode = currentNode;
      Aliases     = aliases;
      Defines     = defines;
    }

    public AddAlias(alias : string, path : list[string], _loc : Location) : Environment
    {
      Environment(Root, Project, OpenNodes, CurrentNode, (alias, path) :: Aliases, Defines)
    }
    
    public AddOpen(path : list[string], loc : Location) : Environment
    {
      match (path)
      {
        | head :: tail =>
          mutable possible_expansions = [Root.AddNode(path)];
          foreach ((alias, fullPath) when alias == head in Aliases)
            possible_expansions ::= Root.AddNode(fullPath).AddNode(tail);

          AddOpen(possible_expansions, loc)

        | _ => assert(false, "empty or null namespace cannot be opened")
      }
    }
    
    public AddOpen(nodes : list[HierarchyNode], loc : Location) : Environment
    {
      mutable allOpened = nodes;
      foreach (node in nodes)
      {
        // in case we are inside some namespace, we must open every namespace path
        // composed of current namespace's parts suffixed with opened one
        def openNested(curr : HierarchyNode)
        {
          unless (curr.Parent == null)
          {
            allOpened = curr.AddNode(node.FullNameParts) :: allOpened;
            openNested (curr.Parent)
          }
        }
        
        openNested(CurrentNode);
      }

      // we will warn if some of those namespace are already open
      def new_opened = AddOpenNodes(OpenNodes, allOpened, loc, true);

      Environment(Root, Project, new_opened, CurrentNode, Aliases, Defines)
    }

    /// this is the auxiliary function for making set of opened namespaces
    /// unique and warn if namespaces are opened multiple times by user
    private AddOpenNodes(old : list[HierarchyNode], added : list[HierarchyNode], loc : Location, should_warn : bool) : list[HierarchyNode]
    {
      def nodes = added.FoldLeft(old, 
        (x, acc) =>
          if (NList.ContainsRef(old, x))
          {
            when (should_warn)
              Project.Warning(loc, $ @"namespace `$(x.FullName)' is already open", 105);
            acc
          }
          else
            x :: acc
      );
      nodes
    }
  }
}
