using System.Reflection;
using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.IO;
using System.Collections.Generic;
using System.Linq;

namespace N2.Typing
{
  public module ExportableSymbolReader
  {
    public Read(symbolRegistry : ExternalSymbolReaderRegistry, root : NamespaceSymbol, buffer : BinaryReader) : void
    {
      def nodes = ReadNameTree(root.Node, buffer);
      ReadSymbols(symbolRegistry, nodes, buffer);
    }

    private ReadNameTree(rootNode : HierarchyNode, buffer : BinaryReader) : Dictionary[int, HierarchyNode]
    {
      def nodes = Dictionary();
      def blockSize   = buffer.ReadInt32();
      def blockEndPos = blockSize + buffer.BaseStream.Position;
      while (buffer.BaseStream.Position < blockEndPos)
      {
        def id       = buffer.ReadInt32();
        def parentId = buffer.ReadInt32();
        def partName = buffer.ReadString();

        def parent   = if (parentId == -1) rootNode else nodes[parentId];
        def node     = parent.AddNode(partName);
        nodes.Add(id, node);
      }
      nodes
    }

    private ReadSymbols(symbolRegistry : ExternalSymbolReaderRegistry, nodes : Dictionary[int, HierarchyNode], buffer : BinaryReader) : void
    {
      def blockSize   = buffer.ReadInt32();
      def blockEndPos = blockSize + buffer.BaseStream.Position;
      while (buffer.BaseStream.Position < blockEndPos)
      {
        def symbolTypeId = buffer.ReadString();
        def symbolReader = symbolRegistry.Resolve(symbolTypeId);
        symbolReader.Invoke(nodes, buffer);
      }
    }
  }
}
