using Nemerle;
using Nemerle.Imperative;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using SCG = System.Collections.Generic;
using System.Linq;
using N2.Internal;

namespace N2.Runtime
{
  public abstract class AstWalkerBase
  {
    public abstract Init(compositeAstWalker : CompositeAstWalker) : void;
  }

  // Этот абстрактный базовый класс не нужен. Можно сразу генерировать конкретную реализацию SimpleRuleWalker.
  public abstract class SimpleRuleWalker[T] : AstWalkerBase
  {
    public abstract RuleId : int { get; }
    public abstract Walk(pos : ref int, parser : ref Parser) : T;
  }

  // этот и следующий класс нужны, так как они кладутся в массивы в классе ExtensibleRuleWalker. 
  public abstract class PrefixRuleWalker[T] : AstWalkerBase
  {
    public abstract Walk(pos : ref int, astPtr : int, parser : ref Parser) : T;
  }

  public abstract class PostfixRuleWalker[T] : AstWalkerBase
  {
    public abstract Walk(prefix : T, startPos : int, pos : ref int, astPtr : int, parser : ref Parser) : T;
  }

  // Этот абстрактный базовый класс не нужен. Можно сразу генерировать конкретную реализацию SimpleRuleWalker.
  // Для этого класса нужно объявить базовый класс в который вынести функции идущие в конце файла.
  public class ExtensibleRuleWalker[T] : ExtensibleRuleWalkerBase
  {
    public PrefixWalkers : array[PrefixRuleWalker[T]];   // генерируется с конкретными типами
    public PostfixWalkers : array[PostfixRuleWalker[T]]; // генерируется с конкретными типами

    public this(walkerData : ExtensibleRuleWalkerData[T], parser : ExtensibleRuleParser)
    {
      base(parser);

      PrefixWalkers         = walkerData.PrefixWalkers;
      PostfixWalkers        = walkerData.PostfixWalkers;
    }

    // этот код доджен генерироваться генератором волокеров и подставляться по мнесту.
    public virtual OnPrefixAmbiguity(startPos : int, endPos : int, parser : ref Parser, ambiguities : SCG.List[T * PrefixRuleWalker[T]]) : T
    {
      _ = parser;
      _ = endPos;
      throw PrefixAmbiguityException($"Ambiguity between prefix rules of '$RuleFullName'.", startPos, Parser, ambiguities);
    }

    // этот код доджен генерироваться генератором волокеров и подставляться по мнесту.
    public virtual OnPostfixAmbiguity(startPos : int, endPos : int, parser : ref Parser, ambiguities : SCG.List[T * PostfixRuleWalker[T]]) : T
    {
      _ = parser;
      _ = endPos;
      throw PostfixAmbiguityException($"Ambiguity between postfix rules of '$RuleFullName'.", startPos, Parser, ambiguities);
    }

    // этот код доджен генерироваться генератором волокеров и подставляться по мнесту.
    public virtual OnPrefixMissed(pos : int, parser : ref Parser) : T
    {
      _ = parser;
      throw PrefixMissedException($"Expected '$RuleFullName' rule.", pos, Parser);
    }

    // этот код должен генерироваться, так как через него протаскиваются параметры и возвращаемое значение.
    public Walk(pos : ref int, parser : ref Parser) : T
    {
      mutable newPos;
      mutable ast = FindFirstPrefix(pos, ref parser);
      if (ast > 0)
      {
        mutable prefixWalker = PrefixWalkers[parser.ast[ast + ExtensibleRuleParser.AstOfs.Id] - PrefixWalkersOffset];
        newPos = pos;
        def prefixStartPos = pos;
        mutable prefixValue = prefixWalker.Walk(ref newPos, ast, ref parser);
        ast = FindNextPrefix(ast, ref parser);
        when (ast > 0)
        {
          def firstNewPos = newPos;
          def ambiguilitys = SCG.List();
          ambiguilitys.Add((prefixValue, prefixWalker));
          while (ast > 0)
          {
            def nextPrefixWalker = PrefixWalkers[parser.ast[ast + ExtensibleRuleParser.AstOfs.Id] - PrefixWalkersOffset];
            newPos = pos;
            def nextValue = nextPrefixWalker.Walk(ref newPos, ast, ref parser);
            assert(newPos == firstNewPos);
            ambiguilitys.Add((nextValue, nextPrefixWalker));
            prefixWalker = nextPrefixWalker;
            ast = FindNextPrefix(ast, ref parser);
          }
          prefixValue = OnPrefixAmbiguity(pos, firstNewPos, ref parser, ambiguilitys);
        }
        pos = newPos;

        mutable postfixWalker;
        mutable postfixValue;
        while (pos < parser.Text.Length && { ast = FindFirstPostfix(pos, ref parser); ast > 0 })
        {
          postfixWalker = PostfixWalkers[(parser.ast[ast + ExtensibleRuleParser.AstOfs.Id] & ExtensibleRuleParser.PostfixMask.Id) - PostfixWalkersOffset];
          newPos = pos;
          postfixValue = postfixWalker.Walk(prefixValue, prefixStartPos, ref newPos, ast, ref parser);
          when (newPos == pos)
            break;
          ast = FindNextPostfix(ast, ref parser);
          when (ast > 0)
          {
            def firstNewPos = newPos;
            def ambiguilitys = SCG.List();
            ambiguilitys.Add((postfixValue, postfixWalker));
            while (ast > 0)
            {
              def nextWalker = PostfixWalkers[(parser.ast[ast + ExtensibleRuleParser.AstOfs.Id] & ExtensibleRuleParser.PostfixMask.Id) - PostfixWalkersOffset];
              newPos = pos;
              def nextValue = nextWalker.Walk(prefixValue, prefixStartPos, ref newPos, ast, ref parser);
              assert(newPos == firstNewPos);
              ambiguilitys.Add((nextValue, nextWalker));
              postfixWalker = nextWalker;
              ast = FindNextPostfix(ast, ref parser);
            }
            postfixValue = OnPostfixAmbiguity(pos, firstNewPos, ref parser, ambiguilitys);
          }
          prefixValue = postfixValue;
          pos = newPos;
        }
        prefixValue;
      }
      else
      {
        OnPrefixMissed(pos, ref parser);
      }
    }
  }
}
