using Nemerle;
using Nemerle.Imperative;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using SCG = System.Collections.Generic;
using System.Linq;
using N2.Internal;

namespace N2.Runtime
{
  public class AstWalkers
  {
    public Grammar                  : CompositeGrammar;
    public AstWalkerDescriptors     : SCG.HashSet[AstWalkerDescriptor];
    public AstWalkerHost            : AstWalkerHost;

    public SimpleWalkers            : Hashtable[SimpleRuleDescriptor, Internal.SimpleRuleParser];
    public ExtensibleRules          : Hashtable[ExtensibleRuleDescriptor, ExtensibleRuleParserData] = Hashtable();

    public this(host : AstWalkerHost, grammar : CompositeGrammar)
    {
      AstWalkerHost        = host;
      Grammar              = grammar;
      AstWalkerDescriptors = SCG.HashSet(grammar.Grammars.MapLazy(host.FindAstWalkerDescriptor));
    }
  }

  public abstract class AstWalkerHost
  {
    public abstract Type : AstWalkerTypeDescriptor { get; }
    public abstract FindAstWalkerDescriptor(grammar : GrammarDescriptor) : AstWalkerDescriptor;
    public NewAstWalkers(grammar : CompositeGrammar) : AstWalkers
    {
      AstWalkers(this, grammar);
    }
  }

  public abstract class AstWalkerTypeDescriptor
  {
  }

  public abstract class AstWalkerDescriptor
  {
    public abstract Type    : AstWalkerTypeDescriptor { get; }
    public abstract Grammar : GrammarDescriptor { get; }
    public abstract NewWalker(rd : RuleParser) : AstWalkerBase;
  }

  public abstract class AstWalkerBase
  {
    public abstract Init() : void;
  }

  public abstract class SimpleAstWalker[T]
  {
    public abstract Walk(pos : ref int, astPtr : int, parser : ref Parser) : T;
  }

  public abstract class PrefixAstWalker[T]
  {
    public abstract Walk(pos : ref int, astPtr : int, parser : ref Parser) : T;
  }

  public abstract class PostfixAstWalker[T]
  {
    public abstract Walk(pos : ref int, prefix : T, astPtr : int, parser : ref Parser) : T;
  }

  public class ExtensibleRuleWalker[T]
  {
    public PrefixId : int;
    public PostfixId : int;

    public FirstPostfixRule : int;
    public FirstPostfixRuleId : int;

    public PrefixRules : array[PrefixAstWalker[T]];
    public PostfixRules : array[PostfixAstWalker[T]];

    public PrefixRulesOfs : int;
    public PostfixRulesOfs : int;

    public virtual OnPrefixAmbiguility(pos : int, parser : ref Parser, walker : PrefixAstWalker[T], value : T, nextWalker : PrefixAstWalker[T], nextValue : T) : T
    {
      _ = pos;
      _ = parser;
      _ = walker;
      _ = value;
      _ = nextWalker;
      _ = nextValue;
      throw Exception("PrefixAmbiguility");
    }

    public virtual OnPostfixAmbiguility(pos : int, parser : ref Parser, walker : PostfixAstWalker[T], value : T, nextWalker : PostfixAstWalker[T], nextValue : T) : T
    {
      _ = pos;
      _ = parser;
      _ = walker;
      _ = value;
      _ = nextWalker;
      _ = nextValue;
      throw Exception("PostfixAmbiguility");
    }

    public virtual OnPrefixMissed(pos : int, parser : ref Parser) : T
    {
      _ = pos;
      _ = parser;
      throw Exception("PrefixMissed");
    }

    public this(parser : ExtensibleRuleParser)
    {
    }

    public Walk(pos : ref int, parser : ref Parser) : T
    {
      mutable newPos;
      mutable ast = FindFirstPrefix(pos, ref parser);
      if (ast > 0)
      {
        mutable prefixWalker = PrefixRules[parser.ast[ast + ExtensibleRuleParser.AstOfs.Id] - PrefixRulesOfs];
        newPos = pos;
        mutable prefixValue = prefixWalker.Walk(ref newPos, ast, ref parser);
        ast = FindNextPrefix(ast, ref parser);
        when (ast > 0)
        {
          def firstNewPos = newPos;
          while (ast > 0)
          {
            def nextPrefixWalker = PrefixRules[parser.ast[ast + ExtensibleRuleParser.AstOfs.Id] - PrefixRulesOfs];
            newPos = pos;
            def nextValue = nextPrefixWalker.Walk(ref newPos, ast, ref parser);
            assert(newPos == firstNewPos);
            prefixValue = OnPrefixAmbiguility(pos, ref parser, prefixWalker, prefixValue, nextPrefixWalker, nextValue);
            prefixWalker = nextPrefixWalker;
            ast = FindNextPrefix(ast, ref parser);
          }
        }
        pos = newPos;

        mutable postfixWalker;
        mutable postfixValue;
        for (ast = FindFirstPostfix(pos, ref parser); ast > 0; ast = FindFirstPostfix(pos, ref parser))
        {
          postfixWalker = PostfixRules[(parser.ast[ast + ExtensibleRuleParser.AstOfs.Id] & ExtensibleRuleParser.PostfixMask.Id) - PostfixRulesOfs];
          newPos = pos;
          postfixValue = postfixWalker.Walk(ref newPos, prefixValue, ast, ref parser);
          ast = FindNextPostfix(ast, ref parser);
          when (ast > 0)
          {
            def firstNewPos = newPos;
            while (ast > 0)
            {
              def nextWalker = PostfixRules[(parser.ast[ast + ExtensibleRuleParser.AstOfs.Id] & ExtensibleRuleParser.PostfixMask.Id) - PostfixRulesOfs];
              newPos = pos;
              def nextValue = nextWalker.Walk(ref newPos, prefixValue, ast, ref parser);
              assert(newPos == firstNewPos);
              postfixValue = OnPostfixAmbiguility(pos, ref parser, postfixWalker, postfixValue, nextWalker, nextValue);
              postfixWalker = nextWalker;
              ast = FindNextPostfix(ast, ref parser);
            }
          }
          prefixValue = postfixValue;
          pos = newPos;
        }
        prefixValue;
      }
      else
      {
        OnPrefixMissed(pos, ref parser);
      }
    }

    private FindFirstPrefix(pos : int, parser : ref Parser) : int
    {
      for (mutable ast = parser.memoize[pos]; ast > 0; ast = parser.ast[ast + ExtensibleRuleParser.PrefixOfs.Next])
        when (parser.ast[ast + ExtensibleRuleParser.PrefixOfs.Id] == PrefixId)
          return parser.ast[ast + ExtensibleRuleParser.PrefixOfs.List];
      0
    }

    private FindNextPrefix(prevPrefix : int, parser : ref Parser) : int
    {
      parser.ast[prevPrefix + ExtensibleRuleParser.AstOfs.Next];
    }

    private FindFirstPostfix(pos : int, parser : ref Parser) : int
    {
      for (mutable ast = parser.memoize[pos]; ast > 0; ast = parser.ast[ast + ExtensibleRuleParser.PostfixOfs.Next])
        when (parser.ast[ast + ExtensibleRuleParser.PostfixOfs.Id] == PostfixId)//нашли
        {
          mutable result = parser.ast[ast + ExtensibleRuleParser.PostfixOfs.AstList];//список разобраных с этого места правил
          // пропускаем правила с низкой силой связывания.
          while (result > 0 && (parser.ast[result] & ExtensibleRuleParser.PostfixMask.Id) < FirstPostfixRuleId)
            result = parser.ast[result + ExtensibleRuleParser.PostfixAstOfs.Next];
          // пропускаем плохие варианты.
          while (result > 0 && (parser.ast[result] & ExtensibleRuleParser.PostfixMask.Mark) == ExtensibleRuleParser.PostfixMark.Bad)
            result = parser.ast[result + ExtensibleRuleParser.PostfixAstOfs.Next];
          return result;
        }
      0
    }

    private FindNextPostfix(mutable prevPostfix : int, parser : ref Parser) : int
    {
      //если у нас лучшее значение то заканчиваем перебор
      when ((parser.ast[prevPostfix] & ExtensibleRuleParser.PostfixMask.Mark) == ExtensibleRuleParser.PostfixMark.Best)
        return 0;
      prevPostfix = parser.ast[prevPostfix + ExtensibleRuleParser.PostfixAstOfs.Next];
      // пропускаем плохие варианты.
      while (prevPostfix > 0 && (parser.ast[prevPostfix] & ExtensibleRuleParser.PostfixMask.Mark) == ExtensibleRuleParser.PostfixMark.Bad)
        prevPostfix = parser.ast[prevPostfix + ExtensibleRuleParser.PostfixAstOfs.Next];
      prevPostfix;
    }
  }
}
