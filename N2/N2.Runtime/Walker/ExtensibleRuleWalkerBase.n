using Nemerle;
using Nemerle.Imperative;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using SCG = System.Collections.Generic;
using System.Linq;
using N2.Internal;

namespace N2.Runtime
{
  public abstract class ExtensibleRuleWalkerBase
  {
    public PrefixId             : int;
    public PostfixId            : int;
    public FirstPostfixRule     : int;
    public FirstPostfixRuleId   : int;
    public PrefixWalkersOffset  : int;
    public PostfixWalkersOffset : int;
    public ParseResult               : ExtensibleRuleParser;

    public this(parser : ExtensibleRuleParser)
    {
      ParseResult                = parser;
      PrefixId              = parser.PrefixId;
      PostfixId             = parser.PostfixId;

      FirstPostfixRule      = parser.FirstPostfixRule;
      FirstPostfixRuleId    = parser.FirstPostfixRuleId;

      PrefixWalkersOffset   = if (parser.PrefixRules.Length > 0)  parser.PrefixRules[0].RuleId  else 0; //FIXME empty array
      PostfixWalkersOffset  = if (parser.PostfixRules.Length > 0) parser.PostfixRules[0].RuleId else 0; //FIXME empty array
    }

    public RuleFullName : string
    {
      get { this.ParseResult.Descriptor.Grammar.Name + "." + this.ParseResult.Descriptor.Name }
    }

    private SkipBadResults(mutable result : int, parser : ParseResult) : int
    {
      while (result > 0 && ((parser.ast[result] & ExtensibleRuleParser.AstMask.Flags) == ExtensibleRuleParser.AstFlags.Bad || parser.ast[result + ExtensibleRuleParser.AstOfs.State] != N2.Internal.ParseResult.AstParsedState))
        result = parser.ast[result + ExtensibleRuleParser.AstOfs.Next];
      result
    }

    protected FindFirstPrefix(pos : ref int, parser : ParseResult) : int
    {
      mutable ast = parser.TryGetAst(pos, PrefixId);
      when (ast > 0)
        return SkipBadResults(parser.TryGetPrefix(ref pos, ref ast), parser);
      0
    }

    protected FindNextPrefix(result : int, parser : ParseResult) : int
    {
      //если у нас лучшее значение то заканчиваем перебор
      when ((parser.ast[result] & ExtensibleRuleParser.AstMask.Flags) == ExtensibleRuleParser.AstFlags.Best)
        return 0;
      SkipBadResults(parser.ast[result + ExtensibleRuleParser.AstOfs.Next], parser)
    }

    protected FindFirstPostfix(pos : ref int, parser : ParseResult) : int
    {
      mutable ast = parser.TryGetAst(pos, PostfixId);
      when (ast > 0)
      {
        mutable result = parser.TryGetPostfix(ref pos, ref ast);
        // пропускаем правила с низкой силой связывания.
        while (result > 0 && (parser.ast[result] & ExtensibleRuleParser.AstMask.Id) < FirstPostfixRuleId)
          result = parser.ast[result + ExtensibleRuleParser.AstOfs.Next];
        return SkipBadResults(result, parser);
      }
      0
    }

    protected FindNextPostfix(result : int, parser : ParseResult) : int
    {
      //если у нас лучшее значение то заканчиваем перебор
      when ((parser.ast[result] & ExtensibleRuleParser.AstMask.Flags) == ExtensibleRuleParser.AstFlags.Best)
        return 0;
      SkipBadResults(parser.ast[result + ExtensibleRuleParser.AstOfs.Next], parser)
    }
  }
}
