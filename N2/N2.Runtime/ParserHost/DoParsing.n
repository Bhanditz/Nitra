using Nemerle;
using Nemerle.Assertions;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using N2.Internal;
using N2.Runtime;

using System;
using SCG = System.Collections.Generic;

namespace N2
{
  public partial class ParserHost
  {
    public DoParsing(source : SourceSnapshot, descriptor : SimpleRuleDescriptor) : Parser
    {
      DoParsing(source, AddGrammar(DefaultCompositeGrammar, descriptor.Grammar), descriptor)
    }

    public DoParsing(source : SourceSnapshot, grammar : CompositeGrammar, descriptor : SimpleRuleDescriptor) : Parser
    {
      DoParsing(source, grammar.GetSimpleRuleParser(descriptor))
    }

    public DoParsing(source : SourceSnapshot, descriptor : ExtensibleRuleDescriptor) : Parser
    {
      DoParsing(source, AddGrammar(DefaultCompositeGrammar, descriptor.Grammar), descriptor)
    }

    public DoParsing(source : SourceSnapshot, grammar : CompositeGrammar, descriptor : ExtensibleRuleDescriptor) : Parser
    {
      DoParsing(source, grammar.GetExtensibleRuleParser(descriptor, 0))
    }

    private DoParsing(source : SourceSnapshot, ruleParser : StartRuleParser) : Parser
    {
      mutable parser = N2.Internal.Parser(source, source.Text.Length * 10, this, ruleParser);
      _ = parser.Allocate(2);
      mutable res = ruleParser.Parse(0, parser.Text, parser);
      while (res < 0)
      {
        parser.RecoveryStack.Clear();
        parser.RecoveryStacks.Clear();
        parser.ParsingMode = ParsingMode.Recovery;
        parser.IgnoreRecovery = false;
        res = ruleParser.FindRecoveryPosition(0, parser.Text, parser);

        this.RecoveryStrategy(parser.MaxFailPos, parser);

        assert2(parser.ParsingMode == ParsingMode.EndRecovery);
        assert(parser.ParsingMode == ParsingMode.EndRecovery);

        parser.ParsingMode = ParsingMode.Parsing;
        res = ruleParser.Parse(0, parser.Text, parser);
      }

      parser.ast[Parser.ResultOffset] = res;

      parser
    }
  }
}
