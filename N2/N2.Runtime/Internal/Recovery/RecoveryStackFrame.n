using Nemerle;
using Nemerle.Collections;
using Nemerle.Imperative;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Extensions;

using System;
using System.Text;
using SCG = System.Collections.Generic;
using System.Linq;

namespace N2.Internal
{
  public enum RecoveryStackFrameMode
  {
    | Optional
    | Required
    | Both
  }

  [Record]
  [StructuralEquality]
  public variant RecoveryStackFrame
  {
    [RecordIgnore, EqualsIgnore] public mutable Index            : int;
    [RecordIgnore, EqualsIgnore] public mutable Depth            : int = 0;
    [RecordIgnore, EqualsIgnore] public         Parents          : SCG.HashSet[RecoveryStackFrame] = SCG.HashSet();
    [RecordIgnore, EqualsIgnore] public         Children         : SCG.List[RecoveryStackFrame] = SCG.List();
    [RecordIgnore, EqualsIgnore] public mutable Mode             : RecoveryStackFrameMode = RecoveryStackFrameMode.Both;

    [RecordIgnore, EqualsIgnore] public mutable StartState       : int;
    [RecordIgnore, EqualsIgnore] public mutable StartParsePos    : int;
    [RecordIgnore, EqualsIgnore] public mutable EndParsePos      : int;
    [RecordIgnore, EqualsIgnore] public mutable MaxFailPos       : int;

    public TextPos      : int;

    | Extensible
      {
        RuleParser   : ExtensibleRuleParser;
        State        : int;
        public override GetNextState(state : int) : int { | 0 => 1 | _ => -1 }
      }

    | ExtensiblePrefix
      {
        AstHandle    : AstHandle.ExtensiblePrefix;
        RuleParser   : ExtensibleRuleParser;
        public override GetNextState(state : int) : int { _ = state; -1 }
      }

    | ExtensiblePostfix
      {
        AstHandle    : AstHandle.ExtensiblePostfix;
        RuleParser   : ExtensibleRuleParser;
        public override GetNextState(state : int) : int { _ = state; -1 }
      }

    | Rule
      {
        AstHandle    : AstHandle;
        State        : int;
        public override GetNextState(state : int) : int { GetRuleParser().GetNextState(state) }
      }

    | ListBody
      {
        AstHandle    : AstHandle.Subrule;
        State        : int;
        Counter      : int;
        public override GetNextState(state : int) : int { GetRuleParser().GetNextState(state) }
      }

    | ListSeparator
      {
        AstHandle    : AstHandle.Subrule;
        State        : int;
        Counter      : int;
        public override GetNextState(state : int) : int { GetRuleParser().GetNextState(state) }
        public override GetLoopBodyFrameForSeparatorState(textPos : int, parser : Parser) : RecoveryStackFrame.ListSeparator
        {
          mutable bodyId;
          mutable firstState;
          if (AstHandle.RuleParser.GetLoopBodyForSeparator(AstHandle.RuleId, out bodyId, out firstState))
          {
            assert3(Parents.Count == 1);
            def parent = Parents.First();
            def astHandle = parser.AstHandle_Subrule(AstHandle.RuleParser, bodyId, -1, textPos);
            def frame = parser.RecoveryStackFrame_ListSeparator_AlwaysReturn(parent, textPos, astHandle, firstState, Counter);
            frame
          }
          else
            null
        }
      }

    public IsPrefixParsed : bool
    {
      get
      {
        match (this)
        {
          | ListBody     (_, state, _) 
          | ListSeparator(_, state, _)
          | Rule         (_, state) =>
            def parser = GetRuleParser();
            for (mutable i = parser.GetStartState(state); i < state; i = parser.GetNextState(i))
              unless (parser.IsVoidState(i))
                return true;
            false
            
          | Extensible        as frame => frame.State != 0
          | ExtensiblePrefix           => false
          | ExtensiblePostfix          => false
        }
      }
    }
    
    public IsLoopSeparatorStart : bool { get { this is ListSeparator } }
    
    public FailState : int
    {
      get
      {
        match (this)
        {
          | ListBody     (_, state, _) 
          | ListSeparator(_, state, _)
          | Extensible   (_, state)
          | Rule         (_, state) => state
          | ExtensiblePrefix
          | ExtensiblePostfix => 0
        }
      }
    }
    
    public IsVoidState(state : int) : bool
    {
      match (this)
      {
        | ListBody
        | ListSeparator
        | Rule              => GetRuleParser().IsVoidState(state)
        | Extensible
        | ExtensiblePrefix
        | ExtensiblePostfix => false
      }
    }
    
    public abstract GetNextState(state : int) : int;
    public virtual GetLoopBodyFrameForSeparatorState(textPos : int, parser : Parser) : RecoveryStackFrame.ListSeparator { IgnoreParams(); null }

    public GetSpeculativeFramesForState(textPos : int, parser : Parser, state : int) : array[RecoveryStackFrame]
    {
      def parent = if (FailState == state)
        this
      else
      {
        def newFrame = match (this)
        {
          | Extensible        as frame => parser.RecoveryStackFrame_Extensible_AlwaysReturn   (null, frame.TextPos, frame.RuleParser, state)
          | ExtensiblePrefix           => assert3(false)
          | ExtensiblePostfix          => assert3(false)
          | ListBody          as frame => parser.RecoveryStackFrame_ListBody_AlwaysReturn     (null, frame.TextPos, frame.AstHandle, state, frame.Counter)
          | ListSeparator     as frame => parser.RecoveryStackFrame_ListSeparator_AlwaysReturn(null, frame.TextPos, frame.AstHandle, state, frame.Counter)
          | Rule              as frame => parser.RecoveryStackFrame_Rule_AlwaysReturn         (null, frame.TextPos, frame.AstHandle, state)
        }
        newFrame.Parents.UnionWith(Parents);
        newFrame
      }
      def makeExtentionFrame(ruleParser)
      {
        def handle = parser.AstHandle_Extention(ruleParser, -1, textPos);
        parser.RecoveryStackFrame_Rule_AlwaysReturn(parent, textPos, handle, ruleParser.StartState)
      }
      match (parent)
      {
        | Extensible as frame =>
          match (frame.State)
          {
            | 0 => array[parser.RecoveryStackFrame_ExtensiblePrefix_AlwaysReturn(parent, textPos, parser.AstHandle_Prefix(frame.RuleParser.ParserData, -1, textPos), frame.RuleParser)]
            | 1 => array[parser.RecoveryStackFrame_ExtensiblePostfix_AlwaysReturn(parent, textPos, parser.AstHandle_Postfix(frame.RuleParser.ParserData, -1, textPos), frame.RuleParser)]
            | _ => assert3(false)
          }
        | ExtensiblePrefix  as frame => frame.RuleParser.PrefixRules.MapToArray(makeExtentionFrame)
        | ExtensiblePostfix as frame => frame.RuleParser.PostfixRules.Skip(frame.RuleParser.FirstPostfixRule).MapToArray(makeExtentionFrame)
        | ListBody
        | ListSeparator
        | Rule =>
          def ruleParser = GetRuleParser();
          match (ruleParser.GetRuleParserForState(state))
          {
            | null                               => array[]//TODO:Fix lists & option
            | ExtensibleRuleParser as ruleParser => array[parser.RecoveryStackFrame_Extensible_AlwaysReturn(parent, textPos, ruleParser, 0)]
            | SimpleRuleParser     as ruleParser => array[parser.RecoveryStackFrame_Rule_AlwaysReturn(parent, textPos, parser.AstHandle_Simple(ruleParser, -1, textPos), ruleParser.StartState)]
            | _ => assert3(false)
          }
      }
    }


    public IsTokenRule : bool
    {
      get
      {
        match (this)
        {
          | ListBody
          | ListSeparator => false
          | Extensible as frame => frame.RuleParser.IsTokenRule
          | ExtensiblePrefix
          | ExtensiblePostfix => false
          | Rule(handle, _) => 
            match (handle)
            {
              | Simple
              | Extention => GetRuleParser().IsTokenRule // ???
              | _ => false
            }
        }
      }
    }

    public IsSpeculative : bool
    {
      get
      {
        match (this)
        {
          | ExtensiblePrefix(handle, _)
          | ExtensiblePostfix(handle, _)
          | ListBody     (handle, _, _)
          | ListSeparator(handle, _, _)
          | Rule         (handle, _) => handle.AstPtr < 0
          | Extensible               => false //TODO: Подумать как это реализовать правильно.
        }
      }
    }

    public GetRuleParser() : IRecoveryRuleParser
    {
      match (this)
      {
        | ExtensiblePrefix  as frame => frame.RuleParser
        | ExtensiblePostfix as frame => frame.RuleParser
        | ListBody          as frame => frame.AstHandle.RuleParser
        | ListSeparator     as frame => frame.AstHandle.RuleParser
        | Rule              as frame =>
          match (frame.AstHandle)
          {
            | Extention as handle => handle.RuleParser
            | Subrule   as handle => handle.RuleParser
            | Simple    as handle => handle.RuleParser
            | _                   => assert3(false)
          }

        | Extensible        as frame => frame.RuleParser
      }
    }

    public TryParse(state : int, curTextPos : int, continueList : bool, parsedStates : SCG.List[ParsedStateInfo], parser : Parser) : int
    {
      match (this)
      {
        | ExtensiblePrefix
        | ExtensiblePostfix
        | ListBody
        | ListSeparator
        | Rule
        | Extensible        => GetRuleParser().TryParse(this, state, curTextPos, continueList, parsedStates, parser)
      }
    }
    
    public Dot : string
    {
      get
      {
        DotStacks([this])
      }
    }

    static _colors = array["aquamarine", "beige", "brown1", "burlywood1", "cadetblue1", "chartreuse1", "coral1", "darkorchid2", "deepskyblue2", "gold1", "azure3", "aquamarine3", "deeppink", "blue1", "brown", "cadetblue", "darkorchid1", "antiquewhite4", "aquamarine4", "azure4", "bisque3", "burlywood", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk4", "cyan3", "darkgoldenrod3", "darkolivegreen1", "darkorange1", "darkseagreen", "darkslateblue", "darkslategray4", "deeppink1", "deepskyblue1", "dimgrey", "dodgerblue4", "firebrick4", "gold", "goldenrod"];

    public static DotStacks(stacks : Seq[RecoveryResult]) : string
    {
      DotStacks(stacks.Map(r => r.Stack))
    }

    public static DotStacks(stacks : Seq[RecoveryStackFrame]) : string
    {
      def map = Hashtable();
      def fillMap(frame : RecoveryStackFrame) : void
      {
        mutable counter;
        _ = map.TryGetValue(frame, out counter);
        
        map[frame] = counter + 1;
        
        foreach (subFrame in frame.Parents)
          fillMap(subFrame);
          
      }
      foreach (frame in stacks) 
        fillMap(frame);
      
      def name(frame : RecoveryStackFrame) : string
      {
        frame.GetRuleParser().RuleName + "_" + frame.TypeName + "_" + frame.TextPos + "_" + frame.FailState
      }
      def visited = SCG.HashSet();
      def nodes = SCG.List();
      def edges = SCG.List();
      def label(frame : RecoveryStackFrame, index : int) : string
      {
        def parser = frame.GetRuleParser();
        def makeCode()
        {
          def str = parser.CodeWithStates.Replace("\"", "\\\"");
          def count = 30;
          def sb = StringBuilder();
          def parts = str.Split(array[' '], StringSplitOptions.RemoveEmptyEntries);
          mutable len = 0;
          foreach (part in parts)
          {
            len += part.Length;
            if (len > count)
            {
              len = 0;
              _ = sb.Append("\n  ");
            }
            else
              _ = sb.Append(" ");
            _ = sb.Append(part);
          }
          
          sb.ToString();
        }
        def failRuleCode = "\n" + makeCode();
        def color = if (map[frame] == 1 && index < _colors.Length) $" color=$(_colors[index]) style=filled" else "";
        def label = $"$(parser.RuleName) P=$(frame.TextPos) F=$(frame.FailState) T=$(frame.TypeName) D=$(frame.Depth) S=$(frame.IsSpeculative)";
        def parseData = $"\nStartState=$(frame.StartState) StartParsePos=$(frame.StartParsePos) EndParsePos=$(frame.EndParsePos) MaxFailPos=$(frame.MaxFailPos)";
        name(frame) + $<#[label="$label$parseData$failRuleCode"$color shape=box]#>
      }
      def visitNodes(frame : RecoveryStackFrame, index : int) : void
      {
        when (visited.Add(frame))
        {
          nodes.Add(frame, index);
          foreach (sunFrame in frame.Parents)
          {
            edges.Add($"$(name(frame)) -> $(name(sunFrame)) [dir=back]");
            visitNodes(sunFrame, index);
          }
        }
      }
      foreach (frame in stacks with i)
        visitNodes(frame, i);
      $<#
digraph RecoveryStackFrame
{
  ..$(nodes; ";\n  "; label);
  ..$(edges; ";\n  ");
}#>
    }

    public TypeName : string
    {
      get
      {
        match (this)
        {
          | ExtensiblePrefix  => "Prefix"
          | ExtensiblePostfix => "Postfix"
          | ListBody          => "ListBody"
          | ListSeparator     => "ListSeparator"
          | Rule              => "Rule"
          | Extensible        => "Extensible"
        }
      }
    }
    
    public override ToString() : string
    {
      def ruleParser = GetRuleParser();
      $"$TypeName: $(ruleParser.RuleName) = $(ruleParser.CodeWithStates) FailState=$FailState TextPos=$TextPos"
    }
  }
}
