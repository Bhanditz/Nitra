using Nemerle;
using Nemerle.Collections;
using Nemerle.Imperative;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Extensions;

using System;
using SCG = System.Collections.Generic;
using System.Linq;

namespace N2.Internal
{
  [Record]
  [StructuralEquality]
  public variant RecoveryStackFrame
  {
    [RecordIgnore]
    [EqualsIgnore]
    public Parents      : SCG.HashSet[RecoveryStackFrame] = SCG.HashSet();

    | Extensible
      {
        RulePraser   : ExtensibleRuleParser;
        TextPos      : int;
        State        : int;
        public override GetNextState(state : int) : int { | 0 => 1 | _ => -1 }
        public override GetLoopBodyFrameForSeparatorState(textPos : int, parser : Parser) : RecoveryStackFrame.ListSeparator { IgnoreParams(); null }
        //public override GetFramesForState(startState : int, parser : Parser, parent : RecoveryStackFrame, textPos : int) : array[RecoveryStackFrame]
        //{
        //  match (startState)
        //  {
        //    | 0 => this.PrefixRules.MapToArray(x => x.GetFrameForFirstState(parser, parent, textPos))
        //    | 1 => this.PostfixRules.Skip(FirstPostfixRule).MapToArray(x => x.GetFrameForFirstState(parser, parent, textPos))
        //    | _ => assert3(false)
        //  }
        //}
      }

    | ExtensiblePrefix
      {
        AstHandle    : AstHandle.ExtensiblePrefix;
        public override GetNextState(state : int) : int { _ = state; -1 }
        public override GetLoopBodyFrameForSeparatorState(textPos : int, parser : Parser) : RecoveryStackFrame.ListSeparator { IgnoreParams(); null }
      }

    | ExtensiblePostfix
      {
        AstHandle    : AstHandle.ExtensiblePostfix;
        public override GetNextState(state : int) : int { _ = state; -1 }
        public override GetLoopBodyFrameForSeparatorState(textPos : int, parser : Parser) : RecoveryStackFrame.ListSeparator { IgnoreParams(); null }
      }

    | Rule
      {
        AstHandle    : AstHandle;
        State        : int;
        public override GetNextState(state : int) : int { AstHandle.GetRuleParser().GetNextState(state) }
        public override GetLoopBodyFrameForSeparatorState(textPos : int, parser : Parser) : RecoveryStackFrame.ListSeparator { IgnoreParams(); null }
      }

    | ListBody
      {
        AstHandle    : AstHandle.Subrule;
        State        : int;
        Counter      : int;
        public override GetNextState(state : int) : int { AstHandle.GetRuleParser().GetNextState(state) }
        public override GetLoopBodyFrameForSeparatorState(textPos : int, parser : Parser) : RecoveryStackFrame.ListSeparator { IgnoreParams(); null }
      }

    | ListSeparator
      {
        AstHandle    : AstHandle.Subrule;
        State        : int;
        Counter      : int;
        public override GetNextState(state : int) : int { AstHandle.GetRuleParser().GetNextState(state) }
        public override GetLoopBodyFrameForSeparatorState(textPos : int, parser : Parser) : RecoveryStackFrame.ListSeparator
        {
          mutable bodyId;
          mutable firstState;
          if (AstHandle.RuleParser.GetLoopBodyForSeparator(AstHandle.RuleId, out bodyId, out firstState))
          {
            assert3(Parents.Count == 1);
            def parent = Parents.First();
            def astHandle = parser.GetSubruleAstHandle(AstHandle.RuleParser, bodyId, textPos);
            def frame = parser.RecoveryStackFrame_ListSeparator(parent, astHandle, firstState, Counter);
            frame
          }
          else
            null
        }
      }

    public IsPrefixParsed : bool
    {
      get
      {
        match (this)
        {
          | ListBody     (handle, state, _) 
          | ListSeparator(handle, state, _)
          | Rule         (handle, state) =>
            def parser = handle.GetRuleParser();
            for (mutable i = parser.GetStartState(state); i < state; i = parser.GetNextState(i))
              unless (parser.IsVoidState(i))
                return true;
            false
            
          | Extensible        as frame => frame.State != 0
          | ExtensiblePrefix           => false
          | ExtensiblePostfix          => false
        }
      }
    }
    
    public IsLoopSeparatorStart : bool { get { this is ListSeparator } }
    
    public FailState : int
    {
      get
      {
        match (this)
        {
          | ListBody     (_, state, _) 
          | ListSeparator(_, state, _)
          | Extensible(_, _, state)
          | Rule         (_, state) => state
          | ExtensiblePrefix
          | ExtensiblePostfix => 0
        }
      }
    }
    
    public IsVoidState(state : int) : bool
    {
      match (this)
      {
        | ListBody     (handle, _, _) 
        | ListSeparator(handle, _, _)
        | Rule         (handle, _) => handle.GetRuleParser().IsVoidState(state)
        | Extensible
        | ExtensiblePrefix
        | ExtensiblePostfix        => false
      }
    }
    
    public abstract GetNextState(state : int) : int;
    public abstract GetLoopBodyFrameForSeparatorState(textPos : int, parser : Parser)              : RecoveryStackFrame.ListSeparator;
    public abstract GetFramesForState                (textPos : int, parser : Parser, state : int) : array[RecoveryStackFrame];
    
    public IsTokenRule : bool
    {
      get
      {
        match (this)
        {
          | ListBody      
          | ListSeparator => false
          | Extensible as frame => frame.RulePraser.IsTokenRule
          | ExtensiblePrefix
          | ExtensiblePostfix => false
          | Rule(handle, _) => 
            match (handle)
            {
              | Simple
              | Extention => handle.GetRuleParser().IsTokenRule // ???
              | _ => false
            }
        }
      }
    }

    public IsSpeculative : bool
    {
      get
      {
        match (this)
        {
          | ExtensiblePrefix(handle)
          | ExtensiblePostfix(handle)
          | ListBody     (handle, _, _) 
          | ListSeparator(handle, _, _)
          | Rule         (handle, _) => assert2(false); handle.AstPtr < 0
          | Extensible               => assert3(false)
        }
      }
    }
    
    //public RuleParser : IRecoveryRuleParser { get { this.AstHandle.GetRuleParser() } }
    //public AstPtr     : int                 { get { this.AstHandle.AstPtr } }

    //public abstract GetFrameForFirstState(                         parser : Parser, textPos : int) : RecoveryStackFrame;
    //public abstract GetFramesForState(                state : int, parser : Parser, textPos : int) : array[RecoveryStackFrame];
    //public abstract GetLoopBodyFrameForSeparatorState(state : int, parser : Parser, textPos : int) : RecoveryStackFrame;

    //public override ToString() : string
    //{
    //  def props = SCG.List();
    //  props.Add($"FailState=$FailState");
    //  when (Info != FrameInfo.None)
    //    props.Add($"Info=$Info");
    //  when (ListStartPos > 0)
    //    props.Add($"ListStartPos=$ListStartPos");
    //  when (ListEndPos > 0)
    //    props.Add($"ListEndPos=$ListEndPos");
    //  $"$(AstHandle.GetRuleParser().RuleName) = $(AstHandle.GetRuleParser().CodeWithStates)  (..$props)"
    //}
  }
}
