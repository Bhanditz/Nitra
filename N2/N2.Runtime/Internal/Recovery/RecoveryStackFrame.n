using Nemerle;
using Nemerle.Collections;
using Nemerle.Imperative;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Extensions;

using System;
using SCG = System.Collections.Generic;
using System.Linq;

namespace N2.Internal
{
  [Record]
  [StructuralEquality]
  public variant RecoveryStackFrame
  {
    [RecordIgnore]
    [EqualsIgnore]
    public Parents      : SCG.HashSet[RecoveryStackFrame] = SCG.HashSet();

    | Extensible
      {
        RulePraser   : ExtensibleRuleParser;
        TextPos      : int;
        State        : int;
        public override GetNextState(state : int) : int { | 0 => 1 | _ => -1 }
      }

    | ExtensiblePrefix
      {
        AstHandle    : AstHandle.ExtensiblePrefix;
        public override GetNextState(state : int) : int { _ = state; -1 }
      }

    | ExtensiblePostfix
      {
        AstHandle    : AstHandle.ExtensiblePostfix;
        public override GetNextState(state : int) : int { _ = state; -1 }
      }

    | Rule
      {
        AstHandle    : AstHandle;
        State        : int;
        public override GetNextState(state : int) : int { AstHandle.GetRuleParser().GetNextState(state) }
      }

    | ListBody
      {
        AstHandle    : AstHandle.Subrule;
        State        : int;
        Counter      : int;
        public override GetNextState(state : int) : int { AstHandle.GetRuleParser().GetNextState(state) }
      }

    | ListSeparator
      {
        AstHandle    : AstHandle.Subrule;
        State        : int;
        Counter      : int;
        public override GetNextState(state : int) : int { AstHandle.GetRuleParser().GetNextState(state) }
        public override GetLoopBodyFrameForSeparatorState(textPos : int, parser : Parser) : RecoveryStackFrame.ListSeparator
        {
          mutable bodyId;
          mutable firstState;
          if (AstHandle.RuleParser.GetLoopBodyForSeparator(AstHandle.RuleId, out bodyId, out firstState))
          {
            assert3(Parents.Count == 1);
            def parent = Parents.First();
            def astHandle = parser.AstHandle_Subrule(AstHandle.RuleParser, bodyId, -1, textPos);
            def frame = parser.RecoveryStackFrame_ListSeparator(parent, astHandle, firstState, Counter);
            frame
          }
          else
            null
        }
      }

    public IsPrefixParsed : bool
    {
      get
      {
        match (this)
        {
          | ListBody     (handle, state, _) 
          | ListSeparator(handle, state, _)
          | Rule         (handle, state) =>
            def parser = handle.GetRuleParser();
            for (mutable i = parser.GetStartState(state); i < state; i = parser.GetNextState(i))
              unless (parser.IsVoidState(i))
                return true;
            false
            
          | Extensible        as frame => frame.State != 0
          | ExtensiblePrefix           => false
          | ExtensiblePostfix          => false
        }
      }
    }
    
    public IsLoopSeparatorStart : bool { get { this is ListSeparator } }
    
    public FailState : int
    {
      get
      {
        match (this)
        {
          | ListBody     (_, state, _) 
          | ListSeparator(_, state, _)
          | Extensible(_, _, state)
          | Rule         (_, state) => state
          | ExtensiblePrefix
          | ExtensiblePostfix => 0
        }
      }
    }
    
    public IsVoidState(state : int) : bool
    {
      match (this)
      {
        | ListBody     (handle, _, _) 
        | ListSeparator(handle, _, _)
        | Rule         (handle, _) => handle.GetRuleParser().IsVoidState(state)
        | Extensible
        | ExtensiblePrefix
        | ExtensiblePostfix        => false
      }
    }
    
    public abstract GetNextState(state : int) : int;
    public virtual GetLoopBodyFrameForSeparatorState(textPos : int, parser : Parser) : RecoveryStackFrame.ListSeparator { IgnoreParams(); null }

    public GetSpeculativeFramesForState(textPos : int, parser : Parser, state : int) : array[RecoveryStackFrame]
    {
      def makeExtentionFrame(ruleParser)
      {
        def handle = parser.AstHandle_Extention(ruleParser, -1, textPos);
        parser.RecoveryStackFrame_Rule(this, handle, ruleParser.StartState)
      }
      match (this)
      {
        | Extensible as frame =>
          match (frame.State)
          {
            | 0 => array[parser.RecoveryStackFrame_ExtensiblePrefix(this, parser.AstHandle_Prefix(frame.RulePraser, -1, textPos))]
            | 1 => array[parser.RecoveryStackFrame_ExtensiblePostfix(this, parser.AstHandle_Postfix(frame.RulePraser, -1, textPos))]
            | _ => assert3(false)
          }
        | ExtensiblePrefix  as frame => frame.AstHandle.RuleParser.PrefixRules.MapToArray(makeExtentionFrame)
        | ExtensiblePostfix as frame => frame.AstHandle.RuleParser.PostfixRules.Skip(frame.AstHandle.RuleParser.FirstPostfixRule).MapToArray(makeExtentionFrame)
        | ListBody(astHandle, _, _)
        | ListSeparator(astHandle, _, _)
        | Rule(astHandle, _) =>
          def ruleParser = astHandle.GetRuleParser();
          match (ruleParser.GetRuleParserForState(state))
          {
            | null                               => array[]
            | ExtensibleRuleParser as ruleParser => array[parser.RecoveryStackFrame_Extensible(this, ruleParser, textPos, 0)]
            | SimpleRuleParser     as ruleParser => array[parser.RecoveryStackFrame_Rule(this, parser.AstHandle_Simple(ruleParser, -1, textPos), ruleParser.StartState)]
            | _ => assert3(false)
          }
      }
    }

    public IsTokenRule : bool
    {
      get
      {
        match (this)
        {
          | ListBody
          | ListSeparator => false
          | Extensible as frame => frame.RulePraser.IsTokenRule
          | ExtensiblePrefix
          | ExtensiblePostfix => false
          | Rule(handle, _) => 
            match (handle)
            {
              | Simple
              | Extention => handle.GetRuleParser().IsTokenRule // ???
              | _ => false
            }
        }
      }
    }

    public IsSpeculative : bool
    {
      get
      {
        match (this)
        {
          | ExtensiblePrefix(handle)
          | ExtensiblePostfix(handle)
          | ListBody     (handle, _, _)
          | ListSeparator(handle, _, _)
          | Rule         (handle, _) => handle.AstPtr < 0
          | Extensible               => assert3(false)
        }
      }
    }

    public TryParse(state : int, curTextPos : int, parsedStates : SCG.List[ParsedStateInfo], parser : Parser) : int
    {
      match (this)
      {
        | ExtensiblePrefix (handle)
        | ExtensiblePostfix(handle)
        | ListBody     (handle, _, _) 
        | ListSeparator(handle, _, _)
        | Rule         (handle, _) => handle.GetRuleParser().TryParse(this, state, curTextPos, parsedStates, parser)
        | Extensible               => assert3(false);
      }
    }
    
    //public override ToString() : string
    //{
    //  def props = SCG.List();
    //  props.Add($"FailState=$FailState");
    //  when (Info != FrameInfo.None)
    //    props.Add($"Info=$Info");
    //  when (ListStartPos > 0)
    //    props.Add($"ListStartPos=$ListStartPos");
    //  when (ListEndPos > 0)
    //    props.Add($"ListEndPos=$ListEndPos");
    //  $"$(AstHandle.GetRuleParser().RuleName) = $(AstHandle.GetRuleParser().CodeWithStates)  (..$props)"
    //}
  }
}
