using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Extensions;

using System;
using SCG = System.Collections.Generic;
using System.Linq;

namespace N2.Internal
{
  [Record]
  [StructuralEquality]
  public variant RecoveryStackFrame
  {
    public abstract GetNextState(state : int) : int;
    public abstract GetSpeculativeBodyFrame(textPos : int, parser : Parser) : RecoveryStackFrame.ListSeparator;

    [RecordIgnore]
    [EqualsIgnore]
    public Parents      : SCG.HashSet[RecoveryStackFrame] = SCG.HashSet();

    | Extensible
      {
        RulePraser   : ExtensibleRuleParser;
        TextPos      : int;
        State        : int;
        public override GetNextState(state : int) : int { | 0 => 1 | _ => -1 }
        public override GetSpeculativeBodyFrame(textPos : int, parser : Parser) : RecoveryStackFrame.ListSeparator { IgnoreParams(); null }
        //public override GetFramesForState(startState : int, parser : Parser, parent : RecoveryStackFrame, textPos : int) : array[RecoveryStackFrame]
        //{
        //  match (startState)
        //  {
        //    | 0 => this.PrefixRules.MapToArray(x => x.GetFrameForFirstState(parser, parent, textPos))
        //    | 1 => this.PostfixRules.Skip(FirstPostfixRule).MapToArray(x => x.GetFrameForFirstState(parser, parent, textPos))
        //    | _ => assert3(false)
        //  }
        //}
      }

    | ExtensiblePrefix
      {
        AstHandle    : AstHandle.ExtensiblePrefix;
        public override GetNextState(state : int) : int { _ = state; -1 }
        public override GetSpeculativeBodyFrame(textPos : int, parser : Parser) : RecoveryStackFrame.ListSeparator { IgnoreParams(); null }
      }

    | ExtensiblePostfix
      {
        AstHandle    : AstHandle.ExtensiblePostfix;
        public override GetNextState(state : int) : int { _ = state; -1 }
        public override GetSpeculativeBodyFrame(textPos : int, parser : Parser) : RecoveryStackFrame.ListSeparator { IgnoreParams(); null }
      }

    | Rule
      {
        AstHandle    : AstHandle;
        State        : int;
        public override GetNextState(state : int) : int { AstHandle.GetRuleParser().GetNextState(state) }
        public override GetSpeculativeBodyFrame(textPos : int, parser : Parser) : RecoveryStackFrame.ListSeparator { IgnoreParams(); null }
      }

    | ListBody
      {
        AstHandle    : AstHandle.Subrule;
        State        : int;
        Counter      : int;
        public override GetNextState(state : int) : int { AstHandle.GetRuleParser().GetNextState(state) }
        public override GetSpeculativeBodyFrame(textPos : int, parser : Parser) : RecoveryStackFrame.ListSeparator { IgnoreParams(); null }
      }

    | ListSeparator
      {
        AstHandle    : AstHandle.Subrule;
        State        : int;
        Counter      : int;
        public override GetNextState(state : int) : int { AstHandle.GetRuleParser().GetNextState(state) }
        public override GetSpeculativeBodyFrame(textPos : int, parser : Parser) : RecoveryStackFrame.ListSeparator
        {
          mutable bodyId;
          mutable firstState;
          if (AstHandle.RuleParser.GetLoopBodyForSeparator(AstHandle.RuleId, out bodyId, out firstState))
          {
            assert3(Parents.Count == 1);
            def parent = Parents.First();
            def astHandle = parser.GetSubruleAstHandle(AstHandle.RuleParser, bodyId, textPos);
            def frame = parser.RecoveryStackFrame_ListSeparator(parent, astHandle, firstState, Counter);
            frame
          }
          else
            null
        }
      }

    //public RuleParser : IRecoveryRuleParser { get { this.AstHandle.GetRuleParser() } }
    //public AstPtr     : int                 { get { this.AstHandle.AstPtr } }

    //public abstract GetFrameForFirstState(                         parser : Parser, textPos : int) : RecoveryStackFrame;
    //public abstract GetFramesForState(                state : int, parser : Parser, textPos : int) : array[RecoveryStackFrame];
    //public abstract GetLoopBodyFrameForSeparatorState(state : int, parser : Parser, textPos : int) : RecoveryStackFrame;

    //public override ToString() : string
    //{
    //  def props = SCG.List();
    //  props.Add($"FailState=$FailState");
    //  when (Info != FrameInfo.None)
    //    props.Add($"Info=$Info");
    //  when (ListStartPos > 0)
    //    props.Add($"ListStartPos=$ListStartPos");
    //  when (ListEndPos > 0)
    //    props.Add($"ListEndPos=$ListEndPos");
    //  $"$(AstHandle.GetRuleParser().RuleName) = $(AstHandle.GetRuleParser().CodeWithStates)  (..$props)"
    //}
  }
}
