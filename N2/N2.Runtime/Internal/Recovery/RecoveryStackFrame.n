using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Extensions;

using System;
using SCG = System.Collections.Generic;
using System.Linq;

namespace N2.Internal
{
  [Record]
  [StructuralEquality]
  public variant RecoveryStackFrame
  {
    public abstract GetNextState(state : int) : int;

    [RecordIgnore]
    [EqualsIgnore]
    public Parents      : SCG.HashSet[RecoveryStackFrame] = SCG.HashSet();

    | Extensible
      {
        RulePraser   : ExtensibleRuleParser;
        TextPos      : int;
        State        : int;
        public override GetNextState(state : int) : int { | 0 => 1 | _ => -1 }
      }

    | ExtensiblePrefix
      {
        AstHandle    : AstHandle.ExtensiblePrefix;
        public override GetNextState(state : int) : int { _ = state; -1 }
      }

    | ExtensiblePostfix
      {
        AstHandle    : AstHandle.ExtensiblePostfix;
        public override GetNextState(state : int) : int { _ = state; -1 }
      }

    | Rule
      {
        AstHandle    : AstHandle;
        State        : int;
        public override GetNextState(state : int) : int { AstHandle.GetRuleParser().GetNextState(state) }
      }

    | ListBody
      {
        AstHandle    : AstHandle.Subrule;
        State        : int;
        Counter      : int;
        public override GetNextState(state : int) : int { AstHandle.GetRuleParser().GetNextState(state) }
      }

    | ListSeparator
      {
        AstHandle    : AstHandle.Subrule;
        State        : int;
        Counter      : int;
        public override GetNextState(state : int) : int { AstHandle.GetRuleParser().GetNextState(state) }
        public GetSpeculativeBodyFrame(textPos : int, parser : Parser) : RecoveryStackFrame.ListSeparator
        {
          mutable bodyId;
          mutable firstState;
          assert3(AstHandle.RuleParser.GetLoopBodyForSeparator(AstHandle.RuleId, out bodyId, out firstState));
          assert3(Parents.Count == 1);
          def parent = Parents.First();
          def astHandle = parser.GetSubruleAstHandle(AstHandle.RuleParser, bodyId, textPos);
          def frame = parser.RecoveryStackFrame_ListSeparator(parent, astHandle, firstState, Counter);
          frame
        }
      }

    //public RuleParser : IRecoveryRuleParser { get { this.AstHandle.GetRuleParser() } }
    //public AstPtr     : int                 { get { this.AstHandle.AstPtr } }

    //public abstract GetFrameForFirstState(                         parser : Parser, textPos : int) : RecoveryStackFrame;
    //public abstract GetFramesForState(                state : int, parser : Parser, textPos : int) : array[RecoveryStackFrame];
    //public abstract GetLoopBodyFrameForSeparatorState(state : int, parser : Parser, textPos : int) : RecoveryStackFrame;

    //public override ToString() : string
    //{
    //  def props = SCG.List();
    //  props.Add($"FailState=$FailState");
    //  when (Info != FrameInfo.None)
    //    props.Add($"Info=$Info");
    //  when (ListStartPos > 0)
    //    props.Add($"ListStartPos=$ListStartPos");
    //  when (ListEndPos > 0)
    //    props.Add($"ListEndPos=$ListEndPos");
    //  $"$(AstHandle.GetRuleParser().RuleName) = $(AstHandle.GetRuleParser().CodeWithStates)  (..$props)"
    //}
  }
}
