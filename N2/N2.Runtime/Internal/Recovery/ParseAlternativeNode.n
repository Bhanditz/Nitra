using Nemerle;
using Nemerle.Collections;
using Nemerle.Extensions;
using Nemerle.Imperative;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;

namespace N2.Internal
{
    /// <summary>
    /// Описывает одно пропарсивание. Для каждого RecoveryStackFrame сздается столько ParseAlternativeNode сколько в нем есть ParseAlternative.
    /// </summary>
    [StructuralEquality]
    public class ParseAlternativeNode
    {
      public Frame                 : RecoveryStackFrame;
      public ParseAlternativeIndex : int;
      [EqualsIgnore]
      public Parents               : List[ParseAlternativeNode];

      public this(frame : RecoveryStackFrame, parseAlternativeIndex : int, nodeMap : Dictionary[int, ParseAlternativeNode])
      {
        this.Frame = frame;
        this.ParseAlternativeIndex = parseAlternativeIndex;

        def parents = List();
        def stop = frame.ParseAlternatives[parseAlternativeIndex].Stop;

        foreach (parent in frame.Parents)
        {
          when (!parent.Best)
            continue;

          for (mutable index = 0; index < parent.ParseAlternatives.Length; index++)
          {
            def a = parent.ParseAlternatives[index];
            when (stop == a.Start)
            {
              def key = parent.Id << 8 | index;
              mutable node;
              when (!nodeMap.TryGetValue(key, out node))
              {
                node = ParseAlternativeNode(parent, index, nodeMap);
                nodeMap[key] = node;
              }
              parents.Add(node);
            }
          }
        }

        Parents = parents;
      }

      public GetFlatParseAlternatives() : List[list[ParseAlternativeNode]]
      {
        def total = List();

        foreach (parent in Parents)
        {
          def results = parent.GetFlatParseAlternatives();
          for (mutable index = 0; index < results.Count; index++)
            results[index] = this :: results[index];

          total.AddRange(results);
        }

        when (total.Count == 0)
          total.Add([this]);

        total
      }

      public ParseAlternative : ParseAlternative { get { Frame.ParseAlternatives[ParseAlternativeIndex] }}

      public override ToString() : string
      {
        this.Frame.ToStringImpl($" PA=[$(this.ParseAlternative)]")
      }
    }
}
