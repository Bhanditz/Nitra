using Nemerle;
using Nemerle.Collections;
using Nemerle.Extensions;
using Nemerle.Imperative;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;

namespace N2.Internal
{
    /// <summary>
    /// Описывает одно пропарсивание. Для каждого RecoveryStackFrame сздается столько ParseAlternativeNode сколько в нем есть ParseAlternative.
    /// </summary>
    [StructuralEquality]
    public class ParseAlternativeNode
    {
      public Frame                 : RecoveryStackFrame;
      public ParseAlternativeIndex : int;

      [EqualsIgnore]
      [FlagAccessor(Best, IsVisited, IsMarked, IsClone, IsInsideToken, flags = WantSetter)]
      mutable _state : StateFlag;
      
      [EqualsIgnore]
      public MissedSeparator : ParseAlternativeNode { get; internal set; }

      [EqualsIgnore] mutable _skipedMandatoryTokenCount         : int = -1;
      [EqualsIgnore] mutable _maxTotalSkipedMandatoryTokenCount : int = -1;
      [EqualsIgnore] mutable _minTotalSkipedMandatoryTokenCount : int = -1;
      
      [EqualsIgnore]
      protected _children : List[ParseAlternativeNode] = List();
      
      [EqualsIgnore]
      protected _parents     : List[ParseAlternativeNode];

      private this(frame : RecoveryStackFrame, parseAlternativeIndex : int, nodeMap : Dictionary[int, ParseAlternativeNode])
      {
        assert3(frame.Best);
        assert3(frame.ParseAlternatives.Length > 0);
        assert3(parseAlternativeIndex >= 0);
        assert3(parseAlternativeIndex < frame.ParseAlternatives.Length);
        
        this.Frame = frame;
        this.ParseAlternativeIndex = parseAlternativeIndex;
        this.Best = true;
        nodeMap.Add(MakeKey(frame, parseAlternativeIndex), this);
        
        def parseAlternative = frame.ParseAlternatives[parseAlternativeIndex];
        def fail  = parseAlternative.Fail;
        //def start = parseAlternative.Start;
        def end   = parseAlternative.End;
        
        def getNode(frame : RecoveryStackFrame, parseAlternativeIndex : int) : ParseAlternativeNode
        {
          def key = MakeKey(frame, parseAlternativeIndex);
          mutable node;
          when (!nodeMap.TryGetValue(key, out node))
            node = ParseAlternativeNode(frame, parseAlternativeIndex, nodeMap);
          node
        }

        when (frame is ListBody as body when body.MissedSeparator != null)
        {
          def missed = body.MissedSeparator;
          assert3(missed.ParseAlternatives.Length == 1);
          assert3(body.StartPos == missed.StartPos);
          assert3(body.StartPos == missed.ParseAlternatives[0].Start);
          
          this.MissedSeparator = getNode(missed, 0);
        }
        
        def frameParents = frame.Parents;
        mutable parentCount = 0;
        
        foreach (parent when parent.Best in frameParents)
          parentCount += parent.ParseAlternatives.Length;

        def parents = List(parentCount);
        
        foreach (parent when parent.Best in frameParents with i)
        {
          for (mutable index = 0; index < parent.ParseAlternatives.Length; index++)
          {
            def a = parent.ParseAlternatives[index];
            when (end == a.Start && a.End >= 0 || a.End == -1 && end == -1 && a.Start == fail)
            {
              def node = getNode(parent, index);
              parents.Add(node);
            }
          }
        }

        _parents = parents;
      }
      
      public static MakeKey(frame : RecoveryStackFrame, parseAlternativeIndex : int) : int
      {
        assert3(parseAlternativeIndex < 100);
        frame.Id * 100 + parseAlternativeIndex
      }
      
      public static IsAdded(nodeMap : Dictionary[int, ParseAlternativeNode], frame : RecoveryStackFrame, parseAlternativeIndex : int) : bool
      {
        nodeMap.ContainsKey(MakeKey(frame, parseAlternativeIndex))
      }
      
      public static MakeGraph(topFrames : Seq[RecoveryStackFrame]) : List[ParseAlternativeNode]
      {
        def nodeMap = Dictionary.[int, ParseAlternativeNode]();

        foreach (frame when frame.IsTop in topFrames)
          for (mutable i = 0; i < frame.ParseAlternatives.Length; i++)
            unless (IsAdded(nodeMap, frame, i))
              _ = ParseAlternativeNode(frame, i, nodeMap);

        def result = nodeMap.Values.ToList();
        result.Sort(fun(a, b) { def res = a.Frame.Depth - b.Frame.Depth;  if (res != 0)  res else a.ParseAlternativeIndex - b.ParseAlternativeIndex; });
        
        // fill children
        foreach (node in result)
        {
          assert3(node.Best);
          foreach (parent in node._parents)
            parent._children.Add(node);
        }
        
        result
      }

      
      public HasChildren : bool
      {
        get
        {
          foreach (node in _children)
            when (node.Best)
              return true;
            
          false
        }
      }
      
      public HasParents : bool
      {
        get
        {
          foreach (node in _parents)
            when (node.Best)
              return true;
            
          false
        }
      }
      
      public IsTop : bool { get { this.Best && !this.HasChildren } }
      
      public IsRoot : bool { get { this.Best && !this.HasParents } }
      
      public Id : int { get { MakeKey(this.Frame, this.ParseAlternativeIndex) } }

      public IsEmpty : bool
      {
        get
        {
          def frame = this.Frame;
          
          when (frame.StartPos != frame.TextPos)
            return false;
            
          def a = frame.ParseAlternatives[ParseAlternativeIndex];
          
          when (frame.TextPos != a.Stop)
            return false;
            
          frame.FailState == frame.FirstState && a.State == -1
        }
      }
      
      public Parents : Seq[ParseAlternativeNode]
      {
        get
        {
          foreach (node when node.Best in _parents)
            yield node;
        }
      }

      public AllParents : Seq[ParseAlternativeNode]
      {
        get
        {
          _parents
        }
      }
      
      public Children : Seq[ParseAlternativeNode]
      {
        get
        {
          foreach (node when node.Best in _children)
            yield node;
        }
      }
      
      public AllChildren : Seq[ParseAlternativeNode]
      {
        get
        {
          _children
        }
      }
      
      ResetSkipedMandatoryTokenCount() : void
      {
        _skipedMandatoryTokenCount         = -1;
        _minTotalSkipedMandatoryTokenCount = -1;
        _maxTotalSkipedMandatoryTokenCount = -1;
      }
      
      public SkipedMandatoryTokenCount : int
      {
        get
        {
          when (_skipedMandatoryTokenCount < 0)
            _skipedMandatoryTokenCount = CalcSkipedMandatoryTokenCount();
            
          _skipedMandatoryTokenCount
        }
      }
      public MaxTotalSkipedMandatoryTokenCount : int
      {
        get
        {
          when (_maxTotalSkipedMandatoryTokenCount < 0)
          {
            def max = if (HasChildren) Children.Max(n => n.MaxTotalSkipedMandatoryTokenCount) else 0;
            _maxTotalSkipedMandatoryTokenCount = max + SkipedMandatoryTokenCount;
          }
            
          _maxTotalSkipedMandatoryTokenCount
        }
      }

      public MinTotalSkipedMandatoryTokenCount : int
      {
        get
        {
          when (_minTotalSkipedMandatoryTokenCount < 0)
          {
            def mix = if (HasChildren) Children.Min(n => n.MinTotalSkipedMandatoryTokenCount) else 0;
            _minTotalSkipedMandatoryTokenCount = mix + SkipedMandatoryTokenCount;
          }
            
          _minTotalSkipedMandatoryTokenCount
        }
      }

      public CalcSkipedMandatoryTokenCount() : int
      {
        def endState           = this.ParseAlternative.State;
        def frame              = this.Frame;
        
        when (frame is RecoveryStackFrame.Root)
          return 0;
        
        def parsingFailAtState = frame.FailState2;
        def recursionState     = frame.FailState;
        def ruleParser         = frame.GetRuleParser();
        def calcSkipedMandatoryTokenCount(startState : int, endState : int) : int
        {
          mutable count = 0;
          
          for (mutable i = startState; i != endState; i = frame.GetNextState(i))
            count += ruleParser.GetMandatoryTokensForState(i);
            
          count
        }
        
        mutable skippedPrefixMandatoryTokenCount  = 0;
        mutable skippedPostfixMandatoryTokenCount = 0;

        if (this.IsTop)
        {
          when (recursionState != endState)
            skippedPrefixMandatoryTokenCount = calcSkipedMandatoryTokenCount(parsingFailAtState, endState);
        }
        else
        {
          when (parsingFailAtState < recursionState)
            skippedPrefixMandatoryTokenCount = calcSkipedMandatoryTokenCount(parsingFailAtState, recursionState);

          def startState = frame.GetNextState(recursionState);

          when (startState >= 0 && (startState < endState || endState < 0))
            skippedPostfixMandatoryTokenCount = calcSkipedMandatoryTokenCount(startState, endState);
        }
        
        skippedPrefixMandatoryTokenCount + skippedPostfixMandatoryTokenCount
      }
      
      public GetFlatParseAlternatives() : List[list[ParseAlternativeNode]]
      {
        def total = List();

        foreach (parent in Parents)
        {
          def results = parent.GetFlatParseAlternatives();
          for (mutable index = 0; index < results.Count; index++)
            results[index] = this :: results[index];

          total.AddRange(results);
        }

        when (total.Count == 0)
          total.Add([this]);

        total
      }

      public ParseAlternative : ParseAlternative { get { Frame.ParseAlternatives[ParseAlternativeIndex] }}

      public static DownToTop(nodes : List[ParseAlternativeNode], task : Action[ParseAlternativeNode]) : void
      {
        for (mutable i = nodes.Count - 1; i >= 0; i--)
        {
          def node = nodes[i];
          when (node.Best)
            task(node);
        }
      }

      public static TopToDown(nodes : List[ParseAlternativeNode], task : Action[ParseAlternativeNode]) : void
      {
        foreach (node in nodes)
        {
          when (node.Best)
            task(node);
        }
      }
      
      public Remove() : void
      {
        def children = this.Children.ToList();
        
        foreach (child in children)
        {
          def parents = child.Parents.ToList();
          
          when (parents.Count == 1)
          {
            assert3(parents[0] == this);
            child.Remove();
          }
        }

        foreach (node in Parents)
          node.ResetSkipedMandatoryTokenCount();

        this.Best = false;
      }

    private MakeMissedSeparator(parser : Parser) : void
    {
      def node = this.MissedSeparator;
      
      when (node != null)
      {
        // костыли и подпорки для обхода проблем возникающих от восстановления разделителя цикла
        def frame = node.Frame;
        node.Best  = true;
        frame.Best = true;
        mutable errorIndex = parser.ErrorData.Count;
        // Берем последнее сообщение об ошибке, так как его только что добавили, а MissedSeparator должен идти перед ним.
        def error = parser.ErrorData[errorIndex - 1];
        when (error.RecoveryNodes.Any(f => f.IsRoot && f.MinTotalSkipedMandatoryTokenCount == 0))
        {
          // Это фрейм успешно пропарсился. Стало быть его нужно удалить. Но здесь мы это сделать не можем. Так что просто помечаем его.
          error.Deleted = true;
        }
        def id = node.Id;
        def realNode = error.RecoveryNodes.First(f => f.Id == id); //TODO: Приседание из-за того, что объекты клонируются. Возможно в будущем можно будет это длео убрать.
        parser.ErrorData.Add(ParseErrorData(NToken(frame.StartPos, frame.StartPos), array[realNode], error.Index));
        error.Index++; // меняем сообщения об ошибках местами
        
        def rp = frame.GetRuleParser();
        // TODO: У PatchAst должен появиться парметр принимающий индекс парс-альтернативы. Надо пофиксить вызов PatchAst после этого.
        _ = rp.PatchAst(frame.StartPos, -1, errorIndex, frame, parser);
        this.MissedSeparator = null;
      }
    }
      
      public static DotNodes(stacks : Seq[ParseAlternativeNode]) : string
      {
        def allFrames = HashSet();
        def collectAllFrames(frame : ParseAlternativeNode) : void
        {
          unless (allFrames.Add(frame))
            return;
          
          foreach (parent in frame.Parents)
             collectAllFrames(parent);
        }
      
        foreach (frame in stacks)
          collectAllFrames(frame);
        
        def map = Hashtable();
        def colorIndex(frame)
        {
          mutable value;
          _ = map.TryGetValue(frame, out value);
          value
        }
        def fillMap(node : ParseAlternativeNode) : void
        {
          def frame = node.Frame;
          mutable counter;
          _ = map.TryGetValue(frame, out counter);
        
          map[frame] = counter + 1;

          when (node.MissedSeparator != null)
            fillMap(node.MissedSeparator);
        
          foreach (subFrame in node.Parents)
            fillMap(subFrame);
          
        }
        foreach (node in allFrames) 
          when (node.IsTop)
            fillMap(node);
      
        def name(node : ParseAlternativeNode) : string
        {
          node.Id.ToString()
        }
        def visited = HashSet();
        def nodes = List();
        def edges = List();
        def label(node : ParseAlternativeNode, index : int) : string
        {
          def frame = node.Frame;
          def label = 
            match (frame)
            {
              | Root => $<#Root PA=$(node.ParseAlternative)$(if (node.Best) " B" else "")#>
              | _ =>
                def parser = frame.GetRuleParser();
                def makeCode()
                {
                  def str = parser.CodeWithStates.Replace("\"", "\\\"");
                  def count = 30;
                  def sb = Text.StringBuilder();
                  def parts = str.Split(array[' '], StringSplitOptions.RemoveEmptyEntries);
                  mutable len = 0;
                  foreach (part in parts)
                  {
                    len += part.Length;
                    if (len > count)
                    {
                      len = 0;
                      _ = sb.Append("\n  ");
                    }
                    else
                      _ = sb.Append(" ");
                    _ = sb.Append(part);
                  }
          
                  sb.ToString();
                }
              def failRuleCode = "\n" + makeCode();
              def txt = frame.Parser.Text;
              def len(a : ParseAlternative) : int { (if (a.End < 0) a.Fail else a.End) - a.Start }
              def getText(a : ParseAlternative) : string
              {
                txt.Substring(a.Start, len(a)).Replace("\"", "\\\"")
              }
              def a = node.ParseAlternative;
              def parse = $<#  '$(getText(a))'#>;
              def top = if (frame.IsTop) "T" else "";
              def pa = $" PA$(node.ParseAlternative)";
              def minMaxSkip = if (node.IsTop) null else $"\nMinST=$(node.MinTotalSkipedMandatoryTokenCount) MaxST=$(node.MaxTotalSkipedMandatoryTokenCount)";
              def skipedTokens = $"$minMaxSkip ST=$(node.SkipedMandatoryTokenCount)";
              def label = $"$top«$(parser.RuleName)»$(frame.Info(node.Id, pa, node.Best))$skipedTokens: $parse\n";
              $"$label$failRuleCode"
            };
          def color = if (colorIndex(frame) == 1 && index < RecoveryStackFrame._colors.Length) $" color=$(RecoveryStackFrame._colors[index]) style=filled" else "";
          name(node) + $<#[label="$label"$color shape=box]#>
        }
        def visitNodes(node : ParseAlternativeNode, index : int) : void
        {
          //def frame = node.Frame;
          when (visited.Add(node))
          {
            when (node.MissedSeparator != null)
            {
              edges.Add($"$(name(node)) -> $(name(node.MissedSeparator)) [dir=back color=red]");
              visitNodes(node.MissedSeparator, index);
            }
            nodes.Add(node, index);
            foreach (parent in node.AllParents)
            {
              def color = if (node.Best && parent.Best) " color=lime" else "";
              edges.Add($"$(name(node)) -> $(name(parent)) [dir=back$color]");
              visitNodes(parent, index);
            }
          }
        }
        foreach (node in stacks with i)
          visitNodes(node, i);
        $<#
  digraph ParseAlternativeNode
  {
    ..$(nodes; ";\n  "; label);
    ..$(edges; ";\n  ");
  }#>
      }
      
      public override ToString() : string
      {
        this.Frame.ToStringImpl(this.Id, $" PA$(this.ParseAlternative)")
      }
    }
}
