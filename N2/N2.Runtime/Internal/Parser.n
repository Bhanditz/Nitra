using N2.Runtime;
using N2.Runtime.Reflection;
using Nemerle;
using Nemerle.Imperative;
using Nemerle.Collections;
using Nemerle.Late;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Diagnostics;
using System.Linq;

using SCG = System.Collections.Generic;

namespace N2.Internal
{
  public enum ParsingMode
  {
    | Parsing
    | Recovery
    | EndRecovery
  }

  [Record]
  public sealed class ParseErrorData
  {
    [RecordIgnore] public mutable Data : int;
    public Skip      : NToken;
    public Result    : SCG.List[RecoveryResult];
  }

#if !PARSER_DEBUG
  //[DebuggerStepThroughAttribute]
#endif
  public class Parser
  {
    public static AstParsedState = ~int.MaxValue;

    public static ResultOffset = 0;

    public mutable ast            : array[int];
    public mutable memoize        : array[int];
    public mutable allocated      : int;
    public         ParserHost     : ParserHost;
    public mutable ParsingMode    : ParsingMode;

    public         Source         : SourceSnapshot;
    public         Text           : string;
    public         RuleParser     : RuleParser { get }
    public mutable LastParseStart : int;
    public mutable LastParseEnd   : int;
    public         ListData       : SCG.List[RecoveryListData];
    public         RecoveryStack  : SCG.Stack[RecoveryStackFrame];
    public         ErrorData      : SCG.List[ParseErrorData];
    public mutable IgnoreRecovery : bool;
    public mutable _maxTextPos    : int;
    public MaxTextPos             : int
    {
      get { _maxTextPos }
      set { _maxTextPos = value; }
    }
    
    public IsSuccess : bool { get { true } }
    public LastSuccessPos : int { get { 0 } }

    public Parser : string
    {
      get
      {
        if (LastParseEnd >= 0)
          Text.Substring(LastParseStart, LastParseEnd - LastParseStart)
        else
          "<fail>"
      }
    }

    public RestText : string
    {
      get { Text.Substring(if (LastParseEnd >= 0) LastParseEnd else LastParseStart) }
    }

    public mutable PreviousTextSize : int;

    public PreviousText : string
    {
      get
      {
        when (PreviousTextSize <= 0)
          PreviousTextSize = 20;

        def pos = if (LastParseEnd >= 0) LastParseEnd else LastParseStart;
        if (pos >= PreviousTextSize)
          Text.Substring(pos - PreviousTextSize, PreviousTextSize)
        else
          Text.Substring(0, pos)
      }
    }

    public this(source : SourceSnapshot, initalSize : int, parserHost : ParserHost, ruleParser : RuleParser)
    {
      ErrorData       = SCG.List();
      ListData        = SCG.List();
      RecoveryStack   = SCG.Stack();
      def textSize    = source.Text.Length;
      this.Source     = source;
      this.Text       = source.Text;
      this.ast        = array(if (initalSize < 10) 10 else initalSize);
      this.memoize    = array(textSize + 1);
      this.allocated  = 0;
      this.ParserHost = parserHost;
      LastParseStart  = -1;
      LastParseEnd    = -1;
      MaxTextPos      = 0;
      ParsingMode     = ParsingMode.Parsing;
      this.RuleParser = ruleParser;
    }

    public Allocate(size : int) : int
    {
      def newAst = allocated;
      allocated = allocated + size;
      while (ast.Length <= allocated)
        Array.Resize(ref ast, (ast.Length * 3) / 2);

      newAst
    }

    public Allocate(size : int, ruleId : int) : int
    {
      def newAst = Allocate(size);
      ast[newAst] = ruleId;
      newAst;
    }

    public TryGetPrefix(pos : ref int, prefixAst : int) : int
    {
      mutable bestResult = ast[prefixAst + ExtensibleRuleParser.PrefixOfs.List];
      when (bestResult < 0)
      {
        def error = ErrorData[~bestResult];
        pos += error.Skip.Length; // грязь
        bestResult = error.Data; // исходная ссылка на AST
      }
      bestResult;
    }

    public TryGetAst(pos : int, ruleId : int) : int
    {
      for (mutable astPtr = memoize[pos]; astPtr > 0; astPtr = ast[astPtr + 1])
        when (ast[astPtr] == ruleId)
          return astPtr;
      0;
    }

    public GetAst(pos : int, ruleId : int) : int
    {
      def astPtr = TryGetAst(pos , ruleId);
      assert(astPtr > 0);
      astPtr;
    }

    public GetSize(sizePos : int) : int
    {
      def size = ast[sizePos];
      if (size >= 0)
        size
      else if (size == int.MinValue)
        0
      else
      {
        def error = ErrorData[~size];
        error.Skip.Length + error.Data
      }
    }

    public AstSize(astPtr : int, begin : int, end : int) : int
    {
      mutable size = 0;
      def end = astPtr + end;
      for (mutable i = astPtr + begin; i < end; ++i)
        size += GetSize(i);
      size;
    }

    public StartRecovery(startTextPos : int) : void
    {
      when (!IgnoreRecovery)
      {
        def recoveryStrategy = this.ParserHost.RecoveryStrategy;
        
        def bestResult =
          if (recoveryStrategy != null)
            recoveryStrategy(startTextPos, this)
          else
          {
            assert2(false);
            throw NotImplementedException();
          }
          
        _ = bestResult;

        this.ParsingMode = ParsingMode.EndRecovery;
        //assert2(false);
        //assert(false);
      }
    }
    
    
    public GetSpans(startPos : int, endPos : int, spans : SCG.List[SpanInfo]) : void
    {
      def walkerHost = this.ParserHost.GetWalkerHost(StandardWalkerTypes.Highlighter);
      def start_Walker = walkerHost.GetRootWalker(this);
      mutable num = 0;
      _ = late start_Walker.Walk(ref num, this, spans, startPos, endPos);
    }

    public GetOutlining(outlining : SCG.List[OutliningInfo]) : void
    {
      def timer = Stopwatch.StartNew();
      def context = N2.Internal.OutliningWalkerContext(outlining);
      def walkerHost = this.ParserHost.GetWalkerHost(StandardWalkerTypes.Outlining);
      def start_Walker = walkerHost.GetRootWalker(this);
      mutable num = 0;
      timer.Stop();
      Debug.WriteLine($"GetOutlining prepare: $(timer.Elapsed)");
      timer.Reset();
      timer.Start();
      _ = late start_Walker.Walk(ref num, this, context);
      timer.Stop();
      Debug.WriteLine($"GetOutlining Walk: $(timer.Elapsed)");
    }

    public Reflect() : ReflectionStruct
    {
      def walkerHost = this.ParserHost.GetWalkerHost(StandardWalkerTypes.Reflection);
      def start_Walker = walkerHost.GetRootWalker(this);
      mutable num = 0;
      def result = late start_Walker.Walk(ref num, this);
      result :> ReflectionStruct
    }
  }
}
