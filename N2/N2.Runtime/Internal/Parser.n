using Nemerle;
using Nemerle.Imperative;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Diagnostics;
using System.Linq;

using SCG = System.Collections.Generic;

namespace N2.Internal
{
  public enum ParsingMode
  {
    | Parsing
    | Recovery
    | EndRecovery
  }

  [Record]
  public struct Error
  {
    public SkipBefore : int;
    public Size       : int;
    public SkipAfter  : int;
    public Skip       : int { get { SkipBefore + Size + SkipAfter } }
  }

#if !PARSER_DEBUG
  //[DebuggerStepThroughAttribute]
#endif
  public struct Parser
  {
    public static AstParsedState = ~int.MaxValue;

    public static ResultOffset = 0;

    public mutable ast            : array[int];
    public mutable memoize        : array[int];
    public mutable allocated      : int;
    public         parserHost     : ParserHost;
    public mutable ParsingMode    : ParsingMode;

    public         Source         : SourceSnapshot;
    public         Text           : string;
    public mutable LastParseStart : int;
    public mutable LastParseEnd   : int;
    public         RecoveryStack  : SCG.Stack[RecoveryInfo];
    public         Errors         : SCG.List[Error];
    public mutable IgnoreRecovery : bool;
    public mutable _maxTextPos    : int;
    public MaxTextPos             : int
    {
      get { _maxTextPos }
      set { _maxTextPos = value; }
    }

    public ParseResult : string
    {
      get
      {
        if (LastParseEnd >= 0)
          Text.Substring(LastParseStart, LastParseEnd - LastParseStart)
        else
          "<fail>"
      }
    }

    public RestText : string
    {
      get { Text.Substring(if (LastParseEnd >= 0) LastParseEnd else LastParseStart) }
    }

    public mutable PreviousTextSize : int;

    public PreviousText : string
    {
      get
      {
        when (PreviousTextSize <= 0)
          PreviousTextSize = 20;

        def pos = if (LastParseEnd >= 0) LastParseEnd else LastParseStart;
        if (pos >= PreviousTextSize)
          Text.Substring(pos - PreviousTextSize, PreviousTextSize)
        else
          Text.Substring(0, pos)
      }
    }

    public this(source : SourceSnapshot, initalSize : int, parserHost : ParserHost)
    {
      Errors          = SCG.List();
      RecoveryStack   = SCG.Stack();
      def textSize    = source.Text.Length;
      this.Source     = source;
      this.Text       = source.Text;
      this.ast        = array(if (initalSize < 10) 10 else initalSize);
      this.memoize    = array(textSize + 1);
      this.allocated  = 0;
      this.parserHost = parserHost;
      LastParseStart  = -1;
      LastParseEnd    = -1;
      MaxTextPos      = 0;
      ParsingMode     = ParsingMode.Parsing;
    }

    public Allocate(size : int) : int
    {
      def newAst = allocated;
      allocated = allocated + size;
      while (ast.Length <= allocated)
        Array.Resize(ref ast, (ast.Length * 3) / 2);

      newAst
    }

    public Allocate(size : int, ruleId : int) : int
    {
      def newAst = Allocate(size);
      ast[newAst] = ruleId;
      newAst;
    }

    public TryGetAst(pos : int, ruleId : int) : int
    {
      for (mutable astPtr = memoize[pos]; astPtr > 0; astPtr = ast[astPtr + 1])
        when (ast[astPtr] == ruleId)
          return astPtr;
      0;
    }

    public GetAst(pos : int, ruleId : int) : int
    {
      def astPtr = TryGetAst(pos , ruleId);
      assert(astPtr > 0);
      astPtr;
    }

    public AstSize(astPtr : int, begin : int, end : int) : int
    {
      mutable size = 0;
      def end = astPtr + end;
      for (mutable i = astPtr + begin; i < end; ++i)
        size += ast[i];
      size;
    }

    public StartRecovery(startTextPos : int) : void
    {
      when (!IgnoreRecovery)
      {
        def recoveryStrategy = this.parserHost.RecoveryStrategy;
        
        def bestResult =
          if (recoveryStrategy != null)
            recoveryStrategy(startTextPos, this)
          else
          {
            def res = SCG.List();
            def recoveryStack = RecoveryStack.ToArray();
            mutable curTextPos = startTextPos;

            this.ParsingMode = ParsingMode.Parsing;

            def continueParse(level : int, startTextPos : int) : int
            {
              when (level >= recoveryStack.Length)
                return startTextPos;

              def recoveryInfo = recoveryStack[level];
              def pos3 = 
                if (recoveryInfo.State + 1 >= recoveryInfo.StatesCount)
                  startTextPos
                else
                  recoveryInfo.RuleParser.TryParse(recoveryInfo.AstPtr, startTextPos, Text, ref this, recoveryInfo.State + 1);

              if (pos3 >= 0)
                continueParse(level + 1, pos3)
              else
                Math.Max(MaxTextPos, startTextPos);
            }
        
            def visited = Hashtable();
            def text = Text;
            do
            {
              foreach (r in recoveryStack with level)
              {
                def ruleParser = r.RuleParser;
                def key = (curTextPos, ruleParser);
                mutable startState;
                when (visited.TryGetValue(key, out startState) && startState <= r.State)
                  continue;
                visited[key] = r.State;
            
                def lastState = r.StatesCount - 1;
            
                for (mutable state = r.State + 1; state <= lastState; state++)
                {
              
                  this.MaxTextPos = startTextPos;
                  def pos = ruleParser.TryParse(r.AstPtr, curTextPos, text, ref this, state);
                  if (pos > curTextPos || pos == Text.Length)
                  {
                    def pos2 = continueParse(level + 1, pos);
                    res.Add(RecoveryResult(curTextPos, pos2,        state, level, r, text, startTextPos));
                  }
                  else if (MaxTextPos > curTextPos)
                    res.Add(RecoveryResult(curTextPos, MaxTextPos, state, level, r, text, startTextPos));
                  else
                  {
                  }
                }
              }

              curTextPos++;
            }
            while (/*res.Count == 0 && */ /*(res.Count == 0 || curTextPos - startTextPos < 10) &&*/ curTextPos <= Text.Length);

            def filterMax(res, func : RecoveryResult -> int) : array[RecoveryResult]
            {
              if (res.Length == 0)
                res
              else
              {
                def max = res.Max(func);
                def bestResults = res.Filter(x => func(x) == max);
                bestResults.ToArray()
              }
            }
            def filterMin(res, func : RecoveryResult -> int) : array[RecoveryResult]
            {
              if (res.Length == 0)
                res
              else
              {
                def min = res.Min(func);
                def bestResults = res.Filter(x => func(x) == min);
                bestResults.ToArray()
              }
            }

            def bestResults1 = filterMax(res.ToArray(), x => x.EndPos);
            def bestResults2 = filterMin(bestResults1,  x => x.StartPos);
            def bestResults3 = filterMin(bestResults2,  x => x.StackLevel);
            def bestResults4 = filterMin(bestResults3,  x => x.StartState);
            assert(bestResults4.Length == 1);
            bestResults4[0]
          };

        _ = bestResult;

        this.ParsingMode = ParsingMode.EndRecovery;
        assert2(false);
        assert(false);
      }
    }
  }
}
