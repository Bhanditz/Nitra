using Nemerle;
using Nemerle.Imperative;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Diagnostics;
using System.Linq;

using SCG = System.Collections.Generic;

namespace N2.Internal
{
  public enum ParsingMode
  {
    | Parsing
    | Recovery
    | EndRecovery
  }

  [Record]
  public struct Error
  {
    public SkipBefore : int;
    public Size       : int;
    public SkipAfter  : int;
    public Skip       : int { get { SkipBefore + Size + SkipAfter } }
  }

#if !PARSER_DEBUG
  //[DebuggerStepThroughAttribute]
#endif
  public struct Parser
  {
    public static AstParsedState = ~int.MaxValue;

    public static ResultOffset = 0;

    public mutable ast            : array[int];
    public mutable memoize        : array[int];
    public mutable allocated      : int;
    public         parserHost     : ParserHost;
    public mutable ParsingMode    : ParsingMode;

    public         Source         : SourceSnapshot;
    public         Text           : string;
    public mutable LastParseStart : int;
    public mutable LastParseEnd   : int;
    public         RecoveryStack  : SCG.Stack[RecoveryInfo];
    public         Errors         : SCG.List[Error];
    public mutable IgnoreRecovery : bool;
    public mutable _maxTextPos    : int;
    public MaxTextPos             : int
    {
      get { _maxTextPos }
      set { _maxTextPos = value; }
    }

    public ParseResult : string
    {
      get
      {
        if (LastParseEnd >= 0)
          Text.Substring(LastParseStart, LastParseEnd - LastParseStart)
        else
          "<fail>"
      }
    }

    public RestText : string
    {
      get { Text.Substring(if (LastParseEnd >= 0) LastParseEnd else LastParseStart) }
    }

    public mutable PreviousTextSize : int;

    public PreviousText : string
    {
      get
      {
        when (PreviousTextSize <= 0)
          PreviousTextSize = 20;

        def pos = if (LastParseEnd >= 0) LastParseEnd else LastParseStart;
        if (pos >= PreviousTextSize)
          Text.Substring(pos - PreviousTextSize, PreviousTextSize)
        else
          Text.Substring(0, pos)
      }
    }

    public this(source : SourceSnapshot, initalSize : int, parserHost : ParserHost)
    {
      Errors          = SCG.List();
      RecoveryStack   = SCG.Stack();
      def textSize    = source.Text.Length;
      this.Source     = source;
      this.Text       = source.Text;
      this.ast        = array(if (initalSize < 10) 10 else initalSize);
      this.memoize    = array(textSize + 1);
      this.allocated  = 0;
      this.parserHost = parserHost;
      LastParseStart  = -1;
      LastParseEnd    = -1;
      MaxTextPos      = 0;
      ParsingMode     = ParsingMode.Parsing;
    }

    public Allocate(size : int) : int
    {
      def newAst = allocated;
      allocated = allocated + size;
      while (ast.Length <= allocated)
        Array.Resize(ref ast, (ast.Length * 3) / 2);

      newAst
    }

    public Allocate(size : int, ruleId : int) : int
    {
      def newAst = Allocate(size);
      ast[newAst] = ruleId;
      newAst;
    }

    public TryGetAst(pos : int, ruleId : int) : int
    {
      for (mutable astPtr = memoize[pos]; astPtr > 0; astPtr = ast[astPtr + 1])
        when (ast[astPtr] == ruleId)
          return astPtr;
      0;
    }

    public GetAst(pos : int, ruleId : int) : int
    {
      def astPtr = TryGetAst(pos , ruleId);
      assert(astPtr > 0);
      astPtr;
    }

    public AstSize(astPtr : int, begin : int, end : int) : int
    {
      mutable size = 0;
      def end = astPtr + end;
      for (mutable i = astPtr + begin; i < end; ++i)
        size += ast[i];
      size;
    }

    public StartRecovery(startTextPos : int) : void
    {
      when (!IgnoreRecovery)
      {
        def res = SCG.List();
        mutable curTextPos = startTextPos;

        this.ParsingMode = ParsingMode.Parsing;
        
        while (res.Count == 0 && curTextPos < Text.Length)
        {
          foreach (r in RecoveryStack with level)
          {
            for (mutable state = r.State; state < r.StatesCount; state++)
            {
              this.MaxTextPos = startTextPos;
              def pos = r.RuleParser.TryParse(r.AstPtr, curTextPos, Text, ref this, state);
              if (pos > curTextPos)
                res.Add(RecoveryResult(curTextPos, pos,        state, level, r));
              else if (MaxTextPos > curTextPos)
                res.Add(RecoveryResult(curTextPos, MaxTextPos, state, level, r));
              else
              {
              }
            }
          }

          curTextPos++;
        }

        def filterMax(res, func : RecoveryResult -> int) : array[RecoveryResult]
        {
          def max = res.Max(func);
          def bestResults = res.Filter(x => func(x) == max);
          bestResults.ToArray()
        }
        def filterMin(res, func : RecoveryResult -> int) : array[RecoveryResult]
        {
          def min = res.Min(func);
          def bestResults = res.Filter(x => func(x) == min);
          bestResults.ToArray()
        }

        def bestResults1 = filterMax(res.ToArray(), x => x.EndPos);
        def bestResults2 = filterMin(bestResults1,  x => x.StartPos);
        def bestResults3 = filterMin(bestResults2,  x => x.StartState);
        def bestResults4 = filterMin(bestResults3,  x => x.StackLevel);
        assert(bestResults4.Length == 1);
        def bestResult = bestResults4[0];

        this.ParsingMode = ParsingMode.EndRecovery;
      }
    }
  }
}
