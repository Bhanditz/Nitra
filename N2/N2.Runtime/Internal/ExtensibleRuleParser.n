using Nemerle;
using Nemerle.Imperative;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;

using N2.Runtime.Reflection;

namespace N2.Internal
{
  public sealed partial class ExtensibleRuleParser : IRecoveryRuleParser
  {
    public GetParsers() : array[IRecoveryRuleParser]
    {
      //(PrefixRules : object) :> array[IRecoveryRuleParser]
      PrefixRules.MapToArray(_ :> IRecoveryRuleParser)
    }

    public StatesCount    : int    { get assert(false) }
    public Code           : string { get assert(false) }
    public CodeWithStates : string { get assert(false) }
    public RuleName       : string { get assert(false) }
    public CodeForState(_state : int) : string { assert(false) }

    public override FindRecoveryPosition(mutable curTextPos : int, text : string, parser : N2.Internal.Parser) : int
    {
      mutable i;
      mutable bestResult;
      mutable prefixAst = parser.memoize[curTextPos];
      for (; prefixAst > 0; prefixAst = parser.ast[prefixAst + PrefixOfs.Next])
      {
        when (parser.ast[prefixAst + PrefixOfs.Id] == PrefixId)
        {
          bestResult = parser.ast[prefixAst + PrefixOfs.List];
          if (bestResult > 0 && parser.ast[bestResult + AstOfs.State] == Parser.AstParsedState)
          {
            //TODO: убрать цикл
            i = bestResult + AstOfs.Sizes;
            for (; parser.ast[i] >= 0; ++i)
              curTextPos += parser.ast[i];
            return curTextPos;
          }
          else
          {
            break;
          }
        }
      }
      parser.RecoveryStack.Push(RecoveryStackFrame(this, prefixAst, curTextPos, 0, 0));
      def res = if (bestResult == 0)
      {//0
        when (parser.MaxTextPos == curTextPos)
          parser.StartRecovery(curTextPos);
        -1
      }
      else if (parser.ast[bestResult + AstOfs.Next] == 0)
      {//1
        def prefixRule = PrefixRules[parser.ast[bestResult + N2.Internal.ExtensibleRuleParser.AstOfs.Id] - PrefixOffset];
        prefixRule.FindRecoveryPosition(curTextPos, text, bestResult, parser);
      }
      else
      {//many
        assert2(false);
        assert(false);
      }
      when (parser.ParsingMode != N2.Internal.ParsingMode.EndRecovery)
        _ = parser.RecoveryStack.Pop();
      res;
    }

    public override TryParse(stackFrame : RecoveryStackFrame, startState : int, curTextPos : int, parser : N2.Internal.Parser) : int
    {
      ignore(stackFrame, startState, curTextPos, parser);
      throw NotImplementedException();
    }

    public override GetParsersForState(startState : int) : array[IRecoveryRuleParser]
    {
      ignore(startState);
      throw NotImplementedException();
    }

    public GetNextState(state : int) : int
    {
      ignore(state);
      throw NotImplementedException();
    }
  }
}
