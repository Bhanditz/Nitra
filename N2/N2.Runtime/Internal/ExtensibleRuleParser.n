using Nemerle;
using Nemerle.Imperative;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;

using N2.Runtime.Reflection;

namespace N2.Internal
{
  public sealed partial class ExtensibleRuleParser : IRecoveryRuleParser
  {
    private static PrefixState = 0;
    private static PostfixState = 1;

    public GetParsers() : array[IRecoveryRuleParser]
    {
      //(PrefixRules : object) :> array[IRecoveryRuleParser]
      PrefixRules.MapToArray(_ :> IRecoveryRuleParser)
    }

    public Code           : string { get Descriptor.Name }
    public CodeWithStates : string { get Descriptor.Name }
    public RuleName       : string { get Descriptor.Name }
    public CodeForState(_state : int) : string { Descriptor.Name }

    public override FindRecoveryPosition(mutable curTextPos : int, text : string, parser : N2.Internal.Parser) : int
    {
      mutable i;
      mutable bestResult;
      mutable prefixAst = parser.memoize[curTextPos];
      for (; prefixAst > 0; prefixAst = parser.ast[prefixAst + PrefixOfs.Next])
      {
        when (parser.ast[prefixAst + PrefixOfs.Id] == PrefixId)
        {
          bestResult = parser.ast[prefixAst + PrefixOfs.List];
          if (bestResult > 0 && parser.ast[bestResult + AstOfs.State] == Parser.AstParsedState)
          {
            //TODO: убрать цикл
            i = bestResult + AstOfs.Sizes;
            for (; parser.ast[i] >= 0; ++i)
              curTextPos += parser.ast[i];
            return curTextPos;
          }
          else
          {
            break;
          }
        }
      }
      parser.RecoveryStack.Push(RecoveryStackFrame(this, prefixAst, false, curTextPos, PrefixState, 0, FrameInfo.None));
      def res = if (bestResult == 0)
      {//0
        when (parser.MaxTextPos == curTextPos)
          parser.StartRecovery(curTextPos);
        -1
      }
      else if (parser.ast[bestResult + AstOfs.Next] == 0)
      {//1
        def prefixRule = PrefixRules[parser.ast[bestResult + N2.Internal.ExtensibleRuleParser.AstOfs.Id] - PrefixOffset];
        prefixRule.FindRecoveryPosition(curTextPos, text, bestResult, parser);
      }
      else
      {//many
        assert2(false);
        assert(false);
      }
      when (parser.ParsingMode != N2.Internal.ParsingMode.EndRecovery)
        _ = parser.RecoveryStack.Pop();
      res;
    }

    public override TryParse(recoveryStack : list[RecoveryStackFrame].Cons, startState : int, mutable curTextPos : int, writeAstSize : bool, parser : N2.Internal.Parser) : int
    {
      _ = recoveryStack;
      _ = writeAstSize; // TODO: сделать?
      def text = parser.Text;
      if (startState == PrefixState)
      {
        mutable bestPos;
        curTextPos = ParsePrefix(curTextPos, text, parser);
        if (curTextPos > 0)
        {
          do
          {
            bestPos = curTextPos;
            curTextPos = ParsePostfix(curTextPos, text, parser);
          }
          while (curTextPos > bestPos);
          bestPos;
        }
        else
          -1;
      }
      else if (startState == PostfixState || startState == -2) // -2 is a continue parse
      {
        mutable bestPos;
        do
        {
          bestPos = curTextPos;
          curTextPos = ParsePostfix(curTextPos, text, parser);
        }
        while (curTextPos > bestPos);
        
        bestPos
      }
      else
        assert(false);
    }

    public override GetParsersForState(startState : int) : array[IRecoveryRuleParser]
    {
      ignore(startState);
      //throw NotImplementedException();
      array[]
    }

    public PatchAst(failPos : int, startPos : int, startState : int, errorIndex : int, stack : list[RecoveryStackFrame].Cons, parser : N2.Internal.Parser) : void
    {
      parser.ast[stack.Head.AstPtr + 2] = ~startState;
    }

    public GetNextState(state : int) : int
    {
      match (state)
      {
        | 0 =>  1
        | 1 => -1
        | _ => assert(false)
      }
    }

    public StartState : int { get { 0 } }
  }
}
