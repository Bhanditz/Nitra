using Nemerle;
using Nemerle.Imperative;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;

using N2.Runtime.Reflection;

namespace N2.Internal
{
  public sealed partial class ExtensibleRuleParser : StartRuleParser, IRecoveryRuleParser
  {
    private static PrefixState = 0;
    private static PostfixState = 1;

    public GetParsers() : array[IRecoveryRuleParser]
    {
      //(PrefixRules : object) :> array[IRecoveryRuleParser]
      PrefixRules.MapToArray(_ :> IRecoveryRuleParser)
    }

    public Code           : string { get Descriptor.Name }
    public CodeWithStates : string { get Descriptor.Name }
    public RuleName       : string { get Descriptor.Name }
    public CodeForState(_state : int) : string { Descriptor.Name }

    public PrefixRuleParser(ptr : int, parser : Parser) : ExtentionRuleParser
    {
      PrefixRules[parser.ast[ptr + PrefixOfs.Id] - PrefixOffset]
    }

    public GetPrefixSize(bestResult : int, parser : Parser) : int
    {
      mutable size = 0;
      mutable i = bestResult + AstOfs.Sizes;
      mutable end = i + PrefixRuleParser(bestResult, parser).FieldsCount;
      for (; i < end; ++i)
        size += parser.GetSize(i);
      size;
    }

    public override FindRecoveryPosition(mutable curTextPos : int, text : string, parser : N2.Internal.Parser) : int
    {
      mutable bestResult = 0;
      mutable prefixAst = parser.TryGetAst(curTextPos, PrefixId);
      when (prefixAst > 0)
      {
        bestResult = parser.TryGetPrefix(ref curTextPos, prefixAst);
        when (bestResult > 0)
        {
          def state = parser.ast[bestResult + AstOfs.State];
          if (state == Parser.AstParsedState)
            return curTextPos + GetPrefixSize(bestResult, parser);
          else assert (state >= 0);
        }
      }
      parser.RecoveryStack.Push(RecoveryStackFrame(this, prefixAst, false, curTextPos, PrefixState, 0, FrameInfo.None));
      def res = if (bestResult == 0)
      {//0
        when (parser.MaxFailPos == curTextPos)
          parser.StartRecovery(curTextPos);
        -1
      }
      else if (parser.ast[bestResult + AstOfs.Next] == 0)
      {//1
        def prefixRule = PrefixRules[parser.ast[bestResult + N2.Internal.ExtensibleRuleParser.AstOfs.Id] - PrefixOffset];
        prefixRule.FindRecoveryPosition(curTextPos, text, bestResult, parser);
      }
      else
      {//many
        assert2(false);
        assert(false);
      }
      when (parser.ParsingMode != N2.Internal.ParsingMode.EndRecovery)
        _ = parser.RecoveryStack.Pop();
      res;
    }

    public override TryParse(recoveryStack : list[RecoveryStackFrame].Cons, startState : int, mutable curTextPos : int, writeAstSize : bool, parser : N2.Internal.Parser) : int
    {
      _ = recoveryStack;
      _ = writeAstSize; // TODO: сделать?
      def text = parser.Text;
      if (startState == PrefixState)
      {
        mutable bestPos;
        curTextPos = ParsePrefix(curTextPos, text, parser);
        if (curTextPos > 0)
        {
          do
          {
            bestPos = curTextPos;
            curTextPos = ParsePostfix(curTextPos, text, parser);
          }
          while (curTextPos > bestPos);
          bestPos;
        }
        else
          -1;
      }
      else if (startState == PostfixState || startState == -2) // -2 is a continue parse
      {
        mutable bestPos;
        do
        {
          bestPos = curTextPos;
          curTextPos = ParsePostfix(curTextPos, text, parser);
        }
        while (curTextPos > bestPos);
        
        bestPos
      }
      else
        assert(false);
    }

    public override GetParsersForState(startState : int) : array[IRecoveryRuleParser]
    {
      ignore(startState);
      //throw NotImplementedException();
      array[]
    }

    public override IsStateCanParseEmptyString(start : int) : bool { start != 0 }
    public override IsVoidState(start : int) : bool { IgnoreParams(); false }
    
    public PatchAst(failPos : int, startPos : int, startState : int, errorIndex : int, stack : list[RecoveryStackFrame].Cons, parser : N2.Internal.Parser) : void
    {
      def error = parser.ErrorData[errorIndex];
      def frame = stack.Head;
      def astIndex = parser.GetAst(startPos, PrefixId) + PrefixOfs.List;
      error.Data = parser.ast[astIndex];
      parser.ast[frame.AstPtr + PrefixOfs.List] = ~errorIndex;
    }

    public GetNextState(state : int) : int
    {
      match (state)
      {
        | 0 =>  1
        | 1 => -1
        | _ => assert(false)
      }
    }

    public StartState : int { get { 0 } }
  }
}
