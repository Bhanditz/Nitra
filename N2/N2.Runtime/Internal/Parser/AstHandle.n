using N2.Runtime;
using N2.Runtime.Reflection;
using Nemerle;
using Nemerle.Imperative;
using Nemerle.Collections;
using Nemerle.Late;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Diagnostics;
using System.Linq;
using System.Collections.ObjectModel;

using SCG = System.Collections.Generic;

namespace N2.Internal
{
  public partial class Parser
  {
    private _extentionHandleCache : SCG.Dictionary[ExtentionRuleParser * int, AstHandle.Extention] = SCG.Dictionary();
    public AstHandle_Extention(ruleParser : ExtentionRuleParser, astPtr : int, textPos : int) : AstHandle.Extention
    {
      mutable handle;
      def key = (ruleParser, textPos);
      unless (_extentionHandleCache.TryGetValue(key, out handle))
      {
        handle = AstHandle.Extention(astPtr, textPos, ruleParser);
        _extentionHandleCache.Add(key, handle)
      }
      when (astPtr > 0)
        handle.AstPtr = astPtr;
      handle
    }

    private _extensiblePrefixHandleCache : SCG.Dictionary[ExtensibleRuleParserData * int, AstHandle.ExtensiblePrefix] = SCG.Dictionary();
    public AstHandle_Prefix(ruleParserData : ExtensibleRuleParserData, mutable astPtr : int, textPos : int) : AstHandle.ExtensiblePrefix
    {
      mutable handle;
      def key = (ruleParserData, textPos);
      unless (_extensiblePrefixHandleCache.TryGetValue(key, out handle))
      {
        handle = AstHandle.ExtensiblePrefix(astPtr, textPos, ruleParserData);
        _extensiblePrefixHandleCache.Add(key, handle)
      }
      when (handle.AstPtr <= 0)
      {
        astPtr = TryGetAst(textPos, ruleParserData.PrefixId);
        when (astPtr > 0)
          handle.AstPtr = astPtr;
      }
      handle
    }

    private _extensiblePostfixHandleCache : SCG.Dictionary[ExtensibleRuleParserData * int, AstHandle.ExtensiblePostfix] = SCG.Dictionary();
    public AstHandle_Postfix(ruleParserData : ExtensibleRuleParserData, mutable astPtr : int, textPos : int) : AstHandle.ExtensiblePostfix
    {
      mutable handle;
      def key = (ruleParserData, textPos);
      unless (_extensiblePostfixHandleCache.TryGetValue(key, out handle))
      {
        handle = AstHandle.ExtensiblePostfix(astPtr, textPos, ruleParserData);
        _extensiblePostfixHandleCache.Add(key, handle)
      }
      when (handle.AstPtr <= 0)
      {
        astPtr = TryGetAst(textPos, ruleParserData.PostfixId);
        when (astPtr > 0)
          handle.AstPtr = astPtr;
      }
      handle
    }

    private _simpleHandleCache : SCG.Dictionary[int * int, AstHandle.Simple] = SCG.Dictionary();
    public AstHandle_Simple(ruleParser : SimpleRuleParser, mutable astPtr : int, textPos : int) : AstHandle.Simple
    {
      mutable handle;
      def key = (ruleParser.RuleId, textPos);
      unless (_simpleHandleCache.TryGetValue(key, out handle))
      {
        handle = AstHandle.Simple(astPtr, textPos, ruleParser);
        _simpleHandleCache.Add(key, handle)
      }
      when (handle.AstPtr <= 0)
      {
        astPtr = TryGetAst(textPos, ruleParser.RuleId);
        when (astPtr > 0)
          handle.AstPtr = astPtr;
      }
      handle
    }

    private _subruleHandleCache : SCG.Dictionary[int * int, AstHandle.Subrule] = SCG.Dictionary();
    public AstHandle_Subrule(ruleParser : IRecoveryRuleParser, ruleId : int, mutable astPtr : int, textPos : int) : AstHandle.Subrule
    {
      mutable handle;
      def key = (ruleId, textPos);
      unless (_subruleHandleCache.TryGetValue(key, out handle))
      {
        handle = AstHandle.Subrule(astPtr, textPos, ruleParser, ruleId);
        _subruleHandleCache.Add(key, handle)
      }
      when (handle.AstPtr <= 0)
      {
        astPtr = TryGetAst(textPos, ruleId);
        when (astPtr > 0)
          handle.AstPtr = astPtr;
      }
      handle
    }
  }
}
