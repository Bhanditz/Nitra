using N2.Runtime;
using N2.Runtime.Reflection;
using Nemerle;
using Nemerle.Imperative;
using Nemerle.Collections;
using Nemerle.Late;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Diagnostics;
using System.Linq;
using System.Collections.ObjectModel;

using SCG = System.Collections.Generic;

namespace N2.Internal
{
  public partial class Parser
  {
    public static AstParsedState = ~int.MaxValue;

    public static ResultOffset = 0;

    public mutable ast            : array[int];
    public mutable memoize        : array[int];
    public mutable allocated      : int;
    public         ParserHost     : ParserHost;

    public         Source         : SourceSnapshot;
    public         Text           : string;
    public         RuleParser     : RuleParser { get }
    public mutable LastParseStart : int;
    public mutable LastParseEnd   : int;
    public         RecoveryStacks : SCG.List[RecoveryStackFrame];
    public         ErrorData      : SCG.List[ParseErrorData];
    private mutable _maxFailPos   : int;
    
    public this(source : SourceSnapshot, initalSize : int, parserHost : ParserHost, ruleParser : RuleParser)
    {
      TokenEnumerator1 = TokenEnumerator(this);
      TokenEnumerator2 = TokenEnumerator(this);
      ErrorData       = SCG.List();
      RecoveryStacks  = SCG.List();
      def textSize    = source.Text.Length;
      this.Source     = source;
      this.Text       = source.Text;
      this.ast        = array(if (initalSize < 10) 10 else initalSize);
      this.memoize    = array(textSize + 1);
      this.allocated  = 0;
      this.ParserHost = parserHost;
      LastParseStart  = -1;
      LastParseEnd    = -1;
      MaxFailPos      = 0;
      this.RuleParser = ruleParser;
    }

    public AllRecoveryStackFrames : SCG.List[RecoveryStackFrame] = SCG.List();
    public PrepareRecoveryStacks() : void
    {
      AllRecoveryStackFrames.Clear();
      def clearFrame(frame) : void
      {
        AllRecoveryStackFrames.Add(frame);
        frame.Depth = -1;
        foreach (parent in frame.Parents)
          when (parent.Depth != -1)
          {
            parent.Depth = -1;
            clearFrame(parent);
          }
      }
      def updateFrame(frame) : void
      {
        foreach (parent in frame.Parents)
          when (parent.Depth <= frame.Depth + 1)
          {
            parent.Depth = frame.Depth + 1;
            updateFrame(parent);
          }
      }

      foreach (stack in RecoveryStacks)
        clearFrame(stack);
      foreach (stack in RecoveryStacks)
        stack.Depth = 0;
      foreach (stack in RecoveryStacks)
        updateFrame(stack);
      _ = RecoveryStacks.RemoveAll(stack => stack.Depth != 0);

      AllRecoveryStackFrames.Sort((l, r) => l.Depth.CompareTo(r.Depth));
      foreach (frame in AllRecoveryStackFrames with i)
      {
        frame.Index = i;
        frame.ContinueParsePos = -1;
        frame.Children.Clear();
      }
      foreach (frame in AllRecoveryStackFrames)
        foreach (parent in frame.Parents)
          parent.Children.Add(frame);

      for (mutable i = AllRecoveryStackFrames.Count - 1; i >= 0; --i)
      {
        def frame = AllRecoveryStackFrames[i];
        def isOptional = frame.GetRuleParser().IsStateCanParseEmptyString(frame.FailState);
        frame.Mode = if (isOptional)
          RecoveryStackFrameMode.Optional;
        else
        {
          mutable optional = false;
          mutable required = false;
          foreach (parent in frame.Parents)
            match (parent.Mode)
            {
              | Optional => optional = true;
              | Required => required = true;
              | Both     => optional = true; required = true;
            }
          if (optional)
            if (required)
              RecoveryStackFrameMode.Both;
            else
              RecoveryStackFrameMode.Optional;
          else
            RecoveryStackFrameMode.Required;
        }
      }
    }

    public MaxFailPos : int
    {
      get { _maxFailPos }
      set { _maxFailPos = value }
    }

    public IsSuccess : bool { get { ErrorData.Count == 0 } }
    
    public TokenEnumerator1 : TokenEnumerator;
    public TokenEnumerator2 : TokenEnumerator;

    public Parser : string
    {
      get
      {
        if (LastParseEnd >= 0)
          Text.Substring(LastParseStart, LastParseEnd - LastParseStart)
        else
          "<fail>"
      }
    }

    public RestText : string
    {
      get { Text.Substring(if (LastParseEnd >= 0) LastParseEnd else LastParseStart) }
    }

    public mutable PreviousTextSize : int;

    public PreviousText : string
    {
      get
      {
        when (PreviousTextSize <= 0)
          PreviousTextSize = 20;

        def pos = if (LastParseEnd >= 0) LastParseEnd else LastParseStart;
        if (pos >= PreviousTextSize)
          Text.Substring(pos - PreviousTextSize, PreviousTextSize)
        else
          Text.Substring(0, pos)
      }
    }

    public Allocate(size : int) : int
    {
      def newAst = allocated;
      allocated = allocated + size;
      while (ast.Length <= allocated)
        Array.Resize(ref ast, (ast.Length * 3) / 2);

      newAst
    }

    public Allocate(size : int, ruleId : int) : int
    {
      def newAst = Allocate(size);
      ast[newAst] = ruleId;
      newAst;
    }

    public TryGetPrefix(pos : ref int, prefixAst : ref int) : int
    {
      mutable bestResult = ast[prefixAst + ExtensibleRuleParser.PrefixOfs.List];
      when (bestResult < 0)
      {
        def error = ErrorData[~bestResult];
        when (error.Skip.Length == 0)
          return -1;//правило восстановилось пустым.
        pos += error.Skip.Length; // грязь
        prefixAst = GetAst(pos, ast[prefixAst + ExtensibleRuleParser.PrefixOfs.Id]);
        bestResult = ast[prefixAst + ExtensibleRuleParser.PrefixOfs.List]; // исходная ссылка на AST
        assert3(bestResult >= 0 || ErrorData[~bestResult].Skip.Length == 0);
      }
      bestResult;
    }

    public TryGetPostfix(pos : ref int, postfixAst : ref int) : int
    {
      mutable bestResult = ast[postfixAst + ExtensibleRuleParser.PostfixOfs.List];
      when (bestResult < 0)
      {
        def error = ErrorData[~bestResult];
        when (error.Skip.Length == 0)
          return -1;//правило восстановилось пустым.
        pos += error.Skip.Length; // грязь
        postfixAst = GetAst(pos, ast[postfixAst + ExtensibleRuleParser.PostfixOfs.Id] & ExtensibleRuleParser.PostfixMask.Id);
        bestResult = ast[postfixAst + ExtensibleRuleParser.PostfixOfs.List]; // исходная ссылка на AST
        assert3(bestResult >= 0 || ErrorData[~bestResult].Skip.Length == 0);
      }
      bestResult;
    }

    public TryGetAst(pos : int, ruleId : int) : int
    {
      for (mutable astPtr = memoize[pos]; astPtr > 0; astPtr = ast[astPtr + 1])
        when (ast[astPtr] == ruleId)
          return astPtr;
      0;
    }

    public GetAst(pos : int, ruleId : int) : int
    {
      def astPtr = TryGetAst(pos , ruleId);
      assert3(astPtr > 0);
      astPtr;
    }

    public GetSize(sizePos : int) : int
    {
      def size = ast[sizePos];
      if (size >= 0)
        size
      else if (size == int.MinValue)
        0
      else
      {
        def error = ErrorData[~size];
        error.Skip.Length + error.Data
      }
    }

    public GetSkip(sizePos : int) : int
    {
      def size = ast[sizePos];
      if (size >= 0)
        0
      else if (size == int.MinValue)
        0
      else
      {
        def error = ErrorData[~size];
        error.Skip.Length
      }
    }

    public GetSkipAndSize(sizePos : int) : int * int
    {
      def size = ast[sizePos];
      if (size >= 0)
        (0, size)
      else if (size == int.MinValue)
        (0, 0)
      else
      {
        def error = ErrorData[~size];
        (error.Skip.Length, error.Data)
      }
    }

    public GetSkipAndSize2(sizePos : int) : int
    {
      def size = ast[sizePos];
      if (size >= 0)
        size
      else if (size == int.MinValue)
        0
      else
      {
        def error = ErrorData[~size];
        ~(error.Skip.Length + error.Data)
      }
    }

    public AstSize(astPtr : int, begin : int, end : int) : int
    {
      mutable size = 0;
      def end = astPtr + end;
      for (mutable i = astPtr + begin; i < end; ++i)
        size += GetSize(i);
      size;
    }

    public PatchAst(ruleParser : IRecoveryRuleParser, astPtr : int, errorIndex : int, failState : int, startState : int, failFieldOffset : int) : void
    {
      if (startState == -2)
        ast[astPtr + 2] = ~failState;
      else
      {
        if (startState >= 0)
          ast[astPtr + 2] = ~startState;
        else
          ast[astPtr + 2] = AstParsedState;
        mutable field = astPtr + failFieldOffset;
        ast[field] = ~errorIndex;
        ++field;
        for (mutable state = ruleParser.GetNextState(failState); state != startState; state = ruleParser.GetNextState(state))
        {
          ast[field] = int.MinValue;
          ++field;
        }
      }
    }

    public CreateAst() : N2.Ast
    {
      def walkerHost = this.ParserHost.GetWalkerHost(StandardWalkerTypes.Ast);
      def start_Walker = walkerHost.GetRootWalker(this);
      mutable pos = 0;
      def result = late start_Walker.Walk(ref pos, this);
      result :> N2.Ast
    }

    public GetSpans(startPos : int, endPos : int, spans : SCG.List[SpanInfo]) : void
    {
      def walkerHost = this.ParserHost.GetWalkerHost(StandardWalkerTypes.Highlighter);
      def start_Walker = walkerHost.GetRootWalker(this);
      mutable pos = 0;
      _ = late start_Walker.Walk(ref pos, this, spans, startPos, endPos);
    }

    public GetOutlining(outlining : SCG.List[OutliningInfo]) : void
    {
      def timer = Stopwatch.StartNew();
      def context = N2.Internal.OutliningWalkerContext(outlining);
      def walkerHost = this.ParserHost.GetWalkerHost(StandardWalkerTypes.Outlining);
      def start_Walker = walkerHost.GetRootWalker(this);
      mutable pos = 0;
      timer.Stop();
      //Debug.WriteLine($"GetOutlining prepare: $(timer.Elapsed)");
      timer.Reset();
      timer.Start();
      _ = late start_Walker.Walk(ref pos, this, context);
      timer.Stop();
      //Debug.WriteLine($"GetOutlining Walk: $(timer.Elapsed)");
    }

    public Reflect() : ReflectionStruct
    {
      def walkerHost = this.ParserHost.GetWalkerHost(StandardWalkerTypes.Reflection);
      def start_Walker = walkerHost.GetRootWalker(this);
      mutable pos = 0;
      def result = late start_Walker.Walk(ref pos, this);
      result :> ReflectionStruct
    }

    public GetErrors() : array[Error]
    {
      def result = array(ErrorData.Count);
      foreach (errorData in ErrorData with index)
      {
        def loc = Location(Source, errorData.Skip);
        result[index] = ParseError(loc, errorData.Result);
      }
      result
    }
  }
}
