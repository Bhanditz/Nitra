using N2.Runtime.Reflection;
using Nemerle;
using Nemerle.Collections;
using Nemerle.Imperative;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;

using SCG =  System.Collections.Generic;

namespace N2.Internal
{
  public class TokenEnumerator
  {
    _parser : Parser;

    public this(parser : Parser) { _parser = parser; }

    _stack  : SCG.Stack[ParseFrame] = SCG.Stack();
    
    mutable _ruleStructure : RuleStructure;
    mutable _fieldIndex    : int;
    mutable _astPtr        : int;
    mutable _curTextPos    : int;
    mutable _listEndPos    : int;
    mutable _listSep       : bool;
    
    public Start(astPtr : int, curTextPos : int) : TokenEnumerator
    {
      assert3(_parser != null);
      _stack.Clear();
      
      _ruleStructure  = _parser.ParserHost.GetRuleStructure(_parser, astPtr);
      _astPtr         = astPtr;
      _fieldIndex     = -1;
      _curTextPos     = curTextPos;
      _listEndPos     = -1;
      this
    }
    
    public NextTokenSize() : int
    {
      _fieldIndex++;
      def rules = _ruleStructure.Subrules;
      def state = _parser.ast[_astPtr + ExtensibleRuleParser.AstOfs.State];
      if (_fieldIndex >= rules.Count)
      {
        if (_stack.Count > 0)
        {
          (_ruleStructure, _astPtr, _fieldIndex, _curTextPos, _listEndPos, _listSep) = _stack.Pop();
          NextTokenSize()
        }
        else
          -1
      }
      else
      {
        def ruleInfo = rules[_fieldIndex];
        def sizePtr = _astPtr + ruleInfo.Offset;
        def size     = _parser.GetSkipAndSize2(sizePtr);
        mutable fullSize;
        mutable skip = 0;
        
        if (size >= 0)
          fullSize = size;
        else
        {
          fullSize = ~size;
          skip = fullSize - _parser.GetSkip(sizePtr);
        }

        match (ruleInfo)
        {
          | Empty =>
            if (state >= 0 && _ruleStructure.Subrules[_fieldIndex].State >= state)
              -1
            else
            {
              _curTextPos += fullSize;
              NextTokenSize()
            }

          | TokenCall
          | TokenString
          | ExtensibleCall    (_, _, true)
          | SimpleCall        (_, true) =>
            if (state >= 0 && _ruleStructure.Subrules[_fieldIndex].State >= state)
              -1
            else
            {
              _curTextPos += fullSize;
              fullSize - skip
            }
            
          | SimpleCall        (id, _) =>
            if (state >= 0 && _ruleStructure.Subrules[_fieldIndex].State >= state)
            {
              _stack.Push(ParseFrame(_ruleStructure, _astPtr, _fieldIndex, _curTextPos + fullSize, _listEndPos, _listSep));
              _curTextPos    += skip;
              _astPtr         = _parser.TryGetAst(_curTextPos, id);
              if (_astPtr > 0)
              {
                _ruleStructure  = _parser.ParserHost.GetRuleStructure(_parser, _astPtr);
                _fieldIndex     = -1;
                _listEndPos = -1;
                NextTokenSize()
              }
              else
                -1
            }
            else
            {
              _stack.Push(ParseFrame(_ruleStructure, _astPtr, _fieldIndex, _curTextPos + fullSize, _listEndPos, _listSep));
              _curTextPos    += skip;
              _astPtr         = _parser.TryGetAst(_curTextPos, id);
              if (_astPtr > 0)
              {
                _ruleStructure  = _parser.ParserHost.GetRuleStructure(_parser, _astPtr);
                _fieldIndex     = -1;
                _listEndPos = -1;
                NextTokenSize()
              }
              else
                -1
            }

          | ExtensibleCall(prefixId, postfixId, _)    =>
            if (fullSize - skip == 0)
              _curTextPos += skip;
            else if (_listEndPos == -1)
            {
              _listEndPos     = _curTextPos + fullSize;
              _curTextPos    += skip;
              mutable prefixAst = _parser.GetAst(_curTextPos, prefixId);
              def astPtr      = _parser.TryGetPrefix(ref _curTextPos, ref prefixAst);
              assert3(astPtr > 0);
              def rule        = _parser.ParserHost.GetRuleStructure(_parser, astPtr);
              def astSize     = rule.GetSize(astPtr, _parser);
              _stack.Push(ParseFrame(_ruleStructure, _astPtr, _fieldIndex - 1, _curTextPos + astSize, _listEndPos, _listSep));
              _astPtr         = astPtr;
              _ruleStructure  = rule;
              _fieldIndex     = -1;
            }
            else if (_curTextPos < _listEndPos)
            {
              mutable postfixAst = _parser.GetAst(_curTextPos, postfixId);
              def bestResult = _parser.ParserHost.GetExtentionRuleParser(postfixId).BestPostfix(_parser.TryGetPostfix(ref _curTextPos, ref postfixAst), _parser);
              assert3(bestResult > 0);
              def rule        = _parser.ParserHost.GetRuleStructure(_parser, bestResult);
              def astSize     = rule.GetSize(bestResult, _parser);
              _stack.Push(ParseFrame(_ruleStructure, _astPtr, _fieldIndex - 1, _curTextPos + astSize, _listEndPos, _listSep));
              _astPtr         = bestResult;
              _ruleStructure  = rule;
              _fieldIndex     = -1;
            }
            else
            {
              assert3(_curTextPos == _listEndPos);
              _fieldIndex = int.MaxValue - 1;
            }

            NextTokenSize()

          | Option            (rule) =>
            if (fullSize - skip == 0)
            {
              _curTextPos += skip;
              NextTokenSize()
            }
            else
            {
              _stack.Push(ParseFrame(_ruleStructure, _astPtr, _fieldIndex, _curTextPos + fullSize, _listEndPos, _listSep));
              _curTextPos    += skip;
              _astPtr         = _parser.GetAst(_curTextPos, rule.Id);
              _ruleStructure  = _parser.ParserHost.GetRuleStructure(_parser, _astPtr);
              _fieldIndex     = -1;
              _listEndPos = -1;
              NextTokenSize()
            }

          | List              (rule) =>
            if (fullSize - skip == 0)
              _curTextPos += skip;
            else if (_listEndPos == -1)
            {
              _listEndPos     = _curTextPos + fullSize;
              _curTextPos    += skip;
              def astPtr      = _parser.GetAst(_curTextPos, rule.Id);
              def astSize     = rule.GetSize(astPtr, _parser);
              _stack.Push(ParseFrame(_ruleStructure, _astPtr, _fieldIndex - 1, _curTextPos + astSize, _listEndPos, _listSep));
              _astPtr         = astPtr;
              _ruleStructure  = _parser.ParserHost.GetRuleStructure(_parser, _astPtr);
              _fieldIndex     = -1;
            }
            else if (_curTextPos < _listEndPos)
            {
              def astPtr      = _parser.GetAst(_curTextPos, rule.Id);
              def astSize     = rule.GetSize(astPtr, _parser);
              _stack.Push(ParseFrame(_ruleStructure, _astPtr, _fieldIndex - 1, _curTextPos + astSize, _listEndPos, _listSep));
              _astPtr         = astPtr;
              _ruleStructure  = _parser.ParserHost.GetRuleStructure(_parser, _astPtr);
              _fieldIndex     = -1;
            }
            else
            {
              assert3(_curTextPos == _listEndPos);
              _fieldIndex = int.MaxValue - 1;
            }

            NextTokenSize()

          | ListWithSeparator (rule, separator) =>
            def curRule = if (_listSep) separator else rule;
            
            if (fullSize - skip == 0)
              _curTextPos += skip;
            else if (_listEndPos == -1)
            {
              _listEndPos     = _curTextPos + fullSize;
              _curTextPos    += skip;
              def astPtr      = _parser.GetAst(_curTextPos, curRule.Id);
              def astSize     = curRule.GetSize(astPtr, _parser);
              _stack.Push(ParseFrame(_ruleStructure, _astPtr, _fieldIndex - 1, _curTextPos + astSize, _listEndPos, false));
              _astPtr         = astPtr;
              _ruleStructure  = _parser.ParserHost.GetRuleStructure(_parser, _astPtr);
              _fieldIndex     = -1;
            }
            else if (_curTextPos < _listEndPos)
            {
              def astPtr      = _parser.GetAst(_curTextPos, curRule.Id);
              def astSize     = curRule.GetSize(astPtr, _parser);
              _stack.Push(ParseFrame(_ruleStructure, _astPtr, _fieldIndex - 1, _curTextPos + astSize, _listEndPos, !_listSep));
              _astPtr         = astPtr;
              _ruleStructure  = _parser.ParserHost.GetRuleStructure(_parser, _astPtr);
              _fieldIndex     = -1;
            }
            else
            {
              assert3(_curTextPos == _listEndPos);
              _fieldIndex = int.MaxValue - 1;
            }
          
            NextTokenSize()
              
          | Predicate                => assert3(false); //NextTokenSize()
          | Marker                   => assert3(false); //NextTokenSize()
        }
      }
    }
  }
}
