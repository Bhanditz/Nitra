using N2.Internal;

using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;

namespace N2
{
  public class ParseError : Error
  {
    protected _recoveries : array[RecoveryStackFrame];

    public this(location : Location, recoveries : array[RecoveryStackFrame])
    {
      //assert(recoveries.Length > 0);
      base(location);
      _recoveries = recoveries;
    }
    
    public Recoveries : ReadOnlyCollection[RecoveryStackFrame]
    {
      [Memoize] get { ReadOnlyCollection(_recoveries) }
    }

    public override Message : string
    {
      [Memoize]
      get
      {
        def nodeMap  = Dictionary();
        def expected = List();
        
        def skipedStatesCode(postfix : List[string], frame : RecoveryStackFrame, startState : int, endState : int) : void
        {
          def res = frame.CodeForStates(startState, endState, true);
          when (res.Length != 0)
            postfix.Add($<#..$(frame.CodeForStates(startState, endState, true); " ")#>);
        }
        
        foreach (topFrame when topFrame.IsTop in _recoveries)
        {
          assert3(topFrame.ParseAlternatives.Length == 1);
          def node = ParseAlternativeNode(topFrame, 0, nodeMap);
          def alternatives = node.GetFlatParseAlternatives();
          foreach (alternative in alternatives)
          {
            def prefixes = List();
            def postfix = List();
            foreach (node in alternative)
            {
              def frame = node.Frame;
              def parsingFailAtState = frame.FailState2;
              def recursionState     = frame.FailState;
              def endState = node.ParseAlternative.State;
              if (frame.IsTop)
                skipedStatesCode(prefixes, frame, parsingFailAtState, endState);
              else
              {
                when (parsingFailAtState < recursionState)
                  skipedStatesCode(prefixes, frame, parsingFailAtState, recursionState);
                  
                def startState = frame.GetNextState(recursionState);

                when (startState >= 0 && (startState < endState || endState < 0))
                  skipedStatesCode(postfix, frame, startState, endState);
              }
            }
            prefixes.AddRange(postfix);
            expected.Add($"..$prefixes");
          }
        }
        def msg = $"Expected: ..$(expected.Distinct()).";
        msg
      }
    }

    public DebugText : string
    {
      [Memoize]
      get
      {
        $<#..$(_recoveries.Filter(f => f.IsTop); "\n")#>
      }
    }
  }
}
