using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using N2.Internal;
using N2.Runtime;

using System;
using System.Linq;
using SCG = System.Collections.Generic;

namespace N2
{
  public class CompositeGrammar
  {
    public Grammars                 : SCG.Dictionary[GrammarDescriptor, int];
    public ParserHost               : ParserHost;
    public SimpleRuleParsers        : Hashtable[SimpleRuleDescriptor, Internal.RuleParser];
    public ExtensibleRuleParsers    : Hashtable[ExtensibleRuleDescriptor * int, Internal.ExtensibleRuleParser];
    public ExtensibleRules          : Hashtable[ExtensibleRuleDescriptor, ExtensibleRuleParserData] = Hashtable();

    internal this(parserHost : ParserHost)
    {
      Grammars = SCG.Dictionary();
      ParserHost = parserHost;
    }

    private this(parent : CompositeGrammar, grammarDescriptor : GrammarDescriptor)
    {
      Grammars = SCG.Dictionary(parent.Grammars);
      ParserHost = parent.ParserHost;

      def addGrammar(descriptor)
      {
        when (!Grammars.ContainsKey(descriptor))
        {
          Grammars.Add(descriptor, 0);
          foreach (descriptor in descriptor.Dependencies)
            addGrammar(descriptor);
        }
      }
      addGrammar(grammarDescriptor);

      def rules = Grammars.Keys.SelectMany(gd => gd.Rules).NToArray();

      def extentionRuleDescriptors = rules
        .OfType.[ExtentionRuleDescriptor]()
        .Grouping(rd => (rd.BaseRule, rd))
        .Map((baseRd, extetions) =>
        {
          def prefix = extetions.OfType.[PrefixRuleDescriptor]().NToArray();
          def postfix = extetions.OfType.[PostfixRuleDescriptor]().NToArray();
          Array.Sort.[PostfixRuleDescriptor](postfix, ((l, r) => l.BindingPower.CompareTo(r.BindingPower)));
          (baseRd, (prefix, postfix))
        });

      foreach (extensibleRule in rules.OfType.[ExtensibleRuleDescriptor]())
      {
        def (prefixDescriptors, postfixDescriptors) = extentionRuleDescriptors.GetValueOrDefault(extensibleRule, (array[], array[]));
        ExtensibleRules[extensibleRule] = ExtensibleRuleParserData(this, extensibleRule, prefixDescriptors, postfixDescriptors);
      }

      SimpleRuleParsers = Hashtable(rules
        .OfType.[SimpleRuleDescriptor]()
        .Map(rd => (rd, rd.NewParser(ParserHost.NewRuleId(rd), this))));

      foreach (extensibleRule in ExtensibleRules)
        extensibleRule.Value.Init();

      foreach (kv in SimpleRuleParsers)
        kv.Value.Init();

      foreach (extensibleRule in ExtensibleRules)
        _ = GetExtensibleRuleParser(extensibleRule.Key, 0);
    }

    public GetExtensibleRuleParser(rd : ExtensibleRuleDescriptor, bindingPower : int) : Internal.ExtensibleRuleParser
    {
      def key = (rd, bindingPower);
      if (ExtensibleRuleParsers.Contains(key))
        ExtensibleRuleParsers[key]
      else
      {
        def parser = Internal.ExtensibleRuleParser(ExtensibleRules[rd], bindingPower);
        ExtensibleRuleParsers[key] = parser;
        parser
      }
    }

    public GetSimpleRuleParser(rd : SimpleRuleDescriptor) : Internal.RuleParser
    {
      SimpleRuleParsers[rd]
    }

    internal static AddGrammar(parent : CompositeGrammar, grammarDescriptor : GrammarDescriptor) : CompositeGrammar
    {
      if (parent.Grammars.ContainsKey(grammarDescriptor))
        parent
      else
        CompositeGrammar(parent, grammarDescriptor)
    }
  }
}
