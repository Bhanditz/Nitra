using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using N2.Internal;
using N2.Runtime;

using System;
using System.Diagnostics;
using System.Linq;
using SCG = System.Collections.Generic;

namespace N2
{
#if !PARSER_DEBUG
  //[DebuggerStepThroughAttribute]
#endif
  public class CompositeGrammar
  {
    public Grammars                 : Set[GrammarDescriptor];
    public ParserHost               : ParserHost;
    public SimpleRuleParsers        : Hashtable[SimpleRuleDescriptor, SimpleRuleParser];
    public ExtensibleRules          : Hashtable[ExtensibleRuleDescriptor, ExtensibleRuleParserData] = Hashtable();

    public StartID                  : int;
    public RuleParserMap            : SCG.List[object] = SCG.List();

    public NewRuleId(ruleParser : object) : int
    {
      def id = StartID + RuleParserMap.Count;
      RuleParserMap.Add(ruleParser);
      id
    }

    internal this(parserHost : ParserHost)
    {
      StartID = 0;
      Grammars = Set();
      SimpleRuleParsers = Hashtable();
      ParserHost = parserHost;
    }

    internal this(parserHost : ParserHost, grammars : Set[GrammarDescriptor], startID : int)
    {
      StartID = startID;
      Grammars = grammars;
      ParserHost = parserHost;

      def rules = Grammars.SelectMany(gd => gd.Rules).NToArray();

      def extensionRuleDescriptors = rules
        .OfType.[ExtensionRuleDescriptor]()
        .Grouping(rd => (rd.BaseRule, rd))
        .Map((baseRd, extetions) =>
        {
          def prefix = extetions.OfType.[PrefixRuleDescriptor]().NToArray();
          def postfix = extetions.OfType.[PostfixRuleDescriptor]().NToArray();
          Array.Sort.[PostfixRuleDescriptor](postfix, ((l, r) => l.BindingPower.CompareTo(r.BindingPower)));
          (baseRd, (prefix, postfix))
        });

      foreach (extensibleRule in rules.OfType.[ExtensibleRuleDescriptor]())
      {
        def (prefixDescriptors, postfixDescriptors) = extensionRuleDescriptors.GetValueOrDefault(extensibleRule, (array[], array[]));
        ExtensibleRules[extensibleRule] = ExtensibleRuleParserData(this, extensibleRule, prefixDescriptors, postfixDescriptors);
      }

      SimpleRuleParsers = Hashtable(rules
        .OfType.[SimpleRuleDescriptor]()
        .Map(rd => (rd, rd.NewParser(this))));

      foreach (extensibleRule in ExtensibleRules)
        extensibleRule.Value.Init();

      foreach (kv in SimpleRuleParsers)
        kv.Value.Init();

      foreach (extensibleRule in ExtensibleRules)
        _ = GetExtensibleRuleParser(extensibleRule.Key, 0);

      UpdateMandatoryTokens();
    }

    private UpdateMandatoryTokens() : void
    {
      def simple = SCG.List(SimpleRuleParsers.Values);
      def prefix = SCG.List(ExtensibleRules.Values.Map(data => data.PrefixParsers).Flatten());
      def postfix = SCG.List(ExtensibleRules.Values.Map(data => data.PostfixParsers).Flatten());
      def extensible = SCG.List(ExtensibleRules.Values.Map(data => data.Parsers.Filter(_ != null)).Flatten());

      foreach (parser in simple)     parser.MandatoryTokens = ~0;
      foreach (parser in prefix)     parser.MandatoryTokens = ~0;
      foreach (parser in postfix)    parser.MandatoryTokens = ~0;
      foreach (parser in extensible) parser.MandatoryTokens = ~0;

      mutable updated = true;
      while (updated)
      {
        updated = false;
        foreach (parser in simple)     when (parser.UpdateMandatoryTokens()) updated = true;
        foreach (parser in prefix)     when (parser.UpdateMandatoryTokens()) updated = true;
        foreach (parser in postfix)    when (parser.UpdateMandatoryTokens()) updated = true;
        foreach (parser in extensible) when (parser.UpdateMandatoryTokens()) updated = true;
      }
    }

    public GetExtensibleRuleParser(rd : ExtensibleRuleDescriptor, bindingPower : int) : Internal.ExtensibleRuleParser
    {
      ExtensibleRules[rd].GetParser(bindingPower)
    }

    public GetSimpleRuleParser(rd : SimpleRuleDescriptor) : Internal.SimpleRuleParser
    {
      SimpleRuleParsers[rd]
    }
    
    public ParstAllGrammarTokens(pos : int, parser : Parser) : SCG.HashSet[int]
    {
      def text = parser.Text;
      def results = SCG.HashSet.[int]();
      
      foreach (d in this.Grammars)
        d.ParstAllGrammarTokens(pos, text, results);
        
      foreach (p when p.Value.IsTokenRule in SimpleRuleParsers)
        _ = results.Add(p.Value.Parse(pos, text, parser));
        
      foreach (p when p.Key.IsTokenRule in ExtensibleRules)
        _ = results.Add(p.Value.GetParser(0).Parse(pos, text, parser));
        
      results
    }
  }
}
