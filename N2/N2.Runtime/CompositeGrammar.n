using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using N2.Internal;
using N2.Runtime;

using System;
using System.Diagnostics;
using System.Linq;
using SCG = System.Collections.Generic;

namespace N2
{
#if !PARSER_DEBUG
  [DebuggerStepThroughAttribute]
#endif
  public class CompositeGrammar
  {
    public Grammars                 : SCG.HashSet[GrammarDescriptor];
    public ParserHost               : ParserHost;
    public SimpleRuleParsers        : Hashtable[SimpleRuleDescriptor, SimpleRuleParser];
    public ExtensibleRules          : Hashtable[ExtensibleRuleDescriptor, ExtensibleRuleParserData] = Hashtable();

    public StartID                  : int;
    public RuleParserMap            : SCG.List[object] = SCG.List();

    public NewRuleId(ruleParser : object) : int
    {
      def id = StartID + RuleParserMap.Count;
      RuleParserMap.Add(ruleParser);
      id
    }

    internal this(parserHost : ParserHost)
    {
      StartID = 0;
      Grammars = SCG.HashSet();
      ParserHost = parserHost;
    }

    internal this(parent : CompositeGrammar, grammarDescriptor : GrammarDescriptor, startID : int)
    {
      StartID = startID;
      Grammars = SCG.HashSet(parent.Grammars);
      ParserHost = parent.ParserHost;

      def addGrammar(descriptor)
      {
        when (!Grammars.Contains(descriptor))
        {
          _ = Grammars.Add(descriptor);
          foreach (descriptor in descriptor.Dependencies)
            addGrammar(descriptor);
        }
      }
      addGrammar(grammarDescriptor);

      def rules = Grammars.SelectMany(gd => gd.Rules).NToArray();

      def extentionRuleDescriptors = rules
        .OfType.[ExtentionRuleDescriptor]()
        .Grouping(rd => (rd.BaseRule, rd))
        .Map((baseRd, extetions) =>
        {
          def prefix = extetions.OfType.[PrefixRuleDescriptor]().NToArray();
          def postfix = extetions.OfType.[PostfixRuleDescriptor]().NToArray();
          Array.Sort.[PostfixRuleDescriptor](postfix, ((l, r) => l.BindingPower.CompareTo(r.BindingPower)));
          (baseRd, (prefix, postfix))
        });

      foreach (extensibleRule in rules.OfType.[ExtensibleRuleDescriptor]())
      {
        def (prefixDescriptors, postfixDescriptors) = extentionRuleDescriptors.GetValueOrDefault(extensibleRule, (array[], array[]));
        ExtensibleRules[extensibleRule] = ExtensibleRuleParserData(this, extensibleRule, prefixDescriptors, postfixDescriptors);
      }

      SimpleRuleParsers = Hashtable(rules
        .OfType.[SimpleRuleDescriptor]()
        .Map(rd => (rd, rd.NewParser(this))));

      foreach (extensibleRule in ExtensibleRules)
        extensibleRule.Value.Init();

      foreach (kv in SimpleRuleParsers)
        kv.Value.Init();

      foreach (extensibleRule in ExtensibleRules)
        _ = GetExtensibleRuleParser(extensibleRule.Key, 0);
    }

    public GetExtensibleRuleParser(rd : ExtensibleRuleDescriptor, bindingPower : int) : Internal.ExtensibleRuleParser
    {
      ExtensibleRules[rd].GetParser(bindingPower)
    }

    public GetSimpleRuleParser(rd : SimpleRuleDescriptor) : Internal.RuleParser
    {
      SimpleRuleParsers[rd]
    }
  }
}
