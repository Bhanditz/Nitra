using Nemerle;
using Nemerle.Collections;
using Nemerle.Compiler.Parsetree;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using SCG = System.Collections.Generic;
using System.Linq;

using N2.Model;

namespace N2.Compiler
{
  internal partial class ParseMethodEmitter : MethodEmitter
  {
    public override CompileOption(code : SCG.List[PExpr], field : RuleStructureField.Option) : void
    {
      def headPredicateCode = CompilePredicate(field.HeadPredicates, GotoFailParseLabel(field));
      def tailPredicateCode = CompilePredicate(field.Rule.TailPredicates, GotoFailLabel(field.Rule));

      code.Add(<[
      $(ParseLabel(field));
        _ = $(field.ToString());
        $(CheckOwnerMemoize(field));
        $headPredicateCode;
        $(AllocateParentAst(field));
      $(RecoveryLabel(field));
        $(AstStart(field.Rule)) = $CurTextPos;
        $(GotoParseLabel(field.Rule.NotMarkerFields[0]));

      $(OkLabel(field.Rule));
        $tailPredicateCode;
        $(AstPtr(field.Rule).Set(field.Rule.HeaderState, <[ N2.Internal.Parser.AstParsedState ]>));// правило полностью разобрано.
        $(AstPtr(field.Owner).Set(field, <[ $CurTextPos - $(AstStart(field.Rule)) ]>));
        $(GotoContinueParseLabel(field));

      $(FailLabel(field.Rule));
        when (parseState > $(field.Rule.AllocateState)) // АСТ создано
          $(AstPtr(field.Rule).Set(field.Rule.HeaderState, <[ parseState ]>));
        $(AstPtr(field.Owner).Set(field, <[ 0 ]>));
        $CurTextPos = $(AstStart(field.Rule));
        $(GotoContinueParseLabel(field));
      ]>);
    }
  }
}
