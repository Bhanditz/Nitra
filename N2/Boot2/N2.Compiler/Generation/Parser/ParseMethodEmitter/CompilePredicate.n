using Nemerle;
using Nemerle.Collections;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Imperative;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using SCG = System.Collections.Generic;
using System.Linq;

using N2.Model;

namespace N2.Compiler
{
  internal partial class ParseMethodEmitter : MethodEmitter
  {
    public CompilePredicate(predicates : array[RuleStructure.Predicate], failLabelGotoExpr : PExpr) : PExpr
    {
      when (predicates.Length == 0)
        return <[ {} ]>;

      def code = SCG.List();

      def tailPredicatesMaxPos   = CreateVariable(Util.tmpname("tailPredicatesMaxPos"));
      def tailPredicatesStartPos = CreateVariable(Util.tmpname("tailPredicatesStartPos"));

      def predicateOkLabel   = Environment.MakeLabel(Util.tmpname("predicateOk"));
      def predicateFailLabel = Environment.MakeLabel(Util.tmpname("predicateFail"));

      def continueLabels = array(predicates.Length);
      def startCode      = array(predicates.Length);
      for (mutable i = 0; i < predicates.Length - 1; ++i)
      {
        def predicateStart = Environment.MakeLabel(Util.tmpname("predicateStart"));
        continueLabels[i] = predicateStart;
        startCode[i + 1] = <[ $(predicateStart.Label()); $CurTextPos = $(tailPredicatesStartPos : dyn); ]>;
      }
      startCode[0] = <[ {} ]>;
      continueLabels[continueLabels.Length - 1] = predicateOkLabel;

      code.Add(<[ _ = "Predicate block"; $(tailPredicatesStartPos : dyn) = $CurTextPos; $(tailPredicatesMaxPos : dyn) = parser.MaxFailPos; ]>);
      foreach (predicate in predicates with i)
      {
        code.Add(startCode[i]);
        code.Add(GotoParseLabel(predicate.NotMarkerFields[0]));

        def (subPredicateCode, subPredicateFailLabel) = CompilePredicate(predicate.TailPredicates);

        def expr = 
          if (predicate.IsAnd)
          <[
            $(OkLabel(predicate));   $subPredicateCode;      $(continueLabels[i].Goto());
            $(FailLabel(predicate)); $subPredicateFailLabel; $(predicateFailLabel.Goto());
          ]>
          else
          <[
            $(OkLabel(predicate));   $subPredicateCode;      $(predicateFailLabel.Goto());
            $(FailLabel(predicate)); $subPredicateFailLabel; $(continueLabels[i].Goto());
          ]>;
        code.Add(expr);

        CompileFields(code, predicate);
      }

      code.Add(predicateFailLabel.Label());
      code.Add(<[ $CurTextPos = $(tailPredicatesStartPos : dyn); when (parser.MaxFailPos < $(tailPredicatesStartPos : dyn)) parser.MaxFailPos = $(tailPredicatesStartPos : dyn); ]>);
      code.Add(failLabelGotoExpr);

      code.Add(predicateOkLabel.Label());
      code.Add(<[ $CurTextPos = $(tailPredicatesStartPos : dyn); parser.MaxFailPos = $(tailPredicatesMaxPos : dyn); ]>);

      code.FlattenPExpr()
    }

    public CompilePredicate(predicates : array[RuleStructure.Predicate]) : PExpr * PExpr
    {
      when (predicates.Length == 0)
        return (<[ {} ]>, <[ {} ]>);

      def failLabel = Environment.MakeLabel(Util.tmpname("failLabel"));
      (CompilePredicate(predicates, failLabel.Goto()), failLabel.Label())
    }
  }
}
