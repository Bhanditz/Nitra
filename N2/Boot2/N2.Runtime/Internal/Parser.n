using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Diagnostics;

using SCG = System.Collections.Generic;

namespace N2.Internal
{
#if !PARSER_DEBUG
  [DebuggerStepThroughAttribute]
#endif
  public struct Parser
  {
    public static ResultOffset = 0;
    public static AstOffset    = 1;

    public mutable ast            : array[int];
    public mutable memoize        : array[int];
    public mutable allocated      : int;
    public         parserHost     : ParserHost;
    public mutable IsRecoveryMode : bool;

    public         Source         : SourceSnapshot;
    public         Text           : string;
    public mutable LastParseStart : int;
    public mutable LastParseEnd   : int;

    public ParseResult : string
    {
      get
      {
        if (LastParseEnd >= 0)
          Text.Substring(LastParseStart, LastParseEnd - LastParseStart)
        else
          "<fail>"
      }
    }

    public RestText : string
    {
      get { Text.Substring(if (LastParseEnd >= 0) LastParseEnd else LastParseStart) }
    }

    public mutable PreviousTextSize : int;

    public PreviousText : string
    {
      get
      {
        when (PreviousTextSize <= 0)
          PreviousTextSize = 20;

        def pos = if (LastParseEnd >= 0) LastParseEnd else LastParseStart;
        if (pos >= PreviousTextSize)
          Text.Substring(pos - PreviousTextSize, PreviousTextSize)
        else
          Text.Substring(0, pos)
      }
    }

    public this(source : SourceSnapshot, initalSize : int, parserHost : ParserHost)
    {
      def textSize    = source.Text.Length;
      this.Source     = source;
      this.Text       = source.Text;
      this.ast        = array(if (initalSize < 10) 10 else initalSize);
      this.memoize    = array(textSize + 1);
      this.allocated  = 0;
      this.parserHost = parserHost;
      IsRecoveryMode  = false;
      LastParseStart  = -1;
      LastParseEnd    = -1;
    }

    public Allocate(size : int) : int
    {
      def newAst = allocated;
      allocated = allocated + size;
      while (ast.Length <= allocated)
        Array.Resize(ref ast, (ast.Length * 3) / 2);

      newAst
    }

    public Allocate(size : int, ruleId : int) : int
    {
      def newAst = Allocate(size);
      ast[newAst] = ruleId;
      newAst;
    }
  }
}
