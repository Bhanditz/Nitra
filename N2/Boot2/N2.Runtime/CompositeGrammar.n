using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using N2.Internal;
using N2.Runtime;

using System;
using System.Diagnostics;
using System.Linq;
using SCG = System.Collections.Generic;

namespace N2
{
#if !PARSER_DEBUG
  //[DebuggerStepThroughAttribute]
#endif
  public class CompositeGrammar
  {
    public Grammars                 : Set[GrammarDescriptor];
    public ParserHost               : ParserHost;
    public SimpleRuleParsers        : Hashtable[SimpleRuleDescriptor, SimpleRuleParser];
    public ExtensibleRules          : Hashtable[ExtensibleRuleDescriptor, ExtensibleRuleParserData] = Hashtable();

    public StartID                  : int;
    public RuleParserMap            : SCG.List[object] = SCG.List();

    public NewRuleId(ruleParser : object) : int
    {
      def id = StartID + RuleParserMap.Count;
      RuleParserMap.Add(ruleParser);
      id
    }

    internal this(parserHost : ParserHost)
    {
      StartID = 0;
      Grammars = Set();
      SimpleRuleParsers = Hashtable();
      ParserHost = parserHost;
    }

    internal this(parserHost : ParserHost, grammars : Set[GrammarDescriptor], startID : int)
    {
      StartID = startID;
      Grammars = grammars;
      ParserHost = parserHost;

      def rules = Grammars.SelectMany(gd => gd.Rules).NToArray();

      def extentionRuleDescriptors = rules
        .OfType.[ExtentionRuleDescriptor]()
        .Grouping(rd => (rd.BaseRule, rd))
        .Map((baseRd, extetions) =>
        {
          def prefix = extetions.OfType.[PrefixRuleDescriptor]().NToArray();
          def postfix = extetions.OfType.[PostfixRuleDescriptor]().NToArray();
          Array.Sort.[PostfixRuleDescriptor](postfix, ((l, r) => l.BindingPower.CompareTo(r.BindingPower)));
          (baseRd, (prefix, postfix))
        });

      foreach (extensibleRule in rules.OfType.[ExtensibleRuleDescriptor]())
      {
        def (prefixDescriptors, postfixDescriptors) = extentionRuleDescriptors.GetValueOrDefault(extensibleRule, (array[], array[]));
        ExtensibleRules[extensibleRule] = ExtensibleRuleParserData(this, extensibleRule, prefixDescriptors, postfixDescriptors);
      }

      SimpleRuleParsers = Hashtable(rules
        .OfType.[SimpleRuleDescriptor]()
        .Map(rd => (rd, rd.NewParser(this))));

      foreach (extensibleRule in ExtensibleRules)
        extensibleRule.Value.Init();

      foreach (kv in SimpleRuleParsers)
        kv.Value.Init();

      foreach (extensibleRule in ExtensibleRules)
        _ = GetExtensibleRuleParser(extensibleRule.Key, 0);
    }

    public GetExtensibleRuleParser(rd : ExtensibleRuleDescriptor, bindingPower : int) : Internal.ExtensibleRuleParser
    {
      ExtensibleRules[rd].GetParser(bindingPower)
    }

    public GetSimpleRuleParser(rd : SimpleRuleDescriptor) : Internal.StartRuleParser
    {
      SimpleRuleParsers[rd]
    }
  }
}
