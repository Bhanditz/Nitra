using N2;
using N2.Utils;
using N2.Model;
using N2.ProjectSystem;
using N2.Runtime;
using N2.Typing;

using Nemerle.Collections;
using Nemerle.Imperative;
using Nemerle.Compiler.Parsetree;

using System.Collections.Generic;
using System.Text;
using System.Linq;

syntax module N2Syntax
{
  using PrettyPrint;
  using TokenNames;
  using StandardSpanClasses;
  using Whitespaces;
  using Identifiers;
  using CStyleComments;

  token field Prefix              = "\\u";
  token field DodDot              = "..";
  token field Op                  = ".";
  token field Pipe                = "|";

  braces "(", ")";
  braces "{", "}";
  braces "[", "]";

  keyword regex IdentifierStartCharacter (IdentifierPartCharacters | '-')* rule S;

  alias Name            = Identifier;
  alias QualifiedName   = QualifiedIdentifier;
  alias NamespaceOrType = QualifiedIdentifier;
  alias Char            = Any;
  alias GrammarName     = QualifiedIdentifier;
  alias BaseName        = QualifiedIdentifier;
  alias SeparatorToken  = TokenRule;
  alias SeparatorRule   = Rule;

  token Keyword = "as" | "syntax" | "token" | "alias" | "in" | "out" | "rule" | "precedence";

  extend syntax IgnoreToken
  {
    | [SpanClass(Comment), ExplicitSpaces] SingleLineComment;
    | [SpanClass(Comment), ExplicitSpaces] MultiLineComment;
  }

  token HexDigit                  = ['0'..'9', 'a'..'f', 'A'..'F'];
  token ReservedStringChar        = "\"" | "\\";
  token ReservedCharChar          = "\'" | "\\";

  [SpanClass(String), ExplicitSpaces]
  syntax StringLiteral                    = "\""  StringPart* "\""
  {
    Value() : string = FoldThrough(StringParts, StringBuilder(), _.Value(_)).ToString();
  }

  [ExplicitSpaces]
  syntax StringPart
  {
    Value(sb : StringBuilder) : StringBuilder;

    | UnicodeEscapeSequence = "\\u" HexDigit HexDigit HexDigit HexDigit
      {
        override Value = sb.Append(HexToChar(this, HexDigit1.StartPos, HexDigit4.EndPos));
      }
    | EscapeSequence        = "\\"  Char
      {
        override Value = sb.Append(EscapeSequence(FirstChar(Char)));
      }
    | Simple                = Chars=(!ReservedStringChar !NewLine Any)+
      {
        override Value = sb.Append(this.GetText());
      }
  }

  [SpanClass(Char), ExplicitSpaces]
  syntax CharLiteral                      = "\'"  CharPart "\'" { Value() : char = CharPart.Value(); }

  [ExplicitSpaces]
  syntax CharPart
  {
    Value() : char;

    | Simple                = !ReservedCharChar Char
      {
        override Value = FirstChar(this.Char);
      }
    | UnicodeEscapeSequence = "\\u" HexDigit HexDigit HexDigit HexDigit
      {
        override Value = HexToChar(this, HexDigit1.StartPos, HexDigit4.EndPos);
      }
    | EscapeSequence        = "\\" Char
      {
        override Value = EscapeSequence(FirstChar(this.Char));
      }
  }

  token Digits = ['0'..'9']+;

  [SpanClass(Number), ExplicitSpaces]
  syntax Number = Digits { Value() : int = DecToInt(this, Digits.StartPos, Digits.EndPos); }

  [ExplicitSpaces]
  syntax Identifier                       = !(Keyword !IdentifierPartCharacters) IdentifierBody
  {
    Value() : string = GetText(IdentifierBody);
    Identifier() : N2.Model.Identifier = N2.Model.Identifier(this, IdentifierBody);
  }

  [ExplicitSpaces]
  syntax QualifiedIdentifier              = Names=(Identifier; s "." s)+
  {
    Identifiers() : list[N2.Located] = Names[0].Map(_.Identifier());
    Parts() : list[string] = Names[0].Map(_.Value());
    CalcLocation() : N2.Location
    {
      this.Location // At present QualifiedIdentifier have no 's' at the end of rule. This allows the use rule location.
    }
    CalcLocations() : list[N2.Location] = Names[0].Map(_.Location);
  }

  ///////////////////////////////////////////////////////////////////////////
  //

  [StartRule, ExplicitSpaces]
  syntax Start                = s NamespaceBody !Any
  {
    CollectGlobalSymbols(rootNs : NamespaceSymbol) : void = NamespaceBody.CollectGlobalSymbols(rootNs);
    [Cached] MakeContext(parent : Context) : Context = NamespaceBody.MakeContext(parent);
    Typing() : void = NamespaceBody.Typing();
  }

  syntax NamespaceBody = Using*  TopDeclaration*
  {
    CollectGlobalSymbols(rootNs : NamespaceSymbol) : void { _ = PassThrough(TopDeclarations, rootNs, _.CollectGlobalSymbols(_)); }
    [Cached] MakeContext(parent : Context) : Context
    {
      def context1 = FoldThrough(Usings, parent, _.MakeContext(_));
      def context2 = PassThrough(TopDeclarations, context1, _.MakeContext(_));
      context2
    }
    Typing() : void = foreach (d in TopDeclarations) d.Typing();
  }

  syntax Using
  {
    [Cached] MakeContext(parent : Context) : Context;

    | UsingOpen  = "using" sm NamespaceOrType ";" nl
      {
        override MakeContext = OpenNamespaceOrTypeContext(parent, NamespaceOrType);
      }
    | UsingAlias = "using" Name sm "=" sm NamespaceOrType ";" nl
      {
        override MakeContext = NamespaceOrTypeAliasContext(parent, Name, NamespaceOrType);
      }
  }

  syntax TopDeclaration
  {
    CollectGlobalSymbols(ns : NamespaceSymbol) : NamespaceSymbol;
    [Cached] MakeContext(parent : Context) : Context;
    Typing() : void;

    | Namespace = "namespace" sm QualifiedName nl "{" inl NamespaceBody d "}" nl
      {
        [Cached] private MakeSymbol(ns : NamespaceSymbol) : NamespaceSymbol = MakeNamespaceSymbol(ns, QualifiedName.CalcLocations());
        override CollectGlobalSymbols
        {
          //assert2(false);
          def currNamespace = MakeSymbol(ns);
          NamespaceBody.CollectGlobalSymbols(currNamespace);
          ns
        }
        override MakeContext
        {
          def nsContext = EnteredNamespaceContext(parent, Symbol);
          _ = NamespaceBody.MakeContext(nsContext);
          parent
        }
        override Typing = NamespaceBody.Typing();
      }

    | SyntaxModule = "syntax" sm "module"sm Name nl "{" inl Using* Declaration* d "}" nl
      {
        override CollectGlobalSymbols
        {
          def sym = ParsedSyntaxModuleSymbol(this);
          _ = ns.Node.AddAndReport(sym, Name.Location);
          _ = PassThrough(Declarations, sym, _.CollectGlobalSymbols(_));
          ns
        }
        [Cached] private MakeInitialContext(contextToSave : SyntaxModuleContext) : SyntaxModuleContext = contextToSave;
        [Cached] private MakeFinalContext(contextToSave : Context) : Context = contextToSave;
        override MakeContext
        {
          def context1 = MakeInitialContext(SyntaxModuleContext(parent, Name));
          def context2 = FoldThrough(Usings, context1, _.MakeContext(_));
          def context3 = SyntaxModuleBodyContext(context2);
          def finalContext = MakeFinalContext(FoldThrough(Declarations, context3, _.MakeContext(_)));
          Utils.RegisterGlobalSpanClassSymbols(context1.SyntaxModuleSymbol, finalContext);
          parent
        }
        [Cached] private MakeTokenFieldNames() : Map[string, N2.Model.Identifier] = FoldThrough(Declarations, Map(), _.GetTokenFieldNames(_));
        override Typing
        {
          _ = MakeTokenFieldNames();
          foreach (x in Declarations)
            x.Typing();
        }
      }
  }

  syntax DefaultReturnType = "default" sm "return" sm "type" Type ";" nl
  {
    [Cached] MakeContext(parent : Context) : Context = parent;
    Typing() : PExpr = NemerleParser.Parse(Type, this.Context);
  }

  syntax RuleAttribute
  {
    Options(inOptions : RuleDefinitionOptions) : RuleDefinitionOptions = inOptions;
    [Cached] MakeContext(_parent : Context) : Context = _parent;

    | Start                  = AttributeName="StartRule"
      {
        override Options = inOptions.SetStart(this, true);
      }
    | SpanClass              = AttributeName="SpanClass" "(" Class=Identifier ")"
      {
        override Options = Context.Bind.[SpanClassSymbol](Class).Map(inOptions.SetSpanClass(Class, _)) ?? inOptions;
      }
    | ExplicitSpaces         = AttributeName="ExplicitSpaces"
      {
        override Options = inOptions.SetExplicitSpaces(this, true);
      }
    | ImplicitSpaces         = AttributeName="ImplicitSpaces"
      {
        override Options = inOptions.SetExplicitSpaces(this, false);
      }
    | SuppressTrailingSpaces = AttributeName="SuppressTrailingSpaces"
      {
        override Options = inOptions.SetSuppressTrailingSpaces(this, true);
      }
    | AllowTrailingSpaces   = AttributeName="AllowTrailingSpaces"
      {
        override Options = inOptions.SetSuppressTrailingSpaces(this, false);
      }
  }

  syntax RuleAttributeList = "[" (RuleAttribute; ","sm)+ "]"
  {
    Options(inOptions : RuleDefinitionOptions) : RuleDefinitionOptions = FoldThrough(RuleAttributes[0], inOptions, _.Options(_));
    MakeContext(parent : Context) : Context = FoldThrough(RuleAttributes[0], parent, _.MakeContext(_));
  }

  syntax RuleAttributes    = RuleAttributeList*
  {
    [Cached] Options(inOptions : RuleDefinitionOptions) : RuleDefinitionOptions = FoldThrough(RuleAttributeLists, inOptions, _.Options(_));
    [Cached] MakeContext(parent : Context) : Context = FoldThrough(RuleAttributeLists, parent, _.MakeContext(_));
  }

  [StartRule]
  syntax Declaration
  {
    CollectGlobalSymbols(sm : SyntaxModuleSymbol) : SyntaxModuleSymbol = sm;
    [Cached] MakeContext(parent : Context) : Context = parent;
    Typing() : void {}

    GetTokenFieldNames(result : Map[string, N2.Model.Identifier]) : Map[string, N2.Model.Identifier] = result;

    | SimpleRule          = RuleAttributes "syntax"  sm             Name  sm "="  sm Rule                     RuleBody
      {
        [Cached] private MakeSymbol() : ParsedSimpleRuleSymbol = ParsedSimpleRuleSymbol(this);
        override CollectGlobalSymbols
        {
          _ = MakeSymbol();
          _ = sm.Node.AddAndReport(Symbol, Location);
          _ = RuleBody.CollectGlobalSymbols(Symbol, None());
          sm
        }
        override MakeContext = MakeContext(parent, RuleAttributes, RuleBody);
        [Cached] private MakeTypedRule()   : Rule.Sequence    = EnsureSequence(this.Rule.Typing(None(), RuleBody.GetPrecedence(), None(), RuleBody.Context, RuleAttributes.Options(RuleDefinitionOptions.Empty)));
        override Typing
        {
          _ = MakeTypedRule();
          RuleBody.Typing(ExtensibleRuleRef.None(Location.Default, false));
        }
      }
    | ExtensibleRule = RuleAttributes "syntax"  sm             Name                                      RuleBody
      {
        [Cached] private MakeSymbol() : ParsedExtensibleRuleSymbol = ParsedExtensibleRuleSymbol(this);
        override CollectGlobalSymbols
        {
          _ = MakeSymbol();
          _ = sm.Node.AddAndReport(Symbol, Location);
          _ = RuleBody.CollectGlobalSymbols(Symbol, Some(Name.GetText()));
          sm
        }
        override MakeContext = MakeContext(parent, RuleAttributes, RuleBody);
        override Typing
        {
          _ = RuleBody.Typing(ExtensibleRuleRef.Create(Name, Context.Bind(Name)));
        }
      }
    | TokenRule           = RuleAttributes "token"   sm             Name  sm "="  sm TokenRule                RuleBody
      {
        [Cached] private MakeSymbol() : ParsedRegularRuleSymbol = ParsedRegularRuleSymbol(this);
        override CollectGlobalSymbols
        {
          _ = MakeSymbol();
          _ = sm.Node.AddAndReport(Symbol, Location);
          _ = RuleBody.CollectGlobalSymbols(Symbol, None());
          sm
        }
        override MakeContext = MakeContext(parent, RuleAttributes, TokenRule, RuleBody);
        [Cached] private MakeRegularRule() : RegularRule      = TokenRule.Typing();
        override Typing
        {
          _ = MakeRegularRule();
          RuleBody.Typing(ExtensibleRuleRef.None(Location.Default, false));
        }
      }
    | VoidRule            = RuleAttributes "void"    sm             Name  sm "="  sm Rule                     RuleBody
      {
        [Cached] private MakeSymbol() : ParsedVoidRuleSymbol = ParsedVoidRuleSymbol(this);
        override CollectGlobalSymbols
        {
          _ = MakeSymbol();
          _ = sm.Node.AddAndReport(Symbol, Location);
          _ = RuleBody.CollectGlobalSymbols(Symbol, None());
          sm
        }
        override MakeContext = MakeContext(parent, RuleAttributes, RuleBody);
        [Cached] private MakeType()        : RuleType         = RuleType.Void();
        [Cached] private MakeTypedRule()   : Rule.Sequence    = EnsureSequence(this.Rule.Typing(None(), RuleBody.GetPrecedence(), None(), RuleBody.Context, RuleAttributes.Options(RuleDefinitionOptions.Empty)));
        override Typing
        {
          _ = MakeType();
          _ = MakeTypedRule();
          RuleBody.Typing(ExtensibleRuleRef.None(Location.Default, false));
        }
      }
    | Marker          =                "marker"  sm             Name                                      ";"nl
      {
        override CollectGlobalSymbols
        {
          _ = sm.Node.AddAndReport(MarkerSymbol(Name), Location);
          sm
        }
      }
    | ExtendSyntax        =                "extend"  sm "syntax" sm BaseName nl "{" inl InlineExtentionRule* d "}"nl
      {
        override CollectGlobalSymbols = PassThrough(InlineExtentionRules, sm, _.CollectGlobalSymbols(_, Some(BaseName.Parts().LastOrDefault(""))));
        override MakeContext = FoldThrough(InlineExtentionRules, parent, _.MakeContext(_));
        override Typing
        {
          def baseRule = ExtensibleRuleRef.Create(BaseName, Context.Bind(BaseName));
          foreach (m in InlineExtentionRules)
            m.Typing(baseRule);
        }
      }
    | Alias               =                RuleAlias
      {
        override MakeContext = RuleAlias.MakeContext(parent);
      }
    | TokenField          =                "token"   sm "field"  sm Name  sm "="  sm (StringLiteral; ","sm)+  ";"nl
      {
        override GetTokenFieldNames
        {
          def name = Name.Identifier();
          FoldThrough(StringLiterals[0], result, (strLit, result) => result.Replace(strLit.Value(), name))
        }
        override MakeContext = TokenFieldContext(parent, Name, StringLiterals[0]);
      }
    | SpanClass           =                "span"    sm "class"  sm Name MatchTokens=("=" TokenRule)?         ";"nl
      {
        [Cached] private MakeSymbol(context : Context) : SpanClassSymbol
        {
          def symbol = ParsedSpanClassSymbol(this, context);
          N2Project.CurrentProject.AddSymbolDef(symbol, Name.Location);
          symbol
        }
        [Cached] private MakeRegularRule() : option[RegularRule] = MatchTokens.Map((_, tr) =>
        {
          def rr = tr.Typing();
          rr.ValidateRegularRule();
          rr
        });
        override MakeContext
        {
          def context = SpanClassContext(parent, MakeSymbol(parent));
          _ = MatchTokens.Map((_, tokenRule) => tokenRule.MakeContext(context));
          context
        }
        override Typing
        {
          _ = MakeRegularRule();
        }
      }
    | BracePair           =                "braces"  sm Open=TokenRule "," sm Close=TokenRule                 ";"nl
      {
        override MakeContext
        {
          def context = BracePairContext(parent, Open, Close);
          _ = Open.MakeContext(context);
          _ = Close.MakeContext(context);
          context
        }
        override Typing
        {
          Open.Typing().ValidateRegularRule();
          Close.Typing().ValidateRegularRule();
        }
      }
    | KeywordRegex        =                "keyword" sm "regex"  sm MatchTokens=TokenRule sm "rule" sm QualifiedName ";"nl
      {
        override MakeContext
        {
          def context = KeywordRegexContext(parent, MatchTokens, QualifiedName);
          _ = MatchTokens.MakeContext(context);
          context
        }
      }
  }

  syntax RuleAlias = "alias"   sm             Name  sm "="  sm Rule                     ";"nl
  {
    [Cached] private MakeSymbol() : RuleAliasSymbol
    {
      def symbol = ParsedRuleAliasSymbol(this);
      N2Project.CurrentProject.AddSymbolDef(symbol, Name.Location);
      symbol
    }
    MakeContext(parent : Context) : Context
    {
      RuleAliasContext(parent, MakeSymbol());
    }
  }

  syntax InlineExtentionRule = "|" RuleAttributes (Name "=")? Rule RuleBody?
  {
    [Cached] private MakeSymbol(baseName : string) : ParsedInlineExtentionRule = ParsedInlineExtentionRule(this, baseName);
    CollectGlobalSymbols(sm : SyntaxModuleSymbol, baseName : option[string]) : SyntaxModuleSymbol
    {
      _ = MakeSymbol(baseName.Value);
      _ = sm.Node.AddAndReport(Symbol, Location);
      when (RuleBodyOpt is Some(ruleBody))
        _ = ruleBody.CollectGlobalSymbols(Symbol, None());
      sm
    }
    [Cached] MakeContext(parent : Context)                          : Context               = MakeContext(parent, RuleAttributes, RuleBodyOpt);
    [Cached] private MakeBaseRuleRef(baseRule : ExtensibleRuleRef)  : ExtensibleRuleRef     = baseRule;
    [Cached] private MakeOptions()                                  : RuleDefinitionOptions = RuleAttributes.Options(BaseRuleRef.Map(r => r.Options.InheritedCopy()) ?? RuleDefinitionOptions.Empty);
    [Cached] private MakeType()                                     : RuleType              = BaseRuleRef.Map(_.Type) ?? RuleType.Void();
    [Cached] private MakeTypedRule()                                : Rule.Sequence         = EnsureSequence(this.Rule.Typing(BaseRuleRef, Precedence(RuleBodyOpt), None(), RuleBodyOpt.Map(_.Context) ?? Context, Options));
    Typing(baseRule : ExtensibleRuleRef) : void
    {
      _ = MakeBaseRuleRef(baseRule);
      _ = MakeOptions();
      _ = MakeType();
      _ = MakeTypedRule();
      when (RuleBodyOpt is Some(ruleBody))
        ruleBody.Typing(BaseRuleRef);
    }
  }

  syntax RuleBody
  {
    CollectGlobalSymbols(ruleRef : RuleSymbol, _baseName : option[string]) : RuleSymbol = ruleRef;
    GetPrecedence() : int = 0;
    [Cached] MakeContext(parent : Context) : Context = parent;
    GetLastLocation() : N2.Location;
    Typing(_baseRule : ExtensibleRuleRef) : void { }

    | Empty = ";"nl
      {
        override GetLastLocation = MakeLastLocation(this, Semicolon);
      }
    | Block = "{"  RuleBodyMember* "}"nl
      {
        override CollectGlobalSymbols = PassThrough(RuleBodyMembers, ruleRef, _.CollectGlobalSymbols(_, _baseName));
        override GetPrecedence
        {
          match (RuleBodyMembers.Map(_.GetPrecedence()).Filter(_.IsSome))
          {
            | [VSome((p, _))] => p
            | [] => 0
            | VSome((p, loc)) :: tail =>
              using (rootMsg = Project.CurrentProject.RootError(loc, "Too many 'precedence' directives. You can define only one a 'precedence' directive.", -1))
                foreach (other in tail)
                  rootMsg.Hint(other.Value[1], "   other definition.");
              p
            | _ => assert2(false); 0
          }
        }
        override MakeContext = FoldThrough(RuleBodyMembers, parent, _.MakeContext(_));
        override GetLastLocation = MakeLastLocation(this, OpenBrace);
        override Typing = foreach (x in RuleBodyMembers) x.Typing(_baseRule);
      }
  }

  syntax ExtraFieldsParam = Name sm ":" sm Type;
  [ExplicitSpaces]
  syntax ExtraFieldPrivate = "private" sm;

  syntax ExtraFieldAttribute
  {
    IsCached() : bool;

    | Cached = AttributeName="Cached"
      {
        override IsCached = true;
      }
  }
  syntax ExtraFieldAttributeList = "[" (ExtraFieldAttribute; ",")+ "]"
  {
    IsCached() : bool
    {
      foreach(x when x.IsCached() in ExtraFieldAttributes[0])
        return true;
      false
    }
  }
  syntax ExtraFieldAttributes = ExtraFieldAttributeList*
  {
    IsCached() : bool
    {
      foreach(x when x.IsCached() in ExtraFieldAttributeLists)
        return true;
      false
    }
  }

  syntax RuleBodyMember
  {
    CollectGlobalSymbols(ruleSymbol : RuleSymbol, _baseName : option[string]) : RuleSymbol = ruleSymbol;
    GetPrecedence() : ValueOption[int * N2.Location] = VNone();
    [Cached] MakeContext(parent : Context) : Context = parent;
    Typing(_baseRule : ExtensibleRuleRef) : void { }

    | InlineExtentionRule
      {
        override CollectGlobalSymbols { _ = InlineExtentionRule.CollectGlobalSymbols(ruleSymbol.Node.Parent.Symbol :> SyntaxModuleSymbol, _baseName); ruleSymbol }
        override Typing = InlineExtentionRule.Typing(_baseRule);
        override MakeContext = InlineExtentionRule.MakeContext(parent);
      }

    | ExtraField = ExtraFieldAttributes ExtraFieldPrivate? Name sm "(" (ExtraFieldsParam; "," sm)* ")" sm ":" sm Type ExtraFieldBody
      {
        [Cached] private MakeSymbol(ruleSymbol : RuleSymbol) : ExtraField.ExtraFieldSymbol
        {
          def symbol =
            if (ExtraFieldPrivateOpt.IsSome)
            {
              when (ExtraFieldBody.IsEmpty())
                Project.CurrentProject.Error(this.Location, "A private extra field must have a body.", -1);
              unless (ruleSymbol is SimpleRuleSymbol || ruleSymbol is ExtentionRuleSymbol)
                Project.CurrentProject.Error(this.Location, "A private extra field can be declared only in simple rules and extention rules.", -1);
              ExtraField.ParsedDefPrivateSymbol(this)
            }
            else if (ExtraFieldBody.IsEmpty())
            {
              unless (ruleSymbol is ExtensibleRuleSymbol)
                Project.CurrentProject.Error(this.Location, "An abstract extra field must be defined in an extention point rule only.", -1);
              ExtraField.ParsedAbstractSymbol(this)
            }
            else
            {
              unless (ruleSymbol is SimpleRuleSymbol || ruleSymbol is ExtensibleRuleSymbol)
                Project.CurrentProject.Error(this.Location, "A public extra field must be defined in an extention point rule or a simple rule only.", -1);
              ExtraField.ParsedDefSymbol(this)
            }
          _ = ruleSymbol.Node.AddAndReport.[ExtraField.DefinitionSymbol](symbol, this.Location);
          symbol
        }
        override CollectGlobalSymbols
        {
          _ = MakeSymbol(ruleSymbol);
          ruleSymbol
        }
        [Cached] private MakeSignature() : ExtraField.ExtraFieldSignature = ExtraField.ExtraFieldSignature(this.Location, NemerleParser.Parse(this.ExtraFieldsParams[0], Context), NemerleParser.Parse(this.Type, Context));
        [Cached] private MakeBody()      : ExtraField.ExtraFieldBody      = ExtraField.ExtraFieldBody(this.ExtraFieldBody.BodyLocation(), NemerleParser.Parse(this.ExtraFieldBody, Context));
        [Cached] private MakeIsCached()  : bool                           = ExtraFieldAttributes.IsCached();
        override Typing
        {
          _ = MakeSignature();
          _ = MakeBody();
          _ = MakeIsCached();
        }
      }
    | ExtraFieldOverride = ExtraFieldAttributes "override"     sm  Name ExtraFieldBody
      {
        [Cached] private MakeSymbol(ruleSymbol : RuleSymbol) : ExtraField.ExtraFieldSymbol
        {
          when (ExtraFieldBody.IsEmpty())
            Project.CurrentProject.Error(this.Location, "A overriding extra field must have a body.", -1);
          def symbol = ExtraField.ParsedOverrideSymbol(this);
          _ = ruleSymbol.Node.AddAndReport.[ExtraField.DefinitionSymbol](symbol, this.Location);
          symbol
        }
        override CollectGlobalSymbols
        {
          _ = MakeSymbol(ruleSymbol);
          ruleSymbol
        }
        [Cached] private MakeBaseExtraField() : SymbolRef[ExtraField.ExtraFieldSymbol]
        {
          match (this.Symbol.DeclaringRule)
          {
            | ExtentionRuleSymbol(BaseRule = SymbolRef.Some(baseRuleSymbol)) =>
              match (baseRuleSymbol.Node.BindMany.[ExtraField.DefinitionSymbol](Name.Location))
              {
                | [ExtraField.DefSymbol      as baseExtraFieldSymbol]
                | [ExtraField.AbstractSymbol as baseExtraFieldSymbol] =>
                  SymbolRef.Some(Name.Location, false, baseExtraFieldSymbol)

                | [_] =>
                  def name = Name.Value();
                  Project.CurrentProject.Error(this.Location, $"Cannot override '$name' extra field.", -1); //TODO: rewrite error message!
                  SymbolRef.None(Name.Location, false)

                | _ =>
                  def name = Name.Value();
                  Project.CurrentProject.Error(this.Location, $"No '$name' extra field to override.", -1);
                  SymbolRef.None(Name.Location, false)
              }

            | _ =>
              Project.CurrentProject.Error(this.Location, "An extra field can be overridden only in extending rules.", -1);
              SymbolRef.None(Name.Location, false)
          }
        }
        [Cached] private MakeBody() : ExtraField.ExtraFieldBody = ExtraField.ExtraFieldBody(this.ExtraFieldBody.BodyLocation(), NemerleParser.Parse(this.ExtraFieldBody, Context));
        override Typing
        {
          _ = MakeBaseExtraField();
          _ = MakeBody();
        }
      }
    | ExtraFieldMissing = ExtraFieldAttributes "missing"        sm  Name ExtraFieldBody
      {
        [Cached] private MakeSymbol(ruleSymbol : RuleSymbol) : ExtraField.ExtraFieldSymbol
        {
          when (ExtraFieldBody.IsEmpty())
            Project.CurrentProject.Error(this.Location, "An 'missing' handler must have a body.", -1);
          def symbol = ExtraField.ParsedExtraFieldMissingValueSymbol(this);
          _ = ruleSymbol.Node.AddAndReport.[ExtraField.ExtraFieldMissingValueSymbol](symbol, this.Location);
          symbol
        }
        override CollectGlobalSymbols
        {
          _ = MakeSymbol(ruleSymbol);
          ruleSymbol
        }
        [Cached] private MakeHandlingExtraField() : SymbolRef[ExtraField.ExtraFieldSymbol]
        {
          match (this.Symbol.DeclaringRule)
          {
            | ExtensibleRuleSymbol as targetRuleSymbol
            | SimpleRuleSymbol     as targetRuleSymbol =>
              match (targetRuleSymbol.Node.BindMany.[ExtraField.DefinitionSymbol](Name.Location))
              {
                | [extraFieldSymbol] => SymbolRef.Some(Name.Location, false, extraFieldSymbol)
                | _ =>
                  def name = Name.Value();
                  Project.CurrentProject.Error(this.Location, $"No '$name' extra field to handle 'missing'.", -1);
                  SymbolRef.None(Name.Location, false)
              }

            | _ =>
              Project.CurrentProject.Error(this.Location, "An 'missing' handler for a extra field can be defined in simple and extensible rules.", -1);
              SymbolRef.None(Name.Location, false)
          }
        }
        [Cached] private MakeBody() : ExtraField.ExtraFieldBody = ExtraField.ExtraFieldBody(this.ExtraFieldBody.BodyLocation(), NemerleParser.Parse(this.ExtraFieldBody, Context));
        override Typing
        {
          _ = MakeHandlingExtraField();
          _ = MakeBody();
        }
      }
    // TODO: Create "Once" attribute which prevent use rule more then one times.
    | InnerAliasDeclaration  = RuleAlias
      {
        override MakeContext = RuleAlias.MakeContext(parent);
      }
    | Precedence = "precedence"   sm  Precedence=Number RightAssociative=("right-associative")? ";"
      {
        override GetPrecedence = VSome((if (RightAssociative.IsSome) -Precedence.Value() else Precedence.Value(), this.Location));
      }  // TODO: make precedence table
  }

  syntax ExtraFieldBody
  {
    BodyLocation() : N2.Location;
    IsEmpty() : bool;

    | Block
      {
        override BodyLocation = Block.Location;
        override IsEmpty = false;
      }
    | Expression = sm "=" sm Expression ";" nl
      {
        override BodyLocation = Expression.Location;
        override IsEmpty = false;
      }
    | Empty = ";" nl
      {
        override BodyLocation = Location(this.Location.Source, this.Location.StartPos, this.Location.StartPos);
        override IsEmpty = true;
      }
  }

  syntax TypeParams = "[" (Type; ","sm)+ "]";
  syntax SimpleName = Identifier TypeParams?;

  syntax Type
  {
    | SimpleName
    | Qualified = Type "." SimpleName { precedence 20; }
    | Pointer   = Type "*" Type       { precedence 10; }
  }

  syntax Block = nl "{" inl (Expression; ";" nl)* ";"* d "}" nl;
  syntax Parentheses = "(" Expression? ")";

  syntax Content
  {
    | Block;
    | IgnoreToken+;
    | CharLiteral;
    | StringLiteral;
    | Parentheses;
    | "fold" sm Identifier "(" Expression ";" (Expression; ";"sm)+ ")";
  }

  syntax ExpressionContent
  {
    | Content1 = Content;
    | Content2 = (!";" !")" !"}" !Content Any)+;
  }

  syntax Expression = ExpressionContent+;

  syntax Range
  {
    RangeSet(inCharSet : RangeSet) : RangeSet;

    | SingleChar = CharLiteral
      {
        override RangeSet = inCharSet.AddSingleCharRange(CharLiteral.Value());
      }
    | CharRange       = CharLiteral ".." CharLiteral
      {
        override RangeSet = inCharSet.AddRange(CharLiteral1.Value(), CharLiteral2.Value());
      }
    | UnicodeRange    = Name
      {
        override RangeSet =
          if (UnicodeCategoryTable.StrToUnicodeCategory(Name.Value()) is Some(cat))
            inCharSet.AddRange(cat)
          else
          {
            Project.CurrentProject.Error(this, "Invalid unicode category.", -1);
            inCharSet
          };
      }
  }

  syntax TokenRule
  {
    [Cached] MakeContext(parent : Context) : Context = parent;
    [Cached] Typing() : RegularRule;

    | Choice                  = LeftRule=TokenRule ^ 10 sm RightRules=("|" TokenRule ^ 10)+
      {
        override MakeContext
        {
          def context1 = LeftRule.MakeContext(parent);
          def context2 = FoldThrough(RightRules, context1, ((_, r), c) => r.MakeContext(c));
          context2
        }
        override Typing = RegularRule.Choice(Location, LeftRule.Typing() :: RightRules.Map(r => r[1].Typing()));
      }
    | Sequence                = LeftRule=TokenRule ^ 20 sm RightRules=(TokenRule ^ 20)+
      {
        override MakeContext
        {
          def context1 = LeftRule.MakeContext(parent);
          def context2 = FoldThrough(RightRules, context1, _.MakeContext(_));
          context2
        }
        override Typing = RegularRule.Sequence(Location, LeftRule.Typing() :: RightRules.Map(_.Typing()));
      }
    | Optional                = TokenRule "?"
      {
        precedence 30;
        override MakeContext = TokenRule.MakeContext(parent);
        override Typing = RegularRule.Repeat(Location, 0, Some(1), this.TokenRule.Typing());
      }
    | ZeroOrMany              = TokenRule "*"
      {
        precedence 30;
        override MakeContext = TokenRule.MakeContext(parent);
        override Typing = RegularRule.Repeat(Location, 0, None(), this.TokenRule.Typing());
      }
    | OneOrMany               = TokenRule "+"
      {
        precedence 30;
        override MakeContext = TokenRule.MakeContext(parent);
        override Typing = RegularRule.Repeat(Location, 1, None(), this.TokenRule.Typing());
      }
    | Char                    = CharLiteral
      {
        override Typing = RegularRule.Chars(Location, [RangeSet().AddSingleCharRange(CharLiteral.Value())]);
      }
    | String                  = StringLiteral
      {
        override Typing = RegularRule.Chars(Location, RangeSet.MakeString(StringLiteral.Value()));
      }
    | Call                    = QualifiedName
      {
        override Typing
        {
          def ruleRef = SymbolRef.Create(QualifiedName, Context.Bind(QualifiedName));
          RegularRule.Call(Location, ruleRef)
        }
      }
    | Rounds                  = "(" TokenRule ")"
      {
        override MakeContext = TokenRule.MakeContext(parent);
        override Typing = TokenRule.Typing();
      }
    | Range                   = "[" (Range; ","sm)+ "]"
      {
        override Typing = RegularRule.Chars(Location, [FoldThrough(Ranges[0], RangeSet(), _.RangeSet(_))]);
      }
    | ZeroOrManyWithSeparator = "(" TokenRule ";"sm SeparatorToken ")" "*"
      {
        override MakeContext  = parent |> TokenRule.MakeContext |> SeparatorToken.MakeContext;
        override Typing = RegularRule.RepeatWithSeparator(Location, 0, None(), TokenRule.Typing(), SeparatorToken.Typing());
      }
    | OneOrManyWithSeparator  = "(" TokenRule ";"sm SeparatorToken ")" "+"
      {
        override MakeContext = parent |> TokenRule.MakeContext |> SeparatorToken.MakeContext;
        override Typing = RegularRule.RepeatWithSeparator(Location, 1, None(), TokenRule.Typing(), SeparatorToken.Typing());
      }
  }

  syntax Rule
  {
    Typing(_baseRule : option[ExtensibleRuleSymbol], _precedence : int, _fieldName : option[string], context : Context, options : RuleDefinitionOptions) : N2.Model.Rule;  // precedence < 0 if it is right-associative
    InferName() : string = "";

    | Sequence                        = LeftRule=Rule ^ 10 RightRules=(sm Rule ^ 10)+
      {
        override Typing
        {
          def bp1   = if (_precedence < 0) -_precedence + 1 else _precedence;
          def bp2   = if (_precedence < 0) -_precedence     else _precedence;
          def flat = List();
          def tryExtractSpaceSequence(rule : N2.Model.Rule) : void
          {
            // assume that 's' is generated whitespace rule
            match (rule)
            {
              | Sequence([String as call1, Call(s, 0) as call2])
              | Sequence([Call   as call1, Call(s, 0) as call2]) =>
                when (s.IsGenerated)
                {
                  flat.Add(call1);
                  flat.Add(call2);
                  return
                }
              | _ => ()
            }
            flat.Add(rule);
          }
          tryExtractSpaceSequence(LeftRule.Typing(_baseRule, bp1, None(), context, options));
          foreach (rule in RightRules)
            tryExtractSpaceSequence(rule.Typing(_baseRule, bp2, None(), context, options));
          def rules =  flat.NToList();
          def type  = MakeType(rules.Map(_.Type));
          Rule.Sequence(this.Location, type, MakeName(_fieldName, rules, context), rules);
        }
        override InferName = LeftRule.InferName();
      }
    | Not                             = "!" Rule ^ 20
      {
        override Typing
        {
          def rule = this.Rule.Typing(None(), 0, None(), context, options);
          Rule.Not(this.Location, RuleType.Void(), "", rule);
        }
      }
    | And                             = "&" Rule ^ 20
      {
        override Typing = Rule.And(this.Location, RuleType.Void(), "", this.Rule.Typing(None(), 0, None(), context, options));
      }
    | Optional                        = Rule "?"
      {
        precedence 30;
        override Typing
        {
          def rule  = this.Rule.Typing(None(), 0, None(), context, options);
          def type  = if (rule.Type is RuleType.Void) RuleType.Void() else RuleType.Option(rule.Type);
          Rule.Repeat(this.Location, type, _fieldName ?? (rule.FieldName + "Opt"), 0, Some(1), rule);
        }
        override InferName = Rule.InferName() + "Opt";
      }
    | ZeroOrMany                      = Rule "*"
      {
        precedence 30;
        override Typing
        {
          def rule  = this.Rule.Typing(None(), 0, None(), context, options);
          def type  = if (rule.Type is RuleType.Void) RuleType.Void() else RuleType.List(rule.Type);
          Rule.Repeat(this.Location, type, MakePlural(_fieldName, rule, context), 0, None(), rule);
        }
        override InferName = MakePlural(Rule.InferName());
      }
    | OneOrMany                       = Rule "+"
      {
        precedence 30;
        override Typing
        {
          def rule  = this.Rule.Typing(None(), 0, None(), context, options);
          def type  = if (rule.Type is RuleType.Void) RuleType.Void() else RuleType.List(rule.Type);
          Rule.Repeat(this.Location, type, MakePlural(_fieldName, rule, context), 1, None(), rule);
        }
        override InferName = MakePlural(Rule.InferName());
      }
    | FieldName1                      = Rule ^ 12 sm "as" sm Name
      {
        override Typing = this.Rule.Typing(_baseRule, _precedence, Some(Name.Value()), context, options);
        override InferName = Name.GetText();
      }
    | FieldName2                      = Name sm "=" sm Rule ^ 11
      {
        override Typing = this.Rule.Typing(_baseRule, _precedence, Some(Name.Value()), context, options);
        override InferName = Name.GetText();
      }
    | Char                            = CharLiteral
      {
        override Typing = StringRuleTyping(CharLiteral.Location, CharLiteral.Value().ToString(), _fieldName, context, options);
        override InferName = CharLiteral.Value().ToString();
      }
    | String                          = StringLiteral
      {
        override Typing = StringRuleTyping(StringLiteral.Location, StringLiteral.Value().ToString(), _fieldName, context, options);
        override InferName = StringLiteral.Value().ToString();
      }
    | Rounds                          = "(" Rule ")"
      {
        override Typing = this.Rule.Typing(_baseRule, _precedence, _fieldName, context, options);
        override InferName = Rule.InferName();
      }
    | Call                            = QualifiedName BindingPower=(sm "^" sm Number)?
      {
        override Typing = CallRuleTyping(_baseRule, _precedence, _fieldName, context, options, QualifiedName, BindingPower);
        override InferName = QualifiedName.Parts().LastOrDefault("");
      }
    | ZeroOrManyWithSeparator         = "(" Rule ";"sm SeparatorRule ")" "*"
      {
        override Typing
        {
          def rule    = this.Rule.Typing(None(), 0, None(), context, options);
          def sepRule = SeparatorRule.Typing(None(), 0, None(), context, options);
          def type    = MakeType(rule, sepRule);
          Rule.RepeatWithSeparator(this.Location, type, MakePlural(_fieldName, rule, sepRule, context), 0, None(), rule, sepRule, false);
        }
        override InferName = MakePlural(Rule.InferName());
      }
    | ZeroOrManyWithHangingSeparator  = "(" Rule ";"sm SeparatorRule ";"sm "?" ")" "*"
      {
        override Typing
        {
          def rule    = this.Rule.Typing(None(), 0, None(), context, options);
          def sepRule = SeparatorRule.Typing(None(), 0, None(), context, options);
          def type    = MakeType(rule, sepRule);
          Rule.RepeatWithSeparator(this.Location, type, MakePlural(_fieldName, rule, sepRule, context), 0, None(), rule, sepRule, true);
        }
        override InferName = MakePlural(Rule.InferName());
      }
    | OneOrManyWithSeparator          = "(" Rule ";"sm SeparatorRule ")" "+"
      {
        override Typing
        {
          def rule    = this.Rule.Typing(None(), 0, None(), context, options);
          def sepRule = SeparatorRule.Typing(_baseRule, 0, None(), context, options);
          def type    = MakeType(rule, sepRule);
          Rule.RepeatWithSeparator(this.Location, type, MakePlural(_fieldName, rule, sepRule, context), 1, None(), rule, sepRule, false);
        }
        override InferName = MakePlural(Rule.InferName());
      }
    | OneOrManyWithHangingSeparator   = "(" Rule ";"sm SeparatorRule ";"sm "?" ")" "+"
      {
        override Typing
        {
          def rule    = this.Rule.Typing(None(), 0, None(), context, options);
          def sepRule = SeparatorRule.Typing(_baseRule, 0, None(), context, options);
          def type    = MakeType(rule, sepRule);
          Rule.RepeatWithSeparator(this.Location, type, MakePlural(_fieldName, rule, sepRule, context), 1, None(), rule, sepRule, true);
        }
        override InferName = MakePlural(Rule.InferName());
      }
  } // extend syntax Rule
} // syntax module
