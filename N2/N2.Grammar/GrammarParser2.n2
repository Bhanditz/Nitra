using N2;

syntax module GrammarParser2
{
  token field OpenBrace           = "(";
  token field CloseBrace          = ")";
  token field OpenBrace           = "{";
  token field CloseBrace          = "}";
  token field OpenSquareBrace     = "[";
  token field CloseSquareBrace    = "]";
  token field SingleQuote         = "\'";
  token field Quote               = "\"";
  token field Semicolon           = ";";
  token field Comma               = ",";
  token field Colon               = ":";
  token field Assign              = "=";
  token field Prefix              = "\\u";
  token field DodDot              = "..";
  token field Op                  = "+", "-", "*", "/", "?", "^", "%", "&", "!";

  span class Char;
  span class String;
  span class Number;
  span class Keyword      = ['a'..'z']['a'..'z']+;
  span class Operator     = ['+', '-', '/', '*', '^', '?', ':']+;
  span class OpenBrace    = "(" | "{" | "[";
  span class CloseBrace   = ")" | "}" | "]";

  braces "(", ")";
  braces "{", "}";
  braces "[", "]";

  [StartRule]
  syntax Start                = s OpenNamespace*  TopDeclaration* !Any;

  [Ast(                         _,       Namespace,  _)]
  syntax OpenNamespace        = "using"s QIdentifier ";"s;

  token Any = ['\u0000'..'\uFFFF'];
  token NewLineCharacter  = '\n'
                    | '\r'
                    | '\u2028'    /*  line separator       */
                    | '\u2029';   /*  paragraph separator  */
  token NewLine  = "\r\n" | NewLineCharacter;
  token Whitespace = [Zs]
              | '\t'
              | '\v'        /*  vertial tab          */
              | '\f';       /*  form feed            */
  token Space = Whitespace | NewLine;
	token Spaces = Space+;


  syntax IgnoreToken;

  [Ast(                                      Start, Body,           NewLine)]
  syntax SingleLineComment  is IgnoreToken = "//"   (!NewLine Any)* NewLine?;

  [Ast(                                      Start, Body,        End)]
  syntax MultiLineComment   is IgnoreToken = "/*"   (!"*/" Any)* "*/";

  syntax SpaceToken         is IgnoreToken = Spaces;


  void s = IgnoreToken*;                      /* optional spacer          */
  void S = !IdentifierPartCharacters s; /* identifier break spacer  */


  token LetterCharacter       = [Lu, Ll, Lt, Lm, Lo, Nl];
  token CombiningCharacter    = [Mn, Mc];
  token DecimalDigitCharacter = [Nd];
  token ConnectingCharacter   = [Pc];
  token FormattingCharacter   = [Cf];
  token IdentifierStartCharacter  = LetterCharacter | "_";
  token IdentifierPartCharacters  = LetterCharacter | DecimalDigitCharacter | ConnectingCharacter | CombiningCharacter | FormattingCharacter;
  token IdentifierBody            = IdentifierStartCharacter IdentifierPartCharacters*;
  token HexDigit           = ['0'..'9', 'a'..'f', 'A'..'F'];
  token ReservedStringChar = "\"" | "\\";
  token ReservedCharChar   = "\'" | "\\";

  syntax TopDeclaration;

  [Ast(                                     _,        _,        Name,      _,    _,            _)]
  syntax SyntaxModule is TopDeclaration   = "syntax"S "module"S Identifier "{"s  Declaration*  "}"s;

  [SpanClass(String)]
  syntax StringLiteral                    = "\""  StringPart* "\"" s;

  syntax StringPart;

  [Ast(                                                   Chars)]
  syntax SimpleStringPart                 is StringPart = (!ReservedStringChar Any)+;

  syntax UnicodeEscapeSequenceStringPart  is StringPart = "\\u"   HexDigit HexDigit HexDigit HexDigit;

  [Ast(                                                   Backslash, Char)]
  syntax EscapeSequenceStringPart         is StringPart = "\\"       Any;


  [SpanClass(Char)]
  syntax CharLiteral                      = "\'"  CharPart "\'" s;


  syntax CharPart;

  [Ast(                                                                   Char)]
  syntax SimpleCharPart                   is CharPart = !ReservedCharChar Any;

  syntax UnicodeEscapeSequenceCharPart    is CharPart = "\\u"   HexDigit HexDigit HexDigit HexDigit;

  [Ast(                                                 Backslash, Char)]
  syntax EscapeSequenceCharPart           is CharPart = "\\"       Any;


  token Digits = ['0'..'9']+;

  [SpanClass(Number)]
  syntax Number                           = Digits s;

  [Ast(                                     Name)]
  syntax Identifier                       = IdentifierBody s;

  [Ast(                                     Names)]
  syntax QIdentifier                      = (Identifier; "."s)+;


  syntax RuleAttribute;

  [Ast(                                        AttributeName)]
  syntax StartAttribute     is RuleAttribute = "StartRule"S;

  [Ast(                                        AttributeName, _,    Names,              _)]
  syntax AstAttribute       is RuleAttribute = "Ast"S         "("s  (Identifier; ","s)* ")"s;

  [Ast(                                        AttributeName, _,    Class,      _)]
  syntax SpanClassAttribute is RuleAttribute = "SpanClass"S   "("s  QIdentifier ")"s;


  syntax RuleAttributeList               = "["s  (RuleAttribute; ","s)+ "]"s;

  syntax RuleAttributes                  = RuleAttributeList*;


  syntax Declaration;

  [Ast(                                          _,             _,        Name,      _,   _,        _)]
  syntax TokenRuleDecl          is Declaration = RuleAttributes "token"S  Identifier "="s TokenRule ";"s;

  [Ast(                                          _,             _,        Name,      _,   _,   _)]
  syntax VoidRuleDecl           is Declaration = RuleAttributes "void"S   Identifier "="s Rule ";"s;

  [Ast(                                          _,             _,        Name,      _,   _,   _)]
  syntax SimpleRuleDecl         is Declaration = RuleAttributes "syntax"S Identifier "="s Rule ";"s;

  [Ast(                                          _,             _,        Name,      _)]
  syntax ExtentionPointRuleDecl is Declaration = RuleAttributes "syntax"S Identifier ";"s;

  [Ast(                                          _,             _,        Name,      _,    BaseName,   _,   _,   _)]
  syntax ExtentionRuleDecl      is Declaration = RuleAttributes "syntax"S Identifier "is"S QIdentifier "="s Rule BodyDeclaration;

  [Ast(                                          _,      _,       Name,      MatchTokens,      _)]
  syntax SpanClass              is Declaration = "span"S "class"S Identifier ("="s TokenRule)? ";"s;

  [Ast(                                          _,       _,       Name,      _,   _,                     _)]
  syntax TokenField             is Declaration = "token"S "field"S Identifier "="s (StringLiteral; ","s)+ ";"s;

  [Ast(                                          _,        Open,     _,   Close,    _)]
  syntax BracePair              is Declaration = "braces"S TokenRule ","s TokenRule ";"s;

  [Ast(                                          _,       GrammarName, _)]
  syntax UsingDecl              is Declaration = "using"S QIdentifier  ";"s;

  [Ast(                                          _,       Alias,     _,   GrammarName, _)]
  syntax AliasDecl              is Declaration = "using"S Identifier "="s QIdentifier  ";"s;

  [Ast(                                          _,        _,                  _,   Value,     _)]
  syntax OptionEmitDebugSources is Declaration = "option"S "EmitDebugSources"S "="s Identifier ";"s;


  syntax BodyDeclaration;

  syntax EmptyBodyDeclaration  is BodyDeclaration = ";"s;
  syntax BlokBodyDeclaration   is BodyDeclaration = "{"s  BodyMemberDeclaration* "}"s;


  syntax BodyMemberDeclaration;

  // TODO: Create "Once" attribute which prevent use rule more then one times.
  [Ast(                                                     _,          Subrules,                     _)]
  syntax SubruleNamesDeclaration is BodyMemberDeclaration = "subrules"S (Identifier "="s Rule; ","s)+ ";"s;

  [Ast(                                                     _,            Precedence, RightAssociative,       _)]
  syntax PrecedenceDeclaration   is BodyMemberDeclaration = "precedence"S Number      ("right-associative"S)? ";"s; // TODO: make precedence table


  syntax Range;

  syntax SingleCharRange is Range = CharLiteral;

  syntax CharRange       is Range = CharLiteral ".."s   CharLiteral;

  [Ast(                             Name)]
  syntax UnicodeRange    is Range = Identifier;


  syntax TokenRule;

  [Ast(                                                  LeftRule,      RightRules)]
  syntax ChoiceTokenRule                  is TokenRule = TokenRule : 10 ("|"s TokenRule : 10)+;

  [Ast(                                                  LeftRule,      RightRules)]
  syntax SequenceTokenRule                is TokenRule = TokenRule : 20 (TokenRule : 20)+;

  syntax OptionalTokenRule                is TokenRule = TokenRule : 30 "?"s;
  syntax ZeroOrManyTokenRule              is TokenRule = TokenRule : 30 "*"s;
  syntax OneOrManyTokenRule               is TokenRule = TokenRule : 30 "+"s;
  syntax RangeTokenRule                   is TokenRule = "["s  (Range; ","s)+ "]"s;
  syntax CharTokenRule                    is TokenRule = CharLiteral;
  syntax StringTokenRule                  is TokenRule = StringLiteral;
  syntax RoundsTokenRule                  is TokenRule = "("s  TokenRule ")"s;

  [Ast(                                                  Name)]
  syntax CallTokenRule                    is TokenRule = QIdentifier;

  [Ast(                                                  _,   _,        _,   Separator, _,   _)]
  syntax ZeroOrManyWithSeparatorTokenRule is TokenRule = "("s TokenRule ";"s TokenRule  ")"s "*"s;

  [Ast(                                                   _,  _,        _,   Separator, _,   _)]
  syntax OneOrManyWithSeparatorTokenRule  is TokenRule = "("s TokenRule ";"s TokenRule  ")"s "+"s;

  syntax Rule;

  [Ast(                                        LeftRule, RightRules)]
  syntax SequenceRule                is Rule = Rule : 10 (Rule : 10)+;

  syntax NotRule                     is Rule = "!"s Rule : 20;
  syntax AndRule                     is Rule = "&"s Rule : 20;
  syntax OptionalRule                is Rule = Rule : 30 "?"s;
  syntax ZeroOrManyRule              is Rule = Rule : 30 "*"s;
  syntax OneOrManyRule               is Rule = Rule : 30 "+"s;
  syntax CharRule                    is Rule = CharLiteral;
  syntax StringRule                  is Rule = StringLiteral;
  syntax RoundsRule                  is Rule = "("s  Rule ")"s;

  [Ast(                                        Name,       BindingPower)]
  syntax CallRule                    is Rule = QIdentifier (":"s Number)?;

  [Ast(                                        _,   _,   _,   Separator, _,   _)]
  syntax ZeroOrManyWithSeparatorRule is Rule = "("s Rule ";"s Rule       ")"s "*"s;

  [Ast(                                        _,   _,   _,   Separator, _,   _)]
  syntax OneOrManyWithSeparatorRule  is Rule = "("s Rule ";"s Rule       ")"s "+"s;

  [Ast(                                        Name,      _,   _,   _)]
  syntax Scope                       is Rule = Identifier "{"s Rule "}"s;
}