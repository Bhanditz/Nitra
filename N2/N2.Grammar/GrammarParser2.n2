using N2;

syntax module GrammarParser2
{
  token field OpenBrace           = "(";
  token field CloseBrace          = ")";
  token field OpenBrace           = "{";
  token field CloseBrace          = "}";
  token field OpenSquareBrace     = "[";
  token field CloseSquareBrace    = "]";
  token field SingleQuote         = "\'";
  token field Quote               = "\"";
  token field Semicolon           = ";";
  token field Comma               = ",";
  token field Colon               = ":";
  token field Assign              = "=";
  token field Prefix              = "\\u";
  token field DodDot              = "..";
  token field Op                  = "+", "-", "*", "/", "?", "^", "%", "&", "!", ".";
  token field Backslash           = "\\";

  span class Char;
  span class String;
  span class Number;
  span class Keyword      = ['a'..'z']['a'..'z']+;
  span class Operator     = ['+', '-', '/', '*', '^', '?', ':']+;
  span class OpenBrace    = "(" | "{" | "[";
  span class CloseBrace   = ")" | "}" | "]";

  braces "(", ")";
  braces "{", "}";
  braces "[", "]";

  [StartRule]
  syntax Start                = s OpenNamespace*  TopDeclaration* !Any;

  token Keyword = "as" | "syntax" | "token" | "alias" | "in" | "out" | "rule";

  syntax OpenNamespace        = "using"s QIdentifier as Namespace ";"s;

  token Any = ['\u0000'..'\uFFFF'];
  token NewLineCharacter  = '\n'
                    | '\r'
                    | '\u2028'    /*  line separator       */
                    | '\u2029';   /*  paragraph separator  */
  token NewLine  = "\r\n" | NewLineCharacter;
  token Whitespace = [Zs]
              | '\t'
              | '\v'        /*  vertial tab          */
              | '\f';       /*  form feed            */
  token Space = Whitespace | NewLine;
  token Spaces = Space+;


  syntax IgnoreToken;

  syntax SingleLineComment  is IgnoreToken = "//" as Start (!NewLine Any)* as Body NewLine? as End;
  syntax MultiLineComment   is IgnoreToken = "/*" as Start (!"*/" Any)*    as Body "*/"     as End;

  syntax SpaceToken         is IgnoreToken = Spaces;


  void s   = IgnoreToken*;                // optional spacer
  void S   = !IdentifierPartCharacters s; // identifier break spacer
  void SM  = !IdentifierPartCharacters s; // identifier break spacer
  void i   = ' '*;                        // increase a indent
  void d   = ' '*;                        // decrease a indent
  void nl  = IgnoreToken*;                // optional spacer and plase for \n while pretty printing
  void inl = IgnoreToken*;                // i + nl
  void sm  = IgnoreToken*;                // optional spacer and prefer to print space while pretty printing


  token LetterCharacter           = ['A'..'Z', 'a'..'z', 'а'..'я', 'А'..'Я'];//[Lu, Ll, Lt, Lm, Lo, Nl];
  token CombiningCharacter        = [Mn, Mc];
  token DecimalDigitCharacter     = [Nd];
  token ConnectingCharacter       = [Pc];
  token FormattingCharacter       = [Cf];
  token IdentifierStartCharacter  = LetterCharacter | "_";
  token IdentifierPartCharacters  = LetterCharacter | DecimalDigitCharacter | ConnectingCharacter | CombiningCharacter | FormattingCharacter;
  token IdentifierBody            = IdentifierStartCharacter IdentifierPartCharacters*;
  token HexDigit                  = ['0'..'9', 'a'..'f', 'A'..'F'];
  token ReservedStringChar        = "\"" | "\\";
  token ReservedCharChar          = "\'" | "\\";

  alias Name          = Identifier;
  alias QualifiedName = QIdentifier;
  alias Char          = Any;

  syntax TopDeclaration;

  syntax SyntaxModule is TopDeclaration = "syntax"SM "module"SM Name nl "{" inl  Declaration* d "}" nl;

  [SpanClass(String)]
  syntax StringLiteral                    = "\""  StringPart* "\"" s;

  syntax StringPart;

  syntax UnicodeEscapeSequenceStringPart  is StringPart = "\\u" HexDigit HexDigit HexDigit HexDigit;
  syntax EscapeSequenceStringPart         is StringPart = "\\"  Char;
  syntax SimpleStringPart                 is StringPart = Chars { alias Chars = (!ReservedStringChar Any)+; }

  [SpanClass(Char)]
  syntax CharLiteral                      = "\'"  CharPart "\'" s;
  
  syntax CharPart;

  syntax SimpleCharPart                   is CharPart = !ReservedCharChar Char;
  syntax UnicodeEscapeSequenceCharPart    is CharPart = "\\u" HexDigit HexDigit HexDigit HexDigit;
  syntax EscapeSequenceCharPart           is CharPart = "\\" Char;
  
  token Digits = ['0'..'9']+;

  [SpanClass(Number)]
  syntax Number                           = Digits s;
  syntax Identifier                       = !(Keyword !IdentifierPartCharacters) IdentifierBody s;
  syntax QIdentifier                      = Names             { alias Names = (Identifier; "."s)+; }
  
  syntax RuleAttribute;

  extend syntax RuleAttribute
  {
    StartAttribute          = AttributeName S                   { alias AttributeName = "StartRule"; }
    AstAttribute            = AttributeName S "("s  Names ")"s  { alias AttributeName = "Ast";       alias Names = (Identifier; ","sm)*; }
    SpanClassAttribute      = AttributeName S "("s  Class ")"s  { alias AttributeName = "SpanClass"; alias Class = QIdentifier; }
    ExplicitSpacesAttribute = AttributeName S                   { alias AttributeName = "ExplicitSpaces"; }
  }

  syntax RuleAttributeList = "["s  (RuleAttribute; ","sm)+ "]"s;
  syntax RuleAttributes    = RuleAttributeList*;

  [StartRule]
  syntax Declaration;

  alias GrammarName = QIdentifier;
  alias BaseName = QIdentifier;

  extend syntax Declaration
  {
    ExtentionRuleDecl       = RuleAttributes "syntax"  SM             Name  sm "is" SM BaseName sm "=" sm Rule  BodyDeclaration;
    SimpleRuleDecl          = RuleAttributes "syntax"  SM             Name  sm "="  sm Rule                     BodyDeclaration;
    TokenRuleDecl           = RuleAttributes "token"   SM             Name  sm "="  sm TokenRule                BodyDeclaration;
    VoidRuleDecl            = RuleAttributes "void"    SM             Name  sm "="  sm Rule                     ";"nl;
    Alias                   =                "alias"   SM             Name  sm "="  sm Rule                     ";"nl;
    TokenField              =                "token"   SM "field"  SM Name  sm "="  sm (StringLiteral; ","sm)+  ";"nl;
    AliasSyntaxModuleDecl   =                "using"   SM             Alias sm "="  sm GrammarName              ";"nl      { alias Alias = Identifier; }
    ImportSyntaxModuleDecl  =                "using"   SM             GrammarName                               ";"nl;
    ExtentionPointRuleDecl  = RuleAttributes "syntax"  SM             Name                                      BodyDeclaration;
    SpanClassDecl           =                "span"    SM "class"  SM Name MatchTokens                          ";"nl      { alias MatchTokens = ("="s TokenRule)?; }
    BracePairDecl           =                "braces"  SM             Open ","sm Close                          ";"nl      { alias Open = TokenRule; alias Close = TokenRule; }
    OptionEmitDebugSources  =                "option"  SM             "EmitDebugSources" SM "=" sm Value        ";"nl      { alias Value = Identifier; }
    ExtendSyntax            =                "extend"  SM "syntax" SM BaseName nl "{" inl ExtendSyntaxMember* d "}"nl;
    MarkerDecl              = RuleAttributes "marker"  SM             Name                                      ";"nl;
    KeywordRegexDecl        =                "keyword" SM "regex"  SM TokenRule as MatchTokens sm "rule" SM Name ";"nl;
  }

  syntax ExtendSyntaxMember = RuleAttributes                     Name                "="s Rule BodyDeclaration;

  syntax BodyDeclaration;

  extend syntax BodyDeclaration
  {
    EmptyBodyDeclaration = ";"nl;
    BlokBodyDeclaration  = "{"s  BodyMemberDeclaration* "}"nl;
  }

  syntax FieldInitializer = "=" sm Expression;

  syntax BodyMemberDeclaration;

  extend syntax BodyMemberDeclaration
  {
    InFieldDeclaration    = "in"    SM Name sm ":" sm Type ";"nl;
    OutFieldDeclaration   = "out"   SM Name sm ":" sm Type FieldInitializer? ";"nl;
    SetDeclaration        = "set"   SM QualifiedName "=" sm Expression ";"nl;
    InnerAliasDeclaration = "alias" SM Name "=" sm Rule ";"nl;                  // TODO: Create "Once" attribute which prevent use rule more then one times.
    PrecedenceDeclaration = "precedence" SM Precedence RightAssociative ";"s { alias Precedence = Number; alias RightAssociative = ("right-associative"S)?; }  // TODO: make precedence table
  }

  syntax TypeParams = "[" (Type; ","sm)+ "]";
  syntax SimpleName = Identifier TypeParams?;

  syntax Type;
  
  extend syntax Type
  {
    Type1 = SimpleName;
    Type2 = Type "."s SimpleName;
  }

  syntax Block = nl "{" inl (Expression; ";" nl)* (";"s)* as Semicolons d "}" nl;

  syntax Content;

  extend syntax Content
  {
    Content1 = Block;
    Content2 = IgnoreToken+;
    Content3 = CharLiteral;
    Content4 = StringLiteral;
  }

  syntax ExpressionContent;

  extend syntax ExpressionContent
  {
    ExpressionContent1 = Content;
    ExpressionContent2 = (!";" !Content Any)+;
  }

  syntax Expression = ExpressionContent+;

  syntax Range;

  extend syntax Range
  {
    SingleCharRange = CharLiteral;
    CharRange       = CharLiteral ".."s   CharLiteral;
    UnicodeRange    = Name;
  }

  syntax TokenRule;

  alias SeparatorToken = TokenRule;
  
  extend syntax TokenRule
  {
    ChoiceTokenRule                  = LeftRule sm RightRules  { alias LeftRule = TokenRule : 10; alias RightRules = ("|"s TokenRule : 10)+; }
    SequenceTokenRule                = LeftRule sm RightRules  { alias LeftRule = TokenRule : 20; alias RightRules = (TokenRule : 20)+; }
    OptionalTokenRule                = TokenRule "?"s       { precedence 30; }
    ZeroOrManyTokenRule              = TokenRule "*"s       { precedence 30; }
    OneOrManyTokenRule               = TokenRule "+"s       { precedence 30; }
    CharTokenRule                    = CharLiteral;
    StringTokenRule                  = StringLiteral;
    CallTokenRule                    = QualifiedName;
    RoundsTokenRule                  = "("s TokenRule ")"s;
    RangeTokenRule                   = "["s (Range; ","sm)+ "]"s;
    ZeroOrManyWithSeparatorTokenRule = "("s TokenRule ";"sm SeparatorToken ")"s "*"s;
    OneOrManyWithSeparatorTokenRule  = "("s TokenRule ";"sm SeparatorToken ")"s "+"s;
  }

  alias SeparatorRule = Rule;

  syntax Rule;

  extend syntax Rule
  {
    SequenceRule                = LeftRule RightRules        { alias LeftRule = Rule : 10; alias RightRules = (sm Rule : 10)+; }
    NotRule                     = "!"s Rule : 20;
    AndRule                     = "&"s Rule : 20;
    OptionalRule                = Rule "?"s          { precedence 30; }
    ZeroOrManyRule              = Rule "*"s          { precedence 30; }
    OneOrManyRule               = Rule "+"s          { precedence 30; }
    FieldName                   = Rule : 11 sm "as"sm Name;
    CharRule                    = CharLiteral;
    StringRule                  = StringLiteral;
    RoundsRule                  = "("s  Rule ")"s;
    CallRule                    = QualifiedName BindingPower { alias BindingPower = (sm ":" sm Number)?; }
    ZeroOrManyWithSeparatorRule = "("s Rule ";"sm SeparatorRule ")"s "*"s;
    OneOrManyWithSeparatorRule  = "("s Rule ";"sm SeparatorRule ")"s "+"s;
    Scope                       = Name sm "{"sm Rule sm "}"sm;
  }
}