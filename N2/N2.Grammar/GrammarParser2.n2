using N2;
using N2.Grammar;
using N2.Grammar.Utils;
using N2.Model;
using Nemerle.Compiler;

syntax module GrammarParser2
{
  token field OpenBrace           = "(";
  token field CloseBrace          = ")";
  token field OpenBrace           = "{";
  token field CloseBrace          = "}";
  token field OpenSquareBrace     = "[";
  token field CloseSquareBrace    = "]";
  token field SingleQuote         = "\'";
  token field Quote               = "\"";
  token field Semicolon           = ";";
  token field Comma               = ",";
  token field Colon               = ":";
  token field Assign              = "=";
  token field Prefix              = "\\u";
  token field DodDot              = "..";
  token field Op                  = "+", "-", "*", "/", "?", "^", "%", "&", "!", ".";
  token field Backslash           = "\\";

  span class Char;
  span class String;
  span class Number;
  span class Keyword      = ['a'..'z']['a'..'z']+;
  span class Operator     = ['+', '-', '/', '*', '^', '?', ':']+;
  span class OpenBrace    = "(" | "{" | "[";
  span class CloseBrace   = ")" | "}" | "]";

  braces "(", ")";
  braces "{", "}";
  braces "[", "]";

  keyword regex ['A'..'Z', 'a'..'z', '_'..'_']+['A'..'Z', 'a'..'z', '_'..'_', '-'..'-']* rule S;

  marker i;   // increase a indent
  marker d;   // decrease a indent
  marker nl;  // optional spacer and plase for \n while pretty printing
  marker inl; // i + nl
  marker sm;  // optional spacer and prefer to print space while pretty printing

  alias Name          = Identifier;
  alias QualifiedName = QIdentifier;
  alias Char          = Any;
  alias GrammarName   = QIdentifier;
  alias BaseName      = QIdentifier;

  token Keyword = "as" | "syntax" | "token" | "alias" | "in" | "out" | "rule";

  token Any = ['\u0000'..'\uFFFF'];
  token NewLineCharacter  = '\n'
                    | '\r'
                    | '\u2028'    /*  line separator       */
                    | '\u2029';   /*  paragraph separator  */
  token NewLine  = "\r\n" | NewLineCharacter;
  token Whitespace = [Zs]
              | '\t'
              | '\v'        /*  vertial tab          */
              | '\f';       /*  form feed            */
  token Space = Whitespace | NewLine;
  token Spaces = Space+;


  [ExplicitSpaces] syntax IgnoreToken;

  extend syntax IgnoreToken
  {
    [ExplicitSpaces] SingleLineComment = "//" as Start (!NewLine Any)* as Body NewLine? as End;
    [ExplicitSpaces] MultiLineComment  = "/*" as Start (!"*/" Any)*    as Body "*/"     as End;
    [ExplicitSpaces] SpaceToken        = Spaces;
  }

  [ExplicitSpaces] void s   = IgnoreToken*;                // optional spacer
  [ExplicitSpaces] void S   = !IdentifierPartCharacters s; // identifier break spacer

  token LetterCharacter           = ['A'..'Z', 'a'..'z', 'а'..'я', 'А'..'Я'];//[Lu, Ll, Lt, Lm, Lo, Nl];
  token CombiningCharacter        = [Mn, Mc];
  token DecimalDigitCharacter     = [Nd];
  token ConnectingCharacter       = [Pc];
  token FormattingCharacter       = [Cf];
  token IdentifierStartCharacter  = LetterCharacter | "_";
  token IdentifierPartCharacters  = LetterCharacter | DecimalDigitCharacter | ConnectingCharacter 
                                  | CombiningCharacter | FormattingCharacter;
  token IdentifierBody            = IdentifierStartCharacter IdentifierPartCharacters*;
  token HexDigit                  = ['0'..'9', 'a'..'f', 'A'..'F'];
  token ReservedStringChar        = "\"" | "\\";
  token ReservedCharChar          = "\'" | "\\";

  [SpanClass(String), ExplicitSpaces]
  syntax StringLiteral                    = "\""  StringPart* "\"";

  [ExplicitSpaces] syntax StringPart;

  extend syntax StringPart
  {
    [ExplicitSpaces] UnicodeEscapeSequenceStringPart = "\\u" HexDigit HexDigit HexDigit HexDigit;
    [ExplicitSpaces] EscapeSequenceStringPart        = "\\"  Char;
    [ExplicitSpaces] SimpleStringPart                = Chars { alias Chars = (!ReservedStringChar Any)+; }
  }

  [SpanClass(Char), ExplicitSpaces]
  syntax CharLiteral                      = "\'"  CharPart "\'";

  [ExplicitSpaces] syntax CharPart;

  extend syntax CharPart
  {
    [ExplicitSpaces] SimpleCharPart                = !ReservedCharChar Char;
    [ExplicitSpaces] UnicodeEscapeSequenceCharPart = "\\u" HexDigit HexDigit HexDigit HexDigit;
    [ExplicitSpaces] EscapeSequenceCharPart        = "\\" Char;
  }
  
  token Digits = ['0'..'9']+;

  [SpanClass(Number), ExplicitSpaces]
  syntax Number                           = Digits;

  [ExplicitSpaces]
  syntax Identifier                       = !(Keyword !IdentifierPartCharacters) IdentifierBody
  {
    Value() : string = GetText(IdentifierBody);
    Identifier() : N2.Model.Identifier = N2.Model.Identifier(this, IdentifierBody);
  }
  syntax QIdentifier                      = Names
  {
    alias Names = (Identifier; ".")+;
    Parts() : list[string] = Names[0].Map(_.Value());
  }
  
  [StartRule, ExplicitSpaces]
  syntax Start                = s OpenNamespace*  TopDeclaration* !Any
  {
    Env(env : GlobalEnv) : GlobalEnv = FoldThrough(OpenNamespaces, env, _.Env(_));
    OutScope(inScope : N2.Scope) : N2.Scope = PassThrough(TopDeclarations, inScope, _.OutScope(_));
  }

  syntax OpenNamespace        = "using" QIdentifier as Namespace ";"
  {
    // FIXME: Namespace.Location include a space locations, which is not good.
    Env(env : GlobalEnv) : GlobalEnv = env.AddOpenNamespace(Namespace.Parts(), Namespace.NLocation());
  }

  syntax TopDeclaration
  {
    GrammarRefs(env : GlobalEnv) : list[GrammarRef];
    OutScope(inScope : N2.Scope) : N2.Scope = inScope;
  }

  syntax SyntaxModule is TopDeclaration = "syntax"sm "module"sm Name nl "{" inl Import* Declaration* d "}" nl
  {
    override GrammarRefs = Imports.MapI((i, import) => import.GrammarRef(env, i));
    override OutScope
    {
      def newScope = FoldThrough(Imports, inScope, _.OutScope(_));
      PassThrough(Declarations, newScope, _.OutScope(_));
    }
  }

  syntax Import
  {
    GrammarRef(env : GlobalEnv, index : int) : GrammarRef;
    OutScope(inScope : N2.Scope) : N2.Scope = inScope;
  }

  extend syntax Import
  {
    AliasSyntaxModuleDecl   = "using" sm Alias sm "="  sm GrammarName ";"nl
    {
      alias Alias = Identifier;
      override GrammarRef = GrammarRef(GrammarName.NLocation(), index, Some(Alias.Identifier()), BindFixedType(env, GrammarName));
    }
    ImportSyntaxModuleDecl  = "using" sm GrammarName                  ";"nl
    {
      override GrammarRef = GrammarRef(GrammarName.NLocation(), index, None(), BindFixedType(env, GrammarName));
    }
  }

  syntax RuleAttribute;

  extend syntax RuleAttribute
  {
    StartAttribute                  = AttributeName               { alias AttributeName = "StartRule"; }
    AstAttribute                    = AttributeName "(" Names ")" { alias AttributeName = "Ast";
                                                                    alias Names = (Identifier; ","sm)*; }
    SpanClassAttribute              = AttributeName "(" Class ")" { alias AttributeName = "SpanClass"; 
                                                                    alias Class = QIdentifier; }
    ExplicitSpacesAttribute         = AttributeName               { alias AttributeName = "ExplicitSpaces"; }
    SuppressTrailingSpacesAttribute = AttributeName               { alias AttributeName = "SuppressTrailingSpaces"; }
  }

  syntax RuleAttributeList = "[" (RuleAttribute; ","sm)+ "]";
  syntax RuleAttributes    = RuleAttributeList*;

  [StartRule]
  syntax Declaration { OutScope(inScope : N2.Scope) : N2.Scope = inScope; }

  extend syntax Declaration
  {
    ExtentionRuleDecl       = RuleAttributes "syntax"  sm             Name  sm "is" sm BaseName sm "=" sm Rule  BodyDeclaration
    {
      //override OutScope { FieldNames(inScope); inScope }
      //FieldNames(scope : Scope) : list[string] = Rule.FieldNames(scope);
    }
    SimpleRuleDecl          = RuleAttributes "syntax"  sm             Name  sm "="  sm Rule                     BodyDeclaration;
    ExtentionPointRuleDecl  = RuleAttributes "syntax"  sm             Name                                      BodyDeclaration;
    ExtendSyntax            =                "extend"  sm "syntax" sm BaseName nl "{" inl ExtendSyntaxMember* d "}"nl
    { override OutScope = PassThrough(ExtendSyntaxMembers, inScope, _.OutScope(_)); }
    TokenRuleDecl           = RuleAttributes "token"   sm             Name  sm "="  sm TokenRule                BodyDeclaration;
    VoidRuleDecl            = RuleAttributes "void"    sm             Name  sm "="  sm Rule                     ";"nl;
    Alias                   =                "alias"   sm             Name  sm "="  sm Rule                     ";"nl;
    TokenField              =                "token"   sm "field"  sm Name  sm "="  sm (StringLiteral; ","sm)+  ";"nl
    { override OutScope = inScope.Nested(Symbol.TokenField(StringLiterals[0], Name)); }
    SpanClassDecl           =                "span"    sm "class"  sm Name MatchTokens                          ";"nl
    { alias MatchTokens = ("=" TokenRule)?; }
    BracePairDecl           =                "braces"  sm             Open ","sm Close                          ";"nl
    { alias Open = TokenRule; alias Close = TokenRule; }
    OptionEmitDebugSources  =                "option"  sm             "EmitDebugSources" sm "=" sm Value        ";"nl
    { alias Value = Identifier; }
    MarkerDecl              =                "marker"  sm             Name                                      ";"nl;
    KeywordRegexDecl        =                "keyword" sm "regex"  sm TokenRule as MatchTokens sm "rule" sm Name ";"nl;
  }

  syntax ExtendSyntaxMember = RuleAttributes Name "=" Rule BodyDeclaration
  { OutScope(inScope : N2.Scope) : N2.Scope = BodyDeclaration.OutScope(inScope); }

  syntax BodyDeclaration { OutScope(inScope : N2.Scope) : N2.Scope = inScope; }

  extend syntax BodyDeclaration
  {
    EmptyBodyDeclaration = ";"nl;
    BlockBodyDeclaration = "{"  BodyMemberDeclaration* "}"nl
    { override OutScope = PassThrough(BodyMemberDeclarations, inScope, _.OutScope(_)); }
  }

  syntax FieldInitializer = "=" sm Expression;

  syntax BodyMemberDeclaration { OutScope(inScope : N2.Scope) : N2.Scope = inScope; }

  syntax ExtraFieldsParam = Name sm ":" sm Type;
  [ExplicitSpaces]
  syntax ExtraFieldPrivate = "private" sm;

  extend syntax BodyMemberDeclaration
  {
    ExtraFieldDeclaration1 = ExtraFieldPrivate? Name sm "(" (ExtraFieldsParam; "," sm)* ")" sm ":" sm Type ExtraFieldBody;
    ExtraFieldDeclaration2 = "override"     sm  Name ExtraFieldBody;
    ExtraFieldDeclaration3 = "error"        sm  Name ExtraFieldBody;
    // TODO: Create "Once" attribute which prevent use rule more then one times.
    InnerAliasDeclaration  = "alias"        sm  Name "=" sm Rule ";"nl; 
    PrecedenceDeclaration  = "precedence"   sm  Precedence RightAssociative ";"
    { alias Precedence = Number; alias RightAssociative = ("right-associative")?; }  // TODO: make precedence table
  }

  syntax ExtraFieldBody;

  extend syntax ExtraFieldBody
  {
    ExtraFieldBody1     = Block;
    ExtraFieldBody2     = sm "=" sm Expression ";" nl;
    ExtraFieldBodyEmpty = ";" nl;
  }

  syntax TypeParams = "[" (Type; ","sm)+ "]";
  syntax SimpleName = Identifier TypeParams?;

  syntax Type;
  
  extend syntax Type
  {
    Type1 = SimpleName;
    Type2 = Type "." SimpleName { precedence 10; }
  }

  syntax Block = nl "{" inl (Expression; ";" nl)* ";"* as Semicolons d "}" nl;
  syntax Parentheses = "(" Expression? ")";

  syntax Content;

  extend syntax Content
  {
    Content1 = Block;
    Content2 = IgnoreToken+;
    Content3 = CharLiteral;
    Content4 = StringLiteral;
    Content5 = Parentheses;
    Content6 = "fold" sm Identifier "(" Expression ";" (Expression; ";"sm)+ ")";
  }

  syntax ExpressionContent;

  extend syntax ExpressionContent
  {
    ExpressionContent1 = Content;
    ExpressionContent2 = (!";" !")" !"}" !Content Any)+;
  }

  syntax Expression = ExpressionContent+;

  syntax Range;

  extend syntax Range
  {
    SingleCharRange = CharLiteral;
    CharRange       = CharLiteral ".." CharLiteral;
    UnicodeRange    = Name;
  }

  syntax TokenRule;

  alias SeparatorToken = TokenRule;
  
  extend syntax TokenRule
  {
    ChoiceTokenRule                  = LeftRule sm RightRules
    { alias LeftRule = TokenRule : 10; alias RightRules = ("|" TokenRule : 10)+; }
    SequenceTokenRule                = LeftRule sm RightRules
    { alias LeftRule = TokenRule : 20; alias RightRules = (TokenRule : 20)+; }
    OptionalTokenRule                = TokenRule "?"       { precedence 30; }
    ZeroOrManyTokenRule              = TokenRule "*"       { precedence 30; }
    OneOrManyTokenRule               = TokenRule "+"       { precedence 30; }
    CharTokenRule                    = CharLiteral;
    StringTokenRule                  = StringLiteral;
    CallTokenRule                    = QualifiedName;
    RoundsTokenRule                  = "(" TokenRule ")";
    RangeTokenRule                   = "[" (Range; ","sm)+ "]";
    ZeroOrManyWithSeparatorTokenRule = "(" TokenRule ";"sm SeparatorToken ")" "*";
    OneOrManyWithSeparatorTokenRule  = "(" TokenRule ";"sm SeparatorToken ")" "+";
  }

  alias SeparatorRule = Rule;

  syntax Rule
  {
    OutScope(inScope : N2.Scope) : N2.Scope = inScope;
    //FieldNames(scope : Scope) : string = [];
  }

  syntax NamespaceName = Name;

  extend syntax Rule
  {
    SequenceRule                = LeftRule RightRules
    {
      alias LeftRule = Rule : 10;
      alias RightRules = (sm Rule : 10)+;

      //override OutScope = a;
      //override FieldNames { LeftRule.FieldName() :: RightRules.Map(r => r.FieldName()) }
    }
    NotRule                     = "!" Rule : 20;
    AndRule                     = "&" Rule : 20;
    OptionalRule                = Rule "?"          { precedence 30; }
    ZeroOrManyRule              = Rule "*"          { precedence 30; }
    OneOrManyRule               = Rule "+"          { precedence 30; }
    FieldName                   = Rule : 11 sm "as"sm Name;
    CharRule                    = CharLiteral;
    StringRule                  = StringLiteral;
    RoundsRule                  = "(" Rule ")";
    CallRule                    = QualifiedName BindingPower
                                { alias BindingPower = (sm ":" sm Number)?; }
    ZeroOrManyWithSeparatorRule = "(" Rule ";"sm SeparatorRule ")" "*";
    OneOrManyWithSeparatorRule  = "(" Rule ";"sm SeparatorRule ")" "+";
    Scope                       = NamespaceName sm "{"sm Rule sm "}"sm;
  }
}