using N2.Model;
using N2.ProjectSystem;

using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;

using G = GrammarParser2;

namespace N2.Typing
{
  [Record]
  public class N2Scope
  {
    public Parent                   : N2Scope                                   { get; }
    public Env                      : Environment[N2Project]                    { get; }
    public Aliases                  : Map[string, G.Rule]                       { get; }
    public TokenFieldNames          : Map[string, Identifier]                   { get; }
    public SpanClassTokensMatchers  : list[(string -> bool) * Identifier]       { get; }
    public SpanClasses              : Map[string, Identifier]                   { get; }
    public BracePairs               : list[(string -> bool) * (string -> bool)] { get; }
    public KeywordRegexs            : list[(string -> bool) * Identifier]       { get; }
   
    public this(env : Environment[N2Project])
    {
      this(null, env, Map(), Map(), [], Map(), [], [])
    }

    public AddAlias(name : string, rule : G.Rule) : N2Scope
    {
      def aliases = Aliases.Replace(name, rule);
      N2Scope(this, Env, aliases, TokenFieldNames, SpanClassTokensMatchers, SpanClasses, BracePairs, KeywordRegexs)
    }

    public AddTokenFieldNames(name : Identifier, stringLiterals : list[G.StringLiteral]) : N2Scope
    {
      def tokenFieldNames = Utils.FoldThrough(stringLiterals, TokenFieldNames, (strLit, result) => result.Replace(strLit.Value(), name));
      N2Scope(this, Env, Aliases, tokenFieldNames, SpanClassTokensMatchers, SpanClasses, BracePairs, KeywordRegexs)
    }

    public AddSpanClass(name : Identifier, tokensMatcherOpt : option[RegularRule]) : N2Scope
    {
      //when (SpanClasses.Contains(name)) // it is need?
      //  Env.Project.Error(name, "Can't resolve name: '$name'.", -1);
        
      def tokensMatchers =
        if (tokensMatcherOpt is Some(tokensMatcher))
          (MakeMatcher(tokensMatcher), name) :: SpanClassTokensMatchers
        else
          SpanClassTokensMatchers;

      N2Scope(this, Env, Aliases, TokenFieldNames, tokensMatchers, SpanClasses.Replace(name.Value, name), BracePairs, KeywordRegexs)
    }

    public AddBracePair(openBraceMatcher : RegularRule, closeBraceMatcher : RegularRule) : N2Scope
    {
      def bracePairs = (MakeMatcher(openBraceMatcher), MakeMatcher(closeBraceMatcher)) :: BracePairs;
      N2Scope(this, Env, Aliases, TokenFieldNames, SpanClassTokensMatchers, SpanClasses, bracePairs, KeywordRegexs)
    }
    
    public AddKeywordRegex(tokensMatcher : RegularRule, name : Identifier) : N2Scope
    {
      def keywordRegexs = (MakeMatcher(tokensMatcher), name) :: KeywordRegexs;
      N2Scope(this, Env, Aliases, TokenFieldNames, SpanClassTokensMatchers, SpanClasses, BracePairs, keywordRegexs)
    }

    public TryGetAlias(nameParts : list[string]) : option[G.Rule]
    {
      if (nameParts is [name]) // TODO: maybe we should implement using aliases from other syntax modules
        Aliases.Find(name)
      else
        None()
    }

    public BindSpanClass(name : G.Identifier) : option[Identifier]
    {
      match (SpanClasses.Find(name.Value()))
      {
        | Some as result => result
        | _ => assert2(false); Env.Project.Error(name, $"The '$name' span class is not defined.", -1); None()
      }
    }
    
    MakeMatcher(regularRule : RegularRule) : string -> bool
    {
      def convert(_ : RegularRule) : FSM
      {
        | Choice(rules)                            => FSMBuilder.Choice(rules.Map(convert))
        | Sequence(rules)                          => FSMBuilder.Seq(rules.Map(convert))
        | Chars(chars)                             => FSMBuilder.Seq(chars)
        | Repeat(min, max, rule)                   => FSMBuilder.Repeat(min, max, convert(rule))
        | RepeatWithSeparator(min, max, rule, sep) => FSMBuilder.RepeatWithSeparator(min, max, convert(rule), convert(sep))
        | Call(name) =>
          def loc = name.Location.N2Location();
          match (Env.Bind.[ParsedRuleRefSymbol[G.TokenRuleDecl.Ast]](name.Parts, name.Location.N2Location()))
          {
            | Some(sym) => convert(sym.Value.TokenRule.RegularRule())
            | _ => Env.Project.Error(loc, "Can't resolve name: '$name'.", -1); FSM()
          }
      }
      
      FSMMatch.MakeMatcher(convert(regularRule))
    }

    public GetNextRuleId() : int
    {
      def project = Env.Project;
      project.GetNextRuleId()
    }
    
    public Bind[TSymbol](name : G.Identifier) : option[TSymbol]
      where TSymbol: Symbol
    {
      Env.Bind.[TSymbol](name.Value(), name.Location)
    }
    
    public Bind[TSymbol](name : G.QIdentifier) : option[TSymbol]
      where TSymbol: Symbol
    {
      Env.Bind.[TSymbol](name.Parts(), name.Location)
    }
  }
}
