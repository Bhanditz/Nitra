using N2.Model;
using N2.ProjectSystem;
using N2.Runtime;
using N2.Typing;

using Nemerle;
using Nemerle.Assertions;
using Nemerle.Collections;
using Nemerle.Compiler;
using Nemerle.Imperative;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;

using System.Text;
using G = GrammarParser2;
using PExpr = Nemerle.Compiler.Parsetree.PExpr;

namespace N2
{
  type IntOrStringList = int * list[string];
  
  //[DebuggerStepThroughAttribute]
  public module Utils
  {
    [DebuggerStepThroughAttribute]
    public PassThrough[TElem, TValue](elems : list[TElem], value : TValue, func : TElem * TValue -> TValue) : TValue
    {
      mutable acc = value;
      
      foreach (elem in elems)
        acc = func(elem, acc);
        
      value
    }

    [DebuggerStepThroughAttribute]
    public FoldThrough[TElem, TValue](elems : list[TElem], mutable value : TValue, func : TElem * TValue -> TValue) : TValue
    {
      foreach (elem in elems)
        value = func(elem, value);
        
      value
    }

    //public FoldRightThrough[TElem, TValue](elems : list[TElem], mutable value : TValue, func : TElem * TValue -> TValue) : TValue
    //{
    //  def elems = List(elems);
    //  elems.Reverse();
    //  foreach (elem in elems)
    //    value = func(elem, value);
    //
    //  value
    //}

    [DebuggerStepThroughAttribute]
    public NLocation(this loc : N2.Location) : Compiler.Location
    {
      def (startLine, startCol) = loc.StartLineColumn;
      def (endLine, endCol) = loc.EndLineColumn;
      Location(loc.Source.FileIndex, startLine, startCol, endLine, endCol)
    }

    [DebuggerStepThroughAttribute]
    public NLocation(this located : N2.Located) : Compiler.Location
    {
      assert2(located != null);
      NLocation(located.Location)
    }

    [DebuggerStepThroughAttribute]
    public NLocation(located : N2.Located, tok : NToken) : Compiler.Location
    {
      def loc = located.Location;
      def source = loc.Source;
      def (startLine, startCol) = source.PositionToLineColumn(tok.StartPos);
      def (endLine,   endCol)   = source.PositionToLineColumn(tok.EndPos);
      Location(loc.Source.FileIndex, startLine, startCol, endLine, endCol)
    }

    public N2Location(this location : Compiler.Location) : N2.Location
    {
      def source = SourceSnapshot("", "", location.FileIndex, location.File, array(0), 0);
      def tok = NToken(0, 0);
      N2.Location(source, tok)
    }
    
    [DebuggerStepThroughAttribute]
    public BindFixedType(env : GlobalEnv, located : N2.Located) : FixedType
    {
      def loc = located.NLocation();
      Util.locate(loc,
      {
        def expr = MainParser.ParseExpr(env, located.GetText(), located.NLocation(), allow_empty=false);
        env.BindFixedType(expr)
      })
    }

    [DebuggerStepThroughAttribute]
    private HexDigit(c : char) : int
    {
      | c when '0' <= c && c <= '9' => c : int - '0' : int
      | c when 'a' <= c && c <= 'f' => c : int - 'a' : int + 10
      | c when 'A' <= c && c <= 'F' => c : int - 'A' : int + 10
      | _ => assert2(false); assert(false);
    }

    [DebuggerStepThroughAttribute]
    private DecDigit(c : char) : int
    {
      | c when '0' <= c && c <= '9' => c : int - '0' : int
      | _ => assert2(false); assert(false);
    }

    [DebuggerStepThroughAttribute]
    public HexToChar(ast : N2.Ast, startPos : int, endPos : int) : char
    {
      unchecked HexToInt(ast, startPos, endPos) :> char
    }
    
    [DebuggerStepThroughAttribute]
    public HexToInt(ast : N2.Ast, startPos : int, endPos : int) : int
    {
      assert2(startPos < endPos);

      def text = ast.Location.Source.OriginalText;
      mutable result = HexDigit(text[startPos]);

      for (mutable i = startPos + 1; i < endPos; i++)
        unchecked result = (result << 4) + HexDigit(text[i]);
      
      result
    }

    [DebuggerStepThroughAttribute]
    public DecToInt(ast : N2.Ast, startPos : int, endPos : int) : int
    {
      assert2(startPos < endPos);

      def text = ast.Location.Source.OriginalText;
      mutable result = DecDigit(text[startPos]);

      for (mutable i = startPos + 1; i < endPos; i++)
        unchecked result = result * 10 + DecDigit(text[i]);
      
      result
    }
    
    //public Appent(this source : StringBuilder, text : N2.Located) : StringBuilder
    //{
    //  def loc = text.Location;
    //  source.Append(loc.Source.Text, loc.StartPos, loc.Length)
    //}
    
    //public LastOrDefault[T](this source : list[T], defaultValue : T) : T
    //{
    //  if (source.IsEmpty)
    //    defaultValue
    //  else
    //    source.Last
    //}

    [DebuggerStepThroughAttribute]
    public LastOrDefault[TElem, TResult](this source : list[TElem], func : TElem -> TResult, defaultValue : TResult) : TResult
    {
      if (source.IsEmpty)
        defaultValue
      else
        func(source.Last)
    }

    [DebuggerStepThroughAttribute]
    public static EscapeSequence(c : char) : char
    {
      | '\'' => '\'' | '\"' => '\"' | '\\' => '\\' | '0'  => '\0'
      | 'a'  => '\a' | 'b'  => '\b' | 'f'  => '\f' | 'n'  => '\n'
      | 'r'  => '\r' | 't'  => '\t' | 'v'  => '\v' | c    => c
    }
    
    [DebuggerStepThroughAttribute]
    public EscapeChar(ch : char) : string
    {
      | '\0' => @"'\0'"
      | '\t' => @"'\t'"
      | '\n' => @"'\n'"
      | '\r' => @"'\r'"
      | '\\' => @"'\\'"
      | '\'' => @"'\''"
      | x when x == char.MaxValue  => @" char.MaxValue"
      | c when char.IsLetter(c)
      | c when char.IsDigit(c)
      | c when char.IsPunctuation(c)
      | c when char.IsSeparator(c)
      | c when char.IsSymbol(c)      => $"'$c'"
      | c =>
        def c = c : uint;
        string.Format(<#'\u{0,4:X}'#>, c).Replace(' ', '0');
    }

    [DebuggerStepThroughAttribute]
    public EscapeStringChar(ch : char) : string
    {
      | '\0' => @"\0"
      | '\t' => @"\t"
      | '\n' => @"\n"
      | '\r' => @"\r"
      | '\\' => @"\\"
      | '\'' => @"\'"
      | c when char.IsLetter(c)
      | c when char.IsDigit(c)
      | c when char.IsPunctuation(c)
      | c when char.IsSeparator(c)
      | c when char.IsSymbol(c)      => $"$c"
      | c =>
        def c = c : uint;
        string.Format(<#\u{0,4:X}#>, c).Replace(' ', '0');
    }
    
    [DebuggerStepThroughAttribute]
    public Bind[TProject, TSymbol](this env : Environment[N2Project], name : G.Identifier) : option[TSymbol]
      where TSymbol: Symbol
    {
      env.Bind.[TSymbol](name.Value(), name.Location)
    }

    [DebuggerStepThroughAttribute]
    public MakeType(types : list[RuleType2]) : RuleType2
    {
      foreach (ty in types)
        unless (ty is RuleType2.Void)
          return RuleType2.Tuple(types);
          
      RuleType2.Void()
    }

    [DebuggerStepThroughAttribute]
    public OptimizeType(ty : RuleType2) : RuleType2
    {
      | List(Void)
      | Option(Void)
      | Tuple(types) when types.ForAll(_ is RuleType2.Void) => RuleType2.Void()
      | _ => ty
    }
    
    public MakeName(fieldName : option[string], rules : list[Rule2], _scope : N2Scope) : string
    {
      match (fieldName)
      {
        | Some(name) => name
        | _ =>
          match (rules.Filter(r => !(r.Type is RuleType2.Void || r.Type is RuleType2.Chars)))
          {
            | [rule] => rule.FieldName
            | _ => ""
          }
      }
    }

    public MakeName(fieldName : option[string], rule : Rule2, _separatorRule : Rule2, _scope : N2Scope) : string
    {
      match (fieldName)
      {
        | Some(name) => name
        | _ => rule.FieldName
      }
    }

    public MakePlural(fieldName : option[string], rule : Rule2, _scope : N2Scope) : string
    {
      match (fieldName)
      {
        | Some(name) => name
        | _ => rule.FieldName + "s"
      }
    }

    public MakeLiteralName(fieldName : option[string], value : string, scope : N2Scope) : string
    {
      match (fieldName)
      {
        | Some(name) => name
        | _ =>
          if (scope.TokenFieldNames.Find(value) is Some(id))
            id.Value
          else if (IsIdentifier(value))
            ToPascalCase(value, "Kw")
          else
            ""
      }
    }

    ///////////////////
    
    public MakeName(fieldName : option[string], rules : list[Rule2], _context : Context) : string
    {
      match (fieldName)
      {
        | Some(name) => name
        | _ =>
          match (rules.Filter(r => !(r.Type is RuleType2.Void || r.Type is RuleType2.Chars)))
          {
            | [rule] => rule.FieldName
            | _ => ""
          }
      }
    }

    public MakeName(fieldName : option[string], rule : Rule2, _separatorRule : Rule2, _context : Context) : string
    {
      match (fieldName)
      {
        | Some(name) => name
        | _ => rule.FieldName
      }
    }

    public MakePlural(fieldName : option[string], rule : Rule2, _context : Context) : string
    {
      match (fieldName)
      {
        | Some(name) => name
        | _ => rule.FieldName + "s"
      }
    }

    public MakeLiteralName(fieldName : option[string], value : string, context : Context) : string
    {
      match (fieldName)
      {
        | Some(name) => name
        | _ =>
          if (context.GetTokenFieldNames().Find(value) is Some(id))
            id.Value
          else if (IsIdentifier(value))
            ToPascalCase(value, "Kw")
          else
            ""
      }
    }
    
    public GetTokenFieldNames(this context : Context) : Map[string, Identifier]
    {
      def p : SyntaxModuleContext = context.GetParent();
      p.Module.TokenFieldNames
    }

    public MakeType(rule : Rule2, sepRule : Rule2) : RuleType2
    {
      def type1 = rule.Type;
      def type2 = sepRule.Type;
      
      if (type1 is RuleType2.Void && type2 is RuleType2.Void)
        RuleType2.Void()
      else if (type1 is RuleType2.Void)
        type2
      else if (type2 is RuleType2.Void)
        type1
      else
        RuleType2.Tuple([type1, type2])
    }
  
    public LastOrDefault[T](this source : list[T], defaultValue : T) : T
    {
      match (source)
      {
        | [] | null => defaultValue
        | _         => source.Last
      }
    }
    
    public ToPascalCase(str : string, suffix : string = null) : string
    {
      def suffixIsEmpty = string.IsNullOrEmpty(suffix);
      if (str.Length == 0 || (char.IsUpper(str[0]) && suffixIsEmpty))
        str
      else
      {
        def suffixLength = if (suffixIsEmpty) 0 else suffix.Length;
        def buffer = array(suffixLength + str.Length);
        when (suffixLength > 0)
          suffix.CopyTo(0, buffer, 0, suffixLength);
        str.CopyTo(0, buffer, suffixLength, str.Length);
        buffer[suffixLength] = char.ToUpperInvariant(buffer[suffixLength]);
        string(buffer)
      }
    }
    
    IsIdentifier(str : string) : bool
    {
      if (str.Length == 0)
        false
      else
      {
        def ch = str[0];
                  
        if (ch == '_' || char.IsLetter(ch))
          str.Exists(ch => ch == '_' || char.IsLetterOrDigit(ch)) // TODO: Performance problem
        else
          false
      }
    }

    public ExtentionRule(context : Context, loc : Location, ruleAttributes : G.RuleAttributes, name : G.Identifier, baseName : G.QIdentifier, rule : G.Rule, 
      bodyDeclaration : G.BodyDeclaration) : RuleDefinition2
    {
      def project = context.GetProject();
      def id = project.GetNextRuleId();
      def ruleSymbol = context.GetParent.[SyntaxModuleContext]().Module.BindByHierarchy(name);
      def baseRule = RuleRef(baseName, context.Bind(baseName));
      def precedence = bodyDeclaration.GetPrecedence();
      def contextWithAliases = bodyDeclaration.GetAliases2(context); // !!!
      def extraFields = bodyDeclaration.GetExtraFields();
      def rule2 = rule.GetRule3(baseRule.Ref, precedence, None(), contextWithAliases);
      def options = ruleAttributes.Options2(contextWithAliases);
      def type = baseRule.Ref.Map(sym => sym.Type) ?? RuleType2.Void();
      def fieldName = baseName.Parts().LastOrDefault("?");
      def ruleDefinition = 
        match (rule2)
        {
          | Sequence((Call(callName, bindingPower) as call) :: rules) when callName.Equals(baseRule) =>
            def prefix = Rule2.PrefixCall(call.Location, type, project.GetNextRuleId(), fieldName, baseRule, bindingPower);
            def seq = Rule2.Sequence(loc, rule2.Type, project.GetNextRuleId(), "", prefix :: rules);
            RuleDefinition2.ExtentionPostfix(loc, id, ruleSymbol, extraFields, options, baseRule, seq, bindingPower)
              
          | _ => RuleDefinition2.ExtentionPrefix(loc, id, ruleSymbol, extraFields, options, baseRule, EnsureSequence(context, loc, rule2))
        };
          
      ruleDefinition
    }

    public SimpleRule(context : Context, loc : Location, ruleAttributes : G.RuleAttributes, name : G.Identifier, rule : G.Rule, 
      bodyDeclaration : G.BodyDeclaration) : RuleDefinition2
    {
      def project = context.GetProject();
      def id = project.GetNextRuleId();
      def ruleSymbol = context.GetParent.[SyntaxModuleContext]().Module.BindByHierarchy(name);
      def precedence = bodyDeclaration.GetPrecedence();
      def contextWithAliases = bodyDeclaration.GetAliases2(context); // !!!
      def extraFields = bodyDeclaration.GetExtraFields();
      def rule2 = rule.GetRule3(None(), precedence, None(), contextWithAliases);
      def options = ruleAttributes.Options2(contextWithAliases);
      RuleDefinition2.Simple(loc, id, ruleSymbol, extraFields, options, EnsureSequence(context, loc, rule2))
    }

    public ExtentionPointRule(context : Context, loc : Location, ruleAttributes : G.RuleAttributes, name : G.Identifier,
      bodyDeclaration : G.BodyDeclaration) : RuleDefinition2
    {
      def project = context.GetProject();
      def id = project.GetNextRuleId();
      def ruleSymbol = context.GetParent.[SyntaxModuleContext]().Module.BindByHierarchy(name);
      def contextWithAliases = bodyDeclaration.GetAliases2(context); // !!!
      def extraFields = bodyDeclaration.GetExtraFields();
      def options = ruleAttributes.Options2(contextWithAliases);
      RuleDefinition2.ExtentionPoint(loc, id, ruleSymbol, extraFields, options)
    }

    public TokenRule(context : Context, loc : Location, ruleAttributes : G.RuleAttributes, name : G.Identifier, tokenRule : G.TokenRule, 
      bodyDeclaration : G.BodyDeclaration) : RuleDefinition2
    {
      def project = context.GetProject();
      def id = project.GetNextRuleId();
      def ruleSymbol = context.GetParent.[SyntaxModuleContext]().Module.BindByHierarchy(name);
      def contextWithAliases = bodyDeclaration.GetAliases2(context); // !!!
      def extraFields = bodyDeclaration.GetExtraFields();
      def options = ruleAttributes.Options2(contextWithAliases);
      RuleDefinition2.Regular(loc, id, ruleSymbol, extraFields, options, tokenRule.RegularRule())
    }

    public EnsureSequence(context : Context, loc : Location, rule : Rule2) : Rule2.Sequence
    {
      match (rule)
      {
        | Rule2.Sequence as result => result
        | _ => Rule2.Sequence(loc, rule.Type, context.GetProject().GetNextRuleId(), "", [rule]);
      }
    }

    public ExtentionRule(inScope : N2Scope, loc : Location, ruleAttributes : G.RuleAttributes, name : G.Identifier, baseName : G.QIdentifier, rule : G.Rule, 
      bodyDeclaration : G.BodyDeclaration) : RuleDefinition2
    {
      //assert2(false);
      def id = inScope.GetNextRuleId();
      def ruleSymbol = inScope.Bind(name);
      assert2(ruleSymbol.IsSome);
      def baseRule = RuleRef(baseName, inScope.Bind(baseName));
      def precedence = bodyDeclaration.GetPrecedence();
      //assert2(precedence == 0);
      def scopeWithAliases = bodyDeclaration.GetAliases(inScope); // !!!
      def extraFields = bodyDeclaration.GetExtraFields();
      def rule2 = rule.GetRule2(baseRule.Ref, precedence, None(), scopeWithAliases);
      def options = ruleAttributes.Options(scopeWithAliases);
      def type = baseRule.Ref.Map(sym => sym.Type) ?? RuleType2.Void();
      def fieldName = baseName.Parts().LastOrDefault("?");
      def ruleDefinition = 
        match (rule2)
        {
          | Sequence((Call(callName, bindingPower) as call) :: rules) when callName.Equals(baseRule) =>
            def prefix = Rule2.PrefixCall(call.Location, type, inScope.GetNextRuleId(), fieldName, baseRule, bindingPower);
            def seq = Rule2.Sequence(loc, rule2.Type, inScope.GetNextRuleId(), "", prefix :: rules);
            RuleDefinition2.ExtentionPostfix(loc, id, ruleSymbol.Value, extraFields, options, baseRule, seq, bindingPower)
              
          | _ => RuleDefinition2.ExtentionPrefix(loc, id, ruleSymbol.Value, extraFields, options, baseRule, EnsureSequence(inScope, loc, rule2))
        };
          
      ruleDefinition
    }

    public SimpleRule(inScope : N2Scope, loc : Location, ruleAttributes : G.RuleAttributes, name : G.Identifier, rule : G.Rule, 
      bodyDeclaration : G.BodyDeclaration) : RuleDefinition2
    {
      def id = inScope.GetNextRuleId();
      def ruleSymbol = inScope.Bind(name);
      assert2(ruleSymbol.IsSome);
      def precedence = bodyDeclaration.GetPrecedence();
      def scopeWithAliases = bodyDeclaration.GetAliases(inScope); // !!!
      def extraFields = bodyDeclaration.GetExtraFields();
      def rule2 = rule.GetRule2(None(), precedence, None(), scopeWithAliases);
      def options = ruleAttributes.Options(scopeWithAliases);
      RuleDefinition2.Simple(loc, id, ruleSymbol.Value, extraFields, options, EnsureSequence(inScope, loc, rule2))
    }
    
    public EnsureSequence(inScope : N2Scope, loc : Location, rule : Rule2) : Rule2.Sequence
    {
      match (rule)
      {
        | Rule2.Sequence as result => result
        | _ => Rule2.Sequence(loc, rule.Type, inScope.GetNextRuleId(), "", [rule]);
      }
    }
    
    public GetProject(this context : Context) : N2Project
    {
      | c is RootContext => c.Project
      | null => assert(false)
      | _ => context.Parent.GetProject()
    }

    public GetParent[T](this context : Context) : T
      where T: Context
    {
      match (context.Parent)
      {
        | null => assert2(false); assert(false);
        | c is T => c
        | c => GetParent.[T](c)
      }
    }
    
    public AddRefSymbol[T](sm : SyntaxModuleSymbol, ast : T, name : string) : SyntaxModuleSymbol
      where T: N2.Ast
    {
      _ = sm.Node.AddAndReport(ParsedRuleRefSymbol(ast, name), ast.Location);
      sm
    }

    BindImpl[T](result : BindingResult[T]) : option[T]
    {
      when (!result.Messages.IsEmpty)
        result.Messages.TranslateTo(N2Project.CurrentProject);

      TryBindImpl(result)
    }

    TryBindImpl[T](result : BindingResult[T]) : option[T]
    {
      match (result.Candidates)
      {
        | [one] => Some(one)
        | _ => None()
      }
    }
    
    public Bind[T](this context : Context, name : G.QIdentifier) : option[T]
      where T: Symbol
    {
      BindImpl(context.BindMany.[T](name.CalcLocations()))
    }

    public Bind[T](this context : Context, name : G.Identifier) : option[T]
      where T: Symbol
    {
      BindImpl(context.BindMany.[T](name.Location))
    }

    public BindByHierarchy[T](this symbol : Symbol, name : G.Identifier) : T
      where T: Symbol
    {
      match (symbol.Node.BindMany(name.Location))
      {
        | [one is T] =>   one
        | _ =>
          assert2(false);
          assert(false);
      }
    }
    
    public TryBind[T](this context : Context, name : G.QIdentifier) : option[T]
      where T: Symbol
    {
      TryBindImpl(context.BindMany.[T](name.CalcLocations()))
    }

    public TryBind[T](this context : Context, name : G.Identifier) : option[T]
      where T: Symbol
    {
      TryBindImpl(context.BindMany.[T](name.Location))
    }

    public TotalLocation(this locations : list[Location]) : Location
    {
      locations.Head + locations.Last
    }
  }
}
