using N2.ProjectSystem;

using Nemerle;
using Nemerle.Collections;
using Nemerle.Imperative;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;

using G = N2Syntax;

namespace N2.Typing
{
  public class SpanClassContext : SimpleNameContext[SpanClassSymbol]
  {
    public          SpanClass : SpanClassSymbol              { get; }
    public override SymbolMap : Map[string, SpanClassSymbol] { get; }

    public this(parent : Context, spanClass : SpanClassSymbol)
    {
      base(parent);
      SpanClass = spanClass;
      def parent = TryGetParent.[SpanClassContext]();
      SymbolMap  = (parent?.SymbolMap ?? Map()).Replace(spanClass.Name, SpanClass);
    }

    public GetSpanClassForString(literal : Location) : option[SpanClassSymbol]
    {
      def str = literal.GetText();
      def matchSpanClass(spanClass : SpanClassSymbol) : bool
      {
        if (spanClass.RegularRule is Some(rr))
          rr.MakeMatcher()(str)
        else
          false
      }

      def getAllSpanClassSymbolFromImportedModule(context : Context, result : List[SpanClassSymbol]) : void
      {
        match (context)
        {
          | usingContext is OpenNamespaceOrTypeContext =>
            when (usingContext.OpenSymbol is Some(mod is SyntaxModuleSymbol))
              result.AddRange(mod.Node.GetChildren.[SpanClassSymbol]());
              
          | null => assert2(false);
          | _ is RootContext => ()
          | _mod is EnteredScopeContext => ()
          | _ => getAllSpanClassSymbolFromImportedModule(context.Parent, result)
        }
      }
      def tryFindInOpenModules() : option[SpanClassSymbol]
      {
        def result = List();
        getAllSpanClassSymbolFromImportedModule(this, result);
        def suitable = result.Filter(sym => sym.RegularRule.Map(rr => rr.MakeMatcher()(str)) ?? false);
        
        match (suitable)
        {
          | [one] => Some(one)
          | []    => None()
          | _ :: _    =>
            ProjectSystem.N2Project.CurrentProject.Error(literal,
              <#Ambigauty between imported span class matchrers for the "$str" literal rule. Define the span class matcher for this rule in the current syntax module. #>, -1);
            None()
        }
      }
      
      def loop(context : Context) : option[SpanClassSymbol]
      {
        | null => None()
        | _mod is SyntaxModuleContext => tryFindInOpenModules()
        | spanClassContext is SpanClassContext when matchSpanClass(SpanClass) => Some(spanClassContext.SpanClass)
        | _ => loop(context.Parent)
      }
      
      loop(this)
    }

    public override ToString() : string
    {
      match(SpanClass.RegularRule)
      {
        | Some(rule) => "span class " + SpanClass.Name + " = " + rule
        | None       => "span class " + SpanClass.Name
      }
    }
  }
}
