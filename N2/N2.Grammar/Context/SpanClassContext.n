using N2.ProjectSystem;

using Nemerle;
using Nemerle.Collections;
using Nemerle.Imperative;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;

using G = N2Syntax;

namespace N2.Typing
{
  public class SpanClassContext : SimpleNameContext[SpanClassSymbol]
  {
    public          SpanClass : SpanClassSymbol              { get; }
    public override SymbolMap : Map[string, SpanClassSymbol] { get; }

    public this(parent : Context, spanClass : SpanClassSymbol)
    {
      base(parent);
      SpanClass = spanClass;
      def parent = TryGetParent.[SpanClassContext]();
      SymbolMap  = (parent?.SymbolMap ?? Map()).Replace(spanClass.Name, SpanClass);
    }

    public GetSpanClassForString(str : string) : option[SpanClassSymbol]
    {
      def matchSpanClass(spanClass : SpanClassSymbol) : bool
      {
        if (spanClass.RegularRule is Some(rr))
          rr.MakeMatcher()(str)
        else
          false
      }

      //def getAllSpanClassSymbolFromImportedModule(context : Context, result : List[SpanClassSymbol]) : void
      //{
      //  match (context)
      //  {
      //    | usingContext is OpenNamespaceOrTypeContext =>
      //      when (usingContext.OpenSymbol is Some(mod is SyntaxModuleSymbol))
      //        result.AddRange(mod.Node.GetChildren.[SpanClassSymbol]());
      //        
      //    | null => assert2(false);
      //    | _ is RootContext => ()
      //    | _mod is EnteredScopeContext => ()
      //    | _ => getAllSpanClassSymbolFromImportedModule(context.Parent, result)
      //  }
      //}
      //def tryFindInOpenModules()
      //{
      //  def result = List();
      //  getAllSpanClassSymbolFromImportedModule(this, result);
      //  def suitable = result.Filter(sym => sym.RegularRule.Map(rr => rr.MakeMatcher()(str)) ?? false);
      //  
      //  match (suitable)
      //  {
      //    | [one] => () // OK
      //    | [] => () // OK
      //  }
      //}
      
      def loop(context : Context) : option[SpanClassSymbol]
      {
        | null => None()
        | _mod is SyntaxModuleContext => None() // TODO: сделать поддержку импортируемых SpanClass-ов
        | spanClassContext is SpanClassContext when matchSpanClass(SpanClass) => Some(spanClassContext.SpanClass)
        | _ => loop(context.Parent)
      }
      
      loop(this)
    }

    public override ToString() : string
    {
      match(SpanClass.RegularRule)
      {
        | Some(rule) => "span class " + SpanClass.Name + " = " + rule
        | None       => "span class " + SpanClass.Name
      }
    }
  }
}
