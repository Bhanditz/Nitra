using N2.Typing;

using Nemerle;
using Nemerle.Imperative;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Text.RegularExpressions;

namespace N2.Model
{
  [Record]
  public variant Rule : N2.Located
  {
    public Type       : RuleType;
    public FieldName  : string;

    | Sequence                { Rules     : list[Rule]; }
    | Call                    { RuleRef   : RuleRef; BindingPower : int; }
    | Repeat                  { MinCount  : int;     MaxCount     : option[int]; Rule : Rule; }
    | RepeatWithSeparator     { MinCount  : int;     MaxCount     : option[int]; Rule : Rule; Separator : Rule; HangingSeparator : bool; }
    | String
      {
        Str       : string;
        [RecordIgnore] public Context : Context { get; }

        public this(loc : N2.Location, type : RuleType, fieldName : string, str : string, context : Context)
        {
          this(loc, type, fieldName, str);
          this.Context = context;
        }

        public SpanClassOpt : option[SpanClassSymbol]
        {
          [Memoize]
          get
          {
            match (Context)
            {
              | null    => None()
              | context => context.GetSpanClassForString(Location, Str)
            }
          }
        }
      }
    | Not                     { Rule      : Rule; }
    | And                     { Rule      : Rule; }

    public this(originalRule : Rule)
    {
      base(originalRule.Location);
      Type      = originalRule.Type;
      FieldName = originalRule.FieldName;
    }

    public UpdateFieldName(newFieldName : string) : Rule
    {
      if (FieldName == newFieldName)
        this
      else match (this)
      {
        | Sequence(rules)                  => Rule.Sequence(Location, Type, newFieldName, rules)
        | Call(ruleRef, bindingPower)      => Rule.Call(Location, Type, newFieldName, ruleRef, bindingPower)
        | Repeat(minCount, maxCount, rule) => Rule.Repeat(Location, Type, newFieldName, minCount, maxCount, rule)
        | RepeatWithSeparator(minCount, maxCount, rule, separator, hangingSeparator) => Rule.RepeatWithSeparator(Location, Type, newFieldName, minCount, maxCount, rule, separator, hangingSeparator)
        | String(Str = str, Context = context) => Rule.String(Location, Type, newFieldName, str, context)
        | Not(rule)   => Rule.Not(Location, Type, newFieldName, rule)
        | And(rule)   => Rule.And(Location, Type, newFieldName, rule)
      }
    }

    public FirstCharBounds() : CharBounds
    {
      def firstCharBounds(rule : Rule, initialRange : RangeSet) : RangeSet
      {
        def loop(rules, range)
        {
          match (rules)
          {
            | [] => range
            | Sequence(rules) :: tail => loop(rules + tail, range);
            | Call(symbolRef, _) :: tail =>
              if (symbolRef is SymbolRef.Some(RuleDefSymbol as symbol))
                range.AddRange(symbol.FirstCharLowerBound, symbol.FirstCharUpperBound)
              else
                loop(tail, range)

            | String(str) :: tail =>
              if (str.Length > 0)
                range.AddSingleCharRange(str[0])
              else
                loop(tail, range)

            | Repeat(minCount, _, rule)                    :: tail
            | RepeatWithSeparator(minCount, _, rule, _, _) :: tail =>
              if (minCount > 0)
                firstCharBounds(rule, range)
              else
                loop(tail, firstCharBounds(rule, range))

            | And :: tail
            | Not :: tail => loop(tail, range)
          }
        }
        loop(if (rule is Sequence(rules)) rules else [rule], initialRange)
      }
      match (firstCharBounds(this, RangeSet()).GetBounds())
      {
        | None => (char.MinValue, char.MaxValue)
        | Some(bounds) => bounds
      }
    }

    public Priority : int
    {
      get
      {
        match (this)
        {
          | String                      => 5
          | Call                        => 5
          | Repeat                      => 4
          | RepeatWithSeparator         => 4
          | Not                         => 3
          | And                         => 3
          | Sequence                    => 2
        }
      }
    }

    public override ToString() : string
    {
      def p(rule : Rule)
      {
        if (rule.Priority <= this.Priority)
          $"($rule)"
        else
          rule.ToString()
      }

      match (this)
      {
        | Sequence(rules)                                      => $<#..$(rules; " "; p)#>
        | Call(name, 0)                                        => name.ToString()
        | Call(name, bp)                                       => $<#$(name) : $bp#>
        | Repeat(0, None, rule)                                => $"$(p(rule))*"
        | Repeat(1, None, rule)                                => $"$(p(rule))+"
        | Repeat(min, None, rule)                              => $"$(p(rule)){$min,}"
        | Repeat(0, Some(1), rule)                             => $"$(p(rule))?"
        | Repeat(min, Some(max), rule) when min == max         => $"$(p(rule)){$min}"
        | Repeat(min, Some(max), rule)                         => $"$(p(rule)){$min, $max}"
        | RepeatWithSeparator(0, None, rule, separator, false) => $"($(p(rule)); $(p(separator)))*"
        | RepeatWithSeparator(0, None, rule, separator, true)  => $"($(p(rule)); $(p(separator)); ?)*"
        | RepeatWithSeparator(1, None, rule, separator, false) => $"($(p(rule)); $(p(separator)))+"
        | RepeatWithSeparator(1, None, rule, separator, true)  => $"($(p(rule)); $(p(separator)); ?)+"
        | RepeatWithSeparator                                  => assert(false);
        | String(str)                                          => $<#'$str'#>
        | Not(rule)                                            => $"!$(p(rule))"
        | And(rule)                                            => $"&$(p(rule))"
      }
    }

    public SubRules : list[Rule]
    {
      get
      {
        match (this)
        {
          | Rule.Sequence(rules) => rules
          | _ => [this]
        }
      }
    }
  }
}
