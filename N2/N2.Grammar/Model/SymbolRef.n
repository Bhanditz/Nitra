using Nemerle;

namespace N2.Typing
{
  [Record]
  public variant SymbolRef[T] : Located
    where T : Symbol
  {
    | Some { Symbol : T }
    | None

    public IsGenerated : bool { get; }
    public IsSome      : bool { get { this is Some } }
    public IsNone      : bool { get { this is None } }
    public HasValue    : bool { get { this is Some } }
    public Value       : T
    {
      get
      {
        match (this)
        {
          | Some(symbol) => symbol
          | None         => assert2(false); assert(false);
        }
      }
    }

    public static Create(located : Located, value : option[T], isGenerated : bool = false) : SymbolRef[T]
    {
      Create(located.Location, value, isGenerated)
    }

    public static Create(location : Location, value : option[T], isGenerated : bool = false) : SymbolRef[T]
    {
      match (value)
      {
        | Some(symbol) => SymbolRef.Some(location, isGenerated, symbol)
        | None         => SymbolRef.None(location, isGenerated)
      }
    }

    public static Create(located : Located, value : ValueOption[T], isGenerated : bool = false) : SymbolRef[T]
    {
      Create(located.Location, value, isGenerated)
    }

    public static Create(location : Location, value : ValueOption[T], isGenerated : bool = false) : SymbolRef[T]
    {
      match (value)
      {
        | VSome(symbol) => SymbolRef.Some(location, isGenerated, symbol)
        | VNone         => SymbolRef.None(location, isGenerated)
      }
    }

    public override ToString() : string
    {
      match (this)
      {
        | Some(r) => r.Name
        | None    => $"$(GetText()) (unresolved)"
      }
    }

    [OverrideObjectEquals]
    public Equals(other : SymbolRef[T]) : bool
    {
      match (this, other)
      {
        | (Some(thisSymbol), Some(otherSymbol)) => thisSymbol : object == otherSymbol : object
        | (None, None) => true
        | _ => false
      }
    }

    public static @==[K](self : SymbolRef[K], other : SymbolRef[T]) : bool
      where K : Symbol
    {
      match (self, other)
      {
        | (Some(selfSymbol), Some(otherSymbol)) => selfSymbol : object == otherSymbol : object
        | (None, None) => typeof(T).Equals(typeof(K))
        | _ => false
      }
    }

    public override GetHashCode() : int
    {
      def combineHashCodes(a, b)
      {
        unchecked ((a << 5) + a ^ b)
      }
      match (this)
      {
        | Some(symbol : Symbol) => combineHashCodes(symbol.GetHashCode(), IsGenerated.GetHashCode())
        | None                  => IsGenerated.GetHashCode()
      }
    }

    public Map[K](mapper : T -> K) : option[K]
    {
      match (this)
      {
        | Some(symbol) => option.Some(mapper(symbol))
        | None         => option.None()
      }
    }

    public static @:(symbolRef : SymbolRef[T]) : option[T]
    {
      symbolRef.ToOption()
    }

    public ToOption() : option[T]
    {
      match (this)
      {
        | Some(symbol) => option.Some(symbol)
        | None         => option.None()
      }
    }
  }
}
