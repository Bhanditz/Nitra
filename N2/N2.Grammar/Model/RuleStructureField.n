using N2.Typing;
using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;

namespace N2.Model
{
  [Record]
  public variant RuleStructureField
  {
                   public         SrcRule            : N2.Model.Rule;
    [RecordIgnore] public mutable Owner              : RuleStructure;
    [RecordIgnore] public mutable State              : int;
    [RecordIgnore] public mutable EndState           : int;
    [RecordIgnore] public mutable Level              : int;
    [RecordIgnore] public mutable Size               : int;
    [RecordIgnore] public mutable Offset             : int;
    [RecordIgnore] public mutable NextSibling        : RuleStructureField;
    [RecordIgnore] public mutable AllocateAst        : bool;
    [RecordIgnore] public mutable IsPredicateState   : bool;
    [RecordIgnore] public mutable CanParseEmpryString         : bool;

    | TokenString       { String : string; }
    | TokenCall         { Symbol : RegularRuleSymbol; }
    | ExtensibleCall    { Symbol : ExtensibleRuleSymbol; BindingPower : int; }
    | SimpleCall        { Symbol : SimpleRuleSymbol; }
    | Option            { Rule   : RuleStructure.Option; }
    | List              { Rule   : RuleStructure.List; MinCount : int; MaxCount : option[int]; public UseCounter : bool { get MinCount > 0 || MaxCount is Some(_) } }
    | ListWithSeparator { Rule   : RuleStructure.ListWithSeparatorRule; Separator : RuleStructure.ListWithSeparatorSeparator; MinCount : int; MaxCount : option[int]; HangingSeparator : bool; public UseCounter : bool { get MinCount > 0 || MaxCount is Some(_) } }
    | Predicate         { Rule   : RuleStructure.Predicate; IsAnd : bool; }
    | Marker            { Symbol : MarkerSymbol; }
    
    public IsLoopSeparatorStart : bool
    {
      [Memoize]
      get
      {
        match (Owner)
        {
          | ListWithSeparatorSeparator as owner => 
            owner.NotMarkerFields.SkipWhile(f => f.CanParseEmpryString && f : object != this).FirstOrDefault() : object == this
          
          | _ => false
        }
      }
    }
    
    public override ToString() : string
    {
      match (this)
      {
        | TokenString                                     => $"$State:$SrcRule"
        | TokenCall                                       => $"$State:$SrcRule"
        | ExtensibleCall                                  => $"$State:$SrcRule"
        | SimpleCall                                      => $"$State:$SrcRule"
        | Option           (rule)                         => $"$State:($rule)?"
        | List             (rule, 0, _)                   => $"$State:($rule)*"
        | List             (rule, 1, _)                   => $"$State:($rule)+"
        | List             (_rule, _minCount, _)          => assert(false)
        | ListWithSeparator(rule, separator, 0, _, false) => $"$State:($rule; $separator)*"
        | ListWithSeparator(rule, separator, 1, _, false) => $"$State:($rule; $separator)+"
        | ListWithSeparator(rule, separator, 0, _, true)  => $"$State:($rule; $separator; ?)*"
        | ListWithSeparator(rule, separator, 1, _, true)  => $"$State:($rule; $separator; ?)+"
        | ListWithSeparator                               => assert(false)
        | Predicate        (rule, true)                   => $"$State:&($rule)"
        | Predicate        (rule, false)                  => $"$State:!($rule)"
        | Marker                                          => ""
      }
    }
  }
}
