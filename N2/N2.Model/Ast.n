using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;

namespace N2.Model
{
  [Record]
  public variant AstField
  {
    public Parent : int { get; }
    public Level  : int { get; }
    | Ast                 { fields  : list[int];                                                       }
    | TokenString         { str     : string;                                                          }
    | TokenCall           { rd      : RuleDefinition;                                                  }
    | ExtentionPoint      { rd      : RuleDefinition; bindingPower : int;                              }
    | ExternalAst         { rd      : RuleDefinition;                                                  }
    | Void                { rd      : RuleDefinition;                                                  }
    | Option              { fields  : list[int];                                                       }
    | List                { fields  : list[int];                      min   : int;  max : option[int]; }
    | List2               { fields1 : list[int]; fields2 : list[int]; min   : int;  max : option[int]; }
    | Predicate           { fields  : list[int];                      isAnd : bool;                    }

    public override ToString() : string
    {
      def s = match (this)
      {
        | Ast           (fields)                     => $<# Ast            $fields#>
        | TokenString   (str)                        => $<# TokenString    "$str"#>
        | TokenCall     (rd)                         => $<# TokenCall      $(rd.Name)#>
        | ExtentionPoint(rd, bindingPower)           => $<# ExtentionPoint $(rd.Name) $bindingPower#>
        | ExternalAst   (rd)                         => $<# ExternalAst    $(rd.Name)#>
        | Void          (rd)                         => $<# Void           $(rd.Name)#>
        | Option        (fields)                     => $<# Option         $fields#>
        | List          (fields, min, max)           => $<# List           $fields $min $max#>
        | List2         (fields1, fields2, min, max) => $<# List2          $fields1 $fields2 $min $max#>
        | Predicate     (fields, isAnd)              => $<# Predicate      $fields $isAnd#>
      }
      string.Format("{0,4} {1,4} {2}", Parent, Level, s);
    }
  }
}
