using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;

namespace N2.Model
{
  [Record]
  public variant AstField
  {
    public Parent : int { get; }
    public Level  : int { get; }
    | PrefixCall
    | TokenString         { str     : string;                                          }
    | TokenCall           { rd      : RuleDefinition;                                  }
    | ExtentionPoint      { rd      : RuleDefinition;                                  }
    | ExternalAst         { rd      : RuleDefinition;                                  }
    | Void                { rd      : RuleDefinition;                                  }
    | Option              { field   : int;                                             }
    | Sequence            { fields  : list[int];                                       }
    | List                { field   : int;               min : int; max : option[int]; }
    | List2               { field1  : int; field2 : int; min : int; max : option[int]; }
    | Predicate           { field   : int;               isAnd : bool;                 }

    public override ToString() : string
    {
      def s = match (this)
      {
        | PrefixCall                               =>  <# PrefixCall     #>
        | TokenString   (str)                      => $<# TokenString    "$str"#>
        | TokenCall     (rd)                       => $<# TokenCall      $(rd.Name)#>
        | ExtentionPoint(rd)                       => $<# ExtentionPoint $(rd.Name)#>
        | ExternalAst   (rd)                       => $<# ExternalAst    $(rd.Name)#>
        | Void          (rd)                       => $<# Void           $(rd.Name)#>
        | Option        (field)                    => $<# Option         $field#>
        | Sequence      (fields)                   => $<# Sequence       $fields#>
        | List          (field, min, max)          => $<# List           $field $min $max#>
        | List2         (field1, field2, min, max) => $<# List2          $field1 $field2 $min $max#>
        | Predicate     (field, isAnd)             => $<# Predicate      $field $isAnd#>
      }
      string.Format("{0,4} {1,4} {2}", Parent, Level, s);
    }
  }
}
