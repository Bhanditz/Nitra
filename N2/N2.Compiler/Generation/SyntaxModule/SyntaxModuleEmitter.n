using N2.Model;
using N2.Typing;

using Nemerle;
using Nemerle.Compiler;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;

namespace N2.Compiler
{
  internal partial class SyntaxModuleEmitter
  {
    public Environment  : EmitterEnvironment       { get; }
    public Env          : GlobalEnv                { get; }
    public SyntaxModule : ParsedSyntaxModuleSymbol { get; }

    public GrammarTB               : TypeBuilder { get; }
    public GrammarImplTB           : TypeBuilder { get; }
    public GrammarDescriptorImplTB : TypeBuilder { get; }

    private GrammarAstTB           : TypeBuilder; //TODO : переместить в более подходящее место

    private _ruleParserEmitters        : list[RuleParserEmitter];

    private _ruleDescriptorEmitters       : list[ParsingRuleDescriptorEmitter];

    private _allAstEmitters               : list[RuleAstEmitter];
    private _extentionPointAstEmitters    : list[RuleAstEmitter];
    private _otherAstEmitters             : list[RuleAstEmitter];

    public this(environment : EmitterEnvironment, syntaxModule : ParsedSyntaxModuleSymbol)
    {
      Environment  = environment;
      SyntaxModule = syntaxModule;
      Env          = Environment.NamespaceOfSymbol(syntaxModule);
      _externalGrammars = HashSet(syntaxModule.ExternalImports);

      GrammarTB               = Env.Define(<[ decl: public partial module $(syntaxModule.Name : usesite) { } ]>);
      GrammarImplTB           = GrammarTB.DefineNestedType(<[decl: public module $(AssemblyConstants.GrammarImplName : usesite) { } ]>);
      GrammarDescriptorImplTB = GrammarTB.DefineNestedType(<[decl:
        public sealed class $(AssemblyConstants.GrammarDescriptorImplName : usesite) : N2.GrammarDescriptor
        {
          private this() {}
          public override Name      : string { get { $(syntaxModule.Name : string) } }
          public override FullName  : string { get { $(syntaxModule.Node.FullName : string) } }
          public override Namespace : string { get { $(syntaxModule.Node.Parent.FullName : string) } }
        }
      ]>);
      GrammarDescriptorImplTB.DefineConditional(<[ decl: private static _staticDescriptor : this = $(GrammarDescriptorImplTB.GetMemType() : typed)() ]>);
      GrammarDescriptorImplTB.DefineConditional(<[ decl: public static StaticDescriptor : this { get { _staticDescriptor } } ]>);
      GrammarTB.DefineConditional(<[ decl: public static StaticDescriptor : N2.GrammarDescriptor { get { $(GrammarDescriptorImplTB.GetMemType() : typed).StaticDescriptor } } ]>);

      GrammarAstTB            = Env.Define(<[ decl: public partial module $(syntaxModule.Name + "Ast" : usesite) {} ]>);

      _ruleParserEmitters = SyntaxModule.Node.GetChildren.[RuleDefSymbol]().FoldLeft([],
        fun(rs : RuleDefSymbol, acc)
        {
          match (rs)
          {
            | ExtensibleRuleSymbol       => acc
            | ExtentionRuleSymbol  as rs => ExtentionRuleParserEmitter(this, rs) :: acc
            | SimpleRuleSymbol     as rs => SimpleRuleParserEmitter(this, rs) :: acc
            | RegularRuleSymbol    as rs => RegularRuleParserEmitter(this, rs) :: acc
            | _                          => assert(false);
          }
        });

      _ruleDescriptorEmitters       = SyntaxModule.Node.GetChildren.[RuleDefSymbol]().Map(ParsingRuleDescriptorEmitter(this, _));

      def isAst(symbol) : bool
      {
        | SimpleRuleSymbol as symbol => !(symbol.Type is RuleType.Void)
        | ExtensibleRuleSymbol       => true
        | ExtentionRuleSymbol        => true
        | _                          => false
      }

      _allAstEmitters = SyntaxModule.Node.GetChildren.[SyntaxRuleSymbol]().Where(isAst).Map(RuleAstEmitter(Environment, _));
      (_extentionPointAstEmitters, _otherAstEmitters) = _allAstEmitters.Partition(x => x.RuleSymbol is ExtensibleRuleSymbol);

      foreach (spanClass in SyntaxModule.Node.GetChildren.[SpanClassSymbol]())
      {
        GrammarTB.DefineConditional(<[decl:
          public static $("SpanClass_" + spanClass.Name : usesite) : N2.SpanClass
            = N2.SpanClass($(spanClass.Name : string), $(GrammarDescriptorImplTB.GetMemType() : typed).StaticDescriptor)
        ]>)
      }
    }

    public DefineExtentionPointAstTypes() : void
    {
      foreach (emitter in _extentionPointAstEmitters)
        emitter.DefineTypes(GrammarAstTB);
    }

    public DefineOtherAstTypes() : void
    {
      foreach (emitter in _otherAstEmitters)
        emitter.DefineTypes(GrammarAstTB);
    }

    public DefineAstMembers() : void
    {
      foreach (emitter in _allAstEmitters)
        emitter.DefineMembers();
    }

    private _externalGrammars : HashSet[SyntaxModuleSymbol];

    public CallRule(callSymbol : RuleSymbol) : void
    {
      when (callSymbol.DeclaringModule : object != SyntaxModule)
        _ = _externalGrammars.Add(callSymbol.DeclaringModule);
    }

    public DefineParserTypes() : void
    {
      foreach (emitter in _ruleParserEmitters)
        emitter.DefineParser();

      foreach (emitter in _ruleDescriptorEmitters)
        emitter.DefineDescriptor();
    }

    public DefineParserMethods() : void
    {
      foreach (emitter in _ruleParserEmitters)
        emitter.DefineParserMethods();

      GrammarDescriptorImplTB.DefineConditional(<[decl:
        public override Rules : array[N2.RuleDescriptor]
        {
          get { array[..$(_ruleDescriptorEmitters.Map(emitter => <[ $(emitter.RuleSymbol.GetDescriptorClassRef()).StaticDescriptor ]>))] }
        }
      ]>);

      GrammarDescriptorImplTB.DefineConditional(<[decl:
        public override Dependencies : array[N2.GrammarDescriptor]
        {
          get { array[..$(_externalGrammars.Map(moduleSymbol => <[ $(PExprUtils.FromQualifiedIdentifier(moduleSymbol.Node.FullNameParts)).StaticDescriptor ]>))] }
        }
      ]>);
    }

    public Emit() : void
    {
      foreach (emitter in _ruleParserEmitters)
        emitter.Emit();
      foreach (emitter in _ruleDescriptorEmitters)
        emitter.Emit();
      foreach (emitter in _allAstEmitters)
        emitter.Emit();

      GrammarAstTB.Compile();
      GrammarDescriptorImplTB.Compile();
      GrammarImplTB.Compile();
      GrammarTB.Compile();
    }
  }
}
