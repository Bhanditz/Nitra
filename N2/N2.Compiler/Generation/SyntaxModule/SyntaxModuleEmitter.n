using N2.Model;
using N2.Typing;

using Nemerle;
using Nemerle.Compiler;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;

namespace N2.Compiler
{
  internal partial class SyntaxModuleEmitter
  {
    public Environment  : EmitterEnvironment       { get; }
    public Env          : GlobalEnv                { get; }
    public SyntaxModule : ParsedSyntaxModuleSymbol { get; }

    public GrammarTB               : TypeBuilder { get; }
    public GrammarImplTB           : TypeBuilder { get; }
    public GrammarDescriptorImplTB : TypeBuilder { get; }

    private _ruleParserEmitters        : list[RuleParserEmitter];

    private _ruleDescriptorEmitters       : list[ParsingRuleDescriptorEmitter];
    private _markerRuleDescriptorEmitters : list[MarkerRuleDescriptorEmitter];

    private _allAstEmitters               : list[RuleAstEmitter];
    private _extentionPointAstEmitters    : list[RuleAstEmitter];
    private _otherAstEmitters             : list[RuleAstEmitter];

    //TODO: переместить эмиттеры волкеров в более подходящее место
    private _grammarDescriptorEmitters    : list[GrammarWalkerDescriptorEmitter];
    private _abstractWalkerEmitters       : list[AbstractWalkerEmitter];

    private _spanClassEmitters            : list[SpanClassEmitter];

    public this(environment : EmitterEnvironment, syntaxModule : ParsedSyntaxModuleSymbol)
    {
      Environment  = environment;
      SyntaxModule = syntaxModule;
      Env          = Environment.NamespaceOfSymbol(syntaxModule);

      GrammarTB               = Env.Define(<[ decl: public abstract partial class $(syntaxModule.Name : usesite) { } ]>);
      GrammarImplTB           = GrammarTB.DefineNestedType(MakeGrammarImpl());
      GrammarDescriptorImplTB = GrammarImplTB.DefineNestedType(MakeGrammarDescriptorImpl());

      _ruleParserEmitters = SyntaxModule.Node.GetChildren.[RuleDefSymbol]().FoldLeft([], 
        fun(rs : RuleDefSymbol, acc)
        {
          match (rs)
          {
            | ExtensibleRuleSymbol       => acc
            | ExtentionRuleSymbol  as rs => ExtentionRuleParserEmitter(this, rs) :: acc
            | SimpleRuleSymbol     as rs => SimpleRuleParserEmitter(this, rs) :: acc
            | RegularRuleSymbol    as rs => RegularRuleParserEmitter(this, rs) :: acc
            | _                          => assert(false);
          }
        });

      _ruleDescriptorEmitters       = SyntaxModule.Node.GetChildren.[RuleDefSymbol]().Map(ParsingRuleDescriptorEmitter(this, _));
      _markerRuleDescriptorEmitters = SyntaxModule.Node.GetChildren.[MarkerSymbol]().Map(MarkerRuleDescriptorEmitter(this, _));

      _allAstEmitters = SyntaxModule.Node.GetChildren.[SyntaxRuleSymbol]().Where(_.IsAst).Map(RuleAstEmitter(this, _));
      (_extentionPointAstEmitters, _otherAstEmitters) = _allAstEmitters.Partition(x => x.RuleSymbol is ExtensibleRuleSymbol);

      //TODO: сделать обработку для void
      _abstractWalkerEmitters = 
        if (this.Environment.IsIdeMode)
          []
        else
          SyntaxModule.Node.GetChildren.[SyntaxRuleSymbol]().NToList().MapFiltered(r => r.IsAst && !r.IsExtentionPoint, AbstractWalkerEmitter(this, _));

      _grammarDescriptorEmitters = [
        GrammarWalkerDescriptorEmitter(this,
          WalkerTypeDescriptorInfo(
            <[ N2.Runtime.AstWalkerTypeDescriptor.StaticDescriptor ]>,
            _abstractWalkerEmitters,
            SyntaxModule.Node.GetChildren.[ExtensibleRuleSymbol]().NToList()))
      ];

      _spanClassEmitters  = SyntaxModule.Node.GetChildren.[SpanClassSymbol]().Select(SpanClassEmitter(this, _)).NToList();
    }

    public DefineExtentionPointAstTypes() : void
    {
      foreach (emitter in _extentionPointAstEmitters)
        emitter.DefineTypes();
    }

    public DefineOtherAstTypes() : void
    {
      foreach (emitter in _otherAstEmitters)
        emitter.DefineTypes();
    }

    public DefineAstMembers() : void
    {
      foreach (emitter in _allAstEmitters)
        emitter.DefineMembers();
    }

    public DefineParserTypes() : void
    {
      def astSizes = Dictionary();
      def externalCalls = List();
      foreach (emitter in _ruleParserEmitters)
      {
        mutable astSize;
        mutable rootAstStruct;
        emitter.DefineParser(out astSize, out rootAstStruct, externalCalls);
        astSizes[emitter.RuleSymbol] = (astSize, rootAstStruct);
      }
      foreach (emitter in _ruleDescriptorEmitters)
        match (emitter.RuleSymbol)
        {
          | _ when !emitter.NeedsAstInfo =>
            emitter.DefineDescriptor(0, None())

          | ExtensibleRuleSymbol =>
            emitter.DefineDescriptor(5, None())

          | rs =>
            assert2(astSizes.ContainsKey(rs));
            emitter.DefineDescriptor(astSizes[rs])
        }

      foreach (emitter in _markerRuleDescriptorEmitters)
        emitter.DefineDescriptor();
        
      foreach (emitter in _abstractWalkerEmitters)
      {
        emitter.DefineTypes();
        emitter.DefineMembers(astSizes[emitter.RuleSymbol][1]);
      }

      foreach (emitter in _grammarDescriptorEmitters)
      {
        emitter.DefineTypes();
        emitter.DefineMembers();
      }

      GrammarDescriptorImplTB.DefineConditional(<[decl:
        public override Rules : array[N2.RuleDescriptor]
        {
          get { array[..$(_ruleDescriptorEmitters.Map(emitter => <[ $(emitter.RuleSymbol.GetDescriptorClassRef()).StaticDescriptor ]>))] }
        }
      ]>);

      def externalGrammars = externalCalls.Select(x => x.Node.Parent).Distinct().NToList();
      GrammarDescriptorImplTB.DefineConditional(<[decl:
        public override Dependencies : array[N2.GrammarDescriptor]
        {
          get { array[..$(externalGrammars.Map(node => <[ $(PExprUtils.FromQualifiedIdentifier(node.FullNameParts + [AssemblyConstants.GrammarImplName])).StaticDescriptor ]>))] }
        }
      ]>);

      GrammarDescriptorImplTB.DefineConditional(<[decl:
        public override GetAstWalkerDescriptor() : N2.Runtime.GrammarWalkerDescriptor
        {
          $(GrammarTB.GetMemType() : typed).$(SyntaxModule.Name + "AstWalkerDescriptor" : usesite).StaticDescriptor
        }
      ]>);
    }

    private _idInGrammarTable : Dictionary[RuleSymbol, int] = Dictionary();

    internal GetIdInGrammar(ruleSymbol : RuleSymbol) : int
    {
      mutable id;
      unless (_idInGrammarTable.TryGetValue(ruleSymbol, out id))
      {
        id = _idInGrammarTable.Count;
        _idInGrammarTable.Add(ruleSymbol, id);
      }
      id
    }

    public DefineParserMethods() : void
    {
      foreach (emitter in _ruleParserEmitters)
        emitter.DefineParserMethods();
    }

    public DefineMetadataMembers() : void
    {
      foreach (emitter in _spanClassEmitters)
        emitter.Emit();
    }

    public Emit() : void
    {
      foreach (emitter in _ruleParserEmitters)
        emitter.Emit();
      foreach (emitter in _ruleDescriptorEmitters)
        emitter.Emit();
      foreach (emitter in _allAstEmitters)
        emitter.Emit();
      foreach (emitter in _grammarDescriptorEmitters)
        emitter.Emit();
      foreach (emitter in _abstractWalkerEmitters)
        emitter.Emit();
      foreach (emitter in _grammarDescriptorEmitters)
        emitter.Emit();
      GrammarDescriptorImplTB.Compile();
      GrammarImplTB.Compile();
      GrammarTB.Compile();
    }
  }
}
