using N2.Typing;
using Nemerle;
using Nemerle.Collections;
using Nemerle.Compiler.Parsetree;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Imperative;

using System;
using SCG = System.Collections.Generic;
using System.Linq;

using N2.Model;

using Nemerle.Compiler;

namespace N2.Compiler
{
  internal partial class ParseMethodEmitter : MethodEmitter
  {
    public Owner : RuleParserEmitter { get; }
    public RuleStructure : RuleStructure.Ast;
    private _tb : TypeBuilder;
    public override Environment     : EmitterEnvironment { get { Owner.Environment } }
    public override ConstantEmitter : IConstantEmitter   { get { Owner } }
    private _endLabel : PExprLabel;

    public this(owner : RuleParserEmitter, tb : TypeBuilder, ruleStructure : RuleStructure.Ast)
    {
      Owner         = owner;
      _tb           = tb;
      RuleStructure = ruleStructure;
      _data         = RuleStructureDataContainer(ruleStructure, this, RuleStructureData, RuleStructureFieldData);
      _endLabel     = Environment.MakeLabel("EndParse");
    }

    public Emit() : void
    {
      if (RuleStructure.Symbol is ExtentionRuleSymbol)
      {
        _tb.DefineConditional(<[decl:
          public override Parse(mutable curTextPos : int, text : string, resultRef : ref int, parser : N2.Internal.Parser) : int
          {
            $(if (Owner.Environment.IsIdeMode)
              <[ _ = curTextPos; _ = text; _ = resultRef; _ = parser; -1 ]>
            else
              CompileAst(RuleStructure))
          }
        ]>);
      }
      else
      {
        _tb.DefineConditional(<[decl:
          public override Parse(mutable curTextPos : int, text : string, parser : N2.Internal.Parser) : int
          {
            $(if (Owner.Environment.IsIdeMode)
              <[ _ = curTextPos; _ = text; _ = parser; -1 ]>
            else
              CompileAst(RuleStructure))
          }
        ]>);
      }
    }

    public CurTextPos : PExpr { get { <[ curTextPos ]> } }

    public AllocateParentAst(field : RuleStructureField) : PExpr
    {
      def structure = field.Owner;
      if (field.AllocateAst)
      {
        match (structure)
        {
          | RuleStructure.Predicate
          | RuleStructure.Ast(Symbol = N2.Typing.ExtentionRuleSymbol) =>
            <[
              when ($(AstPtr(structure).Var) == 0)
                $(AstPtr(structure).Var) = parser.Allocate($(structure.Size), $(structure.AstId : dyn));
            ]>

          | _ =>
            <[
              when ($(AstPtr(structure).Var) == 0)
              {
                $(AstPtr(structure).Var) = parser.Allocate($(structure.Size), $(structure.AstId : dyn));
                $(AstPtr(structure).Set(structure.HeaderNext, <[ parser.memoize[$(AstStart(structure))] ]>));
                parser.memoize[$(AstStart(structure))] = $(AstPtr(structure).Var);
              }
            ]>
        }
      }
      else
        <[ {} ]>
    }

    public RecoveryCode() : PExpr
    {
      <[
        when (parser.MaxFailPos < curTextPos)
          parser.MaxFailPos = curTextPos;
      ]>
    }

    private CheckOwnerMemoize(field : RuleStructureField) : PExpr
    {
      def jumpToRecovery(structure : RuleStructure) : PExpr
      {
        def code = SCG.List();
        def field = structure.NotMarkerFields.First();
        code.Add(<[
          if (parseState >= $(field.EndState))
            $CurTextPos += $(AstPtr(field.Owner).GetSize(field)); // skip
          else
            continueParse();
        ]>);
        foreach (field in structure.NotMarkerFields.Skip(1))
          code.Add(<[
            if (parseState >= $(field.EndState))
              $CurTextPos += $(AstPtr(field.Owner).GetSize(field)); // skip
            else
              $(GotoRecoveryLabel(field))
          ]>);
        code.Add(<[ assert2(false); assert(false) ]>);
        <[ { continueParse: { ..$code } } ]>.FlattenPExpr();
      }
      def checkMemoize(structure : RuleStructure, okCode : PExpr, failCode : PExpr) : PExpr
      {
        <[
          $(AstPtr(structure).Var) = parser.TryGetAst($CurTextPos, $(structure.AstId : dyn));
          when ($(AstPtr(structure).Var) > 0)
          {
            parseState = $(AstPtr(structure).Get(structure.HeaderState));
            if (parseState == N2.Internal.Parser.AstParsedState)
            {
              $CurTextPos += parser.AstSize($(AstPtr(structure).Var), $(structure.SizesStart), $(structure.SizesEnd));
              $okCode;
            }
            else if (parseState < 0)
            {
              parseState = ~parseState;
              $(jumpToRecovery(structure : RuleStructure));
            }
            else
            {
              $failCode
            }
          }
        ]>
      }
      if (field.AllocateAst && !field.IsPredicate)
      {
        if (field.Owner is RuleStructure.Ast as ruleStructure)
        {
          if (ruleStructure.Symbol is SimpleRuleSymbol)
            checkMemoize(ruleStructure, _endLabel.Goto(),
            <[
              $CurTextPos = -1;
              def maxFailPos = $(AstPtr(ruleStructure).GetSize(ruleStructure.NotMarkerFields.Last()));
              when (maxFailPos > parser.MaxFailPos)
                parser.MaxFailPos = maxFailPos;
              $(_endLabel.Goto());
            ]>)
          else
            <[
              $(AstPtr(ruleStructure).Var) = 0;
              when (resultRef > 0)
              {
                $(AstPtr(ruleStructure).Var) = resultRef;
                parseState = parser.ast[resultRef + 2];
                assert(parseState < 0 && parseState != N2.Internal.Parser.AstParsedState);
                parseState = ~parseState;
                $(jumpToRecovery(ruleStructure));
              }
            ]>;
        }
        else
          checkMemoize(field.Owner, GotoOkLabel(field.Owner), GotoFailLabel(field.Owner));
      }
      else
        <[ {} ]>
    }
  }
}
