using N2.Internal;
using N2.Typing;
using N2.Model;

using Nemerle;
using Nemerle.Collections;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Imperative;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using SCG = System.Collections.Generic;
using System.Linq;

namespace N2.Compiler
{
  internal sealed partial class TryParseMethodEmitter : MethodEmitter
  {
    public           Owner           : RuleParserEmitter { get; }
    public           RuleStructure   : RuleStructure.Ast;
    private          _tb             : TypeBuilder;
    private          _endLabel       : PExprLabel;
    public  override Environment     : EmitterEnvironment { get { Owner.Environment } }
    public  override ConstantEmitter : IConstantEmitter   { get { Owner } }

    public this(owner : RuleParserEmitter, tb : TypeBuilder, ruleStructure : RuleStructure.Ast)
    {
      Owner         = owner;
      _tb           = tb;
      RuleStructure = ruleStructure;
      _data         = RuleStructureDataContainer(ruleStructure, this, RuleStructureData, RuleStructureFieldData);
      _endLabel     = Environment.MakeLabel("EndParse");
    }

    public Emit() : void
    {
      def defineIntMethod(name : string, predicate : RuleStructureField -> int)
      {
        _tb.DefineConditional(<[decl:
          public override $(name : global)(state : int) : int
          {
            $(if (Environment.IsIdeMode)
              <[ IgnoreParams(); 0 ]>
            else
              CompileIntMethod(RuleStructure, predicate))
          }
        ]>);
      }
      def defineBoolMethod(name : string, predicate : RuleStructureField -> bool)
      {
        _tb.DefineConditional(<[decl:
          public override $(name : global)(state : int) : bool
          {
            $(if (Environment.IsIdeMode)
              <[ IgnoreParams(); false ]>
            else
              CompileBoolMethod(RuleStructure, predicate))
          }
        ]>);
      }
      _tb.DefineConditional(<[decl:
        public override TryParse(frame : RecoveryStackFrame, startState : int, mutable curTextPos : int, continueList : bool, parsedStates : SCG.List[ParsedStateInfo], parser : N2.Internal.Parser) : int
        {
          def text = parser.Text;
          mutable startLevel;
          parsedStates.Clear();
          $(if (Environment.IsIdeMode)
            <[ ignore(recoveryStack, startState, curTextPos, parser, text, startLevel); -1 ]>
          else
            CompileAst(RuleStructure))
        }
      ]>);
      //TODO: Move this methods outside TryParseMethodEmitter
      defineBoolMethod("IsStateCanParseEmptyString", _.CanParseEmptyString);
      defineBoolMethod("IsVoidState",                field => field.SrcRule.Type is RuleType.Void);
      defineBoolMethod("IsStartState",               _.IsStart);
      defineBoolMethod("IsLoopSeparatorStart",       _.IsLoopSeparatorStart);
      defineBoolMethod("IsLoopSeparator",            _.IsLoopSeparator);
      defineBoolMethod("IsLoopBody",                 _.IsLoopBody);
      defineIntMethod("GetStartState",               field => field.Owner.NotMarkerFields[0].State);
      
      _tb.DefineConditional(<[decl: public override GetLoopBodyForSeparator(separatorId : int, bodyId : out int, firstState : out int) : bool { $(Compile_GetLoopBodyForSeparator(RuleStructure)) } ]>);
      _tb.DefineConditional(<[decl: public override GetRuleParserForState(state : int) : IRecoveryRuleParser { IgnoreParams(); assert3(false) } ]>);
      _tb.DefineConditional(<[decl: public override CodeForState(state : int) : string { $(Compile_CodeForState(RuleStructure)) } ]>);
      _tb.DefineConditional(<[decl: public override IsTokenRule    : bool   { get { $(RuleStructure.Symbol.Options.IsExplicitSpaces) } } ]>);
      _tb.DefineConditional(<[decl: public override Code           : string { get { $(RuleStructure.SrcRule.ToString()) } } ]>);
      _tb.DefineConditional(<[decl: public override CodeWithStates : string { get { $(RuleStructure.ToString()) } } ]>);
      _tb.DefineConditional(<[decl: public override RuleName       : string { get { $(RuleStructure.Symbol.Name) } } ]>);

      _tb.DefineConditional(<[decl: private static EmptyArray : array[RecoveryStackFrame] = array(0) ]>);
    }

    public CurTextPos : PExpr { get { <[ curTextPos ]> } }

    Compile_GetLoopBodyForSeparator(ruleStructure : RuleStructure.Ast) : PExpr
    {
      def loops = SCG.List();

      foreach (field is RuleStructureField.ListWithSeparator in ruleStructure.AllNonMarkerFields)
      {
        loops.Add(<[  
          when (separatorId == $(field.Separator.AstId : global))
          {
            bodyId = $(field.Rule.AstId : global);
            firstState = $(field.Rule.NotMarkerFields[0].State : int);
            return true;
          } ]>);
      }

      <[ IgnoreParams(); ..$loops; false ]>
    }

    Compile_CodeForState(ruleStructure : RuleStructure.Ast) : PExpr
    {
      def nextField(field : RuleStructureField) : RuleStructureField
      {
        if (field == null)
          null
        else if (field.NextSibling != null)
          field.NextSibling
        else
          nextField(field.Owner.Owner)
      }

      def code = SCG.List();

      for (mutable i = 0; i < ruleStructure.StateCount; i++)
      {
        mutable str = ruleStructure.CodeForState(i);
        def field = ruleStructure.AllNonMarkerFields[i];
        when (field.IsLoopSeparatorStart)
        {
          def afterLoopField = nextField(field);

          when (afterLoopField != null)
            str += ", " + ruleStructure.CodeForState(afterLoopField.State);
        }
        code.Add(<[ case: | $i => $str ]>);
      }

      code.Add(<[ case: | _ => assert3(false) ]>);

      <[
        match (state)
        {
          ..$code
        }
      ]>
    }

    EndOfFieldLevel(field : RuleStructureField) : PExpr
    {
      <[ startLevel > $(field.Level) ]>
    }

    AddParsedStateInfo(field : RuleStructureField, size : PExpr) : PExpr
    {
      <[
        when (startLevel == $(field.Level))
          parsedStates.Add(N2.Internal.ParsedStateInfo($(field.State), $size));
      ]>
    }

    public RecoveryCode() : PExpr
    {
      <[
        when (parser.MaxFailPos < curTextPos)
          parser.MaxFailPos = curTextPos;
      ]>
    }
  }
}
