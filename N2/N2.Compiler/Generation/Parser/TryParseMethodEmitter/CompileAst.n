using N2.Typing;
using Nemerle;
using Nemerle.Collections;
using Nemerle.Compiler.Parsetree;
using Nemerle.Imperative;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using SCG = System.Collections.Generic;
using System.Linq;

using N2.Model;

namespace N2.Compiler
{
  internal sealed partial class TryParseMethodEmitter : MethodEmitter
  {
    public CompileAst(ruleStructure : RuleStructure.Ast) : PExpr
    {
      def makeContinueStateSelector() : PExpr
      {
        def continueCases = SCG.List();
        foreach (field in ruleStructure.AllNonMarkerFields)
        {
          def getContinueStateCode(field : RuleStructureField) : PExpr
          {
            match (field)
            {
              //| RuleStructureField(Owner=RuleStructure(Owner=RuleStructureField.List as lst)) when lst.IsSkipAnyPattern // если это Any из SkipAnyPattern
              | List as lst when lst.IsSkipAnyPattern => <[ assert3(false); ]>
              | List =>
                <[
                  $(ListStartPos(field)) = frame.ListStartPos;
                  $(ListEndPos(field))   = $CurTextPos;
                  $(GotoParseLabel(field));
                ]>

              | ListWithSeparator as field =>
                <[
                  $(ListStartPos(field)) = frame.ListStartPos;
                  match (frame.Info)
                  {
                    | LoopBody      =>
                      $(ListEndPos(field)) = $CurTextPos;
                      $(GotoParseLabel(field.Separator.NotMarkerFields[0]))

                    | LoopSeparator =>
                      $(ListEndPos(field)) = $(if (field.HangingSeparator) CurTextPos else <[ frame.ListEndPos ]>);
                      $(GotoParseLabel(field.Rule.NotMarkerFields[0]))

                    | x             => assert(false, $"Invalid frame info value '$x'")
                  }
                ]>

              | _ =>
                match(field.NextSibling)
                {
                  | null  => _endLabel.Goto() // продолжения нет
                  | field => GotoParseLabel(field)
                }
            }
          }
          def sourceStateComment = field.ToString();
          if (field.IsPredicate)
            continueCases.Add(<[ case: | $(field.State) => assert(false, $($"Cannot continue parse from predicate state: '$sourceStateComment'.")) ]>);
          else
          {
            def code = getContinueStateCode(field);
            continueCases.Add(<[ case: | $(field.State) => _ = $sourceStateComment; startLevel = $(field.Level); $code; ]>);
          }
        }
        continueCases.Add(<[ case: | x => assert(false, $"Unknown continue parse state '$x'.") ]>);
        <[ match (frame.FailState) { ..$continueCases } ]>
      }

      def makeStartStateSelector() : PExpr
      {
        def startCases = SCG.List();
        startCases.Add(<[ case: | -2 => $(makeContinueStateSelector()) ]>);
        foreach (field in ruleStructure.AllNonMarkerFields)
        {
          def comment = field.ToString();
          if (field.IsPredicate)
            startCases.Add(<[ case: | $(field.State) => assert(false, $($"Cannot parse from predicate state: '$comment'.")) ]>);
          else if (field is RuleStructureField(Owner=RuleStructure(Owner=RuleStructureField.List as lst)) when lst.IsSkipAnyPattern)            
            startCases.Add(<[ case: | $(field.State) => assert(false, $($"Cannot parse from predicate state: '$comment'.")) ]>);
          else
            startCases.Add(<[ case: | $(field.State) => _ = $comment; startLevel = $(field.Level); $(GotoParseLabel(field)) ]>);
        }
        startCases.Add(<[ case: | x => assert(false, $"Unknown parse state '$x'.") ]>);
        <[ match (startState) { ..$startCases } ]>
      }

      def code = SCG.List();
      code.Add(<[ ignore(curTextPos, parser); ]>);
      code.Add(<[ _ = $(ruleStructure.ToString()) ]>);
      code.Add(makeStartStateSelector());

      //parse ok
      code.Add(OkLabel(ruleStructure));
      code.Add(_endLabel.Goto());

      //parse fail
      code.Add(FailLabel(ruleStructure));
      code.Add(<[ $CurTextPos = -1; ]>);
      code.Add(_endLabel.Goto());

      CompileFields(code, ruleStructure);

      code.Add(_endLabel.Label());
      code.Add(<[ $CurTextPos; ]>);

      def codeWithVariables = SCG.List();
      codeWithVariables.Add(<[
        def     astPtr      : int = frame.AstHandle.AstPtr;    _ = astPtr;
        def     targetState : int = frame.FailState; _ = targetState;
        mutable tmpSize     : int; _ = tmpSize;
        mutable newPos      : int; _ = newPos;

      ]>);
      codeWithVariables.AddRange(LocalVariables.Map(name => <[ mutable $(name : global) ]>));
      codeWithVariables.AddRange(code);

      codeWithVariables.FlattenPExpr();
    }
  }
}
