using N2.Model;
using N2.Typing;

using Nemerle;
using Nemerle.Collections;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using SCG = System.Collections.Generic;
using System.Linq;

namespace N2.Compiler
{
  public abstract class MethodEmitter : IVariableEmitter
  {
    public abstract Environment     : EmitterEnvironment { get; };
    public abstract ConstantEmitter : IConstantEmitter   { get; };
    protected LocalVariables : SCG.HashSet[string] = SCG.HashSet();

    public CreateVariable(name : string) : string
    {
      _ = LocalVariables.Add(name);
      name
    }

    public CompileFields(code : SCG.List[PExpr], structure : RuleStructure) : void
    {
      foreach (field in structure.Fields)
      {
        | Empty             as field => CompileEmpty            (code, field);
        | ExtensibleCall    as field => CompileExtensibleCall   (code, field);
        | SimpleCall        as field => CompileSimpleCall       (code, field);
        | TokenCall         as field => CompileTokenCall        (code, field);
        | List              as field => CompileList             (code, field); CompileFields(code, field.Rule);
        | ListWithSeparator as field => CompileListWithSeparator(code, field); CompileFields(code, field.Rule); CompileFields(code, field.Separator);
        | Option            as field => CompileOption           (code, field); CompileFields(code, field.Rule);
        | TokenString       as field => CompileTokenString      (code, field);
        | Marker                     => ()
      }
    }

    public abstract CompileEmpty            (code : SCG.List[PExpr], field : RuleStructureField.Empty)             : void;
    public abstract CompileTokenCall        (code : SCG.List[PExpr], field : RuleStructureField.TokenCall)         : void;
    public abstract CompileExtensibleCall   (code : SCG.List[PExpr], field : RuleStructureField.ExtensibleCall)    : void;
    public abstract CompileSimpleCall       (code : SCG.List[PExpr], field : RuleStructureField.SimpleCall)        : void;
    public abstract CompileList             (code : SCG.List[PExpr], field : RuleStructureField.List)              : void;
    public abstract CompileListWithSeparator(code : SCG.List[PExpr], field : RuleStructureField.ListWithSeparator) : void;
    public abstract CompileOption           (code : SCG.List[PExpr], field : RuleStructureField.Option)            : void;
    public abstract CompileTokenString      (code : SCG.List[PExpr], field : RuleStructureField.TokenString)       : void;

    protected MakeTokenRuleCall(ruleSymbol : RegularRuleSymbol, pos : PExpr, text : PExpr) : PExpr
    {
      def grammarType = PExprUtils.FromQualifiedIdentifier(ruleSymbol.DeclaringModule.Node.FullNameParts);
      <[ $grammarType.$(AssemblyConstants.GrammarImplName : usesite).$(ruleSymbol.DecorateRuleName() : dyn)($pos, $text) ]>
    }
  }
}
