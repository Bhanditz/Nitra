using N2.Typing;
using Nemerle;
using Nemerle.Collections;
using Nemerle.Compiler.Parsetree;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Imperative;

using System;
using SCG = System.Collections.Generic;
using System.Linq;

using N2.Model;

namespace N2.Compiler
{
  internal abstract partial class RuleParserEmitter
  {
    public CompileRecoveryAst(ruleStructure : RuleStructure.Ast) : PExpr
    {
      def code = SCG.List();
      def endLabel = Environment.MakeLabel("End");
      def startLabel = Environment.MakeLabel("Start");

      code.Add(<[ _ = $(ruleStructure.SrcRule.ToString()) ]>);
      code.Add(<[ mutable state = startState - 1; ]>);

      code.Add(startLabel.Label());
      code.Add(<[ mutable curTextPos = startTextPos; ]>);
      code.Add(<[ state += 1; ]>);
      def cases = SCG.List();
      foreach (field in ruleStructure.AllFields)
        cases.Add(<[ case: | $(field.State) => $(field.ParserExtention().ParseLabel.Goto()) ]>);
      cases.Add(<[ case: | _ => $(endLabel.Goto()) ]>);
      code.Add(<[ match (state) { ..$(cases.NToList()) } ]>);

      code.Add(endLabel.Label());

      code.FlattenPExpr();
    }
  }
}
