using Nemerle;
using Nemerle.Collections;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Text;
using Nemerle.Utility;

using N2.Model;
using N2.Typing;

using System;
using System.Collections.Generic;
using System.Linq;

namespace N2.Compiler
{
  internal abstract partial class RuleParserEmitter
  {
    public Owner : SyntaxModuleEmitter { get; }
    public RuleSymbol : RuleDefSymbol { get; }
    public Environment : EmitterEnvironment { get { Owner.Environment } }
    public this(owner : SyntaxModuleEmitter, ruleSymbol : RuleDefSymbol)
    {
      Owner          = owner;
      RuleSymbol     = ruleSymbol;
    }

    private mutable _callCounter : int = 0;
    private _simpleCalls : List[SimpleRuleSymbol * string] = List();

    [Memoize]
    public MakeParserName(ruleSymbol : SimpleRuleSymbol) : string
    {
      Owner.CallRule(ruleSymbol);
      def name = $"_parser_$(_callCounter)_$(ruleSymbol.Name)";
      _simpleCalls.Add((ruleSymbol, name));
      ++_callCounter;
      name
    }

    private _extensibleCalls : List[ExtensibleRuleSymbol * int * string] = List();

    [Memoize]
    public MakeParserName(ruleSymbol : ExtensibleRuleSymbol, bindingPower : int) : string
    {
      Owner.CallRule(ruleSymbol);
      def name = $"_parser_$(_callCounter)_$(ruleSymbol.Name)";
      _extensibleCalls.Add((ruleSymbol, bindingPower, name));
      ++_callCounter;
      name
    }

    public abstract DefineParser() : void;

    public abstract DefineParserMethods() : void;

    public abstract Emit() : void;

    protected DefineImplementation(member : ClassMember) : void
    {
      if (Owner.Environment.IsDebug)
        Owner.GrammarImplTB.DefineConditional(member)
      else
        Owner.GrammarImplTB.Define(member)
    }

    protected DefineInit(tb : TypeBuilder, ruleStructure : RuleStructure.Ast) : void
    {
      def getDescriptor(ruleSymbol : RuleDefSymbol)
      {
        <[ $(ruleSymbol.GetDescriptorClassRef()).StaticDescriptor ]>
      }
      def inits = List();

      def reflectionCases = List();
      def reflectionFields = List();
      def structReflect(ruleStructure : RuleStructure) : PExpr
      {
        def type = match (ruleStructure)
        {
          | RuleStructure.Ast                        => <[ N2.Runtime.Reflection.RuleStructure.Ast                        ]>
          | RuleStructure.List                       => <[ N2.Runtime.Reflection.RuleStructure.List                       ]>
          | RuleStructure.Option                     => <[ N2.Runtime.Reflection.RuleStructure.Option                     ]>
          | RuleStructure.Predicate                  => <[ N2.Runtime.Reflection.RuleStructure.Predicate                  ]>
          | RuleStructure.ListWithSeparatorRule      => <[ N2.Runtime.Reflection.RuleStructure.ListWithSeparatorRule      ]>
          | RuleStructure.ListWithSeparatorSeparator => <[ N2.Runtime.Reflection.RuleStructure.ListWithSeparatorSeparator ]>
        }
        def subrules = List();
        foreach (field in ruleStructure.Fields)
        {
          def (subruleType, args) = match (field)
          {
            | RuleStructureField.List               as x => (<[ N2.Runtime.Reflection.RuleInfo.List              ]>, [structReflect(x.Rule)])
            | RuleStructureField.ListWithSeparator  as x => (<[ N2.Runtime.Reflection.RuleInfo.ListWithSeparator ]>, [structReflect(x.Rule), structReflect(x.Separator)])
            | RuleStructureField.Option             as x => (<[ N2.Runtime.Reflection.RuleInfo.Option            ]>, [structReflect(x.Rule)])
            | RuleStructureField.Predicate          as x => (<[ N2.Runtime.Reflection.RuleInfo.Predicate         ]>, [structReflect(x.Rule)])
            | RuleStructureField.SimpleCall         as x => (<[ N2.Runtime.Reflection.RuleInfo.SimpleCall        ]>, [<[ ($(MakeParserName(x.Symbol) : dyn) :> N2.Internal.SimpleRuleParser).RuleId ]>])
            | RuleStructureField.ExtensibleCall          => (<[ N2.Runtime.Reflection.RuleInfo.ExtensibleCall    ]>, [])
            | RuleStructureField.TokenCall               => (<[ N2.Runtime.Reflection.RuleInfo.TokenCall         ]>, [])
            | RuleStructureField.TokenString             => (<[ N2.Runtime.Reflection.RuleInfo.TokenString       ]>, [])
          }
          def args = [<[ $(field.Offset) ]>, <[ $(field.SrcRule.ToString()) ]>, <[ $(field.State) ]>] + args;
          subrules.Add(<[ $subruleType(..$args) ]>);
        }
        def field = $"reflectionField$(reflectionFields.Count)";
        reflectionFields.Add((field, type));
        reflectionCases.Add(<[case: | _ when ruleId == $(ruleStructure.AstId : dyn) => $(field : dyn) ]>);
        <[
          $(field : dyn) = $type($(ruleStructure.AstId : dyn), $(ruleStructure.SrcRule.ToString()), System.Collections.ObjectModel.ReadOnlyCollection(array[..$(subrules.NToList())]));
          $(field : dyn);
        ]>
      }
      def reflection = structReflect(ruleStructure);
      reflectionCases.Add(<[case: | _ => assert(false) ]>);
      foreach (structure in ruleStructure.InternalRuleStructures)
      {
        tb.DefineConditional(<[decl: public mutable $(structure.AstId : dyn) : int; ]>);
        inits.Add(<[ $(structure.AstId : dyn) = Grammar.NewRuleId(this); ]>);
      }
      foreach ((field, type) in reflectionFields)
        tb.DefineConditional(<[decl: private mutable $(field : dyn) : $type ]>);

      tb.DefineConditional(<[decl:
        public override Reflection(ruleId : int) : N2.Runtime.Reflection.RuleStructure
        {
          when ($(reflectionFields[reflectionFields.Count - 1][0] : dyn) == null)
            _ = $(reflection);

          match (ruleId)
          {
            ..$(reflectionCases.NToList())
          }
        }]>);

      foreach ((ruleSymbol, name) in _simpleCalls)
      {
        tb.DefineConditional(<[decl: private mutable $(name : dyn) : N2.Internal.StartRuleParser; ]>);
        inits.Add(<[ $(name : dyn) = Grammar.GetSimpleRuleParser($(getDescriptor(ruleSymbol))); ]>);
      }
      foreach ((ruleSymbol, bp, name) in _extensibleCalls)
      {
        tb.DefineConditional(<[decl: private mutable $(name : dyn) : N2.Internal.StartRuleParser; ]>);
        inits.Add(<[ $(name : dyn) = Grammar.GetExtensibleRuleParser($(getDescriptor(ruleSymbol)), $bp); ]>);
      }
      tb.DefineConditional(<[decl:
        public override Init() : void
        {
          ..$(inits.NToList())
        }
      ]>);
    }

    protected DefineParse(tb : TypeBuilder, ruleStructure : RuleStructure.Ast) : void
    {
      ParseMethodEmitter(this, tb, ruleStructure).Emit();
      TryParseMethodEmitter(this, tb, ruleStructure).Emit();
      if (ruleStructure.Symbol is ExtentionRuleSymbol)
      {
        tb.DefineConditional(<[decl:
          public override FindRecoveryPosition(mutable curTextPos : int, text : string, astPtr : int, parser : ref N2.Internal.Parser) : int
          {
            $(if (Owner.Environment.IsIdeMode)
              <[ _ = curTextPos; _ = text; _ = astPtr; _ = parser; -1 ]>
            else
              CompileFindRecoveryPositionAst(ruleStructure))
          }
        ]>);
      }
      else
      {
        tb.DefineConditional(<[decl:
          public override FindRecoveryPosition(mutable curTextPos : int, text : string, parser : ref N2.Internal.Parser) : int
          {
            $(if (Owner.Environment.IsIdeMode)
              <[ _ = curTextPos; _ = text; _ = parser; -1 ]>
            else
              CompileFindRecoveryPositionAst(ruleStructure))
          }
        ]>);
      }
    }

    CompileFindRecoveryPositionAst(_ruleStructure : RuleStructure.Ast) : PExpr
    {
      <[ assert(false) ]>
    }
  }
}
