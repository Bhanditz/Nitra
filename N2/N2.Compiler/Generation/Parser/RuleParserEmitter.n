using N2.Compiler.RuleField;
using Nemerle;
using Nemerle.Collections;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Text;
using Nemerle.Utility;

using N2.Model;
using N2.Typing;

using System;
using System.Collections.Generic;
using System.Linq;

namespace N2.Compiler
{
  internal abstract partial class RuleParserEmitter : IVariableEmitter
  {
    public Owner : SyntaxModuleEmitter { get; }
    public RuleSymbol : RuleDefSymbol { get; }

    public this(owner : SyntaxModuleEmitter, ruleSymbol : RuleDefSymbol)
    {
      Owner          = owner;
      RuleSymbol     = ruleSymbol;
      EndLabel       = owner.Environment.MakeLabel("EndParse");
    }

    public abstract DefineParser(astSize : out int, rootAstStruct : out option[RootAstStruct], externalCalls : List[RuleSymbol]) : void;

    public abstract DefineParserMethods() : void;

    public abstract Emit() : void;

    protected DefineImplementation(member : ClassMember) : void
    {
      if (Owner.Environment.IsDebug)
        Owner.GrammarImplTB.DefineConditional(member)
      else
        Owner.GrammarImplTB.Define(member)
    }

    public InternalRuleIds : Hashtable[InternalAstStruct, string] = Hashtable();
    public MakeRuleId(ruleField : InternalAstStruct) : string
    {
      def name = $"RuleId$(InternalRuleIds.Count)";
      InternalRuleIds[ruleField] = name;
      name;
    }

    [Memoize]
    public MakeTokenCall(ruleSymbol : RegularRuleSymbol) : PExpr
    {
      def grammarType = PExprUtils.FromQualifiedIdentifier(ruleSymbol.DeclaringModule.Node.FullNameParts);
      <[ $grammarType.GrammarImpl.$(ruleSymbol.DecorateRuleName() : dyn) ]>
    }

    private _simpleCalls : List[SimpleRuleSymbol * string] = List();

    [Memoize]
    public MakeParserName(ruleSymbol : SimpleRuleSymbol) : string
    {
      def name = $"_parser_s$(_simpleCalls.Count)_$(ruleSymbol.Name)";
      _simpleCalls.Add((ruleSymbol, name));
      name
    }

    private _extensibleCalls : List[ExtensibleRuleSymbol * int * string] = List();

    [Memoize]
    public MakeParserName(ruleSymbol : ExtensibleRuleSymbol, bindingPower : int) : string
    {
      def name = $"_parser_e$(_extensibleCalls.Count)_$(ruleSymbol.Name)";
      _extensibleCalls.Add((ruleSymbol, bindingPower, name));
      name
    }

    public MakeCall(ruleSymbol : SimpleRuleSymbol) : PExpr
    {
      <[ $(MakeParserName(ruleSymbol) : dyn).Parse ]>
    }

    public MakeCall(ruleSymbol : ExtensibleRuleSymbol, bindingPower : int) : PExpr
    {
      <[ $(MakeParserName(ruleSymbol, bindingPower) : dyn).Parse ]>
    }

    Environment : EmitterEnvironment implements IVariableEmitter.Environment { get { Owner.Environment } }

    private _names : HashSet[string] = HashSet();

    CreateVariable(name : string) : string implements IVariableEmitter.CreateVariable
    {
      _ = _names.Add(name);
      name
    }

    public EndLabel : PExprLabel { get; private set; }

    private mutable _fields : array[RuleField];

    protected MakeRuleFieldsNew(ruleSymbol : RuleDefSymbol, rule : Rule) : void
    {
      def conv(rule : Rule) : array[RuleStructureField]
      {
        match (rule)
        {
          | And                   as rule => array[RuleStructureField.Predicate        (rule, RuleStructure.Predicate(rule.Rule, conv(rule.Rule)), true)]
          | Not                   as rule => array[RuleStructureField.Predicate        (rule, RuleStructure.Predicate(rule.Rule, conv(rule.Rule)), false)]
          | Repeat(0, Some(1), _) as rule => array[RuleStructureField.Option           (rule, RuleStructure.Option(rule.Rule, conv(rule.Rule)))]
          | Repeat                as rule => array[RuleStructureField.List             (rule, RuleStructure.List(rule.Rule, conv(rule.Rule)), rule.MinCount, rule.MaxCount)]
          | RepeatWithSeparator   as rule => array[RuleStructureField.ListWithSeparator(rule, RuleStructure.ListWithSeparatorRule(rule.Rule, conv(rule.Rule)), RuleStructure.ListWithSeparatorSeparator(rule.Separator, conv(rule.Separator)), rule.MinCount, rule.MaxCount, rule.HangingSeparator)]
          | String                as rule => array[RuleStructureField.TokenString      (rule, rule.Str)]
          | Sequence              as rule => rule.Rules.Map(conv(_)).Flatten().NToArray();
          | Call(RuleRef.Some(ruleSymbol) as ruleRef, bindingPower) =>
            match (ruleSymbol)
            {
              | ExtensibleRuleSymbol                   as rs => array[RuleStructureField.ExtensibleCall(rule, rs, bindingPower)]
              | SimpleRuleSymbol                       as rs => array[RuleStructureField.SimpleCall(rule, rs)]
              | RegularRuleSymbol                      as rs => array[RuleStructureField.TokenCall(rule, rs)]
              | MarkerSymbol                                 => array[]
              | _                                            => Message.FatalError(ruleRef.NLocation(), $"N2ICE Typing bug: invalid symbol bound. $(ruleSymbol.GetType().Name)");
            }
          | Call(RuleRef.None as ruleRef, _) => Message.FatalError(ruleRef.NLocation(), "N2ICE Typing bug: not bound symbol.");
        }
      }
      def rule = match (ruleSymbol)
      {
        | ExtentionRuleSymbol(ExtentionType = Postfix(_, rule)) => rule
        | _ => rule
      }
      assert2(false);
      def ast = RuleStructure.Ast(rule, conv(rule), ruleSymbol);
      ast.Init(this);
    }

    protected MakeRuleFields(ruleSymbol : RuleDefSymbol, rule : Rule, astSize : out int, rootAstStruct : out option[RootAstStruct], externalCalls : List[RuleSymbol]) : void
    {
      assert(_fields == null);
      MakeRuleFieldsNew(ruleSymbol, rule);
      def conv(rule : Rule) : array[RuleField]
      {
        def loc = rule.NLocation();
        match (rule)
        {
          | And                   as rule => array[RuleField.Predicate  (loc, rule, conv(rule.Rule), true)]
          | Not                   as rule => array[RuleField.Predicate  (loc, rule, conv(rule.Rule), false)]
          | Repeat(0, Some(1), _) as rule => array[RuleField.Option     (loc, rule, conv(rule.Rule))]
          | Repeat                as rule => array[RuleField.List       (loc, rule, conv(rule.Rule),                       rule.MinCount, rule.MaxCount)]
          | RepeatWithSeparator   as rule => array[RuleField.List2      (loc, rule, conv(rule.Rule), conv(rule.Separator), rule.MinCount, rule.MaxCount, rule.HangingSeparator)]
          | String                as rule => array[RuleField.TokenString(loc, rule, rule.Str)]
          | Sequence              as rule => rule.Rules.Map(conv(_)).Flatten().NToArray();
          | Call(RuleRef.Some(MarkerSymbol), _) => array[]
          | Call(RuleRef.Some(ruleSymbol), bindingPower) =>
            match (ruleSymbol)
            {
              | ExtensibleRuleSymbol                   as rs => array[RuleField.ExtensibleRuleCall(loc, rs, bindingPower)]
              | SimpleRuleSymbol(Type = RuleType.Void) as rs => array[RuleField.Void(loc, rs)]
              | SimpleRuleSymbol                       as rs => array[RuleField.SimpleRuleCall(loc, rs)]
              | RegularRuleSymbol                      as rs => array[RuleField.TokenRuleCall(loc, rs)]
              | MarkerSymbol                                 => array[]
              | _                                            => assert(false)
            }

          | Call(RuleRef.None, _) => assert2(false, "Typing bug: not bound symbol."); assert(false)
        }
      }
      if (Owner.Environment.IsIdeMode)
      {
        _fields = array[];
        astSize = 0;
        rootAstStruct = None();
      }
      else
      {
        def loc = rule.NLocation();
        def rule = match (ruleSymbol)
        {
          | ExtentionRuleSymbol(ExtentionType = Postfix(_, rule)) => rule
          | _ => rule
        }
        def ast = RuleField.Ast(loc, Owner.Environment.IsDebug, conv(rule), ruleSymbol);
        def fields = List();
        ast.Init(this, null, 0, fields);
        ast.CalculateAstInfo();
        foreach (field in fields)
          field.Compile();
        _fields = fields.NToArray();

        match (ast.astStruct)
        {
          | null =>
            astSize       = 0;
            rootAstStruct = None();

          | astStruct =>
            astSize       = astStruct.AstSize;
            rootAstStruct = Some(astStruct);
        }

        def grammarNode = ruleSymbol.Node.Parent;
        foreach ((callSymbol, _) in _simpleCalls)
          when (callSymbol.Node.Parent : object != grammarNode)
            externalCalls.Add(callSymbol);
        foreach ((callSymbol, _, _) in _extensibleCalls)
          when (callSymbol.Node.Parent : object != grammarNode)
            externalCalls.Add(callSymbol);
      }
    }

    protected DefineInit(tb : TypeBuilder) : void
    {
      def getDescriptor(ruleSymbol : RuleDefSymbol)
      {
        <[ $(ruleSymbol.GetDescriptorClassRef()).StaticDescriptor ]>
      }
      def inits = List();

      def reflectionCases = List();
      def reflectionFields = List();
      def structReflect(ruleField : RuleField) : list[PExpr]
      {
        def makeCode(type : PExpr, desc : string, astStruct : AstStruct) : PExpr
        {
          def subrules = List();
          foreach (sizeField in astStruct.SizeFields)
          {
            def (subruleType, subruleDesc, args) = match (sizeField.Field)
            {
              | RuleField.List               as x => (<[ N2.Runtime.Reflection.RuleInfo.List              ]>, x.Rule.ToString(), structReflect(sizeField.Field))
              | RuleField.List2              as x => (<[ N2.Runtime.Reflection.RuleInfo.ListWithSeparator ]>, x.Rule.ToString(), structReflect(sizeField.Field))
              | RuleField.Option             as x => (<[ N2.Runtime.Reflection.RuleInfo.Option            ]>, x.Rule.ToString(), structReflect(sizeField.Field))
              | RuleField.Predicate          as x => (<[ N2.Runtime.Reflection.RuleInfo.Predicate         ]>, x.Rule.ToString(), structReflect(sizeField.Field))
              | RuleField.ExtensibleRuleCall as x => (<[ N2.Runtime.Reflection.RuleInfo.ExtensibleCall    ]>, x.RuleSymbol.Name, [])
              | RuleField.TokenRuleCall      as x => (<[ N2.Runtime.Reflection.RuleInfo.TokenCall         ]>, x.RuleSymbol.Name, [])
              | RuleField.SimpleRuleCall     as x => (<[ N2.Runtime.Reflection.RuleInfo.SimpleCall        ]>, x.RuleSymbol.Name, [<[ ($(MakeParserName(x.RuleSymbol) : dyn) :> N2.Internal.SimpleRuleParser).RuleId ]>])
              | RuleField.Void               as x => (<[ N2.Runtime.Reflection.RuleInfo.SimpleCall        ]>, x.RuleSymbol.Name, [<[ ($(MakeParserName(x.RuleSymbol) : dyn) :> N2.Internal.SimpleRuleParser).RuleId ]>])
              | RuleField.TokenString        as x => (<[ N2.Runtime.Reflection.RuleInfo.TokenString       ]>, x.Rule.ToString(), [])
              | RuleField.Ast                     => assert(false)
              | _                                 => assert(false);
            }
            def args = [<[ $(sizeField.Offset) ]>, <[ $subruleDesc ]>, <[ $(sizeField.Field.State) ]>] + args;
            subrules.Add(<[ $subruleType(..$args) ]>);
          }
          def field = $"reflectionField$(reflectionFields.Count)";
          reflectionFields.Add((field, type));
          reflectionCases.Add(<[case: | _ when ruleId == $(astStruct.AstId : dyn) => $(field : dyn) ]>);
          <[
            $(field : dyn) = $type($(astStruct.AstId : dyn), $desc, System.Collections.ObjectModel.ReadOnlyCollection(array[..$(subrules.NToList())]));
            $(field : dyn);
          ]>
        }
        match (ruleField)
        {
          | RuleField.Ast       as x => [makeCode(<[ N2.Runtime.Reflection.RuleStructure.Ast                        ]>, x.RuleSymbol.Name, x.astStruct)]
          | RuleField.List      as x => [makeCode(<[ N2.Runtime.Reflection.RuleStructure.List                       ]>, $"Item: $(x.Rule)", x.astStruct)]
          | RuleField.Option    as x => [makeCode(<[ N2.Runtime.Reflection.RuleStructure.Option                     ]>, x.Rule.ToString(), x.astStruct)]
          | RuleField.Predicate as x => [makeCode(<[ N2.Runtime.Reflection.RuleStructure.Predicate                  ]>, x.Rule.ToString(), x.astStruct)]
          | RuleField.List2     as x => [makeCode(<[ N2.Runtime.Reflection.RuleStructure.ListWithSeparatorRule      ]>, $"Rule.Item: $(x.Rule.Rule)", x.astRuleStruct),
                                         makeCode(<[ N2.Runtime.Reflection.RuleStructure.ListWithSeparatorSeparator ]>, $"Separator.Item: $(x.Rule.Separator)", x.astSeparatorStruct)]
          | _                        => assert(false);
        }
      }
      def reflection = structReflect(_fields[0]).Head;
      reflectionCases.Add(<[case: | _ => assert(false) ]>);
      foreach ((_astStruct, id) in InternalRuleIds.KeyValuePairs)
      {
        tb.DefineConditional(<[decl: public mutable $(id : dyn) : int; ]>);
        inits.Add(<[ $(id : dyn) = Grammar.NewRuleId(this); ]>);
      }
      foreach ((field, type) in reflectionFields)
        tb.DefineConditional(<[decl: private mutable $(field : dyn) : $type ]>);

      tb.DefineConditional(<[decl:
        public override Reflection(ruleId : int) : N2.Runtime.Reflection.RuleStructure
        {
          when ($(reflectionFields[reflectionFields.Count - 1][0] : dyn) == null)
            _ = $(reflection);

          match (ruleId)
          {
            ..$(reflectionCases.NToList())
          }
        }]>);


      foreach ((ruleSymbol, name) in _simpleCalls)
      {
        tb.DefineConditional(<[decl: private mutable $(name : dyn) : N2.Internal.RuleParser; ]>);
        inits.Add(<[ $(name : dyn) = Grammar.GetSimpleRuleParser($(getDescriptor(ruleSymbol))); ]>);
      }
      foreach ((ruleSymbol, bp, name) in _extensibleCalls)
      {
        tb.DefineConditional(<[decl: private mutable $(name : dyn) : N2.Internal.RuleParser; ]>);
        inits.Add(<[ $(name : dyn) = Grammar.GetExtensibleRuleParser($(getDescriptor(ruleSymbol)), $bp); ]>);
      }
      tb.DefineConditional(<[decl:
        public override Init() : void
        {
          ..$(inits.NToList())
        }
      ]>);
    }

    protected DefineParse(tb : TypeBuilder, ruleSymbol : RuleDefSymbol, rule : Rule) : void
    {
      assert(_fields != null);
      def code = List();
      if (Owner.Environment.IsIdeMode)
        code.Add(<[ _ = curEndPos; _ = text; _ = resultRef; _ = parser; -1 ]>);
      else
      {
        code.Add(<[ _ = $(rule.ToString()) ]>);
        code.AddRange(_fields.Map(field => <[ _ = $(field.Print()) ]>));
        code.Add(<[
          mutable tmpResult  : int; _ = tmpResult;
          mutable tmpSize    : int; _ = tmpSize;
          mutable parseState : int; _ = parseState;
          mutable newPos     : int; _ = newPos;
        ]>);
        code.AddRange(_names.Filter(kv => kv.Key != "resultRef").Map(kv => <[ mutable $(kv.Key : dyn) ]>));
        code.AddRange(_fields.Map(field => field.ParseCode));
        if (ruleSymbol.LastLocation is Some(loc) when Owner.Environment.Manager.Options.EmitDebug)
        {
          //assert2(false);
          def debugCode = <[ () ]>;
          debugCode.Location = loc.NLocation();
          code.Add(<[ $(EndLabel.Label()); $debugCode; curEndPos; ]>);
        }
        else
          code.Add(<[ $(EndLabel.Label()); curEndPos; ]>);
      }
      tb.DefineConditional(<[decl:
        public override Parse(mutable curEndPos : int, text : string, resultRef : ref int, parser : ref N2.Internal.Parser) : int
        {
          ..$(code.FlattenPExprSequence())
        }
      ]>);
    }
  }
}
