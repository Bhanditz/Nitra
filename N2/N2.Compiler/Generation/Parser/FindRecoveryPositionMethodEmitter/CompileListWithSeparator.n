using Nemerle;
using Nemerle.Imperative;
using Nemerle.Collections;
using Nemerle.Compiler.Parsetree;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using SCG = System.Collections.Generic;
using System.Linq;

using N2.Model;

namespace N2.Compiler
{
  internal partial class FindRecoveryPositionMethodEmitter : MethodEmitter
  {
    public override CompileListWithSeparator(code : SCG.List[PExpr], field : RuleStructureField.ListWithSeparator) : void
    {
      CompileFuntion(field.Rule);
      CompileFuntion(field.Separator);
      def localVariableEmitter = LocalVariableEmitter();
      def stateData = ListStateData(localVariableEmitter, field);
      def itemPtr = AstPointer.New(field.Rule, ConstantEmitter, this, "itemPtr");
      def separatorPtr = AstPointer.New(field.Separator, ConstantEmitter, this, "separatorPtr");
      def body = <[
        $(stateData.Init());
        $(stateData.ListStartPos) = $CurTextPos;
        mutable lastItemStart = -1;
        mutable itemEndPos = $CurTextPos;
        mutable isRule = true;
        while (true)
        {
          if (isRule)
          {
            def $(itemPtr.Var) = parser.TryGetAst(itemEndPos, $(field.Rule.AstId : dyn));
            if ($(itemPtr.Var) > 0 && $(itemPtr.Get(itemPtr.Structure.HeaderState)) == N2.Internal.Parser.AstParsedState)
            {
              $(stateData.Inc());
              lastItemStart = itemEndPos;
              itemEndPos += parser.AstSize($(itemPtr.Var), $(field.Rule.SizesStart), $(field.Rule.SizesEnd));
            }
            else
            {
              when (lastItemStart > 0)
              {
                $(stateData.ListEndPos) = lastItemStart;
                $(stateData.FrameInfo) = N2.Internal.FrameInfo.LoopSeparator;
                $(RecoveryStackFramePush(field));
                $(FunctionName(field.Separator) : dyn)(lastItemStart, parser);
                $(RecoveryStackFramePop());
              }
              $(stateData.Inc());
              $(stateData.ListEndPos) = itemEndPos;
              $(stateData.FrameInfo) = N2.Internal.FrameInfo.LoopBody;
              $(RecoveryStackFramePush(field));
              $(FunctionName(field.Rule) : dyn)(itemEndPos, parser);
              $(RecoveryStackFramePop());
              break;
            }
          }
          else
          {
            def $(separatorPtr.Var) = parser.TryGetAst(itemEndPos, $(field.Separator.AstId : dyn));
            if ($(separatorPtr.Var) > 0 && $(separatorPtr.Get(separatorPtr.Structure.HeaderState)) == N2.Internal.Parser.AstParsedState)
            {
              lastItemStart = itemEndPos;
              itemEndPos += parser.AstSize($(separatorPtr.Var), $(field.Separator.SizesStart), $(field.Separator.SizesEnd));
            }
            else
            {
              when (lastItemStart > 0)
              {
                $(stateData.ListEndPos) = lastItemStart;
                $(stateData.FrameInfo) = N2.Internal.FrameInfo.LoopBody;
                $(RecoveryStackFramePush(field));
                $(FunctionName(field.Rule) : dyn)(lastItemStart, parser);
                $(RecoveryStackFramePop());
              }
              $(stateData.ListEndPos) = itemEndPos;
              $(stateData.FrameInfo) = N2.Internal.FrameInfo.LoopSeparator;
              $(RecoveryStackFramePush(field));
              $(FunctionName(field.Separator) : dyn)(itemEndPos, parser);
              $(RecoveryStackFramePop());
              break;
            }
          }
          isRule = !isRule;
        }
      ]>;
      code.Add(<[
        when (startState <= $(field.State))
        {
          ..$(localVariableEmitter.Define());
          $body;
        }
        if (parseState < $(field.State)) ret() else $CurTextPos += $(AstPtr(field.Owner).GetSize(field));
      ]>)
    }
  }
}
