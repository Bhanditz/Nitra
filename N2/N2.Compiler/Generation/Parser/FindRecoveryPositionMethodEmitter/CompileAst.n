using N2.Typing;
using Nemerle;
using Nemerle.Collections;
using Nemerle.Compiler.Parsetree;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Imperative;

using System;
using SCG = System.Collections.Generic;
using System.Linq;

using N2.Model;

namespace N2.Compiler
{
  internal partial class FindRecoveryPositionMethodEmitter : MethodEmitter
  {
    public CompileAst(ruleStructure : RuleStructure.Ast) : PExpr
    {
      def code = SCG.List();
      def (saveIgnoreRecovery, loadIgnoreRecovery) = if (ruleStructure.Symbol.Type is RuleType.Void)
      {
        (<[ $(CreateVariable("ignoreRecovery") : dyn) = parser.IgnoreRecovery; parser.IgnoreRecovery = true; ]>,
        <[ parser.IgnoreRecovery = $(CreateVariable("ignoreRecovery") : dyn) ]>)
      }
      else
      {
        (<[ {} ]>, <[ {} ]>)
      }

      code.Add(<[ _ = $(ruleStructure.ToString()) ]>);
      code.Add(<[ $(AstStart(ruleStructure)) = $CurTextPos ]>);
      code.Add(saveIgnoreRecovery);
      if (ruleStructure.Symbol is SimpleRuleSymbol)
        code.Add(<[
          $(AstPtr(ruleStructure).Var) = parser.TryGetAst($CurTextPos, RuleId);
          parseState = if ($(AstPtr(ruleStructure).Var) > 0)
            $(AstPtr(ruleStructure).Get(ruleStructure.HeaderState));
          else
            $(ruleStructure.NotMarkerFields[0].State);
        ]>)
      else
        code.Add(<[
          $(AstPtr(ruleStructure).Var) = astPtr;
          parseState = if ($(AstPtr(ruleStructure).Var) > 0)
            $(AstPtr(ruleStructure).Get(ruleStructure.HeaderState))
          else
            $(ruleStructure.NotMarkerFields[0].State)
        ]>);

      code.Add(<[
        when (parseState == N2.Internal.Parser.AstParsedState)
          parseState = $(ruleStructure.NotMarkerFields.Last().State)
      ]>);
      code.Add(<[ assert2(parseState >= 0) ]>);
      foreach (field when field.NextSibling != null in ruleStructure.NotMarkerFields)
        code.Add(<[
          if (parseState >= $(field.NextSibling.EndState))
            $CurTextPos += $(AstPtr(field.Owner).GetSize(field)); // skip
          else
            $(GotoRecoveryLabel(field))
        ]>);
      code.Add(GotoRecoveryLabel(ruleStructure.NotMarkerFields.Last()));

      //parse ok
      code.Add(<[ $(OkLabel(ruleStructure)); ]>);
      code.Add(<[ $(EndLabel.Goto()); ]>);

      //parse fail
      code.Add(<[ $(FailLabel(ruleStructure)); ]>);
      code.Add(<[ $CurTextPos = -1; ]>);
      code.Add(<[ $(EndLabel.Goto()); ]>);

      CompileFields(code, ruleStructure);

      code.Add(<[ $(EndLabel.Label()); $loadIgnoreRecovery; $CurTextPos; ]>);

      def variables = SCG.List();
      variables.Add(<[
        mutable parseState : int; _ = parseState;
        mutable newPos     : int; _ = newPos;
      ]>);
      variables.AddRange(LocalVariables.Filter(_ != "resultRef").Map(name => <[ mutable $(name : dyn) ]>));

      variables.Concat(code).FlattenPExpr();
    }
  }
}
