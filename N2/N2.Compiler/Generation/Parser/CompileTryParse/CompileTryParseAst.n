using N2.Typing;
using Nemerle;
using Nemerle.Collections;
using Nemerle.Compiler.Parsetree;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Imperative;

using System;
using SCG = System.Collections.Generic;
using System.Linq;

using N2.Model;

namespace N2.Compiler
{
  internal abstract partial class RuleParserEmitter
  {
    CompileFindRecoveryPositionAst(_ruleStructure : RuleStructure.Ast) : PExpr
    {
      <[ assert(false) ]>
    }

    public CompileTryParseAst(ruleStructure : RuleStructure.Ast) : PExpr
    {
      def cases = SCG.List();
      foreach (field in ruleStructure.AllFields)
      {
        def fieldLabel = PExprLabel(Environment.Manager, field.SrcRule.FieldName + "_" + field.State);
        field.UserData[typeof(PExprLabel)] = fieldLabel;
        cases.Add(<[ case: | $(field.State) => $(fieldLabel.Goto()) ]>);
      }
      cases.Add(<[ case: | x => assert(false, $"Unknown parse state '$x'.") ]>);
      <[ match (startState) { ..$cases } ]>
    }
  }
}
