using N2.Typing;
using Nemerle;
using Nemerle.Collections;
using Nemerle.Compiler.Parsetree;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Imperative;

using System;
using SCG = System.Collections.Generic;
using System.Linq;

using N2.Model;

namespace N2.Compiler
{
  internal sealed partial class PatchAstMethodEmitter : MethodEmitter
  {
    public CompileAst(ruleStructure : RuleStructure.Ast) : PExpr
    {
      def code = SCG.List();
      def createAst(structure)
      {
        if (structure is RuleStructure.Ast(Symbol = N2.Typing.ExtentionRuleSymbol as symbol))
        {
          def (patchFirstRuleIndex, parentType) = if (symbol is ExtentionRuleSymbol(ExtentionType = Prefix))
            (<[
              assert3(parser.ast[parent.AstHandle.AstPtr + N2.Internal.ExtensibleRuleParser.PrefixOfs.List] == 0);
              parser.ast[parent.AstHandle.AstPtr + N2.Internal.ExtensibleRuleParser.PrefixOfs.List] = newAstPtr;
            ]>, <[ N2.Internal.RecoveryStackFrame.ExtensiblePrefix ]>)
          else
            (<[
              assert3(parser.ast[parent.AstHandle.AstPtr + N2.Internal.ExtensibleRuleParser.PostfixOfs.List] == 0);
              parser.ast[frame.AstHandle.AstPtr] = parser.ast[frame.AstHandle.AstPtr] | N2.Internal.ExtensibleRuleParser.AstFlags.Best;
              parser.ast[parent.AstHandle.AstPtr + N2.Internal.ExtensibleRuleParser.PostfixOfs.List] = newAstPtr;
              parser.ast[parent.AstHandle.AstPtr + N2.Internal.ExtensibleRuleParser.PostfixOfs.FirstRuleIndex] = parent.RuleParser.FirstPostfixRule;
            ]>, <[ N2.Internal.RecoveryStackFrame.ExtensiblePostfix ]>);
          <[
            def newAstPtr = parser.Allocate($(structure.Size), $(structure.AstId : global));
            frame.AstHandle.AstPtr = newAstPtr;
            assert3(frame.Parents.Count == 1);
            def parent = frame.Parents.First() :> $parentType;
            assert3(parent.AstHandle.AstPtr > 0);
            $patchFirstRuleIndex;
            newAstPtr
          ]>
        }
        else
          <[
            def newAstPtr = parser.Allocate($(structure.Size), $(structure.AstId : global));
            frame.AstHandle.AstPtr = newAstPtr;
            parser.ast[newAstPtr + $(structure.HeaderNext.Offset)] = parser.memoize[frame.AstHandle.TextPos];
            parser.memoize[frame.AstHandle.TextPos] = newAstPtr;
            newAstPtr
          ]>
      }
      code.Add(<[ _ = startPos; ]>);
      code.Add(<[ def failState = frame.FailState; ]>);
      def asts = ruleStructure.AllNonMarkerFields.Filter(field => !field.IsPredicate).Grouping(field => (field.Owner, field));
      def cases = SCG.List();
      foreach ((structure, fields) in asts.KeyValuePairs)
      {
        foreach (field in fields)
        {
          def getSize = match (field)
          {
            | Empty                                      => Some(<[ 0 ]>)
            | TokenString    (str)                       => Some(<[ { assert3($(ParseMethodEmitter.CheckStringCode(str, <[ parser.Text ]>, <[ startPos ]>))); $(str.Length); } ]>)
            | TokenCall      (ruleSymbol)                => Some(<[ $(MakeTokenRuleCall(ruleSymbol, <[ startPos ]>, <[ parser.Text ]>)) - startPos ]>)
            | SimpleCall     (ruleSymbol)                => Some(<[ $(Owner.MakeParserName(ruleSymbol) : global).Parse(startPos, parser.Text, parser) - startPos ]>)
            | ExtensibleCall (ruleSymbol, bindingPower)  => Some(<[ $(Owner.MakeParserName(ruleSymbol, bindingPower) : global).Parse(startPos, parser.Text, parser) - startPos ]>)
            | Option | List | ListWithSeparator//TODO: FIXME если у поля есть предикат то восстановление может начатья перед циклом
            | Marker => None()
          }
          def patch = <[
            when (startState == $(field.State))
            {
              $(if (getSize is Some(getSize))
                <[
                  parser.ErrorData[errorIndex].Data = $getSize;
                  assert3(parser.ErrorData[errorIndex].Data >= 0);
                  startState = GetNextState(startState);
                ]>
                else
                <[
                  assert3(false);
                ]>
              )
            }
            parser.PatchAst(this, astPtr, errorIndex, $(field.State), startState, $(field.Offset));
          ]>;
          def body = if (field.IsStart)
            <[
              def astPtr = if (frame.AstHandle.AstPtr > 0)
                frame.AstHandle.AstPtr;
              else
                $(createAst(structure));
              $patch;
            ]>;
          else
            <[
              def astPtr = frame.AstHandle.AstPtr;
              assert3(astPtr > 0);
              $patch;
            ]>;
          def frameType = match (field.Owner)
          {
            | Ast | Option                 => <[ N2.Internal.RecoveryStackFrame.Rule ]>
            | List | ListWithSeparatorRule => <[ N2.Internal.RecoveryStackFrame.ListBody ]>
            | ListWithSeparatorSeparator   => <[ N2.Internal.RecoveryStackFrame.ListSeparator ]>
            | Predicate                    => assert3(false);
          }
          cases.Add(<[ case: | $(field.State) => def frame = frame :> $frameType; $body ]>);
        }
      }
      cases.Add(<[ case: | _ => assert(false); ]>);
      code.Add(<[ match (failState) { ..$cases }]>);

      code.FlattenPExpr();
    }
  }
}
