using N2.Typing;
using Nemerle;
using Nemerle.Collections;
using Nemerle.Compiler.Parsetree;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Imperative;

using System;
using SCG = System.Collections.Generic;
using System.Linq;

using N2.Model;

namespace N2.Compiler
{
  internal sealed partial class PatchAstMethodEmitter : MethodEmitter
  {
    public CompileAst(ruleStructure : RuleStructure.Ast) : PExpr
    {
      def code = SCG.List();
      def createAst()
      {
        if (ruleStructure.Symbol is N2.Typing.ExtentionRuleSymbol)
          <[
            def astPtr = parser.Allocate($(ruleStructure.Size), $(ruleStructure.AstId : dyn));
            frame.AstPtr = astPtr;
            match (stack)
            {
              | (_ :: parent :: _) =>
                assert2(parser.ast[parent.AstPtr + N2.Internal.ExtensibleRuleParser.PrefixOfs.List] == 0);
                parser.ast[parent.AstPtr + N2.Internal.ExtensibleRuleParser.PrefixOfs.List] = astPtr;
              | _ => assert(false)
            }
            astPtr
          ]>
        else
          <[
            def astPtr = parser.Allocate($(ruleStructure.Size), $(ruleStructure.AstId : dyn));
            frame.AstPtr = astPtr;
            parser.ast[astPtr + $(ruleStructure.HeaderNext.Offset)] = parser.memoize[frame.AstStartPos];
            parser.memoize[frame.AstStartPos] = astPtr;
            astPtr
          ]>
      }
      code.Add(<[ def frame     = stack.Head; ]>);
      code.Add(<[ def failState = frame.FailState; ]>);
      code.Add(<[ def astPtr    = if (frame.AstPtr > 0) frame.AstPtr else $(createAst()) ]>);
      code.Add(<[ mutable level; ]>);

      code.Add(<[
        when (failState == startState)
        {
          // этим вызовом мы устанавливаем размер для поля соответствующего failState
          def pos42 = TryParse(stack, startState, startPos, true, parser);
          _ = pos42;
        }
      ]>);
      CompileFields(code, ruleStructure);
      def rootAstPtr = AstPointer.Existing(ruleStructure, "rootAstPtr");
      code.Add(<[
        def rootFrame = stack.Nth(level);
        def rootAstPtr =  rootFrame.AstPtr;
        $(rootAstPtr.Set(ruleStructure.HeaderState, <[ ~startState ]>));
      ]>);

      code.FlattenPExpr();
    }
  }
}
