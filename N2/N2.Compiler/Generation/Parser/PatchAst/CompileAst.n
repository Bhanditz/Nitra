using N2.Typing;
using Nemerle;
using Nemerle.Collections;
using Nemerle.Compiler.Parsetree;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Imperative;

using System;
using SCG = System.Collections.Generic;
using System.Linq;

using N2.Model;

namespace N2.Compiler
{
  internal sealed partial class PatchAstMethodEmitter : MethodEmitter
  {
    public CompileAst(ruleStructure : RuleStructure.Ast) : PExpr
    {
      def code = SCG.List();
      def createAst(structure)
      {
        if (structure is RuleStructure.Ast(Symbol = N2.Typing.ExtentionRuleSymbol))
        {
          <[
            def newAstPtr = parser.Allocate($(structure.Size), $(structure.AstId : global));
            frame.AstHandle.AstPtr = newAstPtr;
            newAstPtr
          ]>
        }
        else
          <[
            def newAstPtr = parser.Allocate($(structure.Size), $(structure.AstId : global));
            frame.AstHandle.AstPtr = newAstPtr;
            parser.ast[newAstPtr + $(structure.HeaderNext.Offset)] = parser.memoize[frame.AstHandle.TextPos];
            parser.memoize[frame.AstHandle.TextPos] = newAstPtr;
            newAstPtr
          ]>
      }
      code.Add(<[ _ = startPos; ]>);
      code.Add(<[ def failState = Math.Min(frame.FailState, frame.FailState2); ]>);
      def asts = ruleStructure.AllNonMarkerFields.Filter(field => !field.IsPredicate).Grouping(field => (field.Owner, field));
      def cases = SCG.List();
      foreach ((structure, fields) in asts.KeyValuePairs)
      {
        if (structure.Owner is List as owner when owner.IsSkipAnyPattern)
          foreach (field in fields)
            cases.Add(<[ case: | $(field.State) => assert3(false) ]>)
        else
          foreach (field in fields)
          {
            def getSize = match (field)
            {
              | Empty                                      => Some(<[ 0 ]>)
              | TokenString    (str)                       => Some(<[ { assert3($(ParseMethodEmitter.CheckStringCode(str, <[ parser.Text ]>, <[ startPos ]>))); $(str.Length); } ]>)
              | TokenCall      (ruleSymbol)                => Some(<[ $(MakeTokenRuleCall(ruleSymbol, <[ startPos ]>, <[ parser.Text ]>)) - startPos ]>)
              | SimpleCall     (ruleSymbol)                => Some(<[ $(Owner.MakeParserName(ruleSymbol) : global).Parse(startPos, parser.Text, parser) - startPos ]>)
              | ExtensibleCall (ruleSymbol, bindingPower)  => Some(<[ $(Owner.MakeParserName(ruleSymbol, bindingPower) : global).Parse(startPos, parser.Text, parser) - startPos ]>)
              | Option | List | ListWithSeparator//TODO: FIXME если у поля есть предикат то восстановление может начатья перед циклом
              | Marker => None()
            }
            def getAst = if (field.IsStart)
              <[
                mutable astPtr = if (frame.AstHandle.AstPtr > 0)
                  frame.AstHandle.AstPtr;
                else
                  $(createAst(structure));
              ]>;
            else
              <[
                mutable astPtr = frame.AstHandle.AstPtr;
                assert3(astPtr > 0);
              ]>;
            def frameType = match (field.Owner)
            {
              | Ast | Option                 => <[ N2.Internal.RecoveryStackFrame.Rule ]>
              | List | ListWithSeparatorRule => <[ N2.Internal.RecoveryStackFrame.ListBody ]>
              | ListWithSeparatorSeparator   => <[ N2.Internal.RecoveryStackFrame.ListSeparator ]>
              | Predicate                    => assert3(false);
            }
            def (astPtr, astPtrRef) = if (structure is RuleStructure.Ast(Symbol = N2.Typing.ExtentionRuleSymbol))
              ([<[ astPtr ]>], [<[ ref astPtr ]>])
            else
              ([], []);
            def frameCounter = match (structure.Owner)
            {
              | List              as field when field.UseCounter => [<[ frame.Counter ]>]
              | ListWithSeparator as field when field.UseCounter => [<[ frame.Counter ]>]
              | _                                                => []
            }
            cases.Add(<[ case:
              | $(field.State) =>
                def frame = frame :> $frameType;
                frame.AstHandle.UpdateAstPtr(parser);
                $getAst;
                when (startState == $(field.State))
                {
                  $(if (getSize is Some(getSize))
                    <[
                      parser.ErrorData[errorIndex].Data = $getSize;
                      assert3(parser.ErrorData[errorIndex].Data >= 0);
                      startState = GetNextState(startState);
                    ]>
                    else
                    <[
                      assert3(false);
                    ]>
                  )
                }
                parser.PatchAst(this, astPtr, errorIndex, $(field.State), startState, $(field.Offset));
                def pos = $(structure.ParseFunctionName : global)(frame.StartPos, parser.Text, ..$astPtrRef, parser);
                if (pos < 0)
                {
                  def startPos = frame.StartPos;
                  foreach (parent in frame.Parents)
                    $(structure.FindRecoveryPositionFunctionName : global)(startPos, ..$frameCounter, ..$astPtr, parent, parser);
                  false
                }
                else
                  true
              ]>);
          }
      }
      cases.Add(<[ case: | _ => assert(false); ]>);
      code.Add(<[ match (failState) { ..$cases }]>);

      code.FlattenPExpr();
    }
  }
}
