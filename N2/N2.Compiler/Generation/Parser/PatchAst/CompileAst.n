using N2.Typing;
using Nemerle;
using Nemerle.Collections;
using Nemerle.Compiler.Parsetree;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Imperative;

using System;
using SCG = System.Collections.Generic;
using System.Linq;

using N2.Model;

namespace N2.Compiler
{
  internal sealed partial class PatchAstMethodEmitter : MethodEmitter
  {
    public CompileAst(ruleStructure : RuleStructure.Ast) : PExpr
    {
      def code = SCG.List();
      code.Add(<[ def frame     = stack.Head; ]>);
      code.Add(<[ def failState = frame.State; ]>);
      code.Add(<[ def astPtr    = frame.AstPtr; ]>);
      code.Add(<[ mutable level; ]>);

      CompileFields(code, ruleStructure);

      def rootAstPtr = AstPointer.Existing(ruleStructure, "rootAstPtr");
      code.Add(<[
        def rootFrame = stack.Nth(level);
        def rootAstPtr =  rootFrame.AstPtr;
        //failPos : int, startPos : int, startState : int, errorIndex : int, stack : list[N2.Internal.RecoveryStackFrame].Cons, parser : N2.Internal.Parser
        //recoveryStack : list[N2.Internal.RecoveryStackFrame].Cons, startState : int, mutable curTextPos : int, writeAstSize : bool, parser : N2.Internal.Parser
        assert2(false);
        def pos42 = TryParse(stack, startState, startPos, true, parser);
        _ = pos42;
        $(rootAstPtr.Set(ruleStructure.HeaderState, <[ ~startState ]>));
      ]>);

      code.FlattenPExpr();
    }
  }
}
