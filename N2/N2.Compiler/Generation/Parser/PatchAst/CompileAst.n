using N2.Typing;
using Nemerle;
using Nemerle.Collections;
using Nemerle.Compiler.Parsetree;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Imperative;

using System;
using SCG = System.Collections.Generic;
using System.Linq;

using N2.Model;

namespace N2.Compiler
{
  internal sealed partial class PatchAstMethodEmitter : MethodEmitter
  {
    public CompileAst(ruleStructure : RuleStructure.Ast) : PExpr
    {
      def code = SCG.List();
      def createAst()
      {
        def createRootAst()
        {
          if (ruleStructure.Symbol is N2.Typing.ExtentionRuleSymbol)
            <[
              def astPtr = parser.Allocate($(ruleStructure.Size), $(ruleStructure.AstId : dyn));
              frame.AstPtr = astPtr;
              match (stack)
              {
                | (_ :: parent :: _) =>
                  assert2(parser.ast[parent.AstPtr + N2.Internal.ExtensibleRuleParser.PrefixOfs.List] == 0);
                  parser.ast[parent.AstPtr + N2.Internal.ExtensibleRuleParser.PrefixOfs.List] = astPtr;
                | _ => assert(false)
              }
              astPtr
            ]>
          else
            <[
              def astPtr = parser.Allocate($(ruleStructure.Size), $(ruleStructure.AstId : dyn));
              frame.AstPtr = astPtr;
              parser.ast[astPtr + $(ruleStructure.HeaderNext.Offset)] = parser.memoize[frame.AstStartPos];
              parser.memoize[frame.AstStartPos] = astPtr;
              astPtr
            ]>
        }
        def asts = ruleStructure.AllNonMarkerFields.Filter(field => !field.IsPredicate).Grouping(field => (field.Owner, field));
        if (asts.Count == 1)
          createRootAst()
        else
        {
          def cases = SCG.List();
          foreach ((ast, fields) in asts.KeyValuePairs)
          {
            def body = if (ast is RuleStructure.Ast)
              createRootAst();
            else
            <[
              def astPtr = parser.Allocate($(ast.Size), $(ast.AstId : dyn));
              frame.AstPtr = astPtr;
              parser.ast[astPtr + $(ast.HeaderNext.Offset)] = parser.memoize[frame.AstStartPos];
              parser.memoize[frame.AstStartPos] = astPtr;
              astPtr
            ]>;
            cases.Add(MatchCase(fields.Map(field => <[ $(field.State) ]>), body));
          }
          cases.Add(<[case: | _ => assert(false); ]>);
          <[ match (failState) { ..$cases }]>
        }
      }
      code.Add(<[ def frame     = stack.Head; ]>);
      code.Add(<[ def failState = frame.FailState; ]>);
      code.Add(<[ def astPtr    = if (frame.AstPtr > 0) frame.AstPtr else $(createAst()) ]>);
      code.Add(<[ mutable level; ]>);

      code.Add(<[
        when (failState == startState)
        {
          // этим вызовом мы устанавливаем размер для поля соответствующего failState
          def pos42 = TryParse(stack, startState, startPos, true, parser);
          _ = pos42;
        }
      ]>);
      CompileFields(code, ruleStructure);
      def astPtr = AstPointer.Existing(ruleStructure, ConstantEmitter, "astPtr");
      code.Add(<[
        $(astPtr.Set(ruleStructure.HeaderState, <[ ~startState ]>));
      ]>);

      code.FlattenPExpr();
    }
  }
}
