using N2.Typing;
using Nemerle;
using Nemerle.Collections;
using Nemerle.Compiler.Parsetree;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Imperative;

using System;
using SCG = System.Collections.Generic;
using System.Linq;

using N2.Model;

namespace N2.Compiler
{
  internal sealed partial class PatchAstMethodEmitter : MethodEmitter
  {
    public CompileAst(ruleStructure : RuleStructure.Ast) : PExpr
    {
      def code = SCG.List();
      def createAst(structure)
      {
        if (structure is RuleStructure.Ast(Symbol = N2.Typing.ExtentionRuleSymbol))
          <[
            def newAstPtr = parser.Allocate($(structure.Size), $(structure.AstId : dyn));
            frame.AstPtr = newAstPtr;
            match (stack)
            {
              | (_ :: parent :: _) =>
                assert2(parser.ast[parent.AstPtr + N2.Internal.ExtensibleRuleParser.PrefixOfs.List] == 0);
                parser.ast[parent.AstPtr + N2.Internal.ExtensibleRuleParser.PrefixOfs.List] = newAstPtr;
              | _ => assert(false)
            }
            newAstPtr
          ]>
        else
          <[
            def newAstPtr = parser.Allocate($(structure.Size), $(structure.AstId : dyn));
            frame.AstPtr = newAstPtr;
            parser.ast[newAstPtr + $(structure.HeaderNext.Offset)] = parser.memoize[frame.AstStartPos];
            parser.memoize[frame.AstStartPos] = newAstPtr;
            newAstPtr
          ]>
      }
      code.Add(<[ _ = startPos; ]>);
      code.Add(<[ def frame     = stack.Head; ]>);
      code.Add(<[ def failState = frame.FailState; ]>);
      def asts = ruleStructure.AllNonMarkerFields.Filter(field => !field.IsPredicate).Grouping(field => (field.Owner, field));
      def cases = SCG.List();
      foreach ((structure, fields) in asts.KeyValuePairs)
      {
        foreach (field in fields)
        {
          def getSize = match (field)
          {
            | Empty                                      => Some(<[ 0 ]>)
            | TokenString    (str)                       => Some(<[ $(str.Length) ]>)
            | TokenCall      (ruleSymbol)                => Some(MakeTokenRuleCall(ruleSymbol, <[ startPos ]>, <[ parser.Text ]>))
            | SimpleCall     (ruleSymbol)                => Some(<[ $(Owner.MakeParserName(ruleSymbol) : dyn).Parse(startPos, parser.Text, parser) ]>)
            | ExtensibleCall (ruleSymbol, bindingPower)  => Some(<[ $(Owner.MakeParserName(ruleSymbol, bindingPower) : dyn).Parse(startPos, parser.Text, parser) ]>)
            | Option | List | ListWithSeparator//TODO: FIXME если у поля есть предикат то восстановление может начатья перед циклом
            | Marker => None()
          }
          def patch = <[
            when (startState == $(field.State))
            {
              $(if (getSize is Some(getSize))
                <[
                  parser.ErrorData[errorIndex].Data = $getSize;
                  assert2(parser.ErrorData[errorIndex].Data >= 0);
                  startState = GetNextState(startState);
                ]>
                else
                <[
                  assert2(false);
                  assert(false);
                ]>
              )
            }
            parser.PatchAst(this, astPtr, errorIndex, $(field.State), startState, $(field.Offset));
          ]>;
          def body = if (field.IsStart)
            <[
              def astPtr = if (frame.AstPtr > 0)
                frame.AstPtr;
              else
                $(createAst(structure));
              $patch;
            ]>;
          else
            <[
              def astPtr = frame.AstPtr;
              assert2(astPtr > 0);
              $patch;
            ]>;
          cases.Add(<[ case: | $(field.State) => $body ]>);
        }
      }
      cases.Add(<[ case: | _ => assert(false); ]>);
      code.Add(<[ match (failState) { ..$cases }]>);

      code.FlattenPExpr();
    }
  }
}
