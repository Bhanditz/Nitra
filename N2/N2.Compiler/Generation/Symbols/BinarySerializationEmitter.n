using N2.Serialization;

using Nemerle;
using Nemerle.Collections;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Compiler.Typedtree;
using Nemerle.Imperative;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.RegularExpressions;

using SCG = System.Collections.Generic;

namespace N2.Compiler
{
  public sealed class BinarySerializationEmitter : IDisposable
  {
    static _extractNameRx : Regex        = Regex(@"_N_((\w|\d|_)+)_\d+", RegexOptions.Compiled);
    static _internalNs    : list[string] = ["N2", "Internal"];

    _manager        : ManagerClass;
    _helperName     : PExpr;
    _messageEmitter : IBinarySerializationMessageEmitter;
    _extentions     : array[IBinarySerializationEmitterExtention];
    
    [RecordIgnore] _typesMap       : Hashtable[FixedType, PExpr * PExpr] = Hashtable();
    [RecordIgnore] _typesToProcess : SCG.Queue[FixedType] = SCG.Queue();

    public this(manager : ManagerClass, messageEmitter : IBinarySerializationMessageEmitter, extentions : array[IBinarySerializationEmitterExtention])
    {
      _manager        = manager;
      _messageEmitter = messageEmitter;
      _extentions     = extentions ?? array(0);

      foreach (e in _extentions)
        e.CreateParameters(this);

      _serializationParams   = _serializationParameters.ToNList();
      _serializationArgs     = _serializationParams.Map(p => <[ $(p.Name : usesite) ]>);

      _deserializationParams = _deserializationParameters.ToNList();
      _deserializationArgs   = _deserializationParams.Map(p => <[ $(p.Name : usesite) ]>);

      _helperName = PExpr.FromQualifiedIdentifier(manager, "N2.Internal.SerializationHelper");
    }
    
    private GetSerializableMembers(ti : TypeInfo) : list[IMember]
    {
      def mappedMemberTi = _manager.LookupTypeInfo("Nemerle.Internal.MappedMemberAttribute", 0);
      def members        = ti.GetMembers(BindingFlags.Public | BindingFlags.Instance).Filter(m => m is IField || m is IProperty);
      def memberMap      = members.ToDictionary(m => m.Name);
      def ctors          = ti.GetConstructors(BindingFlags.Public | BindingFlags.Instance);
      
      mutable result;
      
      foreach (ctor in ctors)
        when (ctor.IsCustomAttributeDefined("Nemerle.Internal.RecordCtorAttribute"))
          when (result == null || ctor.Header.Parameters.Length > result.Header.Parameters.Length)
            result = ctor;

      def makeMember(p : TParameter) : IMember
      {
        match (p.AttributesAndModifiers.FindAttribute(mappedMemberTi, _manager.CoreEnv))
        {
          | Some(<[ $_($(name : string)) ]>) => memberMap[name]
          | e => assert2(false); _ = e; assert(false);
        }
      }

      if (result == null)
        []
      else
        result.Header.Parameters.Map(makeMember)
    }

    public CreateSerializationParameter(desiredName : string, type : PExpr) : string
    {
      def name = Util.tmpname(desiredName);
      _serializationParameters.Add(<[ parameter: $(name : usesite) : $type ]>);
      name
    }

    private _serializationParameters : List[PParameter] = List();
    private _serializationParams     : list[PParameter];
    private _serializationArgs       : list[PExpr];

    public CreateDeserializationParameter(desiredName : string, type : PExpr) : string
    {
      def name = Util.tmpname(desiredName);
      _deserializationParameters.Add(<[ parameter: $(name : usesite) : $type ]>);
      name
    }

    private _deserializationParameters : List[PParameter] = List();
    private _deserializationParams     : list[PParameter];
    private _deserializationArgs       : list[PExpr];

    public MakeMembersSerializationCode(owner : FixedType, members : list[IMember], objAccess : PExpr, args : list[PExpr]) : PExpr
    {
      assert2(args.Length == _serializationParams.Length);

      def body = List();
      foreach ((p, e) in _serializationParams.Zip(args))
        body.Add(<[ def $(p.Name : usesite) = $e ]>);
      foreach (m in members)
        body.Add(MakeMemberWriteCode(owner, m, objAccess));
      <[ { ..$(body.ToNList()) } ]>
    }

    public MakeMembersDeserializationCode(owner : FixedType, members : list[IMember], objAccess : PExpr, args : list[PExpr]) : PExpr
    {
      assert2(args.Length == _deserializationParams.Length);

      def body = List();
      foreach ((p, e) in _deserializationParams.Zip(args))
        body.Add(<[ def $(p.Name : usesite) = $e ]>);

      def cases1 = members.RevMap(m => <[ case: | $(GetMemberName(m) : string) => $objAccess.$(m.Name : usesite) = $(MakeMemberReadCode(owner, m)) ]>);
      def cases2 = <[ case: | name => $(_messageEmitter.EmitWarning(<[ "Data for the '" + name + "' member is ignored." ]>)) ]> :: cases1;

      body.Add(<[
        def loop()
        {
          def typeCode = reader.ReadByte() :> TypeTag;
          when (typeCode != TypeTag.Empty)
          {
            def fieldName = reader.ReadString();
            match (fieldName)
            {
              ..$(cases2.Reverse())
            }
            loop()
          }
        }
      ]>);
      body.Add(<[ loop(); ]>);
      <[ { ..$(body.ToNList()) } ]>
    }

    MakeMemberWriteCode(type : FixedType, member : IMember, objExpr : PExpr) : PExpr
    {
      def memberType = type.TypeOfMember(member).Fix();
      def typeCode = GetTypeTag(memberType) :> TypeTag;
      if (typeCode == TypeTag.Object || typeCode == TypeTag.Variant || typeCode :> int >= TypeTag.FirstCustom :> int)
        MakeUserDefinedTypeWriteCode(type, member, objExpr)
      else
        <[
          writer.Write($(GetTypeTag(memberType)));
          writer.Write($(GetMemberName(member)));
          writer.Write($objExpr.$(member.Name : usesite));
        ]>
    }

    MakeMembersWriteCode(type : FixedType, objExpr : PExpr) : PExpr
    {
      def members = GetSerializableMembers(type.TypeInfo);
      if (members is [])
        <[ () ]>
      else
      {
        def code    = members.Map(m => MakeMemberWriteCode(type, m, objExpr));
        <[ { ..$code } ]>
      }
    }

    MakeRecordReadCode(type : FixedType) : PExpr
    {
      def varPrefix = "_____";
      def members = GetSerializableMembers(type.TypeInfo);
      if (members is [])
        <[ $(type : typed)() ]>
      else
      {
        def vars  = List(members.MapLazy(m => <[ mutable $(varPrefix + m.Name : usesite); ]>));
        def cases1 = members.RevMap(m => <[ case: | $(GetMemberName(m) : string) => $(varPrefix + m.Name : usesite) = $(MakeMemberReadCode(type, m)) ]>);
        def cases2 = <[ case: | name => $(_messageEmitter.EmitWarning(<[ "Data for the '" + name + "' member is ignored." ]>)) ]> :: cases1;
        def parameters = members.Map(m => <[ $(varPrefix + m.Name : usesite) ]>);
        def matchExpr = <[ 
          def loop()
          {
            def typeCode = reader.ReadByte() :> TypeTag;
            when (typeCode != TypeTag.Empty)
            {
              def fieldName = reader.ReadString();
              match (fieldName)
              {
                ..$(cases2.Reverse())
              }
              loop()
            }
          }
          loop();
          $(type : typed)(..$parameters)
        ]>;
        vars.Add(matchExpr);
        <[ { ..$(vars.NToList()) } ]>
      }
    }

    IsVariant(ti : TypeInfo) : bool
    {
      match (ti?.GetTydecl())
      {
        | TypeDeclaration.Alias(type) => IsVariant(type.TypeInfo)
        | TypeDeclaration.Variant     => true
        | _                           => false
      }
    }

    private MakeUserDefinedTypeWriteCode(type : FixedType, member : IMember, objExpr : PExpr) : PExpr
    {
      def ti = type.TypeOfMember(member).Fix();
      def name = GetMemberName(member);
      def (writer, _) = GetWriteReadMethods(ti);
      def args = <[ $(name : string) ]> :: <[ $objExpr.$(name : usesite) ]> :: <[ writer ]> :: _serializationArgs;
      <[ $writer(..$args); ]>
    }

    private MakeMemberReadCode(type : FixedType, member : IMember) : PExpr
    {
      def memberType = type.TypeOfMember(member).Fix();
      //def name = GetMemberName(member);
      def (_, reader) = GetWriteReadMethods(memberType);
      def args = <[ reader ]> :: <[ typeCode ]> :: <[ fieldName ]> :: _deserializationArgs;
      <[ $reader(..$args) ]>
    }

    private GetVariantOptions(variantType : FixedType) : list[FixedType.Class]
    {
      def makeOptionType(o)
      {
        def e = _manager.CoreEnv.BindFixedType(<[ $(variantType : typed).$(o.Name : usesite) ]>); // HACK: нужно разбираться, как правильно связать типы вхождений вариантов
        e :> FixedType.Class
      }
      match (variantType.TypeInfo?.GetTydecl())
      {
        | TypeDeclaration.Alias(type)      => GetVariantOptions(type)
        | TypeDeclaration.Variant(options) => options.Map(makeOptionType)
        | _                                => Message.FatalError("Type must be 'variant'.");
      }
    }

    private MakeVarianteReaderMethodBody(ty : FixedType) : PExpr
    {
      def makeCase(optionType : FixedType.Class)
      {
        def code = MakeRecordReadCode(optionType);
        <[ case: | $(optionType.ToString() : string) => $code ]>
      }
      def options = GetVariantOptions(ty);
      def cases1  = options.Map(makeCase);
      def cases2  = cases1 + [<[ case: | m => $(_messageEmitter.EmitFatalError(<[ "The serialisation data for '" + m + "' member is ignored."]>)); ]>];
      <[
        assert(typeCode == TypeTag.Variant);
        match (reader.ReadString())
        {
          ..$cases2
        }
      ]>
    }

    private MakeVarianteWriterMethodBody(ty : FixedType) : PExpr
    {
      def makeCase(optionType : FixedType.Class)
      {
        def code = MakeMembersWriteCode(optionType, <[ o ]>);
        if (code is <[ () ]>)
          <[ case:
            | $(optionType.TypeInfo.Name : usesite) => 
              writer.Write($(optionType.ToString() : string));
          ]>
        else
          <[ case:
            | $(optionType.TypeInfo.Name : usesite) as o => 
              writer.Write($(optionType.ToString() : string));
              $code
          ]>
      }
      def options = GetVariantOptions(ty);
      def cases1  = options.Map(makeCase);

      <[
        writer.Write($(TypeTag.Variant :> byte)); // Variant кодирует variant. Его формат отличается от объекта наличием строки поределяющей подтип.
        writer.Write(memberName);
        match (obj)
        {
          ..$cases1
        };
        writer.Write(0b);
      ]>
    }
    
    private MakeTypeWriteReadMethods(helperType : TypeBuilder, ty : FixedType, writer : Name, reader : Name) : void
    {
      def typeCode = GetTypeTag(ty) :> TypeTag;
      mutable readerCode : PExpr;
      mutable writerCode : PExpr;

      match (typeCode)
      {
        | TypeTag.Object =>
          writerCode = <[ 
              writer.Write($(TypeTag.Object :> byte));
              writer.Write(memberName);
              $(MakeMembersWriteCode(ty, <[ obj ]>));
              writer.Write(0b);
            ]>;

          readerCode = MakeRecordReadCode(ty);
            
        | TypeTag.Variant =>
          readerCode = MakeVarianteReaderMethodBody(ty);
          writerCode = MakeVarianteWriterMethodBody(ty);

        | TypeTag.Empty    => assert2(false); assert(false);
        | TypeTag.DateTime => assert2(false); assert(false);
        | TypeTag.Boolean | TypeTag.Char   | TypeTag.SByte  | TypeTag.Byte 
        | TypeTag.Int16   | TypeTag.UInt16 | TypeTag.Int32  | TypeTag.UInt32  | TypeTag.Int64 
        | TypeTag.UInt64  | TypeTag.Single | TypeTag.Double | TypeTag.Decimal | TypeTag.String =>
          writerCode = null; // чтение примитивных типов производится инлайн

          def cnvFuncName = <[ $("To" + typeCode.ToString() : usesite) ]>;
          readerCode = <[
              match (typeCode) //reader.ReadByte() :> TypeTag
              {
                | TypeTag.Empty        => assert2(false); assert(false);
                | TypeTag.DateTime     => assert2(false); assert(false);
                | TypeTag.Boolean      => System.Convert.$cnvFuncName(reader.ReadBoolean())
                | TypeTag.Char         => System.Convert.$cnvFuncName(reader.ReadChar   ())
                | TypeTag.SByte        => System.Convert.$cnvFuncName(reader.ReadSByte  ())
                | TypeTag.Byte         => System.Convert.$cnvFuncName(reader.ReadByte   ())
                | TypeTag.Int16        => System.Convert.$cnvFuncName(reader.ReadInt16  ())
                | TypeTag.UInt16       => System.Convert.$cnvFuncName(reader.ReadUInt16 ())
                | TypeTag.Int32        => System.Convert.$cnvFuncName(reader.ReadInt32  ())
                | TypeTag.UInt32       => System.Convert.$cnvFuncName(reader.ReadUInt32 ())
                | TypeTag.Int64        => System.Convert.$cnvFuncName(reader.ReadInt64  ())
                | TypeTag.UInt64       => System.Convert.$cnvFuncName(reader.ReadUInt64 ())
                | TypeTag.Single       => System.Convert.$cnvFuncName(reader.ReadSingle ())
                | TypeTag.Double       => System.Convert.$cnvFuncName(reader.ReadDouble ())
                | TypeTag.Decimal      => System.Convert.$cnvFuncName(reader.ReadDecimal())
                | TypeTag.String       => System.Convert.$cnvFuncName(reader.ReadString ())
                | TypeTag.Variant      => assert2(false); assert(false); // ??? видимо нужно скипать variant!
                | TypeTag.Object       => assert2(false); assert(false); // ??? видимо нужно скипать объект!
                | _                    => assert2(false); assert(false);
              }
            ]>;
        | tag when (tag :> byte) < 0 => assert2(false); assert(false);
        | tag =>
          def serializerId = tag :> int - TypeTag.FirstCustom :> int;
          def extention = _extentions[serializerId];
          writerCode = <[ 
            writer.Write($(tag :> byte));
            writer.Write(memberName);
            $(extention.MakeWriteCode(ty, this));
          ]>;
          readerCode = extention.MakeReadCode(ty, this);
      }

      when (writerCode != null)
      {
        def parms = <[ parameter: memberName : string ]>
          :: <[ parameter: obj : $(ty : typed) ]>
          :: <[ parameter: writer : System.IO.BinaryWriter ]>
          :: _serializationParams;

        _ = helperType.DefineWithSource(<[ decl: 
          public $(writer : name)(..$parms) : void
          {
            $writerCode;
          } ]>);
      }

      assert2(readerCode != null);

      def parms = <[ parameter: reader : System.IO.BinaryReader ]>
        :: <[ parameter: typeCode : TypeTag ]>
        :: <[ parameter: memberName : string ]>
        :: _deserializationParams;

      _ = helperType.DefineWithSource(<[ decl:
        public $(reader : name)(..$parms) : $(ty : typed)
        {
          try { $readerCode }
          catch 
          { | e =>
            $(_messageEmitter.EmitWarning(<[ "An exception occurred while deserializing data for the '" + memberName + "' field. Exception: " + e.Message + "." ]>));
            $(TExpr.DefaultValue(ty) : typed);
          }
        } ]>);
    }
    
    private GetWriteReadMethods(type : FixedType) : PExpr * PExpr
    {
      mutable value;
      
      if (_typesMap.TryGetValue(type, out value))
        value
      else
      {
        assert2(type.TypeInfo != null);
        def name = Util.tmpname(type.TypeInfo.Name);
        def writerName = "Serialize_" + name;
        def readerName = "Deserialize_" + name;
        def result     = (<[ $_helperName . $(writerName : usesite) ]>, <[ $_helperName . $(readerName : usesite) ]>);
        _typesMap.Add(type, result);
        _typesToProcess.Enqueue(type);
        result
      }
    }
    
    GetTypeTag(type : FixedType) : byte
    {
      foreach (extention in _extentions with i)
        when (extention.IsSupportedType(type))
          return (i + TypeTag.FirstCustom :> int) :> byte;
      
      match (type)
      {
        | FixedType.Class(ti, _) =>
          if (ti.IsPrimitive || ti.Equals(_manager.InternalType.String_tc))
            Type.GetTypeCode(ti.SystemType) :> byte
          else if (IsVariant(ti))
            TypeTag.Variant :> byte // пока используем Variant для указания, что значение это variant
          else
            TypeTag.Object :> byte
                
        | _ => 0
      }
    }
    
    GetMemberName(member : IMember) : string
    {
      def res = _extractNameRx.Match(member.Name);
          
      if (res.Success)
        res.Groups[1].Value
      else
        member.Name
    }

    public Dispose() : void
    {
      when (_typesToProcess.Count > 0)
      {
        def env        = _manager.CoreEnv.EnterIntoNamespace(["N2", "Internal"]);
        def helperType =
          match (env.LookupType(["SerializationHelper"], null, 0))
          {
            | Some(type is TypeBuilder) => type
            | Some => assert(false);
            | _ => 
              def result = env.Define(<[ decl: internal module SerializationHelper { } ]>);
              def onTypeTreeBuildFinish(manager : ManagerClass) : void
              {
                manager.TypeTreeBuildFinish -= onTypeTreeBuildFinish;
                result.Compile();
              }
              _manager.TypeTreeBuildFinish += onTypeTreeBuildFinish;
              result
          };

        while (_typesToProcess.Count > 0)
        {
          def ti = _typesToProcess.Dequeue();
          match (_typesMap[ti])
          {
            | (<[ $_.$(Splicable.Name(writer)) ]>, <[ $_.$(Splicable.Name(reader)) ]>) => MakeTypeWriteReadMethods(helperType, ti, writer, reader)
            | _ => assert2(false); assert(false);
          }
        }
      }
    }
  }

  internal module BinarySerializationEmitterExtensions
  {
    public CreateBinarySerializationEmitter(this manager : ManagerClass, messageEmitter : IBinarySerializationMessageEmitter, params extentions : array[IBinarySerializationEmitterExtention]) : BinarySerializationEmitter
    {
      assert2(!manager.UserData.Contains(typeof(BinarySerializationEmitter)));

      def instance = BinarySerializationEmitter(manager, messageEmitter, extentions);
      manager.UserData[typeof(BinarySerializationEmitter)] = instance;
      instance
    }

    public DisposeBinarySerializationEmitter(this manager : ManagerClass) : void
    {
      assert2(manager.UserData.Contains(typeof(BinarySerializationEmitter)));

      def instance = manager.UserData[typeof(BinarySerializationEmitter)] :> BinarySerializationEmitter;
      instance.Dispose();
      manager.UserData.Remove(typeof(BinarySerializationEmitter));
    }
  }
}
