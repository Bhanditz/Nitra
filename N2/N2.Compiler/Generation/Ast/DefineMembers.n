using Nemerle;
using Nemerle.Collections;
using Nemerle.Imperative;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Compiler.Typedtree;

using N2.Internal;
using N2.Model;
using N2.Typing;

using System;
using System.Diagnostics;
using System.Linq;
using SCG = System.Collections.Generic;

namespace N2.Compiler
{
  internal partial class RuleAstEmitter
  {
    public DefineMembers() : void
    {
      assert(_baseTb != null);
      DefineBaseAstExtraFields();
      when (_astTb != null)
      {
        CreateAstFields();
        DefineAstFields();
        DefineAstCtor();
        DefineAstPrettyPrint();
        DefineAstGetErrors();
        DefineAstGetDump();
        DefineAstExtraFields();
      }
      when (_spliceTb != null)
      {
        DefineSpliceGetDump();
        DefineSpliceExtraFields();
      }
      when (_errorTb != null)
      {
        DefineErrorGetDump();
        DefineErrorExtraFields();
      }
    }

    private CreateAstFields() : void
    {
      assert(_astFields == null);
      _astFieldsWithVoid = RuleSymbol.GetSubRules();
      _astFields         = _astFieldsWithVoid.Filter(rule => !(rule.Type is RuleType.Void));
    }

    private DefineAstFields() : void
    {
      foreach (rule in _astFields)
        _astTb.DefineConditional(<[decl: public $(rule.FieldName : usesite) : $(Owner.RuleTypeToNType(rule.Type) : typed) ]>);
    }

    private DefineAstCtor() : void
    {
      def args = SCG.List();
      args.Add(<[ parameter: location : N2.Location ]>);
      args.Add(<[ parameter: error : list[N2.ErrorInfo] ]>);
      def init = SCG.List();
      init.Add(<[ base(location, error) ]>);
      foreach (rule in _astFields)
      {
        args.Add(<[ parameter: $(rule.FieldName : usesite) : $(Owner.RuleTypeToNType(rule.Type) : typed)  ]>);
        init.Add(<[ this.$(rule.FieldName : usesite) = $(rule.FieldName : usesite) ]>);
      }
      _astTb.DefineConditional(<[decl: public this(..$(args.ToNList())) { ..$(init.ToNList()) } ]>);
    }

    private DefineAstGetErrors() : void
    {
      def makeGetErrors(expr : PExpr, type) : PExpr // TODO: Оптимизировать списоки токенов.
      {
        match (type : RuleType)
        {
          | _ when type.IsVoidDeep() => <[ () ]>
          | _ when Owner.RuleTypeToNType(type).TryUnify(Owner.Environment.NTokenTypeVar)
          | Chars        => <[ () ]>
          | Ref          => <[ $expr.GetErrors(errors); ]>
          | List(type)   =>
            <[
              foreach (_item in $expr)
                $(makeGetErrors(<[ $("_item" : dyn) ]>, type));
            ]>

          | Option(type) =>
            <[
              match ($expr)
              {
                | Some(_item) => $(makeGetErrors(<[ $("_item" : dyn) ]>, type));
                | _ => ()
              }
            ]>

          | Tuple(types) when types.Count(ty => !(ty is RuleType.Void)) == 1 => <[ $expr.GetErrors(errors); ]>
          | Tuple(types) =>
            def types = types.Filter(ty => !(ty is RuleType.Void));
            def fields = types.Length;
            def names = $[0..fields - 1].Map(n => <[ $($"_item$n" : dyn) ]>);
            <[
              {
                def (..$names) = $expr;
                { ..$(names.Zip(types).Map(makeGetErrors)) };
              }
            ]>
          | Void => assert(false);
        }
      }
      _astTb.DefineConditional(<[decl:
        public override GetErrors(errors : System.Collections.Generic.List[ErrorInfo]) : void
        {
          base.GetErrors(errors);
          { ..$(_astFields.Map(rule => makeGetErrors(<[ this.$(rule.FieldName : dyn) ]>, rule.Type))) }
        }
      ]>);
    }

    private DefineAstPrettyPrint() : void
    {
      def isNoNeedVar(rule : Rule) { rule.Type is RuleType.Void || rule is Rule.String }
      def isVoid(ruleType : RuleType)
      {
        | Void
        | Tuple(types) when types.ForAll(isVoid)
        | Option(type) when isVoid(type)         => true
        | _                                      => false
      }
      def fieldToString(rule : Rule) : PExpr
      {
        def loop(expr : PExpr, rule : Rule) : PExpr
        {
          def result =
            match (rule)
            {
              | String(str)                                     => <[ _ = code.Append($str); ]>
              | And | Not                                       => <[ () ]>
              | Sequence(rules)                                 => 
                def members2 = rules.MapI((i, r) => if (isNoNeedVar(r)) (<[ _ ]>, r), else (<[ $($"_item$i" : dyn) ]>, r));
                def noNeedVars = members2.ForAll((_, r) => isNoNeedVar(r));
                def varNames = $[ n | (n, r) in members2, !(r.Type is RuleType.Void) ]; // make list of names for not void rules
                def lines = members2.Map(loop);
                match (varNames)
                {
                  | _ when noNeedVars
                  | []        => <[ { ..$lines } ]>
                  | [varName] => <[ { ..$(<[ def $varName      = $expr; ]> :: lines) } ]>
                  | _         => <[ { ..$(<[ def (..$varNames) = $expr; ]> :: lines) } ]>
                }

              | Call(ruleRef, _bp) when rule.Type is RuleType.Void =>
                def Indent() : PExpr.Sequence
                { <[ 
                    Indent(code, currentIndent);
                    lastIndntEnd = code.Length;
                  ]>
                }
                def newLine() { <[ { ..$(<[ _ = code.AppendLine(); ]> :: <[ lastStartLine = code.Length; ]> :: Indent().body) } ]> }
                def Unindent() : PExpr
                { <[  currentIndent--;
                      if (lastIndntEnd == code.Length)
                      {
                        code.Length = lastStartLine;
                        Indent(code, currentIndent);
                        lastIndntEnd = code.Length;
                      }
                      else if (options %&& N2.ToStringOptions.DebugIndent)
                        _ = code.Append("!!! no new line before indentation decreasing !!!")
                      else
                        $(newLine());
                  ]>
                }
                match (ruleRef.Ref.Value.Name)
                {
                  | "S"
                  | "s"   => <[ () ]> // TODO: add analysis of a space usefulness
                  | "nl"  => newLine()
                  | "inl" 
                  | "nli" => <[ currentIndent++; $(newLine()) ]>
                  | "d"   => Unindent()
                  | "i"   => <[ currentIndent++; 
                                when (options %&& N2.ToStringOptions.DebugIndent && lastStartLine != code.Length)
                                  _ = code.Append("!!! The indentation increasing not from the beginning of line. !!!");
                                $(Indent()); ]>
                  | _     => <[ _ = code.Append(' '); ]>
                }

              | Call when rule.Type is RuleType.Chars           => <[ def tok = $expr; _ = code.Append(this.Location.Source.Text, tok.StartPos, tok.Length); ]>
              | Call                                            => <[ $expr.PrettyPrint(code, currentIndent, options, ref lastStartLine, ref lastIndntEnd); ]>
              | Repeat(_, _, rule) when isVoid(rule.Type)       => <[ _ = code.Append(' '); ]>
              | Repeat(0, Some(1), rule)                        => <[ when ($expr is Some(_x)) $(loop(<[ _x ]>, rule)) ]>
              | Repeat(_, _, rule)                              => <[ foreach (_elem in $expr) $(loop(<[ _elem ]>, rule)); ]>
              | RepeatWithSeparator(_, _, rule, separator, _)   => 
                if (separator.GetAllSubRules().ForAll(isNoNeedVar))
                  <[  def (elems, separators) = $expr;
                      assert2(elems.IsEmpty || elems.Length >= separators.Length);
                      def endIndex = separators.Length;
                      
                      foreach (elem in elems with i)
                      {
                        $(loop(<[ elem ]>, rule));
                    
                        when (endIndex != i)
                          $(loop(<[ separator ]>, separator));
                      } ]>
                else
                  <[  def (elems, separators) = $expr;
                      assert2(elems.IsEmpty || elems.Length >= separators.Length);
                      mutable separatorRest = separators;
                    
                      foreach (elem in elems)
                      {
                        $(loop(<[ elem ]>, rule));
                    
                        unless (separatorRest.IsEmpty)
                        {
                          def separator = separatorRest.Head;
                          $(loop(<[ separator ]>, separator));
                          separatorRest = separatorRest.Tail;
                        }
                      } ]>
            };
          result
        }
        loop(<[ this.$(rule.FieldName : dyn) ]>, rule);
      }

      def code = _astFieldsWithVoid.Map(fieldToString);
      def body = <[ { ..$code } ]>;
      _astTb.DefineConditional(<[ decl: 
        public override PrettyPrint(code : System.Text.StringBuilder, mutable currentIndent : int, options : N2.ToStringOptions, 
          lastStartLine : ref int, lastIndntEnd : ref int) : void
        {
          ignore(currentIndent, options, currentIndent, lastStartLine, lastIndntEnd);
          $body
        }
      ]>);
    }

    private DefineAstGetDump() : void
    {
      def makeDump(expr : PExpr, type) : PExpr // TODO: Оптимизировать списоки токенов.
      {
        match (type : RuleType)
        {
          | _ when type.IsVoidDeep() => <[ () ]>
          | _ when Owner.RuleTypeToNType(type).TryUnify(Owner.Environment.NTokenTypeVar)
          | Chars        => <[ N2.Internal.AstDump.Token(GetText($expr)) ]>
          | Ref          => <[ $expr.GetDump(); ]>
          | List(type)   =>
            <[
              N2.Internal.AstDump.List($expr.Map(fun(_item)
              {
                $(makeDump(<[ $("_item" : dyn) ]>, type))
              }))
            ]>

          | Option(Void) => <[ () ]>
          | Option(type) =>
            <[
              match ($expr)
              {
                | Some(_item) => N2.Internal.AstDump.Option(Some($(makeDump(<[ $("_item" : dyn) ]>, type))));
                | _ => N2.Internal.AstDump.Option(None())
              }
            ]>

          | Tuple(types) when types.Count(ty => !(ty is RuleType.Void)) == 1 => <[ $expr.GetDump(); ]>
          | Tuple(types) =>
            def types = types.Filter(ty => !(ty is RuleType.Void));
            def fields = types.Length;
            def names = $[0..fields - 1].Map(n => <[ $($"_item$n" : dyn) ]>);
            <[
              {
                def (..$names) = $expr;
                N2.Internal.AstDump.Tuple([..$(names.Zip(types).Map(makeDump))]);
              }
            ]>

          | Void => assert(false);
        }
      }
      def makeFieldDump(rule) : PExpr
      {
        <[ N2.Internal.AstDump.Field($(rule.FieldName : string), $(makeDump(<[ this.$(rule.FieldName : dyn) ]>, rule.Type))) ]>
      }
      _astTb.DefineConditional(<[decl:
        public override GetDump() : N2.Internal.AstDump
        {
          N2.Internal.AstDump.Ast($(_baseTb.FullName : string), [..$(_astFields.Map(makeFieldDump))])
        }
      ]>);
    }

    private DefineSpliceGetDump() : void
    {
      _spliceTb.DefineConditional(<[decl:
        public override GetDump() : N2.Internal.AstDump
        {
          N2.Internal.AstDump.Splice($(_baseTb.FullName : string))
        }
      ]>);
    }

    private DefineErrorGetDump() : void
    {
      _errorTb.DefineConditional(<[decl:
        public override GetDump() : N2.Internal.AstDump
        {
          N2.Internal.AstDump.Error($(_baseTb.FullName : string), GetText())
        }
      ]>);
    }

    private DefineBaseAstExtraFields() : void
    {
      foreach (field in RuleSymbol.ExtraFields)
      {
        | ExtraField.AbstractSymbol  (Signature = signature, IsCached = isCached)
        | ExtraField.DefPrivateSymbol(Signature = signature, IsCached = isCached) =>
          def n     = <[ $(field.Name : dyn) ]>.name;
          def attrs = <[ N2.Runtime.ExtraFieldAttribute($(isCached : bool)) ]>;
          when (isCached)
            _baseTb.Define(<[ decl: public virtual $(cachingPropertyName(n) : name) : $(signature.Type) { get { throw System.NotImplementedException(); } } ]>);
          _baseTb.Define(<[ decl: [$attrs] public abstract $(n : name)(..$(signature.Params)) : $(signature.Type); ]>);

        | ExtraField.DefSymbol (Signature = signature, IsCached = isCached, Body = body) =>
          def n     = <[ $(field.Name : dyn) ]>.name;
          def attrs = <[ N2.Runtime.ExtraFieldAttribute($(isCached : bool)) ]>;
          if (RuleSymbol is SimpleRuleSymbol)
          {
            when (isCached)
              _baseTb.Define(<[ decl: public virtual $(cachingPropertyName(n) : name) : $(signature.Type) { get { throw System.NotImplementedException(); } } ]>);
            _baseTb.Define(<[ decl: [$attrs] public abstract $(n : name)(..$(signature.Params)) : $(signature.Type); ]>);
          }
          else
          {
            def body2 = if (isCached) addCaching(_baseTb, n, signature.Type, body.Expr, false) else body.Expr;
            def body3 = addRecursionCheck(_baseTb, body2);
            _baseTb.Define(<[ decl: [$attrs] public virtual  $(n : name)(..$(signature.Params)) : $(signature.Type) $body3 ]>);
          }

        | _ => ()
      }
    }

    private DefineAstExtraFields() : void
    {
      foreach (field in RuleSymbol.ExtraFields)
      {
        | ExtraField.DefPrivateSymbol (Signature = signature, IsCached = isCached, Body = body)
        | ExtraField.DefSymbol        (Signature = signature, IsCached = isCached, Body = body) when (RuleSymbol is SimpleRuleSymbol) => 
          def n     = <[ $(field.Name : dyn) ]>.name;
          def attrs = <[ N2.Runtime.ExtraFieldAttribute($(isCached : bool)) ]>;
          def body2 = if (isCached) addCaching(_astTb, n, signature.Type, body.Expr, true) else body.Expr;
          def body3 = addRecursionCheck(_astTb, body2);
          _astTb.Define(<[  decl: [$attrs] public override $(n : name)(..$(signature.Params)) : $(signature.Type) $body3 ]>);

        | ExtraField.OverrideSymbol(BaseExtraField = baseExtraFieldSymbol, Body = body) =>
          def n          = <[ $(field.Name : dyn) ]>.name;
          def signature  = baseExtraFieldSymbol.Ref.Value.GetExtraFieldSignature();
          def isCached   = baseExtraFieldSymbol.Ref.Value.GetExtraFieldIsCached();
          def parameters = signature.Params;
          def type       = signature.Type;
          def attrs      = <[ N2.Runtime.ExtraFieldAttribute($(isCached : bool)) ]>;
          def body2      = if (isCached) addCaching(_astTb, n, type, body.Expr, true) else body.Expr;
          def body3      = addRecursionCheck(_astTb, body2);
          _astTb.Define(<[ decl: [$attrs] public override $(n : name)(..$parameters) : $type $body3 ]>);

        | _ => ()
      }
    }

    private DefineSpliceExtraFields() : void
    {
      foreach (field in RuleSymbol.ExtraFields)
      {
        | ExtraField.AbstractSymbol  (Signature = signature)
        | ExtraField.DefPrivateSymbol(Signature = signature)
        | ExtraField.DefSymbol       (Signature = signature) =>
          def n    = <[ $(field.Name : dyn) ]>.name;
          def body = SCG.List();
          foreach (p in signature.Params)
            body.Add(<[ _ = $(p.ReferencingExpr); ]>);
          body.Add(<[ throw System.InvalidOperationException("This method should not be invoked.") ]>);
          _spliceTb.Define(<[ decl:
            public override $(n : name)(..$(signature.Params)) : $(signature.Type)
            {
              ..$(body.ToNList())
            }
          ]>);

        | _ => ()
      }
    }

    private DefineErrorExtraFields() : void
    {
      def extraFieldsWithErrorHandler = SCG.HashSet();
      foreach (field is ExtraField.OnErrorSymbol in RuleSymbol.ExtraFields)
        _ = extraFieldsWithErrorHandler.Add(field.HandlingExtraField.Ref.Value);

      foreach (field in RuleSymbol.ExtraFields)
      {
        | ExtraField.AbstractSymbol  (Signature = signature)
        | ExtraField.DefPrivateSymbol(Signature = signature) when !extraFieldsWithErrorHandler.Contains(field)
        | ExtraField.DefSymbol       (Signature = signature) when !extraFieldsWithErrorHandler.Contains(field) =>
          def n    = <[ $(field.Name : dyn) ]>.name;
          def body = SCG.List();
          foreach (p in signature.Params)
            body.Add(<[ _ = $(p.ReferencingExpr); ]>);
          def msg = $"Parse error handling for '$(field.Name)' extra field of '$(RuleSymbol.Name)' rule is not implemented.";
          body.Add(<[ throw System.NotImplementedException($(msg : string)) ]>);
          _errorTb.Define(<[ decl:
            public override $(n : name)(..$(signature.Params)) : $(signature.Type)
            {
              ..$(body.ToNList())
            }
          ]>);

        | ExtraField.OnErrorSymbol(Body = body) =>
          def n          = <[ $(field.Name : dyn) ]>.name;
          def signature  = field.GetExtraFieldSignature();
          def parameters = signature.Params;
          def type       = signature.Type;
          _errorTb.Define(<[ decl: public override $(n : name)(..$parameters) : $type $(body.Expr) ]>);

        | _ => ()
      }
    }

    private static cachingPropertyName(extraFieldName : Name) : Name
    {
      regexp match (extraFieldName.Id)
      {
        | "(Get|Compute|Calculate|Calc|Create|Make|Evaluate|Eval)(?<baseName>.*)" => <[ $(baseName : usesite) ]>.name
        | _ =>  <[ $("Computed" + extraFieldName.Id : usesite) ]>.name
      }
    }

    private static addRecursionCheck(tb : TypeBuilder, body : PExpr) : PExpr.Sequence
    {
      def bitField = tb.GetBitFieldManager().Allocate();
      <[
        when ($(bitField.Read()))
          throw System.InvalidOperationException("Recursion detected (see stack trace for details).");
        $(bitField.Set());
        try $body
        finally $(bitField.Clear());
      ]>
    }

    private static addCaching(tb : TypeBuilder, name : Name, type : PExpr, body : PExpr, isOverride : bool) : PExpr
    {
      def bitField = tb.GetBitFieldManager().Allocate();
      def fieldName = <[ $(Util.tmpname(name.Id + "_cache") : usesite) ]>.name;
      tb.Define(<[ decl: private mutable $(fieldName : name) : $type ]>);
      def mods = Modifiers(NemerleModifiers.Public %| if (isOverride) NemerleModifiers.Override else NemerleModifiers.Virtual, []);
      tb.Define(<[ decl:
        ..$mods $(cachingPropertyName(name) : name) : $type
        {
          get
          {
            unless ($(bitField.Read()))
            {
              //FIXME: fix compiler bug!!
              //assert2(false, "Extra field value not computed yet.");
              throw System.InvalidOperationException("Extra field value not computed yet.");
            }
            $(fieldName : name);
          }
        }
      ]>);

      <[
        if ($(bitField.Read()))
          $(fieldName : name);
        else
        {
          $(fieldName : name) = $body;
          $(bitField.Set());
          $(fieldName : name);
        }
      ]>
    }
  }
}
