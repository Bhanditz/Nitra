using N2.Model;
using N2.Typing;

using Nemerle;
using Nemerle.Collections;
using Nemerle.Compiler.Parsetree;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;

namespace N2.Compiler
{
  [Record]
  public class HighlighterWalkerGenerator : WalkerGenerator
  {
    public Environment : EmitterEnvironment { get; }

    public override Name : string { get "Highlighter" }

    public override GetWalkerTypeDescriptorExpr() : PExpr
    {
      <[ N2.Runtime.HighlighterWalkerTypeDescriptor.StaticDescriptor ]>
    }

    public override GetSignature(_rule : RuleSymbol) : WalkerSignature
    {
      WalkerSignature(
        [
          <[ parameter: spans    : System.Collections.Generic.List[N2.SpanInfo] ]>, 
          <[ parameter: startPos : int ]>, 
          <[ parameter: endPos   : int ]>
        ],
        <[ void ]>);
    }

    protected override GetRuleValue(field : RuleStructureField, parentAstPointer : void -> AstPointer) : PExpr
    {
      def fieldLocCode = GetRangeOf(field, parentAstPointer);
      
      match (field)
      {
        | SimpleCall(ruleSymbol) with bp = 0
        | ExtensibleCall(ruleSymbol, bp) =>
          <[  if ($fieldLocCode.IntersectsWith(startPos, endPos))
                $(CallSyntaxRule(ruleSymbol, bp, <[ spans ]>, <[ startPos ]>, <[ endPos ]>))
              else
                $(Skip(field, parentAstPointer)) ]>

        | TokenCall(symbol) =>
          if (symbol.Options.SpanClassSymbol != null)
            <[  def loc = $fieldLocCode;
                if (loc.IntersectsWith(startPos, endPos))
                  spans.Add(N2.SpanInfo(loc, 
                    $(MakeSpanClassFieldName(symbol.Options.SpanClassSymbol))))
                else
                  $(Skip(field, parentAstPointer)) ]>
          else
            Skip(field, parentAstPointer)

        | TokenString =>
          def rule = field.SrcRule :> Rule.String;
          
          if (rule.SpanClassOpt is Some(spanClass))
          <[  if ($fieldLocCode.IntersectsWith(startPos, endPos))
                spans.Add(N2.SpanInfo($fieldLocCode, 
                  $(MakeSpanClassFieldName(spanClass))))
              else
                $(Skip(field, parentAstPointer))]>
          else
            Skip(field, parentAstPointer)

        | Option as field =>
          GetOptionValue(
            field            = field,
            parentAstPointer = parentAstPointer,
            hasValue         = <[ _ = $(GetRuleValue(field.Rule, "valuePointer")); ]>,
            noValue          = <[ () ]>)

        | List as lst=>
          GetListValue(field            = lst,
            parentAstPointer = parentAstPointer,
            init             = <[ () ]>,
            item             = GetRuleValue(lst.Rule, "itemPointer"),
            returnCode       = <[ () ]>,
            emptyCode        = <[ () ]>);

        | ListWithSeparator as lst=>
          GetListWithSeparatorValue(
            field            = lst,
            parentAstPointer = parentAstPointer,
            init             = <[ () ]>,
            item             = GetRuleValue(lst.Rule, "itemPointer"),
            separator        = GetRuleValue(lst.Separator, "separatorPointer"),
            returnCode       = <[ () ]>,
            emptyCode        = <[ () ]>);
            
        | Predicate => assert(false)
      }
    }
    
    MakeSpanClassFieldName(spanClassSymbol : SpanClassSymbol) : PExpr
    {
      assert2(spanClassSymbol != null);
      def expr = PExprUtils.FromQualifiedIdentifier(spanClassSymbol.DeclaringModule.Node.FullNameParts);
      <[ $expr.$("SpanClass_" + spanClassSymbol.Name : usesite) ]>
    }

    protected override CombineValues(_ruleStructure : RuleStructure, _arguments : list[PExpr]) : PExpr
    {
      <[ () ]>
    }

    protected override GetSyntaxRuleValue(ruleSymbol : SyntaxRuleSymbol, astPointer : void -> AstPointer) : PExpr
    {
      def loc = <[ N2.NToken(startPos, pos) ]>;
      def ruleStruct = ruleSymbol.Structure;
      def statementsList = List();

      foreach (field in ruleStruct.Fields)
        statementsList.Add(GetRuleValue(field, astPointer));
        
      def statements = statementsList.NToList();

      if (ruleSymbol.Options.SpanClassSymbol != null)
        <[ 
          def loc = $loc;
          { ..$statements }
          when (loc.IntersectsWith(startPos, endPos))
            spans.Add(N2.SpanInfo(loc, 
              $(MakeSpanClassFieldName(ruleSymbol.Options.SpanClassSymbol))))
        ]>
      else
        <[ { ..$statements } ]>
    }
  }
  
  //protected override MakeGenerator(ruleStruct : RuleStructure.Ast) : WalkerCode
  //{
  //  def makeCodeForField(field : RuleStructureField) : PExpr
  //  {
  //    def fieldLocCode = NTokenOf(field);
  //
  //    match (field)
  //    {
  //      | SimpleCall(ruleSymbol) | ExtensibleCall(ruleSymbol , _) =>
  //        <[  when ($fieldLocCode.IntersectsWith(startPos, endPos))
  //              $(MakeVisit(field))(spans, startPos, endPos) ]>
  //
  //      | TokenCall(symbol) =>
  //        if (symbol.Options.SetSpanClass != null)
  //          <[ 
  //            def loc = $fieldLocCode;
  //            when (loc.IntersectsWith(startPos, endPos))
  //              spans.Add(N2.SpanInfo(loc, 
  //                $(MakeSpanClassFieldName(symbol.Options.SetSpanClass.Name) : usesite)))
  //          ]>
  //        else
  //          <[ () ]>
  //        
  //      | String(str, None) => ()
  //      | String(str, Some(spanClass)) =>
  //        <[  when ($fieldLocCode.IntersectsWith(startPos, endPos))
  //              spans.Add(N2.SpanInfo($fieldLocCode, 
  //                $(MakeSpanClassFieldName(spanClass.Name) : usesite))) ]>
  //
  //      | Option(subRuleStruct) as field =>
  //        MakeOption(field, MakeCodeForStruct(subRuleStruct))
  //
  //      | List(subRuleStruct, _, _) as lst =>
  //        // если MakeCodeForStruct(subRuleStruct) вернет <[ () ]> 
  //        // то результатом ForEach будет <[ () ]>
  //        MakeForEach(lst, MakeCodeForStruct(subRuleStruct))
  //
  //      | ListWithSeparator(ruleStruct, separatorStruct, _, _) as lst =>
  //        // если MakeCodeForStruct(subRuleStruct) вернет <[ () ]> 
  //        // то результатом ForEachWithSeparator будет <[ () ]>
  //        MakeForEachWithSeparator(lst, 
  //          makeCodeForField(ruleStruct), makeCodeForField(separatorStruct))
  //            
  //      | Predicate => ()
  //    }
  //  }
  //
  //  def code = MakeCodeForStruct(ruleStruct);
  //  def codeForAst =
  //    if (symbol.Options.SetSpanClass != null)
  //      <[ 
  //        { ..$code }
  //        def loc = $(NTokenOf(ruleStruct));
  //        when (loc.IntersectsWith(startPos, endPos))
  //          spans.Add(N2.SpanInfo(loc, 
  //            $(MakeSpanClassFieldName(symbol.Options.SetSpanClass.Name) : usesite)))
  //      ]>
  //    else
  //      <[ ..$code ]>;
  //
  //  WalkerCode(codeForAst, 
  //        [<[ parameter: spans    : System.Collections.Generic.List[N2.SpanInfo] ]>,
  //         <[ parameter: startPos : int ]>,
  //         <[ parameter: endPos   : int ]>
  //        ], 
  //        <[ void ]>)
  //}
  //
  //MakeCodeForStruct(ruleStruct : RuleStructure) : PExpr
  //{
  //  def code = ruleStruct.Fields.Map(GetRuleValue);
  //  <[ ..$code ]>
  //}
}
