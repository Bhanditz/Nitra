using N2.Model;
using N2.Typing;

using Nemerle;
using Nemerle.Imperative;
using Nemerle.Collections;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;

namespace N2.Compiler
{
  public sealed partial class WalkerEmitter
  {
    [Record]
    private sealed class ExtensibleRuleWalkerEmitter : RuleWalkerEmitter[ExtensibleRuleSymbol]
    {
      [RecordIgnore] private mutable _prefixWalkerTB  : TypeBuilder;
      [RecordIgnore] private mutable _postfixWalkerTB : TypeBuilder;
      [RecordIgnore] public          WalkerDataTb     : TypeBuilder { get; private set; }
      [RecordIgnore] public override WalkerTb         : TypeBuilder { get; private set; }

      public override RuleParserBaseType : PExpr
      {
        get { assert(false) }
      }

      public override Define(walkersModule : TypeBuilder) : void
      {
        Generator.Init(this);

        def signature = Generator.GetSignature(Rule);
        def returnTypeIsVoid = signature.ReturnType is <[ void ]>; // TODO: сделать более точную проверку на void

        _prefixWalkerTB = walkersModule.DefineNestedType({
          def prefixParameters =
            <[ parameter: pos : ref int ]>
            :: <[ parameter: astPtr : int ]>
            :: <[ parameter: parser : N2.Internal.Parser ]>
            :: signature.Parameters;

          <[ decl:
            public abstract class $(Rule.DecorateWalkerName("PrefixWalker") : usesite) : N2.Runtime.WalkerBase
            {
              public abstract Walk(..$prefixParameters) : $(signature.ReturnType);
            }
          ]>
        });

        _postfixWalkerTB = walkersModule.DefineNestedType({
          def postfixParameters =
          {
            def mandatoryParameters =
              <[ parameter: __startPos : int ]>
              :: <[ parameter: pos : ref int ]>
              :: <[ parameter: astPtr : int ]>
              :: <[ parameter: parser : N2.Internal.Parser ]>
              :: signature.Parameters;

            if (returnTypeIsVoid) mandatoryParameters
            else <[ parameter: prefix : $(signature.ReturnType) ]> :: mandatoryParameters;
          }

          <[ decl:
            public abstract class $(Rule.DecorateWalkerName("PostfixWalker") : usesite) : N2.Runtime.WalkerBase
            {
              public abstract Walk(..$postfixParameters) : $(signature.ReturnType);
            }
          ]>
        });

        WalkerDataTb = walkersModule.DefineNestedType(<[ decl:
          public sealed class $(Rule.DecorateWalkerName("WalkerData") : usesite) : N2.Runtime.ExtensibleRuleWalkerData
          {
            public PrefixWalkers      : array[$(_prefixWalkerTB.GetMemType() : typed)];
            public PostfixWalkers     : array[$(_postfixWalkerTB.GetMemType() : typed)];

            public this(parserData : N2.Internal.ExtensibleRuleParserData, compositeAstWalker : N2.Runtime.CompositeAstWalker)
            {
              base(compositeAstWalker);

              PrefixWalkers = array(parserData.PrefixParsers.Length);
              foreach (parser in parserData.PrefixParsers with i)
                PrefixWalkers[i] = compositeAstWalker.NewWalker(parser) :> $(_prefixWalkerTB.GetMemType() : typed);

              PostfixWalkers = array(parserData.PostfixParsers.Length);
              foreach (parser in parserData.PostfixParsers with i)
                PostfixWalkers[i] = compositeAstWalker.NewWalker(parser) :> $(_postfixWalkerTB.GetMemType() : typed);

              Walkers = array(parserData.Parsers.Count);
              foreach (parser when parser != null in parserData.Parsers with bp)
                Walkers[bp] = NewWalker(parser);
            }

            public override Init() : void
            {
              foreach (walker in PrefixWalkers)
                walker.Init(CompositeAstWalker);
              foreach (walker in PostfixWalkers)
                walker.Init(CompositeAstWalker);
            }
          }
        ]>);

        WalkerTb = walkersModule.DefineNestedType(<[ decl:
          public sealed class $(Rule.DecorateWalkerName("Walker") : usesite) : N2.Runtime.ExtensibleRuleWalkerBase
          {
            public PrefixWalkers : array[$(_prefixWalkerTB.GetMemType() : typed)];
            public PostfixWalkers : array[$(_postfixWalkerTB.GetMemType() : typed)];

            public this(walkerData : $(WalkerDataTb.GetMemType() : typed), parser : N2.Internal.ExtensibleRuleParser)
            {
              base(parser);

              PrefixWalkers         = walkerData.PrefixWalkers;
              PostfixWalkers        = walkerData.PostfixWalkers;
            }
          }
        ]>);

        unless (Environment.IsIdeMode)
        {
          def onPrefixAmbiguityParameters =
          {
            def ambiguityListType =
              if(returnTypeIsVoid) <[ System.Collections.Generic.List[$(_prefixWalkerTB.GetMemType() : typed)] ]>
              else <[ System.Collections.Generic.List[$(signature.ReturnType) * $(_prefixWalkerTB.GetMemType() : typed)] ]>;

            <[ parameter: __startPos : int ]>
            :: <[ parameter: endPos : int ]>
            :: <[ parameter: parser : N2.Internal.Parser ]>
            :: <[ parameter: ambiguities : $ambiguityListType ]>
            :: signature.Parameters;
          };

          WalkerTb.DefineConditional(<[ decl:
            private OnPrefixAmbiguity(..$onPrefixAmbiguityParameters) : $(signature.ReturnType)
            {
              $(Generator.PrefixAmbiguity(Rule).FlattenPExpr());
            }
          ]>);
        }

        unless (Environment.IsIdeMode)
        {
          def onPostfixAmbiguityParameters =
          {
            def ambiguityListType =
              if(returnTypeIsVoid) <[ System.Collections.Generic.List[$(_postfixWalkerTB.GetMemType() : typed)] ]>
              else <[ System.Collections.Generic.List[$(signature.ReturnType) * $(_postfixWalkerTB.GetMemType() : typed)] ]>;

            <[ parameter: __startPos : int ]>
            :: <[ parameter: endPos : int ]>
            :: <[ parameter: parser : N2.Internal.Parser ]>
            :: <[ parameter: ambiguities : $ambiguityListType ]>
            :: signature.Parameters;
          };

          WalkerTb.DefineConditional(<[ decl:
            private OnPostfixAmbiguity(..$onPostfixAmbiguityParameters) : $(signature.ReturnType)
            {
              $(Generator.PostfixAmbiguity(Rule).FlattenPExpr());
            }
          ]>);
        }

        unless (Environment.IsIdeMode)
        {
          def onPrefixMissedParameters =
            <[ parameter: pos : int ]>
            :: <[ parameter: parser : N2.Internal.Parser ]>
            :: signature.Parameters;

          WalkerTb.DefineConditional(<[ decl:
            private OnPrefixMissed(..$onPrefixMissedParameters) : $(signature.ReturnType)
            {
              $(Generator.PrefixMissed(Rule).FlattenPExpr());
            }
          ]>);
        }

        def walkParameters =
          <[ parameter: pos : ref int ]>
          :: <[ parameter: parser : N2.Internal.Parser ]>
          :: signature.Parameters;

        def onPrefixAmbiguityArguments =
          <[ pos ]>
          :: <[ firstNewPos ]>
          :: <[ parser ]>
          :: <[ ambiguilitys ]>
          :: signature.Parameters.Map(PassParameter);

        def onPostfixAmbiguityArguments =
          <[ pos ]>
          :: <[ firstNewPos ]>
          :: <[ parser ]>
          :: <[ ambiguilitys ]>
          :: signature.Parameters.Map(PassParameter);

        def onPrefixMissedArguments =
          <[ pos ]>
          :: <[ parser ]>
          :: signature.Parameters.Map(PassParameter);

        def prefixWalkCallArguments =
          <[ ref newPos ]>
          :: <[ ast ]>
          :: <[ parser ]>
          :: signature.Parameters.Map(PassParameter);

        def postfixWalkCallArguments =
        {
          def mandatoryArguments =
            <[ prefixStartPos ]>
            :: <[ ref newPos ]>
            :: <[ ast ]>
            :: <[ parser ]>
            :: signature.Parameters.Map(PassParameter);

          if (returnTypeIsVoid) mandatoryArguments
          else <[ prefixValue ]> :: mandatoryArguments
        };

        def addAmbiguilityArguments(valueExpr, walkerExpr)
        {
          if (returnTypeIsVoid)
            walkerExpr
          else
            <[ ($valueExpr, $walkerExpr) ]>
        }

        def walkCode =
          if (Environment.IsIdeMode)
            <[ assert(false) ]>
          else
          <[
            mutable newPos;
            mutable ast = FindFirstPrefix(ref pos, parser);
            if (ast > 0)
            {
              mutable prefixWalker = PrefixWalkers[parser.ast[ast + N2.Internal.ExtensibleRuleParser.AstOfs.Id] - PrefixWalkersOffset];
              newPos = pos;
              def prefixStartPos = pos;
              mutable prefixValue = prefixWalker.Walk(..$prefixWalkCallArguments);
              ast = FindNextPrefix(ast, parser);
              when (ast > 0)
              {
                def firstNewPos = newPos;
                def ambiguilitys = System.Collections.Generic.List();
                ambiguilitys.Add($(addAmbiguilityArguments(<[ prefixValue ]>, <[ prefixWalker ]>)));
                while (ast > 0)
                {
                  def nextPrefixWalker = PrefixWalkers[parser.ast[ast + N2.Internal.ExtensibleRuleParser.AstOfs.Id] - PrefixWalkersOffset];
                  newPos = pos;
                  def _nextValue = nextPrefixWalker.Walk(..$prefixWalkCallArguments);
                  assert(newPos == firstNewPos);
                  ambiguilitys.Add($(addAmbiguilityArguments(<[ _nextValue ]>, <[ nextPrefixWalker ]>)));
                  prefixWalker = nextPrefixWalker;
                  ast = FindNextPrefix(ast, parser);
                }
                prefixValue = OnPrefixAmbiguity(..$onPrefixAmbiguityArguments);
              }
              pos = newPos;

              mutable postfixWalker;
              mutable postfixValue;
              while (pos < parser.Text.Length && { ast = FindFirstPostfix(pos, parser); ast > 0 })
              {
                postfixWalker = PostfixWalkers[(parser.ast[ast + N2.Internal.ExtensibleRuleParser.AstOfs.Id] & N2.Internal.ExtensibleRuleParser.AstMask.Id) - PostfixWalkersOffset];
                newPos = pos;
                postfixValue = postfixWalker.Walk(..$postfixWalkCallArguments);
                when (newPos == pos)
                  break;
                ast = FindNextPostfix(ast, parser);
                when (ast > 0)
                {
                  def firstNewPos = newPos;
                  def ambiguilitys = System.Collections.Generic.List();
                  ambiguilitys.Add($(addAmbiguilityArguments(<[ postfixValue ]>, <[ postfixWalker ]>)));
                  while (ast > 0)
                  {
                    def nextWalker = PostfixWalkers[(parser.ast[ast + N2.Internal.ExtensibleRuleParser.AstOfs.Id] & N2.Internal.ExtensibleRuleParser.AstMask.Id) - PostfixWalkersOffset];
                    newPos = pos;
                    def _nextValue = nextWalker.Walk(..$postfixWalkCallArguments);
                    assert(newPos == firstNewPos);
                    ambiguilitys.Add($(addAmbiguilityArguments(<[ _nextValue ]>, <[ nextWalker ]>)));
                    postfixWalker = nextWalker;
                    ast = FindNextPostfix(ast, parser);
                  }
                  postfixValue = OnPostfixAmbiguity(..$onPostfixAmbiguityArguments);
                }
                prefixValue = postfixValue;
                pos = newPos;
              }
              prefixValue;
            }
            else
            {
              OnPrefixMissed(..$onPrefixMissedArguments);
            }
          ]>;

        WalkerTb.DefineConditional(<[ decl:
          public Walk(..$walkParameters) : $(signature.ReturnType)
          {
            unchecked { $walkCode; }
          }
        ]>);

        WalkerDataTb.Define(<[ decl:
          public Walkers : array[$(WalkerTb.GetMemType() : typed)];
        ]>);

        WalkerDataTb.Define(<[decl:
          public NewWalker(parser : N2.Internal.ExtensibleRuleParser) : $(WalkerTb.GetMemType() : typed)
          {
            $(WalkerTb.GetMemType() : typed)(this, parser)
          }
        ]>);

        WalkerDataTb.Define(<[decl:
          public override GetWalkers() : array[N2.Runtime.ExtensibleRuleWalkerBase]
          {
            this.Walkers :> array[N2.Runtime.ExtensibleRuleWalkerBase]
          }
        ]>);

        when (Rule.Options.IsStart)
          DefineEntranceMethod(walkersModule, signature);
      }

      public override Emit() : void
      {
        _prefixWalkerTB.Compile();
        _postfixWalkerTB.Compile();
        WalkerDataTb.Compile();
        WalkerTb.Compile();
      }
    }
  }
}
