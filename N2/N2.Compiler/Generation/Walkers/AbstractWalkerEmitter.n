using Nemerle;
using Nemerle.Collections;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Text;
using Nemerle.Utility;

using N2.Model;
using N2.Typing;

using System;
using System.Collections.Generic;
using System.Linq;

namespace N2.Compiler
{
  internal class AbstractWalkerEmitter : IVariableEmitter
  {
    public Owner      : SyntaxModuleEmitter { get; }
    public RuleSymbol : SyntaxRuleSymbol    { get; }
    public TB         : TypeBuilder         { get { assert(_tb != null); _tb; } }

    public this(owner : SyntaxModuleEmitter, ruleSymbol : SyntaxRuleSymbol)
    {
      Owner = owner;
      RuleSymbol = ruleSymbol;
    }

    mutable _tb : TypeBuilder;

    Environment : EmitterEnvironment implements IVariableEmitter.Environment { get { Owner.Environment } }

    CreateVariable(name : string) : PExpr implements IVariableEmitter.CreateVariable
    {
      <[ $(name : dyn) ]>
    }

    public RuleParserBaseType : PExpr
    {
      get
      {
        match (RuleSymbol)
        {
          | SimpleRuleSymbol    => <[ N2.Internal.SimpleRuleParser ]>
          | ExtentionRuleSymbol => <[ N2.Internal.ExtentionRuleParser ]>
          | _                   => assert(false)
        }
      }
    }

    public DefineTypes() : void
    {
      assert(_tb == null);
      _tb = Owner.GrammarTB.DefineNestedType(<[ decl:
        public class $(RuleSymbol.Name + "Walker" : usesite) : $(GetWalkerBaseType(RuleSymbol))
        {
          private RuleParser : $(RuleSymbol.GetParserClassRef());
          public this(ruleParser : $(RuleParserBaseType))
          {
            RuleParser = ruleParser :> $(RuleSymbol.GetParserClassRef());
          }
        }
      ]>);
    }

    public DefineMembers(rootAstStruct : option[RootAstStruct]) : void
    {
      assert(_tb != null);

      def parms =
        <[ parameter: $("location" : usesite) : N2.Location ]>
        :: <[ parameter: $("errorInfo" : usesite) : list[N2.ErrorInfo] ]> //TODO: удалить этот параметр
        :: RuleSymbol.NonVoidSubRules.Map(r => <[ parameter: $(r.FieldName : usesite) : $(Owner.Environment.RuleTypeToNType(r.Type) : typed) ]>);
      _tb.DefineConditional(<[ decl:
        public Accept(..$parms) : $(Owner.Environment.RuleTypeToNType(RuleSymbol.Type) : typed)
        {
          $(Owner.Environment.NTypeOfRuleSymbol(RuleSymbol) : typed).Ast(..$(parms.Map(p => <[ $(p.Name : usesite) ]>)))
        }
      ]>);

      def referencedWalkers = GetDependencies(RuleSymbol);
      foreach(p in referencedWalkers)
        _tb.Define(<[ decl: private mutable $(p.Value.FieldName : usesite) : $(GetWalkerType(p.Key[0])) ]>);

      def initBody = List();
      foreach (id in rootAstStruct.Value.RuleField.Compiler.InternalRuleIds.Values)
      {
        _tb.DefineConditional(<[decl: private mutable $(id : dyn) : int; ]>);
        initBody.Add(<[ $(id : dyn) = RuleParser. $(id : dyn); ]>);
      }
      initBody.Add(<[ ignore(compositeAstWalker) ]>);
      foreach (p in referencedWalkers)
      {
        def walkerInfo = p.Value;
        match (p.Key)
        {
          | (ExtensibleRuleSymbol as s, bp) =>
            initBody.Add(<[ this.$(walkerInfo.FieldName : usesite) = compositeAstWalker.GetWalker($(s.GetDescriptorClassRef()).StaticDescriptor, $(bp : int)) ]>);

          | (s, _) =>
            initBody.Add(<[ this.$(walkerInfo.FieldName : usesite) = compositeAstWalker.GetWalker($(s.GetDescriptorClassRef()).StaticDescriptor) ]>);
        }
      }
      when (RuleSymbol is SimpleRuleSymbol)
        _tb.DefineConditional(<[ decl: 
          public override RuleId : int { get { RuleParser.RuleId } }
        ]>);
      _tb.DefineConditional(<[ decl: 
        public override Init(compositeAstWalker : N2.Runtime.CompositeAstWalker) : void
        {
          ..$(initBody.ToNList())
        }
      ]>);

      DefineWalkMethod(rootAstStruct, referencedWalkers);
    }

    private DefineWalkMethod(rootAstStruct : option[RootAstStruct], referencedWalkers : Hashtable[RuleSymbol * int, WalkerInfo]) : void
    {
      def rootAstMaker(arguments : list[PExpr]) : PExpr
      {
        def acceptArgs =
          <[ N2.Location(parser.Source, startPos, pos) ]>
          :: <[ [] ]>
          :: arguments;
        <[ this.Accept(..$acceptArgs) ]>
      }
      def internalAstMaker(_ : list[PExpr]) : PExpr
      {
        | []   => assert(false)
        | [x]  => x
        | many => <[ (..$many) ]>
      }
      def makeAstPointer(astStruct : AstStruct, name : string)
      {
        mutable astPointer = null;
        def getPointer()
        {
          when (astPointer == null)
            astPointer = AstPointer(astStruct, name, this);
          astPointer
        }
        def initPointer()
        {
          if (astPointer == null)
            <[ () ]>
          else
            <[
              def $(name : dyn) = {
                astPtr:
                {
                  for (mutable ast = parser.memoize[pos]; ast > 0; ast = parser.ast[ast + 1])
                    when (parser.ast[ast] == $(astStruct.AstId : dyn))
                      astPtr(ast);
                  assert(false);
                }
              }
            ]>
        }
        (getPointer, initPointer)
      }
      and makeInternalAst(astStruct : AstStruct, name : string)
      {
        def (getPointer, initPointer) = makeAstPointer(astStruct, name);
        def ast = makeAst(astStruct, getPointer, internalAstMaker);
        (ast, initPointer());
      }
      and makeReader(structField : AstStruct.StructField, astPointer : void -> AstPointer) : PExpr
      {
        match(structField.Field)
        {
          | RuleField.TokenString
          | RuleField.TokenRuleCall =>
            <[
              def tokenPos = pos;
              pos += $(astPointer().SizeRef(structField));
              N2.NToken(tokenPos, pos)
            ]>

          | RuleField.SimpleRuleCall(RuleSymbol = ruleSymbol) =>
            def walkerFieldName = referencedWalkers[(ruleSymbol, 0)].FieldName;
            if (ruleSymbol.Type is RuleType.Void)
              <[ pos += $(astPointer().SizeRef(structField)); ]>
            else
              <[ this.$(walkerFieldName : usesite).Walk(ref pos, ref parser); ]>

          | RuleField.ExtensibleRuleCall(RuleSymbol = ruleSymbol, BindingPower = bp) =>
            def walkerFieldName = referencedWalkers[(ruleSymbol, bp)].FieldName;
            if (ruleSymbol.Type is RuleType.Void)
              <[ pos += $(astPointer().SizeRef(structField)); ]>
            else
              <[ this.$(walkerFieldName : usesite).Walk(ref pos, ref parser); ]>

          | RuleField.List(astStruct = itemStruct) =>
            def (itemAst, itemPointerInit) = makeInternalAst(itemStruct, "itemPointer");
            <[
              def listEnd = pos + $(astPointer().SizeRef(structField));
              if (listEnd > pos)
              {
                def astBuffer = System.Collections.Generic.List(16);
                def loop()
                {
                  $itemPointerInit;
                  astBuffer.Add($itemAst);
                  if (listEnd > pos)
                    loop();
                  else
                    assert(listEnd == pos);
                }
                loop();
                Nemerle.Collections.NList.ToList(astBuffer)
              }
              else []
            ]>

          | RuleField.List2(astRuleStruct = itemStruct, astSeparatorStruct = separatorStruct) =>
            def (itemAst, itemPointerInit) = makeInternalAst(itemStruct, "itemPointer");
            def (separatorAst, separatorPointerInit) = makeInternalAst(separatorStruct, "separatorPointer");
            <[
              def listEnd = pos + $(astPointer().SizeRef(structField));
              if (listEnd > pos)
              {
                def astBuffer = System.Collections.Generic.List(16);
                def separatorBuffer = System.Collections.Generic.List(16);
                def loop()
                {
                  $itemPointerInit;
                  astBuffer.Add($itemAst);
                  if (listEnd > pos)
                  {
                    $separatorPointerInit;
                    separatorBuffer.Add($separatorAst);
                    if (listEnd > pos)
                      loop();
                    else
                      assert(listEnd == pos);
                  }
                  else
                    assert(listEnd == pos);
                }
                loop();
                (Nemerle.Collections.NList.ToList(astBuffer), Nemerle.Collections.NList.ToList(separatorBuffer))
              }
              else
                ([], [])
            ]>

          | RuleField.Option(astStruct = valueAstStruct) =>
            def (valueAst, valuePointerInit) = makeInternalAst(valueAstStruct, "valuePointer");
            <[
              if ($(astPointer().SizeRef(structField)) > 0)
              {
                $valuePointerInit;
                Some($valueAst)
              }
              else
                None()
            ]>

          | _ => assert(false)
        }
        //<[ throw System.NotImplementedException(); ]>
      }
      and makeAst(astStruct : AstStruct, astPointer : void -> AstPointer, maker : list[PExpr] -> PExpr) : PExpr
      {
        def statements = List();
        def arguments = List();
        when (astStruct is RootAstStruct(IsPostfix = true))
          arguments.Add(<[ prefix ]>);

        foreach (structField in astStruct.SizeFields)
          match (structField.Field)
          {
            | RuleField.Ast
            | RuleField.Predicate => ()
            | RuleField.Void =>
              statements.Add(<[ pos += $(astPointer().SizeRef(structField)); ]>);

            | RuleField.List  
            | RuleField.List2 
            | RuleField.Option
            | _                =>
              def varName = Util.tmpname("ast");
              statements.Add(<[ def $(varName : usesite) = $(makeReader(structField, astPointer)) ]>);
              arguments.Add(<[ $(varName : usesite) ]>);
          }

        statements.Add(<[ _ = $(astStruct.RuleField.Print()) ]>);
        statements.Add(maker(arguments.ToNList()));
        <[ { ..$(statements.ToNList()) } ]>
      }

      match (RuleSymbol)
      {
        | SimpleRuleSymbol as s =>
          def (astPointer, initPointer) = makeAstPointer(rootAstStruct.Value, "astPtr");
          def ast = makeAst(rootAstStruct.Value, astPointer, rootAstMaker);
          _tb.DefineConditional(<[ decl:
            public override Walk(pos : ref int, parser : ref N2.Internal.Parser) : $(Owner.Environment.RuleTypeToNType(s.Type) : typed)
            {
              ignore(pos, parser);
              unchecked
              {
                def startPos = pos;
                $(initPointer());
                $ast
              }
            }
          ]>);

        | ExtentionRuleSymbol(ExtentionType = Prefix) as s =>
          def astPointer() { AstPointer(rootAstStruct.Value, "astPtr", this) }
          _tb.DefineConditional(<[ decl:
            public override Walk(pos : ref int, astPtr : int, parser : ref N2.Internal.Parser) : $(Owner.Environment.RuleTypeToNType(s.Type) : typed)
            {
              ignore(pos, astPtr, parser);
              unchecked
              {
                def startPos = pos;
                $(makeAst(rootAstStruct.Value, astPointer, rootAstMaker))
              }
            }
          ]>);

        | ExtentionRuleSymbol(ExtentionType = Postfix) as s =>
          def astPointer() { AstPointer(rootAstStruct.Value, "astPtr", this) }
          _tb.DefineConditional(<[ decl:
            public override Walk(prefix : $(Owner.Environment.RuleTypeToNType(s.Type) : typed), startPos : int, pos : ref int, astPtr : int, parser : ref N2.Internal.Parser) : $(Owner.Environment.RuleTypeToNType(s.Type) : typed)
            {
              ignore(prefix, startPos, pos, astPtr, parser);
              unchecked
              {
                $(makeAst(rootAstStruct.Value, astPointer, rootAstMaker))
              }
            }
          ]>);

        | _ => assert2(false);
      }
    }

    private static GetDependencies(rule : RuleSymbol) : Hashtable[RuleSymbol * int, WalkerInfo]
    {
      def refs = Hashtable();
      def collect(rule : Rule) : void
      {
        | String
        | Not
        | And => ()
        | Sequence            (rules)                    => foreach(r in rules) collect(r);
        | Repeat              (_, _, rule)               => collect(rule)
        | RepeatWithSeparator (_, _, rule, separator, _) => collect(rule); collect(separator)
        | Call                (ruleRef, bp) as callRule  =>
          assert2(bp != 31);
          def symbol = ruleRef.Value;
          // TODO: deal with 'void'
          unless (callRule.Type is RuleType.Chars || callRule.Type is RuleType.Void || symbol is MarkerSymbol)
            unless (refs.ContainsKey((symbol, bp)))
              _ = refs.Add((symbol, bp), WalkerInfo(symbol, bp));
      }
      match (rule)
      {
        | ExtentionRuleSymbol(ExtentionType = Prefix, Rule = r)
        | ExtentionRuleSymbol(ExtentionType = Postfix(_, r))
        | SimpleRuleSymbol   (Rule = r)
          => collect(r);
        | _ => assert2(false); assert(false)
      }
      refs
    }

    private struct WalkerInfo
    {
      public this(symbol : RuleSymbol, bindingPower : int)
      {
        FieldName    = Util.tmpname(symbol.Name + "Walker");
        BindingPower = bindingPower;
      }
      public FieldName : string;
      public BindingPower : int;
    }

    private GetWalkerType(rule : RuleSymbol) : PExpr
    {
      | SimpleRuleSymbol as s => <[ N2.Runtime.SimpleAstWalker[$(Owner.Environment.RuleTypeToNType(s.Type) : typed)] ]>
      | ExtensibleRuleSymbol as s => <[ N2.Runtime.ExtensibleAstWalker[$(Owner.Environment.RuleTypeToNType(s.Type) : typed)] ]>
      | _ => assert2(false); assert(false)
    }

    private GetWalkerBaseType(rule : RuleSymbol) : PExpr
    {
      | SimpleRuleSymbol                             as s => <[ N2.Runtime.SimpleAstWalker[$(Owner.Environment.RuleTypeToNType(s.Type) : typed)] ]>
      | ExtentionRuleSymbol(ExtentionType = Prefix)  as s => <[ N2.Runtime.PrefixAstWalker[$(Owner.Environment.RuleTypeToNType(s.Type) : typed)] ]>
      | ExtentionRuleSymbol(ExtentionType = Postfix) as s => <[ N2.Runtime.PostfixAstWalker[$(Owner.Environment.RuleTypeToNType(s.Type) : typed)] ]>
      | _ => assert2(false); assert(false)
    }

    public Emit() : void
    {
      assert(_tb != null);
      _tb.Compile();
    }
  }
}
