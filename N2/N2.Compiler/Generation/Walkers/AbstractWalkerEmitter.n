using Nemerle;
using Nemerle.Collections;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Text;
using Nemerle.Utility;

using N2.Model;
using N2.Typing;

using System;
using System.Collections.Generic;
using System.Linq;

namespace N2.Compiler
{
  [Record]
  internal class AstAbstractWalkerEmitter : AbstractWalkerEmitter
  {
    public override WalkerTypeName() : string
    {
      RuleSymbol.Name + "AstWalker"
    }

    public override DefineMembers(rootAstStruct : option[RootAstStruct]) : void
    {
      base.DefineMembers(rootAstStruct);
      def parms =
        <[ parameter: $("location" : usesite) : N2.Location ]>
        :: <[ parameter: $("errorInfo" : usesite) : list[N2.ErrorInfo] ]> //TODO: удалить этот параметр
        :: RuleSymbol.NonVoidSubRules.Map(r => <[ parameter: $(r.FieldName : usesite) : $(Owner.Environment.RuleTypeToNType(r.Type) : typed) ]>);
      TB.DefineConditional(<[ decl:
        public Accept(..$parms) : $(Owner.Environment.RuleTypeToNType(RuleSymbol.Type) : typed)
        {
          $(Owner.Environment.NTypeOfRuleSymbol(RuleSymbol) : typed).Ast(..$(parms.Map(p => <[ $(p.Name : usesite) ]>)))
        }
      ]>);
    }

    public override RootAstMaker(_astStruct : AstStruct, arguments : list[PExpr]) : PExpr
    {
      def acceptArgs =
        <[ N2.Location(parser.Source, startPos, pos) ]>
        :: <[ [] ]>
        :: arguments;
      <[ this.Accept(..$acceptArgs) ]>
    }

    public override InternalAstMaker(_astStruct : AstStruct, arguments : list[PExpr]) : PExpr
    {
      match (arguments)
      {
        | []   => assert(false)
        | [x]  => x
        | many => <[ (..$many) ]>
      }
    }

    public override WalkMethodReturnType(ruleType : RuleType) : PExpr
    {
      <[ $(Owner.Environment.RuleTypeToNType(ruleType) : typed) ]>
    }

    public override TokenWalkCode(_structField : AstStruct.StructField) : PExpr
    {
      <[ N2.NToken(tokenPos, pos) ]>
    }

    public override ListWalkCode(_structField : AstStruct.StructField, itemAst : PExpr) : PExpr * PExpr * PExpr * PExpr
    {
      def init       = <[ def astBuffer = System.Collections.Generic.List(16); ]>;
      def addItem    = <[ astBuffer.Add($itemAst); ]>;
      def returnCode = <[ Nemerle.Collections.NList.ToList(astBuffer) ]>;
      def emptyCode  = <[ [] ]>;
      (init, addItem, returnCode, emptyCode)
    }

    public override List2WalkCode(_structField : AstStruct.StructField, itemAst : PExpr, separatorAst : PExpr) : PExpr * PExpr * PExpr * PExpr * PExpr
    {
      def init         = <[ def astBuffer = System.Collections.Generic.List(16); def separatorBuffer = System.Collections.Generic.List(16); ]>;
      def addItem      = <[ astBuffer.Add($itemAst); ]>;
      def addSeparator = <[ separatorBuffer.Add($separatorAst); ]>;
      def returnCode   = <[ (Nemerle.Collections.NList.ToList(astBuffer), Nemerle.Collections.NList.ToList(separatorBuffer)) ]>;
      def emptyCode    = <[ ([], []) ]>;
      (init, addItem, addSeparator, returnCode, emptyCode)
    }

    public override OptionWalkCode(_structField : AstStruct.StructField, valueAst : PExpr) : PExpr * PExpr
    {
      def someCode = <[ Some($valueAst) ]>;
      def noneCode = <[ None() ]>;
      (someCode, noneCode)
    }

    public override SkipVoid() : bool { true }
  }

  [Record]
  internal class ReflectionAbstractWalkerEmitter : AbstractWalkerEmitter
  {
    public override WalkerTypeName() : string
    {
      RuleSymbol.Name + "ReflectionWalker"
    }

    private MakeReflectionStruct(name : PExpr, location : PExpr, items : PExpr) : PExpr
    {
      <[ N2.Runtime.Reflection.ReflectionStruct($name, $location, System.Collections.ObjectModel.ReadOnlyCollection.[N2.Runtime.Reflection.ReflectionStruct]($items)) ]>
    }

    private MakeName(ruleField : RuleField) : string
    {
      match (ruleField)
      {
        | RuleField.List               as x => x.Rule.ToString()
        | RuleField.List2              as x => x.Rule.ToString()
        | RuleField.Option             as x => x.Rule.ToString()
        | RuleField.Predicate          as x => x.Rule.ToString()
        | RuleField.ExtensibleRuleCall as x => x.RuleSymbol.Name
        | RuleField.TokenRuleCall      as x => x.RuleSymbol.Name
        | RuleField.SimpleRuleCall     as x => x.RuleSymbol.Name
        | RuleField.Void               as x => x.RuleSymbol.Name
        | RuleField.TokenString        as x => x.Rule.ToString()
        | RuleField.Ast                as x => x.RuleSymbol.Name
        | _                                 => assert(false);
      }
    }

    public override RootAstMaker(astStruct : AstStruct, arguments : list[PExpr]) : PExpr
    {
      MakeReflectionStruct(<[ $(MakeName(astStruct.RuleField)) ]>, <[ N2.NToken(startPos, pos) ]>, <[ array[..$arguments] ]>);
    }

    public override InternalAstMaker(astStruct : AstStruct, arguments : list[PExpr]) : PExpr
    {
      MakeReflectionStruct(<[ $(MakeName(astStruct.RuleField) + " ~~ ") ]>, <[ N2.NToken(startPos, pos) ]>, <[ array[..$arguments] ]>);
    }

    public override WalkMethodReturnType(_ruleType : RuleType) : PExpr
    {
      <[ N2.Runtime.Reflection.ReflectionStruct ]>
    }

    public override TokenWalkCode(structField : AstStruct.StructField) : PExpr
    {
      MakeReflectionStruct(<[ $(MakeName(structField.Field)) ]>, <[ N2.NToken(tokenPos, pos) ]>, <[ array(0) ]>);
    }

    public override ListWalkCode(structField : AstStruct.StructField, itemAst : PExpr) : PExpr * PExpr * PExpr * PExpr
    {
      def init       = <[ def listStartPos = pos; def astBuffer = System.Collections.Generic.List(16); ]>;
      def addItem    = <[ astBuffer.Add($itemAst); ]>;
      def returnCode = MakeReflectionStruct(<[ $(MakeName(structField.Field)) ]>, <[ N2.NToken(listStartPos, pos) ]>, <[ astBuffer ]>);
      def emptyCode  = MakeReflectionStruct(<[ $(MakeName(structField.Field)) ]>, <[ N2.NToken(pos, pos) ]>, <[ array(0) ]>);
      (init, addItem, returnCode, emptyCode)
    }

    public override List2WalkCode(structField : AstStruct.StructField, itemAst : PExpr, separatorAst : PExpr) : PExpr * PExpr * PExpr * PExpr * PExpr
    {
      def init         = <[ def listStartPos = pos; def astBuffer = System.Collections.Generic.List(16); ]>;
      def addItem      = <[ astBuffer.Add($itemAst); ]>;
      def addSeparator = <[ astBuffer.Add($separatorAst); ]>;
      def returnCode   = MakeReflectionStruct(<[ $(MakeName(structField.Field)) ]>, <[ N2.NToken(listStartPos, pos) ]>, <[ astBuffer ]>);
      def emptyCode    = MakeReflectionStruct(<[ $(MakeName(structField.Field)) ]>, <[ N2.NToken(pos, pos) ]>, <[ array(0) ]>);
      (init, addItem, addSeparator, returnCode, emptyCode)
    }

    public override OptionWalkCode(structField : AstStruct.StructField, valueAst : PExpr) : PExpr * PExpr
    {
      def someCode = <[
        def startOprionPos = pos;
        def value = $valueAst;
        $(MakeReflectionStruct(<[ $(MakeName(structField.Field)) ]>, <[ N2.NToken(startOprionPos, pos) ]>, <[ array[value] ]>));
      ]>;
      def noneCode = MakeReflectionStruct(<[ $(MakeName(structField.Field)) ]>, <[ N2.NToken(pos, pos) ]>, <[ array(0) ]>);
      (someCode, noneCode)
    }

    public override SkipVoid() : bool { false }
  }

  internal abstract class AbstractWalkerEmitter : IVariableEmitter
  {
    public Owner      : SyntaxModuleEmitter { get; }
    public RuleSymbol : SyntaxRuleSymbol    { get; }
    public TB         : TypeBuilder         { get { assert(_tb != null); _tb; } }

    public this(owner : SyntaxModuleEmitter, ruleSymbol : SyntaxRuleSymbol)
    {
      Owner = owner;
      RuleSymbol = ruleSymbol;
    }

    mutable _tb : TypeBuilder;

    Environment : EmitterEnvironment implements IVariableEmitter.Environment { get { Owner.Environment } }

    CreateVariable(name : string) : PExpr implements IVariableEmitter.CreateVariable
    {
      <[ $(name : dyn) ]>
    }

    public RuleParserBaseType : PExpr
    {
      get
      {
        match (RuleSymbol)
        {
          | SimpleRuleSymbol    => <[ N2.Internal.SimpleRuleParser ]>
          | ExtentionRuleSymbol => <[ N2.Internal.ExtentionRuleParser ]>
          | _                   => assert(false)
        }
      }
    }

    public abstract WalkerTypeName() : string;
    public DefineTypes() : void
    {
      assert(_tb == null);
      _tb = Owner.GrammarTB.DefineNestedType(<[ decl:
        public class $(WalkerTypeName() : usesite) : $(GetWalkerBaseType(RuleSymbol))
        {
          private RuleParser : $(RuleSymbol.GetParserClassRef());
          public this(ruleParser : $(RuleParserBaseType))
          {
            RuleParser = ruleParser :> $(RuleSymbol.GetParserClassRef());
          }
        }
      ]>);
    }

    public virtual DefineMembers(rootAstStruct : option[RootAstStruct]) : void
    {
      assert(_tb != null);

      def referencedWalkers = GetDependencies(RuleSymbol);
      foreach(p in referencedWalkers)
        _tb.Define(<[ decl: private mutable $(p.Value.FieldName : usesite) : $(GetWalkerType(p.Key[0])) ]>);

      def initBody = List();
      foreach (id in rootAstStruct.Value.RuleField.Compiler.InternalRuleIds.Values)
      {
        _tb.DefineConditional(<[decl: private mutable $(id : dyn) : int; ]>);
        initBody.Add(<[ $(id : dyn) = RuleParser. $(id : dyn); ]>);
      }
      initBody.Add(<[ ignore(compositeAstWalker) ]>);
      foreach (p in referencedWalkers)
      {
        def walkerInfo = p.Value;
        match (p.Key)
        {
          | (ExtensibleRuleSymbol as s, bp) =>
            initBody.Add(<[ this.$(walkerInfo.FieldName : usesite) = compositeAstWalker.GetWalker($(s.GetDescriptorClassRef()).StaticDescriptor, $(bp : int)) ]>);

          | (s, _) =>
            initBody.Add(<[ this.$(walkerInfo.FieldName : usesite) = compositeAstWalker.GetWalker($(s.GetDescriptorClassRef()).StaticDescriptor) ]>);
        }
      }
      when (RuleSymbol is SimpleRuleSymbol)
        _tb.DefineConditional(<[ decl:
          public override RuleId : int { get { RuleParser.RuleId } }
        ]>);
      _tb.DefineConditional(<[ decl:
        public override Init(compositeAstWalker : N2.Runtime.CompositeAstWalker) : void
        {
          ..$(initBody.ToNList())
        }
      ]>);

      DefineWalkMethod(rootAstStruct, referencedWalkers);
    }

    public abstract RootAstMaker(astStruct : AstStruct, arguments : list[PExpr]) : PExpr;
    public abstract InternalAstMaker(astStruct : AstStruct, arguments : list[PExpr]) : PExpr;
    public abstract WalkMethodReturnType(ruleType : RuleType) : PExpr;

    public abstract SkipVoid() : bool;
    public abstract TokenWalkCode(structField : AstStruct.StructField) : PExpr;
    public abstract OptionWalkCode(structField : AstStruct.StructField, valueAst : PExpr) : PExpr * PExpr;
    public abstract ListWalkCode(structField : AstStruct.StructField, itemAst : PExpr) : PExpr * PExpr * PExpr * PExpr;
    public abstract List2WalkCode(structField : AstStruct.StructField, itemAst : PExpr, separatorAst : PExpr) : PExpr * PExpr * PExpr * PExpr * PExpr;

    private DefineWalkMethod(rootAstStruct : option[RootAstStruct], referencedWalkers : Hashtable[RuleSymbol * int, WalkerInfo]) : void
    {
      def makeAstPointer(astStruct : AstStruct, name : string)
      {
        mutable astPointer = null;
        def getPointer()
        {
          when (astPointer == null)
            astPointer = AstPointer(astStruct, name, this);
          astPointer
        }
        def initPointer()
        {
          if (astPointer == null)
            <[ () ]>
          else
            <[
              def $(name : dyn) = {
                astPtr:
                {
                  for (mutable ast = parser.memoize[pos]; ast > 0; ast = parser.ast[ast + 1])
                    when (parser.ast[ast] == $(astStruct.AstId : dyn))
                      astPtr(ast);
                  assert(false);
                }
              }
            ]>
        }
        (getPointer, initPointer)
      }
      and makeInternalAst(astStruct : AstStruct, name : string)
      {
        def (getPointer, initPointer) = makeAstPointer(astStruct, name);
        def ast = makeAst(astStruct, getPointer, InternalAstMaker);
        (ast, initPointer());
      }
      and makeReader(structField : AstStruct.StructField, astPointer : void -> AstPointer) : PExpr
      {
        match (structField.Field)
        {
          | RuleField.TokenString
          | RuleField.TokenRuleCall =>
            <[
              def tokenPos = pos;
              pos += $(astPointer().SizeRef(structField));
              $(TokenWalkCode(structField));
            ]>

          | RuleField.Void(RuleSymbol = ruleSymbol)
          | RuleField.SimpleRuleCall(RuleSymbol = ruleSymbol) =>
            def walkerFieldName = referencedWalkers[(ruleSymbol, 0)].FieldName;
            if (SkipVoid() && ruleSymbol.Type is RuleType.Void)
              <[ pos += $(astPointer().SizeRef(structField)); ]>
            else
              <[ this.$(walkerFieldName : usesite).Walk(ref pos, ref parser); ]>

          | RuleField.ExtensibleRuleCall(RuleSymbol = ruleSymbol, BindingPower = bp) =>
            def walkerFieldName = referencedWalkers[(ruleSymbol, bp)].FieldName;
            if (SkipVoid() && ruleSymbol.Type is RuleType.Void)
              <[ pos += $(astPointer().SizeRef(structField)); ]>
            else
              <[ this.$(walkerFieldName : usesite).Walk(ref pos, ref parser); ]>

          | RuleField.List(astStruct = itemStruct) =>
            def (itemAst, itemPointerInit) = makeInternalAst(itemStruct, "itemPointer");
            def (init, addItem, returnCode, emptyCode) = ListWalkCode(structField, itemAst);
            <[
              def listEnd = pos + $(astPointer().SizeRef(structField));
              if (listEnd > pos)
              {
                $init;
                def loop()
                {
                  $itemPointerInit;
                  $addItem;
                  if (listEnd > pos)
                    loop();
                  else
                    assert(listEnd == pos);
                }
                loop();
                $returnCode;
              }
              else $emptyCode
            ]>

          | RuleField.List2(astRuleStruct = itemStruct, astSeparatorStruct = separatorStruct) =>
            def (itemAst, itemPointerInit) = makeInternalAst(itemStruct, "itemPointer");
            def (separatorAst, separatorPointerInit) = makeInternalAst(separatorStruct, "separatorPointer");
            def (init, addItem, addSeparator, returnCode, emptyCode) = List2WalkCode(structField, itemAst, separatorAst);
            <[
              def listEnd = pos + $(astPointer().SizeRef(structField));
              if (listEnd > pos)
              {
                $init;
                def loop()
                {
                  $itemPointerInit;
                  $addItem;
                  if (listEnd > pos)
                  {
                    $separatorPointerInit;
                    $addSeparator;
                    if (listEnd > pos)
                      loop();
                    else
                      assert(listEnd == pos);
                  }
                  else
                    assert(listEnd == pos);
                }
                loop();
                $returnCode
              }
              else
                $emptyCode
            ]>

          | RuleField.Option(astStruct = valueAstStruct) =>
            def (valueAst, valuePointerInit) = makeInternalAst(valueAstStruct, "valuePointer");
            def (someCode, noneCode) = OptionWalkCode(structField, valueAst);
            <[
              if ($(astPointer().SizeRef(structField)) > 0)
              {
                $valuePointerInit;
                $someCode;
              }
              else
                $noneCode;
            ]>

          | _ => assert(false)
        }
        //<[ throw System.NotImplementedException(); ]>
      }
      and makeAst(astStruct : AstStruct, astPointer : void -> AstPointer, maker : AstStruct * list[PExpr] -> PExpr) : PExpr
      {
        def statements = List();
        def arguments = List();
        when (astStruct is RootAstStruct(IsPostfix = true))
          arguments.Add(<[ prefix ]>);

        when (!(astStruct is RootAstStruct))
        {
          statements.Add(<[ def startPos = pos; ]>);
          statements.Add(<[ _ = startPos; ]>);
        }

        foreach (structField in astStruct.SizeFields)
          match (structField.Field)
          {
            | RuleField.Ast       => assert(false)
            | RuleField.Predicate => ()
            | RuleField.Void when SkipVoid() =>
              statements.Add(<[ pos += $(astPointer().SizeRef(structField)); ]>);

            | _                =>
              def varName = Util.tmpname("ast");
              statements.Add(<[ def $(varName : usesite) = $(makeReader(structField, astPointer)) ]>);
              arguments.Add(<[ $(varName : usesite) ]>);
          }

        statements.Add(<[ _ = $(astStruct.RuleField.Print()) ]>);
        statements.Add(maker(astStruct, arguments.ToNList()));
        <[ { ..$(statements.ToNList()) } ]>
      }

      match (RuleSymbol)
      {
        | SimpleRuleSymbol as s =>
          def (astPointer, initPointer) = makeAstPointer(rootAstStruct.Value, "astPtr");
          def ast = makeAst(rootAstStruct.Value, astPointer, RootAstMaker).FlattenPExpr();
          _tb.DefineConditional(<[ decl:
            public override Walk(pos : ref int, parser : ref N2.Internal.Parser) : $(WalkMethodReturnType(s.Type))
            {
              ignore(pos, parser);
              unchecked
              {
                def startPos = pos;
                $(initPointer());
                $ast
              }
            }
          ]>);

        | ExtentionRuleSymbol(ExtentionType = Prefix) as s =>
          def astPointer() { AstPointer(rootAstStruct.Value, "astPtr", this) }
          _tb.DefineConditional(<[ decl:
            public override Walk(pos : ref int, astPtr : int, parser : ref N2.Internal.Parser) : $(WalkMethodReturnType(s.Type))
            {
              ignore(pos, astPtr, parser);
              unchecked
              {
                def startPos = pos;
                $(makeAst(rootAstStruct.Value, astPointer, RootAstMaker).FlattenPExpr())
              }
            }
          ]>);

        | ExtentionRuleSymbol(ExtentionType = Postfix) as s =>
          def astPointer() { AstPointer(rootAstStruct.Value, "astPtr", this) }
          _tb.DefineConditional(<[ decl:
            public override Walk(prefix : $(WalkMethodReturnType(s.Type)), startPos : int, pos : ref int, astPtr : int, parser : ref N2.Internal.Parser) : $(WalkMethodReturnType(s.Type))
            {
              ignore(prefix, startPos, pos, astPtr, parser);
              unchecked
              {
                $(makeAst(rootAstStruct.Value, astPointer, RootAstMaker).FlattenPExpr())
              }
            }
          ]>);

        | _ => assert2(false);
      }
    }

    private GetDependencies(rule : RuleSymbol) : Hashtable[RuleSymbol * int, WalkerInfo]
    {
      def refs = Hashtable();
      def collect(rule : Rule) : void
      {
        | String
        | Not
        | And => ()
        | Sequence            (rules)                    => foreach(r in rules) collect(r);
        | Repeat              (_, _, rule)               => collect(rule)
        | RepeatWithSeparator (_, _, rule, separator, _) => collect(rule); collect(separator)
        | Call                (ruleRef, bp) as callRule  =>
          assert2(bp != 31);
          def symbol = ruleRef.Value;
          // TODO: deal with 'void'
          unless (callRule.Type is RuleType.Chars || (SkipVoid() && callRule.Type is RuleType.Void) || symbol is MarkerSymbol)
            unless (refs.ContainsKey((symbol, bp)))
              _ = refs.Add((symbol, bp), WalkerInfo(symbol, bp));
      }
      match (rule)
      {
        | ExtentionRuleSymbol(ExtentionType = Prefix, Rule = r)
        | ExtentionRuleSymbol(ExtentionType = Postfix(_, r))
        | SimpleRuleSymbol   (Rule = r)
          => collect(r);
        | _ => assert2(false); assert(false)
      }
      refs
    }

    private struct WalkerInfo
    {
      public this(symbol : RuleSymbol, bindingPower : int)
      {
        FieldName    = Util.tmpname(symbol.Name + "Walker");
        BindingPower = bindingPower;
      }
      public FieldName : string;
      public BindingPower : int;
    }

    private GetWalkerType(rule : RuleSymbol) : PExpr
    {
      | SimpleRuleSymbol     as s => <[ N2.Runtime.SimpleRuleWalker[$(WalkMethodReturnType(s.Type))] ]>
      | ExtensibleRuleSymbol as s => <[ N2.Runtime.ExtensibleRuleWalker[$(WalkMethodReturnType(s.Type))] ]>
      | _ => assert2(false); assert(false)
    }

    public GetWalkerBaseType(rule : RuleSymbol) : PExpr
    {
      | SimpleRuleSymbol                             as s => <[ N2.Runtime.SimpleRuleWalker[$(WalkMethodReturnType(s.Type))] ]>
      | ExtentionRuleSymbol(ExtentionType = Prefix)  as s => <[ N2.Runtime.PrefixRuleWalker[$(WalkMethodReturnType(s.Type))] ]>
      | ExtentionRuleSymbol(ExtentionType = Postfix) as s => <[ N2.Runtime.PostfixRuleWalker[$(WalkMethodReturnType(s.Type))] ]>
      | _ => assert2(false); assert(false)
    }

    public Emit() : void
    {
      assert(_tb != null);
      _tb.Compile();
    }
  }
}
