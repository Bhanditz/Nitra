using N2.Model;
using N2.Typing;

using Nemerle.Collections;
using Nemerle.Compiler.Parsetree;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;

using G = GrammarParser2;
using N = Nemerle.Compiler;

namespace N2
{
  /// <summary>
  /// Description of Util.
  /// </summary>
  public module Util
  {
    public Once[T](this source : IEnumerable[Ast]) : option[T]
      where T: Ast
    {
      def source2 = source.OfType.[T]().NToList();
      
      match (source2)
      {
        [x]           => Some(x)
        | null | []   => None()
        | x :: y :: _ => 
          N.Message.Error(y.Location.ToNemerleLocation(), 
            "Acceptably only one entry.");
          Some(x)
      }
    }

    //TODO: fix the bug in the compiler
    //public Once[T](this source : list[N2.Ast]) : ValueOption[T]
    //  where T: N2.Ast
    //{
    //  def source2 = source.OfType.[T]();
    // 
    //  match (source2)
    //  {
    //    [x]           => VSome(x)
    //    | null | []   => VNone()
    //    | x :: y :: _ => 
    //      Nemerle.Compiler.Message.Error((y : N2.Ast).Location.ToNemerleLocation(), 
    //      "Acceptably only one entry."); VSome(x)
    //  }
    //}
    
    public Flatten[T](this src : Seq[option[T]]) : list[T]
    {
      def dst = List();
      foreach (Some(item) in src)
        dst.Add(item);
      dst.NToList();
    }

    public Flatten[T](this src : list[option[T]]) : list[T]
    {
      def dst = List(src.Length);
      foreach (Some(item) in src)
        dst.Add(item);
      dst.NToList();
    }
    
    public GraphWalk[Key, Value]( start   : IEnumerable[Key]
                                , calc    : Key * (Key -> Value) -> Value
                                , onCycle : Key -> Value)
                                : Map[Key, Value]
    {
      mutable result = Map();
      def visited = Hashtable();
      def getValue(key)
      {
        if (result.Contains(key))
          result.Get(key);
        else
        {
          def value = if (visited.ContainsKey(key))
            onCycle(key);
          else
          {
            visited.Add(key, 0);
            def value = calc(key, getValue);
            visited.Remove(key);
            value;
          }
          result = result.Replace(key, value);
          value;
        }
      }
      foreach (key in start)
        _ = getValue(key);
      result;
    }

    public CreateIdGenerator(seed : int) : void -> int
    {
      mutable counter = seed;
      fun()
      {
        def result = counter;
        counter += 1;
        result
      }
    }
  
    public ToNemerleLocation(this loc : N2.Location) : N.Location
    {
      def (startLine, startCol) = loc.StartLineColumn;
      def (endLine, endCol) = loc.EndLineColumn;
      N.Location(loc.Source.FileIndex, startLine, startCol, endLine, endCol)
    }

    public ToName(this identifier : G.Identifier) : string
    {
      | G.Identifier.Ast as identifier => identifier.GetText(identifier.IdentifierBody)
      | _ => N.Message.FatalError(identifier.NLocation(), "Error.");
    }

    public ToNameRef(this identifier : G.Identifier) : NameRef
    {
      | G.Identifier.Ast as identifier => NameRef(identifier.NLocation(), [identifier.GetText(identifier.IdentifierBody)])
      | _ => N.Message.FatalError(identifier.NLocation(), "Error.");
    }

    public ToNameRef(this identifier : G.QIdentifier) : NameRef
    {
      | G.QIdentifier.Ast as identifier =>
        def nameRefs = identifier.Names[0].Map(_.ToNameRef());
        mutable nameRef = nameRefs.Head;
        foreach (nr in nameRefs.Tail)
          nameRef = nameRef + nr;
        nameRef
      | _ => N.Message.FatalError(identifier.NLocation(), "Error.");
    }

    public GetNestedSubtypes(this ti : N.LibraryReference.ExternalTypeInfo) : list[N.LibraryReference.ExternalTypeInfo]//TODO: Move to Nemerle.Compiler
    {
      def nestedTypes = ti.GetNestedTypes();
      nestedTypes.Where(nested => nested.DeclaringType?.Equals(ti)).OfType.[N.LibraryReference.ExternalTypeInfo]().NToList();
    }

    public ParseRuleClassName(name : string) : option[RuleDefinitionType * string]
    {
      match (name.Substring(0, 11))
      {
        | "_#point#___" with type = RuleDefinitionType.ExtentionPoint()
        | "_#prefix#__" with type = RuleDefinitionType.ExtentionPrefix()
        | "_#postfix#_" with type = RuleDefinitionType.ExtentionPostfix()
        | "_#simple#__" with type = RuleDefinitionType.Simple()
        | "_#regular#_" with type = RuleDefinitionType.Regular()
          =>
          if (name.EndsWith("_"))
            Some((type, name.Substring(11, name.Length - 12)))
          else
            None()
        | _ => None()
      }
    }

    public LoadExtraFields(ti : N.TypeInfo) : list[ExtraField]
    {
      def reflectExtraFieldAttribute(member : N.IMember) : N.IMember * option[bool]
      {
        mutable attrValue = None();
        foreach(attr in member.GetModifiers().GetCustomAttributes())
        {
          | <[ N2.Runtime.ExtraFieldAttribute() ]>                   => attrValue = Some(false)
          | <[ N2.Runtime.ExtraFieldAttribute($(isCached : bool)) ]> => attrValue = Some(isCached)
          | _ => ()
        }
        (member, attrValue)
      }
      def reflectionResult = ti.GetMembers(N.BindingFlags.Instance | N.BindingFlags.Public).Map(reflectExtraFieldAttribute);
      def extraFields = List();
      foreach((method is N.IMethod, Some(isCached)) in reflectionResult)
      {
        def name       = NameRef(method.NameLocation, method.Name);
        def parameters = method.Header.ParametersDeclarations;
        def type       = <[ $(method.ReturnType : typed) ]>;
        def extraField = 
          if (method.IsAbstract)
            ExtraField.Abstract(method.Location, isCached, name, parameters, type)
          else
            ExtraField.Def(method.Location, isCached, name, parameters, type, <[ () ]>);
        extraFields.Add(extraField);
      }
      extraFields.ToNList()
    }

    public LoadExtraFields(ruleType : RuleType) : list[ExtraField]
    {
      match (ruleType)
      {
        | RuleType.NType(N.FixedType.Class(ti, [])) => LoadExtraFields(ti)
        | _ => []
      }
    }

    public IsVoidDeep(this ruleType : RuleType) : bool
    {
      | Void => true
      | Option(t) | List(t) => IsVoidDeep(t)
      | Tuple(types) => types.ForAll(IsVoidDeep)
      | Chars | PType | NType => false
    }

    public IsVoidDeep(this ruleType : RuleType2) : bool
    {
      | Void => true
      | Option(t) | List(t) => IsVoidDeep(t)
      | Tuple(types) => types.ForAll(IsVoidDeep)
      | Chars | Ref => false
    }

    public DefineConditional(this tb : N.TypeBuilder, classMember : ClassMember) : void
    {
#if PARSER_DEBUG
      _ = tb.DefineWithSource(classMember)
#else
      tb.Define(classMember)
#endif
    }

    public GetExtraFieldSignature(this symbol : ExtraFieldRefSymbol) : ExtraFieldSignature
    {
      | symbol is ExternalExtraFieldRefSymbol => symbol.Signature
      | symbol is ParsedExtraFieldRefSymbol[G.ExtraFieldDeclaration1.Ast] => symbol.Value.Signature
      | _ => assert(false)
    }
  }

  namespace Internal
  {
    using Nemerle.Compiler;
    using Nemerle.Macros;
    using PT = Nemerle.Compiler.Parsetree;

    using EvalLocationXImpl;

    /* Gets StartPos value of 'x' when x is NToken or Located, otherwise returns 'default' */
    macro EvalLocationStart(x, default)
    {
      EvalLocation(ImplicitCTX(), PT.Splicable.Name(PT.Name("StartPos")), x, default)
    }

    /* Gets EndPos value of 'x' when x is NToken or Located, otherwise returns 'default' */
    macro EvalLocationEnd(x, default)
    {
      EvalLocation(ImplicitCTX(), PT.Splicable.Name(PT.Name("EndPos")), x, default)
    }

    internal module EvalLocationXImpl
    {
      public EvalLocation(typer : Typer, prop : PT.Splicable, x : PT.PExpr, default : PT.PExpr) : PT.PExpr
      {
        def locatedType = FixedType.Class(typer.Manager.LookupTypeInfo("N2.Located", 0), []);
        def ntokenType = FixedType.Class(typer.Manager.LookupTypeInfo("N2.NToken", 0), []);
  
        def makeResult(tX)
        {
          if(tX.Type.TryRequire(locatedType))
            <[ $(tX : typed).Location.$prop ]>
          else if(tX.Type.TryRequire(ntokenType))
            <[ $(tX : typed).$prop ]>
          else
            default
        }

        def tX = typer.TypeExpr(x);
        match(tX.Type.Hint)
        {
          | Some(_) => makeResult(tX)
          | _ =>
            typer.DelayMacro(lastChance =>
              match(tX.Type.Hint)
              {
                | Some(_) => Some(makeResult(tX))
                | _ when lastChance => Some(default)
                | _ => None()
              }
            )
        }
      }
    }
  }
}