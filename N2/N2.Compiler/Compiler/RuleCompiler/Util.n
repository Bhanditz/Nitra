using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Compiler.Typedtree;
using N2.Model;

using System;
using System.Linq;
using SCG = System.Collections.Generic;

namespace N2
{
  internal partial class RuleCompiler
  {
    private Goto(n : int) : PExpr  { PExpr.Typed(Location.Default, TExpr.Goto(_grammarCompiler.Manager.InternalType.Void, n, 1)) }
    private Label(n : int) : PExpr { PExpr.Typed(Location.Default, TExpr.Label(_grammarCompiler.Manager.InternalType.Void, n, TExpr.DefaultValue(_grammarCompiler.Manager.InternalType.Void))) }
    private MakeLabel() : int
    {
      Util.next_id(_grammarCompiler.Manager)
    }
    private MakeLabels(count : int) : array[int]
    {
      def labels = array(count);
      for(mutable i = 0; i < labels.Length; ++i)
        labels[i] = MakeLabel();
      labels
    }

    private _vars : SCG.HashSet[string] = SCG.HashSet();
    private MakeVarName(rule : Rule) : string
    {
      //assert2(!(rule.Type is RuleType.Void));
      //assert(!(rule.Type is RuleType.Void));
      def name = $"_ast_$(rule.Id)";
      _ = _vars.Add(name);
      name;
    }

    private DefVars(vars : list[string], mainExpr : PExpr.Sequence) : PExpr.Sequence
    {
      def vars = vars.Map(var => <[ mutable $(var : dyn); ]>);
      match (mainExpr)
      {
        | <[ { ..$nestedExprs } ]> => <[ { ..$(vars + nestedExprs) } ]>
      }
    }
  }
}
