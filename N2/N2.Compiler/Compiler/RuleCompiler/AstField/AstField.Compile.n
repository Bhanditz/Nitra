using Nemerle;
using Nemerle.Collections;
using Nemerle.Compiler.Parsetree;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using SCG = System.Collections.Generic;
using System.Linq;

using N2.Model;

namespace N2.Compiler
{
  internal partial abstract class AstField
  {
    public mutable ParseCode : PExpr;
    public abstract Compile() : void;

    public ContinueParseLabel : PExprLabel { get { if (IsLastChild) ParentAstStruct.OkLabel else NextSibling.ParseLabel } }
    public FailParseLabel     : PExprLabel { get { ParentAstStruct.FailLabel } }

    public AstPosPExpr    : PExpr { get { Compiler.GetName($"astPos$Level") } }
    public TextPosPExpr   : PExpr { get { Compiler.GetName($"textPos$Level") } }
    public CounterPExpr   : PExpr { get { Compiler.GetName($"counter$Level") } }
    public ListTailPExpr  : PExpr { get { Compiler.GetName($"listTail$Level") } }
    public AllocatedPExpr : PExpr { get { Compiler.GetName($"allocated$Level") } }

    public MakeParseCode(check : PExpr, astSize : PExpr) : PExpr
    {
      def okCode   = SCG.List();
      def failCode = SCG.List();
      if (IsFirstChild)
      {
        okCode.Add(<[ $(Parent.AstPosPExpr) = parser.Allocate($(ParentAstStruct.AstSize)) ]>);
        when (Level == 1)
        {
          okCode.Add(<[ parser.ast[$(Parent.AstPosPExpr)] = RuleId; ]>);

          for (mutable i = ParentAstStruct.TerminatorOffset; i < ParentAstStruct.AstSize; ++i)
            okCode.Add(<[ parser.ast[$(Parent.AstPosPExpr) + $i] = -1; ]>);
        }
      }
      else
      {
        when (Level == 1)
          failCode.Add(<[ $(FieldOffsets.SizePExpr) = -1 ]>);// размер
      }

      okCode.Add(<[ $(FieldOffsets.SizePExpr) = $astSize ]>);// размер
      okCode.Add(<[ curEndPos += $astSize ]>);

      okCode.Add(<[ $(ContinueParseLabel.Goto()) ]>);

      failCode.Add(<[ parseState = $(State : int); ]>);//состояние
      failCode.Add(<[ $(FailParseLabel.Goto()) ]>);

      def check = if (Level == 1)
          <[ $check && (isBest || ({ diff =  $(FieldOffsets.BestSizePExpr) - ($astSize); isBest = diff < 0; diff <= 0})) ]>;
        else
          check;
      <[
        $(ParseLabel.Label());
        if ($check)
          $(PExpr.Sequence(okCode.FlattenPExprSequence()));
        else
          $(PExpr.Sequence(failCode.FlattenPExprSequence()));
      ]>
    }

    public MakeRuleCall(call : PExpr) : PExpr
    {
      MakeParseCode(<[ ({ newPos = $call; newPos > 0 }) ]>, <[ (newPos - curEndPos) ]>)
    }
  }
}
