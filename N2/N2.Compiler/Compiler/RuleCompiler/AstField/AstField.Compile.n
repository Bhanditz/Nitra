using Nemerle;
using Nemerle.Collections;
using Nemerle.Compiler.Parsetree;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using SCG = System.Collections.Generic;
using System.Linq;

using N2.Model;

namespace N2.Compiler
{
  internal partial abstract class AstField
  {
    public mutable ParseCode : PExpr;
    public abstract Compile() : void;

    public AstPos : PExpr { get { <[ $($"astPos$Level" : dyn) ]> } }

    public MakeParseCode(check : PExpr, astSize : PExpr) : PExpr
    {
      def startCode = SCG.List();
      def endCode   = SCG.List();
      if (IsFirstChild)
      {
        startCode.Add(<[ $AstPos = parser.Allocate($(ParentAstInfo.AstSize)) ]>);
        startCode.Add(<[ parser.ast[astPos0] = RuleId; ]>);
        when (ParentAstInfo.Terminator > 0)
          startCode.Add(<[ parser.ast[$AstPos + $(ParentAstInfo.TerminatorOffset)] = -1; ]>);// терминатор
      }
      else
      {
        endCode.Add(<[ parser.ast[astPos0 + 2] = $(State : int); ]>);//состояние
        endCode.Add(<[ parser.ast[$AstPos + $SizeOffset] = -1; ]>);// размер
      }
      def check = if (Level == 0)
          <[ $check && (isBest || ({ diff = parser.ast[bestAstPos + $SizeOffset] - ($astSize); isBest = diff < 0; diff <= 0})) ]>
        else
          check;
      <[
        $(Compiler.Label(ParseLabel));
        if ($check)
        {
          $(PExpr.Sequence(startCode.NToList()));
          parser.ast[$AstPos + $SizeOffset] = $astSize; // размер
          curEndPos += $astSize;
        }
        else
        {
          $(PExpr.Sequence(endCode.NToList()));
          $(Compiler.Goto(Parent.ChildFailLabel))
        }
      ]>
    }

    public MakeRuleCall(call : PExpr) : PExpr
    {
      MakeParseCode(<[ ({ newPos = $call; newPos > 0 }) ]>, <[ (newPos - curEndPos) ]>)
    }
  }
}
