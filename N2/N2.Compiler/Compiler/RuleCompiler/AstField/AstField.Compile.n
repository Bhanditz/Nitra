using Nemerle;
using Nemerle.Collections;
using Nemerle.Compiler.Parsetree;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using SCG = System.Collections.Generic;
using System.Linq;

using N2.Model;

namespace N2.Compiler
{
  internal partial abstract class AstField
  {
    public mutable ParseCode : PExpr;
    public abstract Compile() : void;

    public ContinueParseLabel : PExprLabel { get { if (IsLastChild) ParentAstInfo.OkLabel else NextSibling.ParseLabel } }
    public FailParseLabel     : PExprLabel { get { ParentAstInfo.FailLabel } }

    public AstPosPExpr   : PExpr { get { <[ $($"astPos$Level" : dyn) ]> } }
    public TextPosPExpr  : PExpr { get { <[ $($"textPos$Level" : dyn) ]> } }
    public CounterPExpr  : PExpr { get { <[ $($"counter$Level" : dyn) ]> } }
    public ListTailPExpr : PExpr { get { <[ $($"listTail$Level" : dyn) ]> } }

    public MakeParseCode(check : PExpr, astSize : PExpr) : PExpr
    {
      def okCode   = SCG.List();
      def failCode = SCG.List();
      if (IsFirstChild && Level == 1)
      {
        okCode.Add(<[ Parent.AstPosPExpr = parser.Allocate($(ParentAstInfo.AstSize)) ]>);
        okCode.Add(<[ parser.ast[Parent.AstPosPExpr] = RuleId; ]>);

        for (mutable i = ParentAstInfo.TerminatorOffset; i < ParentAstInfo.AstSize; ++i)
          okCode.Add(<[ parser.ast[Parent.AstPosPExpr + $i] = -1; ]>);
      }
      else if (IsFirstChild)
      {
        okCode.Add(<[ $(Parent.AstPosPExpr) = parser.Allocate($(ParentAstInfo.AstSize)) ]>);
      }
      else
      {
        failCode.Add(<[ $(FieldOffsets.SizePExpr) = -1; ]>);// размер
      }
      okCode.Add(<[ $(FieldOffsets.SizePExpr) = $astSize ]>);// размер
      okCode.Add(<[ curEndPos += $astSize ]>);

      okCode.Add(<[ $(ContinueParseLabel.Goto()) ]>);

      failCode.Add(<[ parseState = $(State : int); ]>);//состояние
      failCode.Add(<[ $(FailParseLabel.Goto()) ]>);

      def check = if (Level == 1)
          <[ $check && (isBest || ({ diff =  $(FieldOffsets.BestSizePExpr) - ($astSize); isBest = diff < 0; diff <= 0})) ]>;
        else
          check;
      <[
        $(ParseLabel.Label());
        if ($check)
          $(PExpr.Sequence(okCode.FlattenPExprSequence()));
        else
          $(PExpr.Sequence(failCode.FlattenPExprSequence()));
      ]>
    }

    public MakeRuleCall(call : PExpr) : PExpr
    {
      MakeParseCode(<[ ({ newPos = $call; newPos > 0 }) ]>, <[ (newPos - curEndPos) ]>)
    }
  }
}
