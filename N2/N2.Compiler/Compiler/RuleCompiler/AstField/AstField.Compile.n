using Nemerle;
using Nemerle.Collections;
using Nemerle.Compiler.Parsetree;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using SCG = System.Collections.Generic;
using System.Linq;

using N2.Model;

namespace N2.Compiler
{
  internal partial abstract class AstField
  {
    public mutable ParseCode : PExpr;
    public abstract Compile() : void;

    public MakeParseCode(check : PExpr, astSize : PExpr) : PExpr
    {
      def okCode   = SCG.List();
      def failCode = SCG.List();
      if (IsFirstChild && Level == 1)
      {
        okCode.Add(<[ astPos0 = parser.Allocate($(ParentAstInfo.AstSize)) ]>);
        okCode.Add(<[ parser.ast[astPos0] = RuleId; ]>);

        for (mutable i = ParentAstInfo.TerminatorOffset; i < ParentAstInfo.AstSize; ++i)
          okCode.Add(<[ parser.ast[astPos0 + $i] = -1; ]>);
      }
      else if (IsFirstChild)
      {
        okCode.Add(<[ $(FieldOffsets.AstStruct.AstPosPExpr) = parser.Allocate($(ParentAstInfo.AstSize)) ]>);
      }
      else
      {
        failCode.Add(<[ $(FieldOffsets.SizePExpr) = -1; ]>);// размер
      }
      okCode.Add(<[ $(FieldOffsets.SizePExpr) = $astSize ]>);// размер
      okCode.Add(<[ curEndPos += $astSize ]>);

      if (IsLastChild)
        okCode.Add(<[ $(ParentAstInfo.OkLabel.Goto()) ]>);
      else
        okCode.Add(<[ $(NextSibling.ParseLabel.Goto()) ]>);

      failCode.Add(<[ parseState = $(State : int); ]>);//состояние
      failCode.Add(<[ $(ParentAstInfo.FailLabel.Goto()) ]>);

      def check = if (Level == 1)
          <[ $check && (isBest || ({ diff =  $(FieldOffsets.BestSizePExpr) - ($astSize); isBest = diff < 0; diff <= 0})) ]>;
        else
          check;
      <[
        $(ParseLabel.Label());
        if ($check)
          $(PExpr.Sequence(okCode.FlattenPExprSequence()));
        else
          $(PExpr.Sequence(failCode.FlattenPExprSequence()));
      ]>
    }

    public MakeRuleCall(call : PExpr) : PExpr
    {
      MakeParseCode(<[ ({ newPos = $call; newPos > 0 }) ]>, <[ (newPos - curEndPos) ]>)
    }
  }
}
