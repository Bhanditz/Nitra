using Nemerle;
using Nemerle.Collections;
using Nemerle.Compiler.Parsetree;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using SCG = System.Collections.Generic;
using System.Linq;

using N2.Model;

namespace N2.Compiler
{
  internal class AstPointer
  {
    public AstStruct : AstStruct;
    public Var : PExpr;
    public this(astStruct : AstStruct, name : string)
    {
      AstStruct = astStruct;
      Var       = AstStruct.Compiler.GetName(name);
    }
    public this(astStruct : AstStruct, name : string, field : RuleField)
    {
      this(astStruct, $"$name$(field.Level)");
    }
    public Offset(structField : AstStruct.FieldBase) : PExpr
    {
      if (object.ReferenceEquals(AstStruct, structField.AstStruct))
        <[ $Var + $(structField.OffsetInStruct) ]>
      else
        PExpr.Error("Type mismatch.")
    }
    public Ref(structField : AstStruct.FieldBase) : PExpr
    {
      <[ parser.ast[$(Offset(structField))] ]>
    }
  }

  internal partial abstract class RuleField
  {
    public mutable ParseCode : PExpr;
    public abstract Compile() : void;

    public ContinueParseLabel : PExprLabel { get { if (NextSibling == null) ParentAstStruct.OkLabel else NextSibling.ParseLabel } }
    public FailParseLabel     : PExprLabel { get { ParentAstStruct.FailLabel } }

    public CurTextPos     : PExpr { get { <[ curEndPos ]> } }
    public StartTextPos   : PExpr { get { Compiler.GetName($"startTextPos$Level") } }
    public TextPos        : PExpr { get { Compiler.GetName($"textPos$Level") } }

    public AllocateParentAst() : PExpr
    {
      if (AllocateAst)
      {
        if (Parent is Ast)
          <[ $(ParentAstPtr.Var) = parser.Allocate($(ParentAstStruct.AstSize), RuleId) ]>
        else
          <[ $(ParentAstPtr.Var) = parser.Allocate($(ParentAstStruct.AstSize)) ]>
      }
      else
        <[ {} ]>
    }

    public IsAstAllocatetdCode(astStruct : AstStruct) : PExpr
    {
      <[ parseState > $(astStruct.AllocateState) ]>
    }

    public AddBestCheck(check : PExpr, sizeField : AstStruct.SizeField, size : PExpr) : PExpr
    {
      if (ParentAstStruct.MultipleVariants)
        <[ $check && (isBest || ({ diff =  ($(sizeField.BestRef)) - ($size); isBest = diff < 0; diff <= 0 })) ]>;
      else
        check;
    }

    public MakeSyntaxCallCode(call : PExpr, field : option[AstStruct.AstField], sizeField : AstStruct.SizeField) : PExpr
    {
      MakeCallCodeImpl(<[ $call(curEndPos, text, ref tmpResult, ref parser) ]>, field, sizeField)
    }

    public MakeCallCodeImpl(call : PExpr, field : option[AstStruct.AstField], sizeField : AstStruct.SizeField) : PExpr
    {
      def setAst = if (field is Some(field))
        <[ $(ParentAstPtr.Ref(field)) = tmpResult ]>
      else
        <[ () ]>;
      <[
      $(ParseLabel.Label());
        tmpResult = -1;
        newPos = $call;
        tmpSize = newPos - curEndPos;
        if ($(AddBestCheck(<[ newPos >= 0 ]>, sizeField, <[ tmpSize ]>)))
        {
          $(AllocateParentAst());
          $setAst;
          $(ParentAstPtr.Ref(sizeField)) = tmpSize;
          curEndPos = newPos;
          $(ContinueParseLabel.Goto());
        }
        else
        {
          parseState = $(State : int);//состояние
          $(FailParseLabel.Goto());
        }
      ]>
    }
  }
}
