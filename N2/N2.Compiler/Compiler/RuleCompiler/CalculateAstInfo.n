using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Compiler.Typedtree;
using N2.Model;

using System;
using System.Linq;
using SCG = System.Collections.Generic;

namespace N2
{
  internal partial class RuleCompiler
  {
    [Record]
    private class AstInfo
    {
      public HeaderSize : int;
      public Terminator : bool;
      public SizeOffsetsSize : int;
      public AstFieldsSize : int;
      public AstSize : int;
    }

    private CalculateAstInfo() : void
    {
      def calc(ast : list[int], headerSize : int, terminator : bool)
      {
        mutable astSize = headerSize;
        mutable sizeOffsetsSize = ast.Length;
        foreach (i in ast)
          _sizeOffsets[i] = <[ $(i + headerSize) ]>;

        astSize += sizeOffsetsSize + if (terminator) 1 else 0;

        mutable astFieldsSize = 0;
        foreach (i in ast)
        {
          def setOffset(size)
          {
            _astOffsets[i] = <[ $(astSize + astFieldsSize) ]>;
            astFieldsSize += size;
          }
          match (_fields[i])
          {
            | ExtentionPoint => setOffset(2)
            | ExternalAst    => setOffset(1)
            | Option         => setOffset(1)
            | List           => setOffset(1)
            | List2          => setOffset(1)
            | _              => ()
          }
        }
        astSize += astFieldsSize;
        AstInfo(headerSize, terminator, sizeOffsetsSize, astFieldsSize, astSize)
      }
      foreach (astField in _fields with i)
      {
        _astInfo[i] = match (astField)
        {
          // 0         id правила
          // 1         размер узла
          // 2         состояние разбора -1 если правило полностью разобрано.
          | Ast                 (fields)                 => [calc(fields, 3, true)]

          // 0         номер текущей грамматики. Может быть разным из-за расширений грамматики.
          | List                (fields, _, _)           => [calc(fields, 1, false)]

          | List2               (fields1, fields2, _, _) => [calc(fields1, 0, false), calc(fields2, 0, false)]

          | Option              (fields)                 => [calc(fields, 0, false)]

          | _ => []
        }
      }
    }
  }
}
