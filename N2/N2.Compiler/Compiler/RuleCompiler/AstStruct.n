using Nemerle;
using Nemerle.Compiler.Parsetree;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;

namespace N2.Compiler
{
  internal abstract class RootAstStruct : AstStruct
  {
    public IdRef     : AstStruct.HeaderField { get; private set; }
    public SizeRef   : AstStruct.HeaderField { get; private set; }
    public StateRef  : AstStruct.HeaderField { get; private set; }

    public this(compiler : RuleCompiler)
    {
      def okLabel   = compiler.MakeLabel("Ast_Ok");
      def failLabel = compiler.MakeLabel("Ast_Fail");
      base(compiler, okLabel, failLabel);
      IdRef     = AstStruct.HeaderField(this);
      SizeRef   = AstStruct.HeaderField(this);
      StateRef  = AstStruct.HeaderField(this);
    }
  }

  [Record]
  internal class SimpleAstStruct : RootAstStruct
  {
    public override HasTerminator : bool { get { false } }
  }

  [Record]
  internal class PrefixAstStruct : RootAstStruct
  {
    public override HasTerminator : bool { get { true } }
  }

  internal class PostfixAstStruct : RootAstStruct
  {
    public override HasTerminator : bool { get { true } }
    public PrefixRef : AstStruct.AstField;
    public this(compiler : RuleCompiler)
    {
      base(compiler);
      PrefixRef = AstStruct.AstField(this);
    }
  }

  internal class ExtensibleAstStruct : RootAstStruct
  {
    public override HasTerminator : bool { get { false } }
    public AstRef  : AstStruct.AstField;
    public BestRef : AstStruct.AstField;
    public this(compiler : RuleCompiler)
    {
      base(compiler);
      AstRef  = AstStruct.AstField(this);
      BestRef = AstStruct.AstField(this);
    }
  }

  internal class InternalAstStruct : AstStruct
  {
    public override HasTerminator : bool { get { false } }
    public this(field : RuleField, name : string = "")
    {
      def okLabel   = field.Compiler.MakeLabel($"$(field.GetType().Name)_$(name)_$(field.State)_Ok");
      def failLabel = field.Compiler.MakeLabel($"$(field.GetType().Name)_$(name)_$(field.State)_Fail");
      base(field.Compiler, okLabel, failLabel);
    }
  }

  internal abstract class AstStruct
  {
    public Compiler  : RuleCompiler;
    public OkLabel   : PExprLabel;
    public FailLabel : PExprLabel;

    public this(compiler : RuleCompiler, okLabel : PExprLabel, failLabel : PExprLabel)
    {
      Compiler  = compiler;
      OkLabel   = okLabel;
      FailLabel = failLabel;
    }

    public mutable HeaderSize       : int = 0;
    public mutable SizesSize        : int = 0;
    public mutable AstOffsetsSize   : int = 0;
    public mutable AllocateState    : int;
    public mutable MultipleVariants : bool = false;

    public SizesOffset            : int  { get { HeaderSize } }
    public TerminatorOffset       : int  { get { HeaderSize + SizesSize } }
    public TerminatorSize         : int  { get { if (HasTerminator) 1 else 0 } }
    public AstOffset              : int  { get { TerminatorOffset + TerminatorSize } }
    public abstract HasTerminator : bool { get; }

    public AstSize : int { get { HeaderSize + SizesSize + TerminatorSize + AstOffsetsSize } }

    [Record]
    public abstract class FieldBase
    {
      public AstStruct : AstStruct;
      public abstract OffsetInStruct : int { get; }
    }

    public class HeaderField : FieldBase
    {
      public override OffsetInStruct : int { get { InternalOffset } }
      private InternalOffset : int;
      public this(astStruct : AstStruct)
      {
        base(astStruct);
        InternalOffset = astStruct.HeaderSize;
        astStruct.HeaderSize += 1;
      }
    }

    public class SizeField : FieldBase
    {
      public override OffsetInStruct : int { get { InternalOffset + AstStruct.HeaderSize } }
      private InternalOffset : int;
      public this(astStruct : AstStruct)
      {
        base(astStruct);
        InternalOffset = astStruct.SizesSize;
        astStruct.SizesSize += 1;
      }
      public BestRef : PExpr { get { <[ parser.ast[bestAstPos + $(OffsetInStruct : int)] ]> } }
    }

    public class AstField : FieldBase
    {
      public override OffsetInStruct : int { get { InternalOffset + AstStruct.HeaderSize + AstStruct.SizesSize + AstStruct.TerminatorSize } }
      private InternalOffset : int;
      public this(astStruct : AstStruct)
      {
        base(astStruct);
        InternalOffset = astStruct.AstOffsetsSize;
        astStruct.AstOffsetsSize += 1;
      }
    }
  }
}
