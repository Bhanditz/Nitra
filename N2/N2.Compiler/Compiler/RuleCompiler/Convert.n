using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Compiler.Typedtree;
using N2.Model;

using System;
using System.Linq;
using SCG = System.Collections.Generic;

using N2.Compiler;

namespace N2
{
  internal partial class RuleCompiler
  {
    private Convert(rule : Rule) : array[RuleField]
    {
      def conv(rule : Rule) : array[RuleField]
      {
        def loc = rule.Location;
        match (rule)
        {
          | And                   as rule => array[RuleField.Predicate  (loc, conv(rule.rule), true)]
          | Not                   as rule => array[RuleField.Predicate  (loc, conv(rule.rule), false)]
          | Repeat(0, Some(1), _) as rule => array[RuleField.Option     (loc, conv(rule.rule))]
          | Repeat                as rule => array[RuleField.List       (loc, conv(rule.rule),                       rule.minCount, rule.maxCount)]
          | RepeatWithSeparator   as rule => array[RuleField.List2      (loc, conv(rule.rule), conv(rule.separator), rule.minCount, rule.maxCount, rule.hangingSeparator)]
          | String                as rule => array[RuleField.TokenString(loc, rule.str)]
          | Sequence              as rule => rule.rules.Map(conv(_)).Flatten().NToArray();
          | Call                  as rule =>
            def rd   = _grammarCompiler.TypedGrammar.GetRule(rule.name);
            match (rd, _grammarCompiler.GetRuleType(rd))
            {
              | (ExtentionPoint         , _    ) => array[RuleField.ExtentionPoint(loc, rd, rule.bindingPower)]
              | (ExternalRule(_, true)  , _    ) => array[RuleField.ExtentionPoint(loc, rd, rule.bindingPower)]
              | (ExternalRule(_, false) , Void ) => array[RuleField.Void(loc, rd)]
              | (ExternalRule(_, false) , _    ) => array[RuleField.ExternalAst(loc, rd)]
              | (Simple                 , Void ) => array[RuleField.Void(loc, rd)]
              | (Simple                 , _    ) => array[RuleField.ExternalAst(loc, rd)]
              | (Regular                , _    ) => array[RuleField.TokenCall(loc, rd)]
              | (Marker                 , _    ) => array[]
              | _                                => assert(false);
            }
          | PrefixCall => assert(false)
        }
      }
      def loc = rule.Location;
      def rule = match (rule)
      {
        | Sequence(PrefixCall :: rules) as rule => Rule.Sequence(rule.Location, rule.Type, rule.Id, rules)
        | rule => rule
      }
      def ast = RuleField.Ast(loc, _grammarCompiler.IsDebug, conv(rule), _ruleDefinition);
      def fields = SCG.List();
      ast.Init(this, null, 0, fields);
      ast.CalculateAstInfo();
      fields.Iter(_.Compile());
      fields.NToArray();
    }
  }
}
