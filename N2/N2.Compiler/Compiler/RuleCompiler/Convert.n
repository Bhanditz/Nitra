using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Compiler.Typedtree;
using N2.Model;

using System;
using System.Linq;
using SCG = System.Collections.Generic;

namespace N2
{
  internal partial class RuleCompiler
  {
    private Convert(rule : Rule) : array[AstField]
    {
      mutable fields = SCG.List.[AstField]();
      def newField()
      {
        def id = fields.Count;
        fields.Add(null);
        id;
      }

      def convertRule(parent : int, level : int, rule : Rule) : list[int]
      {
        def add(field)
        {
          def fieldId = newField();
          fields[fieldId] = field(convertRule(fieldId, level + 1, _))(parent, level);
          [fieldId]
        }

        match (rule)
        {
          | And                   as rule => add(conv => AstField.Predicate  (_, _, conv(rule.rule), true))
          | Not                   as rule => add(conv => AstField.Predicate  (_, _, conv(rule.rule), false))
          | Repeat(0, Some(1), _) as rule => add(conv => AstField.Option     (_, _, conv(rule.rule)))
          | Repeat                as rule => add(conv => AstField.List       (_, _, conv(rule.rule),                       rule.minCount, rule.maxCount))
          | RepeatWithSeparator   as rule => add(conv => AstField.List2      (_, _, conv(rule.rule), conv(rule.separator), rule.minCount, rule.maxCount))
          | String                as rule => add(_    => AstField.TokenString(_, _, rule.str))
          | Sequence              as rule => rule.rules.Map(convertRule(parent, level, _)).Flatten()
          | Call                  as rule =>
            def rd   = _grammarCompiler.TypedGrammar.GetRule(rule.name);
            def field : _ -> AstField = match (rd, _grammarCompiler.GetRuleType(rd))
            {
              | (ExtentionPoint         , _    ) => AstField.ExtentionPoint
              | (ExternalRule(_, true)  , _    ) => AstField.ExtentionPoint
              | (ExternalRule(_, false) , Void ) => AstField.Void
              | (ExternalRule(_, false) , _    ) => AstField.ExternalAst
              | (Simple                 , Void ) => AstField.Void
              | (Simple                 , _    ) => AstField.ExternalAst
              | (Regular                , _    ) => AstField.TokenCall
              | _     => assert(false);
            }
            add(_ => field(_, _, rd))
          | PrefixCall                  => assert(false)
        }
      }
      def rule = match (rule)
      {
        | Sequence(PrefixCall :: rules) as rule => Rule.Sequence(rule.Location, rule.Type, rule.Id, rules)
        | rule => rule
      }
      fields.Add(null);
      fields[0] = AstField.Ast(-1, -1, convertRule(0, 0, rule));
      fields.NToArray()
    }
  }
}
