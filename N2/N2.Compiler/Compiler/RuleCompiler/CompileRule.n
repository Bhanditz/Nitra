using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Compiler.Typedtree;
using N2.Model;
using N2.Compiler;

using System;
using System.Linq;
using SCG = System.Collections.Generic;

namespace N2
{
  internal partial class RuleCompiler
  {
    private _names : SCG.Dictionary[string, PExpr] = SCG.Dictionary();
    public GetName(name : string) : PExpr
    {
      mutable nameRef;
      if (_names.TryGetValue(name, out nameRef))
        nameRef
      else
      {
        nameRef = <[ $(name : dyn) ]>;
        _names[name] = nameRef;
        nameRef;
      }
    }
    public EndLabel : PExprLabel;

    public Fields : array[RuleField] { get; private set; }
    public RootField : RuleField.Ast { get { if (Fields != null) Fields[0] :> RuleField.Ast else null } }

    private Compile(rule : Rule) : PExpr
    {
      Fields = Convert(rule);

      def code = SCG.List();
      code.Add(<[ _ = $(rule.ToString()) ]>);
      code.AddRange(Fields.Map(field => <[ _= $(field.Print()) ]>));
      code.Add(<[
        def startEndPos             = curEndPos;
        _ = startEndPos; // TODO: We have warning: N168. Maybe this is a bug?
        mutable tmpResult  : int; _ = tmpResult;
        mutable tmpSize    : int; _ = tmpSize;
        mutable parseState : int; _ = parseState;
        mutable newPos     : int; _ = newPos;
      ]>);
      code.AddRange(_names.Filter(kv => kv.Key != "resultRef").Map(kv => <[ mutable $(kv.Key : dyn) ]>));
      code.AddRange(Fields.Map(field => field.ParseCode));
      code.Add(<[ $(EndLabel.Label()); curEndPos; ]>);
      PExpr.Sequence(code.FlattenPExprSequence())
    }

    public CompileRule() : void
    {
      try
      {
        match (_ruleDefinition)
        {
          | ExtentionPoint           => ()
          | ExtentionPrefix as rule  => CompileExtensionPrefix(rule)
          | ExtentionPostfix as rule => CompileExtensionPostfix(rule)
          | Simple as rule           => CompileSimpleRule(rule)
          | Regular as rule          => CompileRegularRule(rule)
          | Marker
          | ExternalRule             => assert(false);
        }
      }
      catch
      {
        | ex => Message.Error(_ruleDefinition.Name.Location, ex.ToString());
      }
    }
  }
}
