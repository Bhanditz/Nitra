using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Compiler.Typedtree;
using N2.Model;

using System;
using System.Linq;
using SCG = System.Collections.Generic;

namespace N2
{
  internal partial class RuleCompiler
  {
    private Compile(rule : Rule) : PExpr
    {
      def fields = Convert(rule);

      def code = SCG.List();
      code.Add(<[ _ = $(rule.ToString()) ]>);
      code.AddRange(fields.Map(_.Print()));
      code.Add(<[
        mutable diff;
        mutable parseState;
        mutable bestAstPos;
        mutable isBest = false;
        mutable newPos;
      ]>);
      def max = fields.Max(_.Level) - 1;
      code.AddRange($[0..max].Map(i => <[ mutable $($"astPos$i" : dyn)   : int; _ = $($"astPos$i" : dyn); ]>));
      code.AddRange($[1..max].Map(i => <[ mutable $($"textPos$i" : dyn)  : int; _ = $($"textPos$i" : dyn); ]>));
      code.AddRange($[1..max].Map(i => <[ mutable $($"counter$i" : dyn)  : int; _ = $($"counter$i" : dyn); ]>));
      code.AddRange($[1..max].Map(i => <[ mutable $($"listTail$i" : dyn) : int; _ = $($"listTail$i" : dyn); ]>));
      code.AddRange(fields.Map(field => <[ $(field.Print()); $(field.ParseCode); ]>));
      code.Add(<[ throw System.Exception() ]>);
      PExpr.Sequence(code.FlattenPExprSequence())
    }

    public CompileRule() : void
    {
      match (_ruleDefinition)
      {
        | ExtentionPoint           => ()
        | ExtentionPrefix as rule  => CompileExtensionPrefix(rule)
        | ExtentionPostfix as rule => CompileExtensionPostfix(rule)
        | Simple as rule           => CompileSimpleRule(rule)
        | Regular as rule          => CompileRegularRule(rule)
        | ExternalRule             => ()
      }
    }




  }
}
