using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Compiler.Typedtree;
using N2.Model;

using System;
using System.Linq;
using SCG = System.Collections.Generic;

namespace N2
{
  internal partial class RuleCompiler
  {
    private Compile(rule : Rule) : PExpr
    {
      //  def ruleCall(call) { parseCode(<[ ({ newPos = $call; newPos > 0 }) ]>, <[ (newPos - curEndPos) ]>) }
      //  match (field : AstField)
      //  {
      //    | TokenString(str)       => parseCode(StringCheckCode(<[ curEndPos ]>, str), <[ $(str.Length) ]>)
      //    | TokenCall(rd)          => ruleCall(<[ $(MakeTokenCall(rd))(curEndPos, text) ]>)
      //    | Void(rd)               => ruleCall(<[ $(MakeCall(rd))(curEndPos, text) ]>)
      //    | ExternalAst(rd)        => ruleCall(<[ $(MakeCall(rd))(curEndPos, text, $astPos + $astOffset, ref parser) ]>)
      //    | ExtentionPoint(rd, bp) => ruleCall(<[ $(MakeCall(rd, bp))(curEndPos, text, $astPos + $astOffset, ref parser) ]>)
      //    | Ast                    => PExpr.Error("Ast                 not implemented")
      //    | Option                 => PExpr.Error("Option              not implemented")
      //    | List                   => PExpr.Error("List                not implemented")
      //    | List2                  => PExpr.Error("List2               not implemented")
      //    | Predicate              => PExpr.Error("Predicate           not implemented")
      //  }
      //}
      def fields = Convert(rule);
      fields.Iter(_.Compile());
      def code = SCG.List();
      code.Add(<[ _ = $(rule.ToString()) ]>);
      code.AddRange(fields.Map(_.Print()));
      code.AddRange(
        [ <[ mutable diff; ]>
        , <[ mutable parseState; ]>
        , <[ mutable bestAstPos; ]>
        , <[ mutable isBest = false; ]>
        , <[ mutable newPos; ]>
        ]);
      code.AddRange($[0..fields.Max(_.Level)].Map(i => <[ { mutable $($"astPos$i" : dyn); _ = $($"astPos$i" : dyn); }]>));
      code.AddRange(fields.Map(field => <[ $(field.Print()); $(field.ParseCode); ]>));
      code.Add(<[ throw System.Exception() ]>);
      PExpr.Sequence(code.FlattenPExprSequence())
    }

    public CompileRule() : void
    {
      match (_ruleDefinition)
      {
        | ExtentionPoint           => ()
        | ExtentionPrefix as rule  => CompileExtensionPrefix(rule)
        | ExtentionPostfix as rule => CompileExtensionPostfix(rule)
        | Simple as rule           => CompileSimpleRule(rule)
        | Regular as rule          => CompileRegularRule(rule)
        | ExternalRule             => ()
      }
    }




  }
}
