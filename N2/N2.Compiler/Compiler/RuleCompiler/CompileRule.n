using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Compiler.Typedtree;
using N2.Model;

using System;
using System.Linq;
using SCG = System.Collections.Generic;

namespace N2
{
  internal partial class RuleCompiler
  {
    private _names : SCG.Dictionary[string, PExpr] = SCG.Dictionary();
    public GetName(name : string) : PExpr
    {
      mutable nameRef;
      if (_names.TryGetValue(name, out nameRef))
        nameRef
      else
      {
        nameRef = <[ $(name : dyn) ]>;
        _names[name] = nameRef;
        nameRef;
      }
    }
    public mutable EndLabel : PExprLabel;
    private Compile(rule : Rule) : PExpr
    {
      def fields = Convert(rule);

      def code = SCG.List();
      code.Add(<[ _ = $(rule.ToString()) ]>);
      code.AddRange(fields.Map(_.Print()));
      code.Add(<[
      ___error___;
        mutable diff;
        mutable parseState;
        mutable bestAstPos;
        mutable isBest = false;
        mutable newPos;
      ]>);
      code.AddRange(_names.Map(kv => <[ mutable $(kv.Key : dyn) ]>));
      code.AddRange(fields.Map(field => <[ $(field.Print()); $(field.ParseCode); ]>));
      code.Add(<[ $(EndLabel.Label()); curEndPos; ]>);
      PExpr.Sequence(code.FlattenPExprSequence())
    }

    public CompileRule() : void
    {
      match (_ruleDefinition)
      {
        | ExtentionPoint           => ()
        | ExtentionPrefix as rule  => CompileExtensionPrefix(rule)
        | ExtentionPostfix as rule => CompileExtensionPostfix(rule)
        | Simple as rule           => CompileSimpleRule(rule)
        | Regular as rule          => CompileRegularRule(rule)
        | ExternalRule             => ()
      }
    }
  }
}
