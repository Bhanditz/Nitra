using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Compiler.Typedtree;
using N2.Model;

using System;
using System.Linq;
using SCG = System.Collections.Generic;

namespace N2
{
  internal partial class RuleCompiler
  {
    private PrintRule(rule : Rule) : PExpr
    {
      PExpr.Sequence(Convert(rule).NToList().MapI((i, field) => <[ _ = $(string.Format("{0, 4} {1}", i, field))]>))
    }

    private mutable _fields      : array[AstField];
    private mutable _sizeOffsets : array[PExpr];
    private mutable _astOffsets  : array[PExpr];

    private Compile(rule : Rule) : PExpr
    {
      _fields      = Convert(rule);
      _sizeOffsets = array(_fields.Length);
      _astOffsets  = array(_fields.Length);
      for(mutable i = 0; i < _sizeOffsets.Length; ++i)
        _sizeOffsets[i] = PExpr.Error($"size offset invalid for $i");
      for(mutable i = 0; i < _astOffsets.Length; ++i)
        _astOffsets[i] = PExpr.Error($"ast offset invalid for $i");

      def parseLabel = MakeLabels(_fields.Length);
      def failLabel  = MakeLabel();

      def gotoParse(n)  { Goto(parseLabel[n]) }
      def labelParse(n) { Label(parseLabel[n]) }

      def parseCode(state : int, check : PExpr, astSize : PExpr)
      {
        def sizeOffset = _sizeOffsets[state];
        <[
          $(labelParse(state));
          if ($check && (isBest || ({ diff = parser.ast[bestAstPos + $sizeOffset] - ($astSize); isBest = diff < 0; diff <= 0})))
          {
            parser.ast[astPos + $sizeOffset] =  $astSize; // размер
            curEndPos += $astSize;
          }
          else
          {
            parser.ast[astPos + 2] = $state;//состояние
            parser.ast[astPos + $sizeOffset] = -1; // размер
            $(Goto(failLabel))
          }
        ]>
      }
      def makeAst(state, field)
      {
        def ruleCall(call) { parseCode(state, <[ ({ newPos = $call; newPos > 0 }) ]>, <[ (newPos - curEndPos) ]>) }
        match (field : AstField)
        {
          | TokenString(str)       => parseCode(state, StringCheckCode(<[ curEndPos ]>, str), <[ $(str.Length) ]>)
          | TokenCall(rd)          => ruleCall(<[ $(MakeTokenCall(rd))(curEndPos, text) ]>)
          | Void(rd)               => ruleCall(<[ $(MakeCall(rd))(curEndPos, text) ]>)
          | ExternalAst(rd)        => ruleCall(<[ $(MakeCall(rd))(curEndPos, text, astPos + __shift__, ref ast) ]>)
          | ExtentionPoint(rd, bp) => ruleCall(<[ $(MakeCall(rd, bp))(curEndPos, text, astPos + __shift__, ref ast) ]>)
          | Ast                    => PExpr.Error("Ast                 not implemented")
          | Option                 => PExpr.Error("Option              not implemented")
          | List                   => PExpr.Error("List                not implemented")
          | List2                  => PExpr.Error("List2               not implemented")
          | Predicate              => PExpr.Error("Predicate           not implemented")
        }
      }
      def localVars =
        [ <[ mutable diff; ]>
        , <[ mutable bestAstPos; ]>
        , <[ mutable isBest = false; ]>
        , <[ mutable astPos = -1; ]>
        , <[ mutable newPos; ]>
        ];
      def flattenSequence(expr : PExpr)
      {
        | Sequence(exprs) => exprs
        | _               => [expr]
      }
      def parsingExprs = _fields.NToList().MapI(makeAst).Map(flattenSequence).Flatten();
      PExpr.Sequence([PrintRule(rule)] + localVars + parsingExprs + [<[ $(Label(failLabel)); ]>, <[ -1 ]>])
    }

    public CompileRule() : void
    {
      match (_ruleDefinition)
      {
        | ExtentionPoint           => ()
        | ExtentionPrefix as rule  => CompileExtensionPrefix(rule)
        | ExtentionPostfix as rule => CompileExtensionPostfix(rule)
        | Simple as rule           => CompileSimpleRule(rule)
        | Regular as rule          => CompileRegularRule(rule)
        | ExternalRule             => ()
      }
    }
  }
}
