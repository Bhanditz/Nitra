using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Compiler.Typedtree;
using N2.Model;
using N2.Compiler;

using System;
using System.Linq;
using SCG = System.Collections.Generic;

namespace N2
{
  internal partial class RuleCompiler
  {
    private _names : SCG.Dictionary[string, PExpr] = SCG.Dictionary();
    public GetName(name : string) : PExpr
    {
      mutable nameRef;
      if (_names.TryGetValue(name, out nameRef))
        nameRef
      else
      {
        nameRef = <[ $(name : dyn) ]>;
        _names[name] = nameRef;
        nameRef;
      }
    }
    public EndLabel : PExprLabel;

    private mutable Fields : array[RuleField];

    public GetFieldCount() : int * int * int * int
    {
      match (_ruleDefinition)
      {
        | ExternalRule => assert(false);
        | ExtentionPoint => (3, 0, 0, 2)
        | Regular        => (0, 0, 0, 0)
        | ExtentionPrefix | ExtentionPostfix | Simple =>
          def ast = Fields[0] :> RuleField.Ast;
          (ast.astStruct.HeaderSize, ast.astStruct.SizesSize, ast.astStruct.TerminatorSize, ast.astStruct.AstOffsetsSize)
      }
    }

    private Compile(rule : Rule) : PExpr
    {
      Fields = Convert(rule);
      def ast = Fields[0] :> RuleField.Ast;

      def code = SCG.List();
      code.Add(<[ _ = $(rule.ToString()) ]>);
      code.AddRange(Fields.Map(field => <[ _= $(field.Print()) ]>));
      when (ast.IsExtension)
        code.Add(<[
          mutable diff       : int; _ = diff;
          mutable bestAstPos : int;
          mutable isBest     : bool = false;
        ]>);
      code.Add(<[
        mutable tmpResult  : int; _ = tmpResult;
        mutable tmpSize    : int; _ = tmpSize;
        mutable parseState;
        mutable newPos;
      ]>);
      code.AddRange(_names.Filter(kv => kv.Key != "resultRef").Map(kv => <[ mutable $(kv.Key : dyn) ]>));
      code.AddRange(Fields.Map(field => field.ParseCode));
      code.Add(<[ $(EndLabel.Label()); curEndPos; ]>);
      PExpr.Sequence(code.FlattenPExprSequence())
    }

    public CompileRule() : void
    {
      try
      {
        match (_ruleDefinition)
        {
          | ExtentionPoint           => ()
          | ExtentionPrefix as rule  => CompileExtensionPrefix(rule)
          | ExtentionPostfix as rule => CompileExtensionPostfix(rule)
          | Simple as rule           => CompileSimpleRule(rule)
          | Regular as rule          => CompileRegularRule(rule)
          | ExternalRule             => assert(false);
        }
      }
      catch
      {
        | ex => Message.Error(_ruleDefinition.Name.Location, ex.ToString());
      }
    }
  }
}
