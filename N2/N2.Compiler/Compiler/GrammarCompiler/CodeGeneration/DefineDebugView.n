using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using N2.Model;

using System;
using System.Diagnostics;
using System.Linq;
using SCG = System.Collections.Generic;

using N2.Internal;

namespace N2
{
  internal partial class GrammarCompiler
  {
    public DefineDebugView(rd : RuleDefinition, descriptorTB : TypeBuilder) : void
    {
      def ruleCompiler = _ruleCompilers[rd];
      //ruleCompiler.RootField.
      def tb = descriptorTB.DefineNestedType(<[decl:
          private class DebugView
          {
            [DebuggerBrowsable(DebuggerBrowsableState.Never)] public parser : N2.Internal.Parser;
            [DebuggerBrowsable(DebuggerBrowsableState.Never)] public index : int;

            public this(parser : N2.Internal.Parser, index : int)
            {
              this.parser = parser;
              this.index  = index;
            }

            public override ToString() : string
            {
              def rd = $(descriptorTB.GetMemType() : typed).StaticDescriptor;
              string.Format("{0, 5} {1, -5} {2} {3} {4}", "Ast", index, rd.Grammar.FullName, rd.Name, rd.GetType().Name);
            }
          }
        ]>);
      tb.Compile();
      _ = descriptorTB.DefineWithSource(<[decl:
        public override FillDebugAst(parser : N2.Internal.Parser, index : int, debugAst : array[object]) : void
        {
          debugAst[index] = $(descriptorTB.GetMemType() : typed).DebugView(parser, index);
        }
      ]>);
    }
  }
}
