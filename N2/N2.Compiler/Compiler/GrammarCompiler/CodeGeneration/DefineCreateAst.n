using Nemerle;
using Nemerle.Collections;
using Nemerle.Imperative;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Compiler.Typedtree;

using N2.Internal;
using N2.Model;

using System;
using System.Diagnostics;
using System.Linq;
using SCG = System.Collections.Generic;

namespace N2
{
  internal partial class GrammarCompiler
  {
    public DefineCreateAst(rd : RuleDefinition, descriptorTB : TypeBuilder) : void
    {
      def ruleCompiler = _ruleCompilers[rd];

      def body = match (rd)
      {
        | Simple when rd.IsAst =>
          def astTb = DefineAstType(rd);
          <[
            assert(ast[index] > 0, "Bad ast offset");
            $(PExpr.FromQualifiedIdentifier(Manager, astTb.FullName)).Ast(N2.Location(source, 0, 0), [])
          ]>

        | ExtentionPrefix
        | ExtentionPostfix
        | ExtentionPoint
        | _ =>
          <[
            ignore(source, parserHost, ast, index);
            throw System.NotImplementedException();
          ]>
      }

      _ = descriptorTB.DefineWithSource(<[decl:
        public override CreateAst(source : N2.SourceSnapshot, parserHost : N2.ParserHost, ast : array[int], index : int) : N2.Ast
        {
          $body;
        }
      ]>);
    }
  }
}
