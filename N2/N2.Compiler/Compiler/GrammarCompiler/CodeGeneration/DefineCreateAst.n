using Nemerle;
using Nemerle.Collections;
using Nemerle.Imperative;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Compiler.Typedtree;

using N2.Internal;
using N2.Model;
using N2.Compiler;

using System;
using System.Diagnostics;
using System.Linq;
using SCG = System.Collections.Generic;

namespace N2
{
  internal partial class GrammarCompiler
  {
    public DefineCreateAst(rd : RuleDefinition, descriptorTB : TypeBuilder) : void
    {
      def rootAstMaker(arguments : list[PExpr]) : PExpr
      {
        def arguments = <[ N2.Location(source, startPos, endPos) ]> :: <[ [] ]> :: arguments;
        <[ $( PExpr.FromQualifiedIdentifier(Manager, DefineAstType(rd).FullName)).Ast(..$arguments) ]>
      }
      def internalAstMaker(_ : list[PExpr]) : PExpr
      {
        | []   => assert(false)
        | [x]  => x
        | many => <[ (..$many) ]>
      }
      def makeReader(structField : AstStruct.StructField, astPointer : AstPointer) : PExpr
      {
        match(structField.Field)
        {
          | RuleField.TokenString
          | RuleField.TokenCall =>
            <[ N2.NToken(startPos, endPos) ]>

          | RuleField.ExternalAst(ruleDefinition = rd) =>
            <[
              $(GetStaticDescriptorRef(rd))
                .CreateAst(source, parserHost, ast, ast[$(astPointer.AstOffset(structField))], startPos)
                :> $(GetRuleNType(rd) : typed)
            ]>

          | RuleField.ExtentionPoint(ruleDefinition = rd) =>
            <[
              def astIndex = ast[$(astPointer.AstOffset(structField))];
              parserHost.GetRuleDescriptorById(ast[astIndex])
                .CreateAst(source, parserHost, ast, astIndex, startPos)
                :> $(GetRuleNType(rd) : typed)
            ]>

          | RuleField.List(astStruct = valueAstStruct, NextRef = nextRef) =>
            def valueAstPointer = AstPointer(valueAstStruct, "astIndex");
            <[
              def buffer = System.Collections.Generic.List();
              mutable astIndex = ast[$(astPointer.AstOffset(structField))];
              while (astIndex > 0)
              {
                buffer.Add($(makeAst(valueAstStruct, valueAstPointer, internalAstMaker)));
                astIndex = ast[$(valueAstPointer.AstOffset(nextRef))];
              }
              Nemerle.Collections.NList.ToList(buffer)
            ]>

          | RuleField.List2 =>
            <[ ([], []) ]>

          | RuleField.Option(astStruct = valueAstStruct) =>
            <[
              def astIndex = ast[$(astPointer.AstOffset(structField))];
              if (astIndex > 0)
                Some($(makeAst(valueAstStruct, AstPointer(valueAstStruct, "astIndex"), internalAstMaker)))
              else
                None()
            ]>

          | _ => assert(false)
        }
      }
      and makeAst(astStruct : AstStruct, astPointer : AstPointer, maker : list[PExpr] -> PExpr) : PExpr
      {
        def statements = SCG.List();
        def arguments = SCG.List();
        foreach(structField in astStruct.SizeFields)
        {
          match(structField.Field)
          {
            | RuleField.Ast
            | RuleField.Predicate => ()
            | RuleField.Void =>
              statements.Add(<[ startPos = endPos + ast[$(astPointer.SizeOffset(structField))] ]>);
              statements.Add(<[ endPos = startPos ]>);

            | _ =>
              def varName = Util.tmpname("ast");
              statements.Add(<[ endPos = startPos + ast[$(astPointer.SizeOffset(structField))] ]>);
              statements.Add(<[ def $(varName : usesite) = $(makeReader(structField, astPointer)) ]>);
              statements.Add(<[ startPos = endPos ]>);
              arguments.Add(<[ $(varName : usesite) ]>);
          }
        }
        statements.Add(maker(arguments.ToNList()));
        <[ { ..$(statements.ToNList()) } ]>
      }
      match (rd)
      {
        | Simple when rd.IsAst =>
          def ruleCompiler = _ruleCompilers[rd];
          def astStruct = ruleCompiler.RootField.astStruct;
          def astPointer = AstPointer(astStruct, "index");
          _ = descriptorTB.DefineWithSource(<[decl:
            public override CreateAst(source : N2.SourceSnapshot, parserHost : N2.ParserHost, ast : array[int], index : int, pos : int) : N2.Ast
            {
              assert(ast[$(astPointer.HeaderOffset(astStruct.StateRef))] == -1);
              mutable startPos = pos;
              mutable endPos = pos;
              ignore(source, parserHost, ast, index, startPos, endPos);
              $(makeAst(astStruct, astPointer, rootAstMaker))
            }
          ]>);

        | ExtentionPrefix
        | ExtentionPostfix
        | ExtentionPoint
        | _ =>
          _ = descriptorTB.DefineWithSource(<[decl:
            public override CreateAst(source : N2.SourceSnapshot, parserHost : N2.ParserHost, ast : array[int], index : int, pos : int) : N2.Ast
            {
              ignore(source, parserHost, ast, index, pos);
              throw System.NotImplementedException();
            }
          ]>);
      }
    }
  }
}
