using System;
using System.Linq;
using SCG = System.Collections.Generic;

using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Imperative;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Compiler.Parsetree.PExpr;
using Nemerle.Compiler.Token;
using N2.Model;

namespace N2
{
  internal partial class GrammarCompiler
  {
    private AddWhitespaceRules() : void
    {
      def sName = NameRef(Location.Default, "s");
      def SName = NameRef(Location.Default, "S");
      def sNameLookupResult = ParsedGrammar.TryGetRule(sName);
      def SNameLookupResult = ParsedGrammar.TryGetRule(SName);

      def compiledKeywordRegex = ParsedGrammar.KeywordRegexes.ToDictionary(_.Id, kr => FSMMatch.MakeMatcher(ConvertRegularRuleToFsm(ParsedGrammar, kr.Match)));

      def convertRule(rd : RuleDefinition, r : Rule.Sequence) : Rule.Sequence
      {
        def needSpaces(name)
        {
          def rd = ParsedGrammar.GetRule(name);
          rd.IsExplicitSpaces || rd is RuleDefinition.Regular
        }
        def makeWhitespaceRuleCall(r : Rule, whitespaceRuleLookupResult : option[RuleDefinition], whitespaceRuleName : NameRef)
        {
          def loc = r.Location.FromEndAsGenerated();
          def nameLocated = NameRef(loc, whitespaceRuleName.Parts);
          match (whitespaceRuleLookupResult)
          {
            | Some => Rule.Call(loc, RuleType.Void(), 0, nameLocated, 0)
            | None => Message.FatalError(rd.Name.Location, $"Whitespace rule '$sName' is required")
          }
        }
        def convert(r : Rule) : Rule
        {
          | Cut => r
          | PrefixCall(name, _)
          | Call(name, _) =>
            result :
            {
              def nameLookupResult = ParsedGrammar.TryGetRule(name);
              when (nameLookupResult.IsSome)
                if (nameLookupResult.Equals(sNameLookupResult) || nameLookupResult.Equals(SNameLookupResult))
                  Message.Error(r.Location, "Unexpected whitespace rule. Mark rule with 'ExplicitSpaces' attribute.");
                else when (needSpaces(name))
                  result(Rule.Sequence(r, [r, makeWhitespaceRuleCall(r, sNameLookupResult, sName)]));
              r
            }

          | String(str) =>
            def isKeyword = rd.KeywordRegexes.FoldLeft(false, fun (keywordRegex, acc)
            {
              mutable compiledKr;
              unless (compiledKeywordRegex.TryGetValue(keywordRegex.Id, out compiledKr))
                assert(false);
              acc || compiledKr(str)
            });
            Rule.Sequence(r, [r,
              if (isKeyword)
                makeWhitespaceRuleCall(r, SNameLookupResult, SName)
              else
                makeWhitespaceRuleCall(r, sNameLookupResult, sName)
            ]);

          | Scope(name, rule)                              => Rule.Scope(r, name, convert(rule))
          | Repeat(min, max, rule)                         => Rule.Repeat(r, min, max, convert(rule))
          | RepeatWithSeparator(min, max, rule, separator) => Rule.RepeatWithSeparator(r, min, max, convert(rule), convert(separator))
          | Not(rule)                                      => Rule.Not(r, convert(rule))
          | And(rule)                                      => Rule.And(r, convert(rule))
          | Sequence(rules)                                => Rule.Sequence(r, rules.Map(convert))
        }
        convert(r) :> Rule.Sequence
      }
      def convertRuleDefinition(rd : RuleDefinition)
      {
        | ExtentionPoint
        | ExtentionPrefix  when rd.IsExplicitSpaces
        | ExtentionPostfix when rd.IsExplicitSpaces
        | Simple           when rd.IsExplicitSpaces
        | Regular
        | ExternalRule => rd

        | ExtentionPrefix(baseRuleName, rule, names)                => RuleDefinition.ExtentionPrefix(rd, baseRuleName, convertRule(rd, rule), names)
        | ExtentionPostfix(baseRuleName, bindingPower, rule, names) => RuleDefinition.ExtentionPostfix(rd, baseRuleName, bindingPower, convertRule(rd, rule), names)
        | Simple(retType, rule, names)                              => RuleDefinition.Simple(rd, retType, convertRule(rd, rule), names)
      }
      mutable grammar = Grammar(ParsedGrammar.GrammarRefs, ParsedGrammar.SpanClasses, ParsedGrammar.BracePairs, ParsedGrammar.KeywordRegexes);
      foreach(rd in ParsedGrammar.Rules) 
        grammar = grammar.Add(convertRuleDefinition(rd));
      WhitespacedGrammar = grammar;
    }
  }
}
