using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Assertions;
using Nemerle.Imperative;
using N2.Model;

using System;
using System.Diagnostics;
using System.Linq;

using G = GrammarParser2;
using SCG = System.Collections.Generic;

namespace N2
{
  internal partial class GrammarCompiler
  {
    private _externalGrammars : SCG.List[GrammarRef * TypeInfo] = SCG.List();
    private _externalRuleTypeGetters : SCG.Dictionary[int, NameRef -> RuleType] = SCG.Dictionary();
    private _externalRuleDescriptorGetters : SCG.Dictionary[RuleDefinition, void -> PExpr] = SCG.Dictionary();
    private mutable _loadingExternalGrammars : bool = false;
    public LoadExternalGrammars() : void
    {
      when (_loadingExternalGrammars)
      {
        //Message.Hint("ignored");
        return;
      }
      _loadingExternalGrammars = true;
      
      //Message.Hint("LoadExternalGrammars() called");

      def parserHost = ParserHost();
      def parseKeywordRegex(text : string) : KeywordRegex
      {
        def parseResult = parserHost.DoParsing(SourceSnapshot(text), G.GrammarImpl.DeclarationRuleDescriptor);
        if (parseResult.IsSuccess)
          match (parseResult.CreateAst.[G.Declaration]())
          {
            | G.KeywordRegexDecl.Ast as decl =>
              def name        = decl.QualifiedName.ToNameRef();
              def matchTokens = decl.MatchTokens.RegularRule();
              KeywordRegex(Location.Default, N2SourceImpl.NextKeywordRegexId(), text, matchTokens, name, true);

            | _ => Message.FatalError($"Expected keyword regex '$text'");
          }
        else
          Message.FatalError($"Failed to parse keyword regex '$text'");
      }

      foreach (grammarRef in ParsedGrammar.GrammarRefs)
      {
        def makeName(name)
        {
          match (grammarRef.Alias)
          {
            | Some(alias) =>
              alias + name
            | _ => name
          }
        }
        match (grammarRef.GrammarType)
        {
          | FixedType.Class(ti, tiArgs) =>
            when (!tiArgs.IsEmpty)
              Message.Error(grammarRef.Location, "Generic grammar not supported.");
            match (ti)
            {
              | tb is TypeBuilder =>
                match (tb.UserData[typeof(GrammarCompiler)])
                {
                  | compiler is GrammarCompiler =>
                    _externalGrammars.Add((grammarRef, compiler.GrammarImplTB));
                    //Message.Hint($"recursive - Grammsr: '$(compiler.GrammarTB.Name)'");
                    compiler.LoadExternalGrammars();
                    def grammar = compiler.ParsedGrammar;
                    foreach (kr in grammar.KeywordRegexes)
                      ParsedGrammar = ParsedGrammar.Add(KeywordRegex(kr.Location, N2SourceImpl.NextKeywordRegexId(), kr.Source, kr.Match, kr.Name, true));
                    _externalRuleTypeGetters.Add(grammarRef.Id, compiler.GetRuleType);
                    foreach (rd in grammar.Rules)
                    {
                      | RuleDefinition.Marker(true)
                      | RuleDefinition.ExternalRule => ()
                      | RuleDefinition.Marker(false) =>
                        ParsedGrammar = ParsedGrammar.Add(RuleDefinition.Marker(
                          rd.Name.Location, ParsedGrammar.Count, makeName(rd.Name), [], Map() /*TODO: !!!*/, [],
                          rd.ExtraFields, None(), true));

                      | rd =>
                        def isExtentionPoint = rd is RuleDefinition.ExtentionPoint;
                        def attributes = rd.Attributes.Filter(fun(_)
                        {
                          | RuleAttribute.ExplicitSpaces
                          | RuleAttribute.SuppressTrailingSpaces => true
                          | _ => false
                        });
                        def externalRD = RuleDefinition.ExternalRule(
                          rd.Name.Location, ParsedGrammar.Count, makeName(rd.Name), attributes, Map() /*TODO: !!!*/, [],
                          rd.ExtraFields, None(), grammarRef, isExtentionPoint);
                        _externalRuleDescriptorGetters.Add(externalRD, () => compiler.GetDescriptorClassRef(rd));
                        ParsedGrammar = ParsedGrammar.Add(externalRD);
                    }

                  | _ => Message.Error("Implementation eror. No GrammarCompiler in type builder.");
                }

              | grammarTI is LibraryReference.ExternalTypeInfo =>
                match (grammarTI.GetNestedSubtypes().Filter(ti => ti.Name == GrammarImplTB.Name))
                {
                  | [grammarImplTI] =>
                    match (grammarImplTI.GetNestedSubtypes().Filter(ti => ti.Name == GrammarDescriptorImplTB.Name))
                    {
                      | [grammarDescriptorImplTI] =>
                        _externalGrammars.Add((grammarRef, grammarImplTI));
                        foreach(attr in grammarImplTI.GetModifiers().CustomAttributes)
                        {
                          | <[ N2.KeywordRegexesAttribute(array[ ..$sources ]) ]> =>
                            foreach(source in sources)
                            {
                              | <[ $(source : string) ]> => ParsedGrammar = ParsedGrammar.Add(parseKeywordRegex(source))
                              | _ => ()
                            }

                          | <[ N2.MarkerAttribute($(name : string)) ]> =>
                            ParsedGrammar = ParsedGrammar.Add(
                              RuleDefinition.Marker(Location.Default, ParsedGrammar.Count, makeName(NameRef(Location.Default, name)), [], Map(), [], [], None(), true))

                          | _ => ()
                        }
                        def ruleNameToType = Hashtable();
                        foreach (ruleTI in grammarDescriptorImplTI.GetNestedSubtypes())
                          when (Util.ParseRuleClassName(ruleTI.Name) is Some((type, name)))
                          {
                            def name = NameRef(ruleTI.NameLocation, name);
                            def ruleType = ret:
                              {
                                foreach (method is IMethod in ruleTI.GetMembers())
                                  when (method.Name == "ResultType")
                                    if (method.ReturnType.TryUnify(Manager.InternalType.Void))
                                      ret(RuleType.Void());
                                    else
                                      ret(RuleType.NType(method.ReturnType :> FixedType));
                                RuleType.Chars();
                              };
                            ruleNameToType.Add(name, ruleType);
                            def isExtentionPoint = type is RuleDefinitionType.ExtentionPoint;
                            def extraFields = Util.LoadExtraFields(ruleType);
                            mutable attributes = [];
                            foreach(attr in ruleTI.GetModifiers().CustomAttributes)
                            {
                              | <[ N2.ExplicitSpacesAttribute() ]>         => attributes ::= RuleAttribute.ExplicitSpaces(Location.Default)
                              | <[ N2.SuppressTrailingSpacesAttribute() ]> => attributes ::= RuleAttribute.SuppressTrailingSpaces(Location.Default)
                              | _ => ()
                            }
                            def externalRD = RuleDefinition.ExternalRule(
                              ruleTI.NameLocation, ParsedGrammar.Count, makeName(name), attributes, Map() /*TODO: !!!*/,
                              [], extraFields, None(), grammarRef, isExtentionPoint);
                            _externalRuleDescriptorGetters.Add(externalRD, () => <[ $(FixedType.Class(ruleTI, []) : typed) ]>);
                            ParsedGrammar = ParsedGrammar.Add(externalRD);
                          }
                        _externalRuleTypeGetters.Add(grammarRef.Id, name => ruleNameToType[name]);

                      | _ => Message.Error(grammarRef.Location, $"$(ti.FullName) not grammar.")
                    }

                  | _ => Message.Error(grammarRef.Location, $"$(ti.FullName) not grammar.")
                }

              | _ => Message.Error("o_O");
            }

          | _ => Message.Error(grammarRef.Location, "Not class.");
        }
      }
      
      LoadExternalTokenFieldNames();
    }
  }
}
