using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Assertions;
using Nemerle.Imperative;
using N2.Model;

using System;
using System.Diagnostics;
using System.Linq;

using G = GrammarParser2;
using SCG = System.Collections.Generic;

namespace N2
{
  internal partial class GrammarCompiler
  {
    public static GetNestedTypes(this ti : LibraryReference.ExternalTypeInfo) : list[LibraryReference.ExternalTypeInfo]//TODO: Move to Nemerle.Compiler
    {
      def nestedTypes = SCG.List();
      foreach ((_, node) in ti.NamespaceNode.Children.KeyValuePairs)
      {
        node.EnsureCached();
        match (node.Value)
        {
          | NamespaceTree.TypeInfoCache.Cached(ti)           => nestedTypes.Add(ti)
          | NamespaceTree.TypeInfoCache.CachedAmbiguous(tis) => nestedTypes.AddRange(tis)
          | _ => ()
        }
      }
      nestedTypes.Filter(nested => nested.DeclaringType?.Equals(ti)).Map(_ :> LibraryReference.ExternalTypeInfo);
    }

    private _externalGrammars : SCG.List[GrammarRef * TypeInfo] = SCG.List();

    private _externalRuleTypeGetters : SCG.Dictionary[int, NameRef -> RuleType] = SCG.Dictionary();
    private _externalRuleDescriptorGetters : SCG.Dictionary[RuleDefinition, void -> PExpr] = SCG.Dictionary();
    private mutable _loadingExternalGrammars : bool = false;
    public LoadExternalGrammars() : void
    {
      when (_loadingExternalGrammars)
        return;
      _loadingExternalGrammars = true;

      def parseKeywordRegex(text : string) : KeywordRegex
      {
        def parser = G.GrammarImpl();
        match (parser.ParseDeclaration(text))
        {
          | None            => Message.FatalError($"Failed to parse keyword regex '$text'");
          | Some(G.KeywordRegexDecl.Ast as decl) =>
            def name        = N2SourceImpl.ToNameRef(decl.Name);
            def matchTokens = N2SourceImpl.ConvertTokenRule(decl.MatchTokens);
            KeywordRegex(Location.Default, N2SourceImpl.NextKeywordRegexId(), text, matchTokens, name, true);

          | Some => Message.FatalError($"Expected keyword regex '$text'");
        }
      }

      foreach (grammarRef in ParsedGrammar.GrammarRefs)
      {
        def makeName(name)
        {
          match (grammarRef.Alias)
          {
            | Some(alias) =>
              alias + name
            | _ => name
          }
        }
        match (grammarRef.GrammarType)
        {
          | FixedType.Class(ti, tiArgs) =>
            when (!tiArgs.IsEmpty())
              Message.Error(grammarRef.Location, "Generic grammar not supported.");
            match (ti)
            {
              | tb is TypeBuilder =>
                match (tb.UserData[typeof(GrammarCompiler)])
                {
                  | compiler is GrammarCompiler =>
                    _externalGrammars.Add((grammarRef, compiler.GrammarImplTB));
                    compiler.LoadExternalGrammars();
                    def grammar = compiler.ParsedGrammar;
                    foreach (kr in grammar.KeywordRegexes)
                      ParsedGrammar = ParsedGrammar.Add(KeywordRegex(kr.Location, N2SourceImpl.NextKeywordRegexId(), kr.Source, kr.Match, kr.Name, true));
                    _externalRuleTypeGetters.Add(grammarRef.Id, compiler.GetRuleType);
                    foreach (rd in grammar.Rules)
                    {
                      | RuleDefinition.Marker(true)
                      | RuleDefinition.ExternalRule => ()
                      | RuleDefinition.Marker(false) =>
                        ParsedGrammar = ParsedGrammar.Add(RuleDefinition.Marker(
                          rd.Name.Location, ParsedGrammar.Count, makeName(rd.Name), [], Map() /*TODO: !!!*/, [],
                          rd.ExtraFields, true));

                      | rd =>
                        def isExtentionPoint = rd is RuleDefinition.ExtentionPoint;
                        def attributes = rd.Attributes.Filter(fun(_)
                        {
                          | RuleAttribute.ExplicitSpaces
                          | RuleAttribute.SuppressTrailingSpaces => true
                          | _ => false
                        });
                        def rd = RuleDefinition.ExternalRule(
                          rd.Name.Location, ParsedGrammar.Count, makeName(rd.Name), attributes, Map() /*TODO: !!!*/, [],
                          rd.ExtraFields, grammarRef, isExtentionPoint);
                        _externalRuleDescriptorGetters.Add(rd, () => compiler.GetDescriptorClassRef(rd));
                        ParsedGrammar = ParsedGrammar.Add(rd);
                    }

                  | _ => Message.Error("Implementation eror. No GrammarCompiler in type builder.");
                }

              | grammarTI is LibraryReference.ExternalTypeInfo =>
                match (grammarTI.GetNestedTypes().Filter(ti => ti.Name == GrammarImplTB.Name))
                {
                  | [grammarImplTI] =>
                    match (grammarImplTI.GetNestedTypes().Filter(ti => ti.Name == GrammarDescriptorImplTB.Name))
                    {
                      | [grammarDescriptorImplTI] =>
                        _externalGrammars.Add((grammarRef, grammarImplTI));
                        foreach(attr in grammarImplTI.GetModifiers().CustomAttributes)
                        {
                          | <[ N2.KeywordRegexesAttribute(array[ ..$sources ]) ]> =>
                            foreach(source in sources)
                            {
                              | <[ $(source : string) ]> => ParsedGrammar = ParsedGrammar.Add(parseKeywordRegex(source))
                              | _ => ()
                            }

                          | <[ N2.MarkerAttribute($(name : string)) ]> =>
                            ParsedGrammar = ParsedGrammar.Add(
                              RuleDefinition.Marker(Location.Default, ParsedGrammar.Count, makeName(NameRef(Location.Default, name)), [], Map(), [], [], true))

                          | _ => ()
                        }
                        def ruleNameToType = Hashtable();
                        foreach (ruleTI in grammarDescriptorImplTI.GetNestedTypes())
                          when (ParseRuleClassName(ruleTI.Name) is Some((type, name)))
                          {
                            def name = NameRef(ruleTI.NameLocation, name);
                            def ruleType = ret:
                              {
                                foreach (method is IMethod in ruleTI.GetMembers())
                                  when (method.Name == "ResultType")
                                    if (method.ReturnType.TryUnify(Manager.InternalType.Void))
                                      ret(RuleType.Void());
                                    else
                                      ret(RuleType.NType(method.ReturnType :> FixedType));
                                RuleType.Chars();
                              };
                            ruleNameToType.Add(name, ruleType);
                            def isExtentionPoint = type is RuleDefinitionType.ExtentionPoint;
                            def extraFields = LoadExtraFields(ruleType);
                            mutable attributes = [];
                            foreach(attr in ruleTI.GetModifiers().CustomAttributes)
                            {
                              | <[ N2.ExplicitSpacesAttribute() ]>         => attributes ::= RuleAttribute.ExplicitSpaces(Location.Default)
                              | <[ N2.SuppressTrailingSpacesAttribute() ]> => attributes ::= RuleAttribute.SuppressTrailingSpaces(Location.Default)
                              | _ => ()
                            }
                            def rd = RuleDefinition.ExternalRule(
                              ruleTI.NameLocation, ParsedGrammar.Count, makeName(name), attributes, Map() /*TODO: !!!*/,
                              [], extraFields, grammarRef, isExtentionPoint);
                            _externalRuleDescriptorGetters.Add(rd, () => <[ $(FixedType.Class(ruleTI, []) : typed) ]>);
                            ParsedGrammar = ParsedGrammar.Add(rd);
                          }
                        _externalRuleTypeGetters.Add(grammarRef.Id, name => ruleNameToType[name]);

                      | _ => Message.Error(grammarRef.Location, $"$(ti.FullName) not grammar.")
                    }

                  | _ => Message.Error(grammarRef.Location, $"$(ti.FullName) not grammar.")
                }

              | _ => Message.Error("o_O");
            }

          | _ => Message.Error(grammarRef.Location, "Not class.");
        }
      }
      
      LoadExternalTokenFieldNames();
    }
  }
}
