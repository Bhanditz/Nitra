using N2.Compiler;
using N2.Model;
using N2.ProjectSystem;
using N2.Typing;
using N2.Runtime;

using Nemerle;
using Nemerle.Collections;
using Nemerle.Compiler;
using Nemerle.Imperative;

using Nemerle.Utility;
using System;
using System.Diagnostics;
using System.Linq;

using System.Reflection;
using SCG = System.Collections.Generic;
using G = GrammarParser2;
using PExpr = Nemerle.Compiler.Parsetree.PExpr;

namespace N2
{
  internal class N2SourceImpl
  {
    type SyntaxModuleInfos = list[string] * G.SyntaxModule.Ast;

    private Path          : string                 { get; }
    private Manager       : ManagerClass           { get; }
    private Env           : GlobalEnv              { get; private set; }
    private SyntaxModules : SCG.List[SyntaxModule] = SCG.List();
    private ParserHost    : ParserHost             = ParserHost();

    public this(path : string, manager : ManagerClass)
    {
      Path    = path;
      Manager = manager;
      Env     = Manager.CoreEnv;
      UpdateCurrentProjectContext();
    }
    
    //IsUserDataPresent[T]() : bool
    //  where T: new(), class
    //{
    //  Manager.UserData[typeof(T)] != null
    //}
    
    IsListUserDataPresent[T]() : bool
    {
      def map = Manager.UserData[typeof(SCG.List[T])];
      map != null
    }
    
    GetListUserData[T]() : SCG.List[T]
    {
      def key = typeof(SCG.List[T]);
      mutable syntaxModules = Manager.UserData[key] :> SCG.List[T];
      when (syntaxModules == null)
      {
        syntaxModules = SCG.List();
        Manager.UserData[key] = syntaxModules;
      }
      syntaxModules
    }

    GetUserData[T]() : T
      where T: new(), class
    {
      def key = typeof(T);
      mutable result = Manager.UserData[key] :> T;
      when (result == null)
      {
        result = T();
        Manager.UserData[key] = result;
      }
      result
    }

    ResetListUserData[T]() : void
    {
      Manager.UserData[typeof(SCG.List[T])] = null
    }
    
    //ResetUserData[T]() : void
    //  where T: new(), class
    //{
    //  Manager.UserData[typeof(T)] = null
    //}

    UpdateCurrentProjectContext() : void
    {
      Project.CurrentProject = GetUserData.[N2Project]();
    }
    
    GetCurrentProjectContext() : N2Project
    {
      Project.CurrentProject :> N2Project
    }
    //GetSyntaxModules() : SCG.List[SyntaxModuleInfos] // Namespace * Name * SyntaxModule
    //{
    //  def key = typeof(G.SyntaxModule.Ast);
    //  mutable syntaxModules = Manager.UserData[key] :> SCG.List[_];
    //  when (syntaxModules == null)
    //  {
    //    syntaxModules = SCG.List();
    //    Manager.UserData[key] = syntaxModules;
    //  }
    //  syntaxModules
    //}

    public static Instance(path : string, manager : ManagerClass) : N2SourceImpl
    {
      def projDir = IO.Path.GetDirectoryName(manager.Options.ProjectPath);
      def path = 
        if (IO.Path.IsPathRooted(path))
          path;
        else
          IO.Path.Combine(projDir, path);
          
      if (manager.UserData.Contains(path))
        manager.UserData[path] :> N2SourceImpl;
      else
      {
        def impl = N2SourceImpl(path, manager);
        manager.UserData[path] = impl;
        impl;
      }
    }

    public BeforeInheritance() : void
    {
      when (!IO.File.Exists(Path))
      {
        Message.Error($<#The "$Path" not exists.#>);
        return;
      }

      def makeWrapperClass(source : ISource, processingCount : int) : void
      {
        // request rebuilding type tree when code changed
        if (processingCount > 1 && Manager.IsIntelliSenseMode)
          Manager.RequestOnBuildTypesTree();
        else
          try Parse(source) catch { | e => Message.Error(e.Message); }
      }
      SubscribeSourceChangedWithCounter(Manager, Location.GetFileIndex(Path), makeWrapperClass);
    }

    public Parse(source : ISource) : void
    {
      def source = SourceSnapshot(source.GetText(), source.FileIndex, Path);
      def parseResult = ParserHost.DoParsing(source, G.GrammarImpl.StartRuleDescriptor);
      if (parseResult.IsSuccess) 
      {
        def start = parseResult.CreateAst.[G.Start.Ast]();
        Env = start.Env(Env);
        
        //def loc = start.NLocation();
        //Message.Hint(loc, $"File $(loc.File) is parsed.");
        
        def fileAsts : SCG.List[G.Start.Ast] = GetListUserData();
        fileAsts.Add(start);
        
        foreach (rd in start.TopDeclarations)
        {
          | G.SyntaxModule.Ast as syntaxModule =>  SyntaxModules.Add(ConvertSyntaxModule(syntaxModule));
          | _ => assert(false);
        }
      }
      else
      {
        //def (pos, tokens) = parser.Parser.GetErrors();
        //def loc = N2.Location(parser.Parser.ParsingSource, pos, pos + 1).ToNemerleLocation();
        //foreach (token in tokens)
        //  Message.Error(loc, $"expected \"$(token.Name)\" in rule $(token.Rule.Grammar.Name).$(token.Rule.Name)");

        def errors = parseResult.CollectErrors();
        def pos = parseResult.Source.PositionToLineColumn(errors.Position);
        def loc = Nemerle.Compiler.Location(source.FileIndex, pos.Line, pos.Column);
        Message.Error(loc, $<#Parse failed: ..$(errors.Messages; ", ")#>);
      }
    }

    private LoadExternalSymbols(project : N2Project, rootNamespace : NamespaceSymbol) : bool
    {
      def errorCount = project.ErrorCount;
      
      foreach (asm in Manager.ReferencedAssemblies)
      {
        foreach ((<[ N2.GrammarsAttribute ]>, [<[ array[..$(elems)] ]>]) in asm.GetCustomAttributes())
          foreach (<[ typeof($(PExpr.TypedType(FixedType.Class(grammarTI is LibraryReference.ExternalTypeInfo, []))))]> in elems)
            LoadExternalSyntaxModule(rootNamespace, grammarTI);
      }
      
      project.ErrorCount == errorCount
    }
    
    private LoadExternalSyntaxModule(rootNamespace : NamespaceSymbol, grammarImplTI : LibraryReference.ExternalTypeInfo) : void
    {
      def root = rootNamespace.Node;
      def grammarTI   = grammarImplTI.BaseType;
      //Message.HintOnce($"   Grammar type: $glammarName");

      def parserHost = ParserHost();
      def parseKeywordRegex(text : string) : KeywordRegex
      {
        def parseResult = parserHost.DoParsing(SourceSnapshot(text), G.GrammarImpl.DeclarationRuleDescriptor);
        if (parseResult.IsSuccess)
          match (parseResult.CreateAst.[G.Declaration]())
          {
            | G.KeywordRegexDecl.Ast as decl =>
              def name        = decl.Name.ToNameRef();
              def matchTokens = decl.MatchTokens.RegularRule();
              KeywordRegex(Location.Default, N2SourceImpl.NextKeywordRegexId(), text, matchTokens, name, true);

            | _ => Message.FatalError($"Expected keyword regex '$text'");
          }
        else
          Message.FatalError($"Failed to parse keyword regex '$text'");
      }
      def keywordRegexs = SCG.List();
      match (grammarImplTI.GetNestedSubtypes().Filter(ti => ti.Name == AssemblyConstants.GrammarDescriptorImplName))
      {
        | [grammarDescriptorImplTI] =>
          //assert2(false);
          def loc = grammarDescriptorImplTI.Location.N2Location();
          def attrs = grammarImplTI.GetModifiers().CustomAttributes;
          
          foreach(<[ N2.KeywordRegexesAttribute(array[ ..$sources ]) ]> in attrs)
            foreach(<[ $(source : string) ]> in sources)
              keywordRegexs.Add(parseKeywordRegex(source));

          def tokenFieldNames = LoadExternalTokenFieldNames(grammarTI);
          
          def symbol = ExternalSyntaxModuleSymbol(grammarTI, grammarImplTI, keywordRegexs.NToList(), tokenFieldNames) : SyntaxModuleSymbol;
          def node = root.AddAndReport(grammarTI.NamespaceNode.Parent.FullName, symbol, symbol.FirstLocation);
          

          foreach(<[ N2.MarkerAttribute($(name : string)) ]> as attr in attrs)
          {
            def loc = attr.Location.N2Location();
            _ = node.AddAndReport([], MarkerSymbol(loc, name, true), loc);
          }
              
          // load rules
          foreach (ruleTI in grammarDescriptorImplTI.GetNestedSubtypes())
          {
            when (Util.ParseRuleClassName(ruleTI.Name) is Some((kind, name)))
            {
              //def name = NameRef(ruleTI.NameLocation, name);
              def (ruleType, typeInfo) =
                ret:
                {
                  foreach (method is IMethod when (method.Name == "ResultType") in ruleTI.GetMembers())
                    if (method.ReturnType.TryUnify(Manager.InternalType.Void))
                      ret(RuleType2.Void(), null);
                    else
                    {
                      def ti = method.ReturnType.Fix().TypeInfo;
                      ret(RuleType2.Ref(NString.SplitToList(ti.FullName, '.')), ti);
                    }
                  (RuleType2.Chars(), null)
                };
              def isExtentionPoint = kind is RuleDefinitionType.ExtentionPoint;
              def extraFields = if (typeInfo == null) [] else Util.LoadExtraFields(typeInfo, Manager);
              mutable attributes = [];
              foreach(attr in ruleTI.GetModifiers().CustomAttributes)
              {
                | <[ N2.ExplicitSpacesAttribute() ]>         => attributes ::= RuleAttribute.ExplicitSpaces(Location.Default)
                | <[ N2.SuppressTrailingSpacesAttribute() ]> => attributes ::= RuleAttribute.SuppressTrailingSpaces(Location.Default)
                | _ => ()
              }
              def symbol = ExternalRuleRefSymbol(loc, name, ruleType, attributes, isExtentionPoint, extraFields);
              _ = node.AddAndReport([], symbol, loc);
            }
          }

        | _ => Message.Error(grammarTI.Location, $"$(grammarTI.FullName) not grammar.")
      }
    }

    public LoadExternalTokenFieldNames(type : TypeInfo) : Map[string, Identifier]
    {
      def env      = type.Manager.CoreEnv;
      def attrType = env.BindFixedType(<[ N2.TokenFieldNameAttribute ]>);
      def loc      = LocationStack.Top();
      mutable tokenFieldNames = Map();

      foreach ((_, [<[ $(name : string) ]>, <[ array[..$tokens] ]>]) in type.GetModifiers().FindAttributesWithArgs(attrType.TypeInfo, env))
        foreach (<[ $(token : string) ]> in tokens)
          tokenFieldNames = tokenFieldNames.Replace(token, Identifier(loc.N2Location(), name));

      tokenFieldNames
    }

    private LoadParsedSymbols(project : N2Project, rootNamespace : NamespaceSymbol, fileAsts : SCG.List[G.Start.Ast]) : bool
    {
      def errorCount = project.ErrorCount;

      //assert2(false);
      
      foreach (start in fileAsts)
        start.CollectGlobalSymbols(rootNamespace);

      /*
      foreach (start in fileAsts)
      foreach ((ns, syntaxModule) in start.GetSyntaxModules())
      {
        def symbol = ParsedSyntaxModuleSymbol(syntaxModule) : SyntaxModuleSymbol;
        def node = root.AddAndReport(ns, symbol, project);
            
        def ruleDefs = SCG.List();
        syntaxModule.RuleRefs(ruleDefs);
          
        foreach (sym in ruleDefs)
          _ = node.AddAndReport(sym, project);
      }
      */

      project.ErrorCount == errorCount
    }
    
    private TypeSyntaxModules(project : N2Project, rootNamespace : NamespaceSymbol, fileAsts : SCG.List[G.Start.Ast]) : bool
    {
      def errorCount   = project.ErrorCount;
      
      def syntaxModules = GetListUserData();
      def context = RootContext(Project.CurrentProject :> N2Project, rootNamespace);

      foreach (start in fileAsts)
        syntaxModules.AddRange(start.Typing(context));
      
      //def syntaxModule = GetListUserData();
      //def root         = rootNamespace.Node;
      //def env          = Environment(root, project);
      //
      //foreach (start in fileAsts)
      //  foreach (sm in start.GetSyntaxModuleDatas(env))
      //    syntaxModule.Add(sm);
          
      project.ErrorCount == errorCount
    }
    
    public BeforeTypedMembers() : void
    {
      //Message.Hint("BeforeTypedMembers(). Prarsed SyntaxModules:");
      when (IsListUserDataPresent.[G.Start.Ast]())
        try
        {
          UpdateCurrentProjectContext();
        
          def project       = GetCurrentProjectContext();
          def root          = GetUserData.[HierarchyNode]();
          def rootNamespace = NamespaceSymbol(null : string);
          
          root.SetRootNamespaceSymbol(rootNamespace);

          def fileAsts : SCG.List[G.Start.Ast] = GetListUserData();

          unless (LoadExternalSymbols(project, rootNamespace))
            return;
          unless (LoadParsedSymbols  (project, rootNamespace, fileAsts))
            return;
          unless (TypeSyntaxModules  (project, rootNamespace, fileAsts))
            return;
        }
        finally ResetListUserData.[G.Start.Ast]();

      foreach (sm in SyntaxModules)
      {
        try
        {
          sm.GrammarCompiler = GrammarCompiler(Manager, Env, sm.TypeBuilder, sm.Name, sm.Grammar);
          sm.TypeBuilder.UserData[typeof(GrammarCompiler)] = sm.GrammarCompiler;
        }
        catch
        {
          | _ is Nemerle.Compiler.Recovery => ()
          | e is GrammarException =>
            def loc = if (e.Location != Location.Default) e.Location else sm.TypeBuilder.Location;
            Message.Error(loc, e.Message);
            
          | e is Exception =>
            assert2(false, e.ToString());
            Message.Error(sm.TypeBuilder.Location,  $"Exception $e");
        }
      }

      foreach (sm in SyntaxModules)
        sm.GrammarCompiler.AddGrammarRefs(sm.Ast.GrammarRefs(Env)); // require initialized TypeBuilders

     //Message.Hint($<#BeforeTypedMembers() - Grammsr: ..$(SyntaxModules; ", "; x => x.Name.AsName)#>);
        
      //foreach (sm in SyntaxModules)
      //{
      //  //Message.Hint($"BeforeTypedMembers() - Grammsr: $(sm.GrammarCompiler.GrammarTB.Name)");
      //  sm.GrammarCompiler.LoadExternalGrammars();
      //}
    }

    public WithTypedMembers() : void
    {
      foreach (sm in SyntaxModules)
      {
        try
        {
          when (sm.GrammarCompiler == null) // new typing is failed
            return;
          
          if (sm.GrammarCompiler.Manager.IsIntelliSenseMode)
            IntelliSenseSupport.AddIntelliSenseSupport(sm.GrammarCompiler);
          else
            when (sm.GrammarCompiler.AllRules)
            {
              sm.GrammarCompiler.CompileGrammar();
              sm.GrammarCompiler.DefineDescriptors();
              sm.GrammarCompiler.DefineStartDescriptors();
            }

          sm.GrammarCompiler.GrammarDescriptorImplTB.Compile();
          sm.GrammarCompiler.GrammarImplTB.Compile();
          sm.TypeBuilder.Compile();
        }
        catch
        {
          | e is GrammarException =>
            def loc = if (e.Location != Location.Default) e.Location else sm.TypeBuilder.Location;
            Message.Error(loc,  e.Message);
          | _ is Nemerle.Compiler.Recovery => ()
          | e is Exception =>
            assert2(false, e.ToString());
            Message.Error(sm.TypeBuilder.Location,  $"Exception $e");
        }
      }
    }

    public SubscribeSourceChangedWithCounter(manager : ManagerClass, fileIndex : int, handler : ISource * int -> void) : void
    {
      mutable counter = 0;
      manager.SubscribeSourceChanged(fileIndex, source =>
      {
        counter += 1;
        handler(source, counter);
      });
    }

    internal static NextKeywordRegexId : void -> int = Util.CreateIdGenerator(0);
    
    private DefineTokenFieldName(typeBuilder : TypeBuilder, tokenFieldNames : Map[string, NameRef]) : void
    {
      foreach (g in tokenFieldNames.GroupBy((_, name) => name))
      {
        def tokens = g.Map((tok, _) => <[ $(tok : string) ]>);
        typeBuilder.Ast.AddCustomAttribute(
          <[ N2.TokenFieldNameAttribute($(g.Key.AsName : string), array[..$tokens]) ]>);
      }
    }

    private AddPrecedence(rule : Rule.Sequence, baseName : NameRef, precedence : G.Number, rightAssociative : bool) : Rule.Sequence
    {
      def newBindingPower = precedence.Value();
      def updateCall(call, bindingPower, newBindingPower) : Rule
      {
        def bp = 
          if (bindingPower == 0)
            newBindingPower
          else
          {
            Message.Warning(call.Location, "You can't use Binding Power and 'precedence' simultaneously.");
            bindingPower
          };
          
        Rule.Call(call.Location, RuleType.Void(), 0, baseName, bp)
      }
      def checkUnary(call)
      {
        when (rightAssociative)
          Message.Error(call.Location, "You can't use 'right-associative' for a unary extending rule.");
      }
      match (rule.rules)
      {
        | (Call(n1, bp1) as call1) :: (String as op)                                     :: (Call(n2, bp2) as call2) :: rest when n1 == baseName && n2 == baseName with (s1 = null, s2 = null) // rec   "op"   rec
        | (Call(n1, bp1) as call1) :: (String as op) :: (Rule(Type=RuleType.Void) as s2) :: (Call(n2, bp2) as call2) :: rest when n1 == baseName && n2 == baseName with (s1 = null)            // rec   "op" s rec
        | (Call(n1, bp1) as call1) :: (Rule(Type=RuleType.Void) as s1) :: (String as op) :: (Rule(Type=RuleType.Void) as s2) :: (Call(n2, bp2) as call2) :: rest when n1 == baseName && n2 == baseName  =>           // rec s "op" s rec
          def newCall1 = updateCall(call1, bp1, newBindingPower + if (rightAssociative) 1 else 0);
          def newCall2 = updateCall(call2, bp2, newBindingPower);
          def prependIfNotNull(e, lst) { if (e == null) lst else e :: lst }
          def rest2 = prependIfNotNull(s2, newCall2 :: rest);
          Rule.Sequence(rule.Location, RuleType.Void(), 0, newCall1 :: prependIfNotNull(s1, op :: rest2))

        | [Call(n, bp) as call, String as op]                                when n == baseName with s = null // rec "op"
        | [Call(n, bp) as call, String as op, Rule(Type=RuleType.Void) as s] when n == baseName =>            // rec "op" s
          checkUnary(call);
          def newCall = updateCall(call, bp, newBindingPower);
          def rest    = if (s == null) [op] else [op, s];
          Rule.Sequence(rule.Location, RuleType.Void(), 0, newCall :: rest)

        | [String as op,                                Call(n, bp) as call] when n == baseName with s = null // "op"   rec 
        | [String as op, Rule(Type=RuleType.Void) as s, Call(n, bp) as call] when n == baseName =>            // "op" s rec
          checkUnary(call);
          def newCall = updateCall(call, bp, newBindingPower);
          def rest    = if (s == null) [newCall] else [s, newCall];

          Rule.Sequence(rule.Location, RuleType.Void(), 0, op :: rest)

        | _ => 
          assert2(false);
          Message.Error(precedence.Location.ToNemerleLocation(), 
            "You can use the 'precedence' for only rules satisfying the following patterns: 'E op E', 'op E', 'E op', 'E op s E', 'op E s', 'E op s'. Where op is literal and s is void rule call. Use a binding power instead.");
          rule
      }
    }
    
    public ConvertSyntaxModule(syntaxModule : G.SyntaxModule.Ast) : SyntaxModule
    {
      mutable grammar = Grammar();
      mutable tokenFieldNames = Map();
      mutable keywordRegexes = [];
      mutable aliases = Map();
      def processBody[T](decl : G.BodyDeclaration, func : _ -> T, defaultValue : T) : T
      {
        match (decl)
        {
          | G.BlockBodyDeclaration.Ast(BodyMemberDeclarations=members) => func(members)
          | _ => defaultValue
        }
      }
      def processLocalAliases(members)
      {
        def localAliasDecls = members.OfType.[G.InnerAliasDeclaration.Ast]();
        mutable localAliasesMap = Map();
            
        foreach (G.InnerAliasDeclaration.Ast(RuleAlias=G.RuleAlias.Ast as alias) in localAliasDecls)
        {
          def name        = alias.Name.NameRef();
          def rule        = alias.Rule.GetRule();
          localAliasesMap = localAliasesMap.Replace(name, rule);
        }
            
        localAliasesMap
      }
      def addSequence(n2Rule : G.Rule, localAliases) : Rule.Sequence * list[NameRef]
      {
        def definedNames = SCG.List();
        def extractName(n2Rule) : G.Rule
        {
          | G.FieldName.Ast as r => definedNames.Add(r.Name.NameRef()); r.Rule
          | _                    => definedNames.Add(null); n2Rule
        }        
        def extractNames(n2Rule)
        {
          | G.FieldName.Ast as r => extractName(r.Rule).GetRule();
          | G.SequenceRule.Ast as rule =>
            def rules = extractName(rule.LeftRule).GetRule() :: rule.RightRules.Map(r => extractName(r).GetRule());
            Rule.Sequence(rule.NLocation(), RuleType.Void(), 0, rules)
          | _ => extractName(n2Rule).GetRule();
        }        
        def rule : Rule = extractNames(n2Rule);
        
        def isAlias(rule) : bool
        {
          | Rule.Call(n, _) when localAliases.Contains(n)
          | Rule.Call(n, _) when aliases.Contains(n) => true
          | _ => false
        }
        def names = SCG.List();
        def none  = NameRef(LocationStack.Top(), "_");
        def replaceAlias(rule) : Rule
        {
          | Rule.Call(n, _) when localAliases.Contains(n) => names.Add(n); localAliases.Get(n)
          | Rule.Call(n, _) when aliases.Contains(n)      => names.Add(n); aliases.Get(n)
          | _ => names.Add(none); rule
        }
        def makeNames()
        {
          assert2(definedNames.Count == names.Count);
          def res = definedNames.Map2Lazy(names, (dn, n) => dn ?? n ?? none).NToList();
          assert2(res.ForAll(_ != null));
          res
        }
        match (rule)
        {
          | Rule.Sequence(rules) when rules.Exists(isAlias) => (Rule.Sequence(rule.Location, rule.Type, rule.Id, rules.Map(replaceAlias)), makeNames())
          | Rule.Sequence as rule => (rule, definedNames.Map(x => x ?? none))
          | _                     => (Rule.Sequence(rule.Location, RuleType.Void(), 0, [replaceAlias(rule)]), makeNames())
        }
      }
      def processExtraFields(members : list[G.BodyMemberDeclaration]) : list[ExtraField]
      {
        def parse(ast : N2.Ast) : PExpr
        {
          def simpleParse(ast : N2.Ast) : PExpr
          {
            def text = ast.Location.GetText();
            assert2(!text.EndsWith("Ge"));
            MainParser.ParseExpr(Env, text, ast.NLocation())
          }
          def parseAndAddIt(ast : N2.Ast) : PExpr
          {
            def e = simpleParse(ast);
            
            def addIt(e)
            {
              | <[ value ]> => e
              | <[ $(n : name) ]> => <[ it.$(n : name)]>
              | <[ $x = $y ]> => <[ $(addIt(x)) = $(addIt(y)) ]>
              | _ => e
            }
            
            addIt(e)
          }
          
          match (ast)
          {
            | G.Expression.Ast(ExpressionContents=[G.ExpressionContent1.Ast(Content=G.Content6.Ast as fold)]) => 
              def collection = simpleParse(fold.Identifier);
              def expr1 = simpleParse(fold.Expression);
              def exprs = fold.Expressions[0].Map(parseAndAddIt);
              //exprs.Fold()
              <[ $collection.Fold($expr1, fun((it, value)) { ..$exprs }) ]>
              
            | _ => simpleParse(ast)
          }
          
        }
        def loop(members : list[G.BodyMemberDeclaration], acc)
        {
          def parseBodyOpt(extraFieldBody : G.ExtraFieldBody) : option[PExpr]
          {
            match (extraFieldBody)
            {
              | G.ExtraFieldBody1.Ast as b => Some(parse(b.Block))
              | G.ExtraFieldBody2.Ast as b => Some(parse(b.Expression))
              | G.ExtraFieldBodyEmpty      => None()
              | _                          => None()
            }
          }
          def parseBody(extraFieldBody : G.ExtraFieldBody) : PExpr
          {
            match (parseBodyOpt(extraFieldBody))
            {
              | Some(e) => e
              | _ =>
                def loc = extraFieldBody.Location.ToNemerleLocation();
                Message.Error(loc, "Expected '= Expression' or block.");
                PExpr.Error(loc)
            }
          }
          match (members)
          {
            | G.ExtraFieldDeclaration1.Ast as m :: tail =>
              def name = m.Name.NameRef();
              def loc = m.Location.ToNemerleLocation();
              def body = parseBodyOpt(m.ExtraFieldBody);
              def toName(e)
              {
                | <[ $(x : name) ]> => x
                | _ => Message.FatalError(e.Location, "Expected simple name.")
              }
              def parseParam(_ : G.ExtraFieldsParam)
              {
                | G.ExtraFieldsParam.Ast as p => <[ parameter: $(toName(parse(p.Name))) : $(parse(p.Type)) ]>
                | e => Message.FatalError(e.Location.ToNemerleLocation(), "Parse error.")
              }
              def parameters = m.ExtraFieldsParams[0].Map(parseParam);
              
              def field =
                if (m.ExtraFieldPrivates.IsSome)
                  if (body.IsSome)
                    ExtraField.DefPrivate(loc, name, parameters, parse(m.Type), body.Value)
                  else
                    Message.FatalError(loc, "A private extra field must have body.");
                else if (body.IsSome)
                  ExtraField.Def(loc, name, parameters, parse(m.Type), body.Value)
                else
                  ExtraField.Abstract(loc, name, parameters, parse(m.Type));
                
              loop(tail, field :: acc)
              
            | G.ExtraFieldDeclaration2.Ast as m :: tail =>
              def name = m.Name.NameRef();
              def loc = m.Location.ToNemerleLocation();
              loop(tail, ExtraField.Override(loc, name, parseBody(m.ExtraFieldBody)) :: acc)
              
            | G.ExtraFieldDeclaration3.Ast as m :: tail =>
              def name = m.Name.NameRef();
              def loc = m.Location.ToNemerleLocation();
              loop(tail, ExtraField.OnError(loc, name, parseBody(m.ExtraFieldBody)) :: acc)
              
            | _ :: tail                               => loop(tail, acc)
            | []                                      => acc
          }
        }
          
        loop(members, [])
      }
      def addExtentionRule(nameId : G.Identifier, ruleAttributes : G.RuleAttributes, bodyDeclaration : G.BodyDeclaration, 
                          rule : G.Rule, baseName : G.QIdentifier) : void
      {
        def name            = nameId.NameRef();
        //assert2(name.AsName != "add");
        def ruleId          = grammar.Count;
        def attributes      = ruleAttributes.Value();
        def localAliases    = processBody(bodyDeclaration, processLocalAliases, Map());
        def (rule1, names)  = addSequence(rule, localAliases);
        def baseName        = baseName.NameRef();
        def processPrecedence(members : list[G.BodyMemberDeclaration]) : Rule.Sequence
        {
          def precedence = members.Once.[G.PrecedenceDeclaration.Ast]();
                
          if (precedence is Some(prec))
            AddPrecedence(rule1, baseName, prec.Precedence, prec.RightAssociative.IsSome)
          else
            rule1
        }
        def rule2 = processBody(bodyDeclaration, processPrecedence, rule1);
        def extraFields = processBody(bodyDeclaration, processExtraFields, []);
        def ruleDefinition = 
          match (rule2)
          {
            | Sequence((Call(callName, bindingPower) as call) :: rules) when callName == baseName =>
              RuleDefinition.ExtentionPostfix(name.Location, ruleId, name, attributes, tokenFieldNames, keywordRegexes, extraFields, baseName, bindingPower, 
                Rule.Sequence(rule1.Location, RuleType.Void(), 0, 
                Rule.PrefixCall(call.Location, RuleType.Void(), 0, baseName, bindingPower) :: rules), names)

            | _ => RuleDefinition.ExtentionPrefix(name.Location, ruleId, name, attributes, tokenFieldNames, keywordRegexes, extraFields, baseName, rule2, names)
          };
            
        try { grammar = grammar.Add(ruleDefinition); }
        catch { | e is Exception => Message.Error(name.Location, "Exception: " + e.Message); }
      }
      
      foreach (decl in syntaxModule.Declarations)
      {
        | G.TokenRuleDecl.Ast as decl =>
          def name        = decl.Name.NameRef();
          def ruleId      = grammar.Count;
          def attributes  = decl.RuleAttributes.Value();
          def rule        = decl.TokenRule.RegularRule();
          
          def extraFields = processBody(decl.BodyDeclaration, processExtraFields, []);
          grammar = grammar.Add(RuleDefinition.Regular(name.Location, ruleId, name, attributes, tokenFieldNames, keywordRegexes, extraFields, rule));

        | G.VoidRuleDecl.Ast   (RuleAttributes=attr, Name=name, Rule=rule, BodyDeclaration=body) with (type = RuleType.Void())
        | (G.SimpleRuleDecl.Ast(RuleAttributes=attr, Name=name, Rule=rule, BodyDeclaration=body)) with type = RuleType.PType(<[ Ast ]>) =>
          def name          = name.NameRef();
          //assert2(name.AsName != "CatchExceptionFulter");
          def ruleId        = grammar.Count;
          def attributes    = attr.Value();
          def localAliases  = processBody(body, processLocalAliases, Map());
          def (rule, names) = addSequence(rule, localAliases);
          def extraFields   = processBody(body, processExtraFields, []);
            
          grammar = grammar.Add(RuleDefinition.Simple(name.Location, ruleId, name, attributes, tokenFieldNames, keywordRegexes, extraFields, type, rule, names));

        | G.ExtentionPointRuleDecl.Ast as decl =>
          def name        = decl.Name.NameRef();
          def ruleId      = grammar.Count;
          def attributes  = decl.RuleAttributes.Value();
          def ruleType    = RuleType.PType(<[ Ast ]>);
          def extraFields = processBody(decl.BodyDeclaration, processExtraFields, []);
          
          grammar = grammar.Add(RuleDefinition.ExtentionPoint(name.Location, ruleId, name, attributes, tokenFieldNames, keywordRegexes, extraFields, ruleType));

        | G.ExtendSyntax.Ast as decl =>
          def baseName = decl.BaseName;
          foreach (m is G.ExtendSyntaxMember.Ast in decl.ExtendSyntaxMembers)
            addExtentionRule(m.Name, m.RuleAttributes, m.BodyDeclaration, m.Rule, baseName);
            
        | G.ExtentionRuleDecl.Ast as decl => addExtentionRule(decl.Name, decl.RuleAttributes, decl.BodyDeclaration, decl.Rule, decl.BaseName);
        | G.AliasDecl.Ast(RuleAlias=G.RuleAlias.Ast as alias) =>
          def name = alias. Name.NameRef();
          def rule = alias.Rule.GetRule();
          aliases  = aliases.Replace(name, rule);
          
        | G.TokenField.Ast(StringLiterals=lits) as decl => 
          foreach (strLit in lits[0])
            tokenFieldNames = tokenFieldNames.Replace(strLit.Value(), decl.Name.NameRef());

        | G.SpanClassDecl.Ast as decl =>
          def name        = decl.Name.NameRef();
          def matchTokens = 
            if (decl.MatchTokens is Some((_, matchTokens)))
            Some(matchTokens.RegularRule())
          else
            None();
          grammar = grammar.Add(SpanClassModel(decl.Location.ToNemerleLocation(), name, matchTokens));

        | G.BracePairDecl.Ast as decl =>
          def open  = decl.Open.RegularRule();
          def close = decl.Close.RegularRule();
          grammar = grammar.Add(BracePair(decl.Location.ToNemerleLocation(), open, close));

        | G.MarkerDecl.Ast as decl =>
          def name   = decl.Name.NameRef();
          def ruleId = grammar.Count;
          grammar = grammar.Add(RuleDefinition.Marker(name.Location, ruleId, name, [], tokenFieldNames, keywordRegexes, [], false));

        | G.KeywordRegexDecl.Ast as decl =>
          def name        = decl.Name.NameRef();
          def matchTokens = decl.MatchTokens.RegularRule();
          def keywordRegex = KeywordRegex(decl.Location.ToNemerleLocation(), NextKeywordRegexId(), decl.Location.GetText(), matchTokens, name, false);
          keywordRegexes ::= keywordRegex;
          grammar = grammar.Add(keywordRegex);

        | error => Message.Error(error.NLocation(), "Error. Unknown declaration.");
      }
      def name = syntaxModule.Name.NameRef();
      def typeBuilder = Manager.CoreEnv.Define(<[decl:
          public partial abstract class $(name.AsName : dyn)
          {
          }
        ]>);
      
      DefineTokenFieldName(typeBuilder, tokenFieldNames);
      
      SyntaxModule(name, grammar, syntaxModule, null, typeBuilder)
    }
  }
}
