using N2.Compiler;
using N2.Model;
using N2.ProjectSystem;
using N2.Typing;
using N2.Runtime;
using N2.Util;
using N2.Serialization;

using Nemerle;
using Nemerle.Collections;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Imperative;

using Nemerle.Utility;
using System;
using System.IO;
using System.Diagnostics;
using System.Linq;

using System.Reflection;
using SCG = System.Collections.Generic;
using G = N2Syntax;
using PExpr = Nemerle.Compiler.Parsetree.PExpr;

namespace N2
{
  internal class N2SourceImpl
  {
    private Path          : string                 { get; }
    private Manager       : ManagerClass           { get; }
    private ParserHost    : ParserHost             = ParserHost();

    public this(path : string, manager : ManagerClass)
    {
      Path    = path;
      Manager = manager;
      _ = UpdateCurrentProjectContext();
    }

    IsListUserDataPresent[T]() : bool
    {
      def map = Manager.UserData[typeof(SCG.List[T])];
      map != null
    }

    GetUserData[T](init : T -> void = null) : T
      where T: new(), class
    {
      def key = typeof(T);
      mutable result = Manager.UserData[key] :> T;
      when (result == null)
      {
        result = T();
        when (init != null)
          init(result);
        Manager.UserData[key] = result;
      }
      result
    }

    ResetListUserData[T]() : void
    {
      Manager.UserData[typeof(SCG.List[T])] = null
    }

    UpdateCurrentProjectContext() : CompilingN2Project
    {
      def project = GetUserData.[CompilingN2Project](p =>
        p.Init(Manager.ReferencedAssemblies.Select(a => a.Assembly.GetName())));
      Project.CurrentProject = project;
      project
    }

    public static Instance(path : string, manager : ManagerClass) : N2SourceImpl
    {
      def projPath = manager.Options.ProjectPath;
      def projDir =
        if (File.Exists(projPath))
          Path.GetFullPath(Path.GetDirectoryName(projPath))
        else if (Directory.Exists(projPath))
          Path.GetFullPath(projPath)
        else
          Environment.CurrentDirectory;
      def path =
        if (IO.Path.IsPathRooted(path))
          path;
        else
          IO.Path.Combine(projDir, path);

      if (manager.UserData.Contains(path))
        manager.UserData[path] :> N2SourceImpl;
      else
      {
        def impl = N2SourceImpl(path, manager);
        manager.UserData[path] = impl;
        impl;
      }
    }

    [Record]
    private class ExportableSymbolData
    {
      public TypeBuilder          : TypeBuilder         { get; }
      public ExportableSymbolType : option[TypeBuilder] { get; }
    }

    public static AddExportableSymbol(tb : TypeBuilder, exportableSymbolType : option[TypeBuilder]) : void
    {
      def data = ExportableSymbolData(tb, exportableSymbolType);
      tb.Manager.GetListUserData.[ExportableSymbolData]().Add(data);
    }

    public BeforeInheritance() : void
    {
      when (!IO.File.Exists(Path))
      {
        Message.Error($<#The "$Path" not exists.#>);
        return;
      }

      def makeWrapperClass(source : ISource, processingCount : int) : void
      {
        // request rebuilding type tree when code changed
        if (processingCount > 1 && Manager.IsIntelliSenseMode)
          Manager.RequestOnBuildTypesTree();
        else
          try Parse(source) catch { | e => Message.Error(e.Message); }
      }
      SubscribeSourceChangedWithCounter(Manager, Location.GetFileIndex(Path), makeWrapperClass);
    }

    public Parse(source : ISource) : void
    {
      def source = SourceSnapshot(source.GetText(), source.FileIndex, Path);
      def parseResult = ParserHost.DoParsing(source, G.GrammarImpl.StartRuleDescriptor);

      try
      {
        def start = parseResult.CreateAst.[G.Start]() :> G.Start.Ast;     // TODO: добавить проверку на ошибки
        unless (parseResult.IsSuccess)
        {
          def lastSuccessPos = parseResult.LastSuccessPos;
          def loc = N2.Location(source, lastSuccessPos, lastSuccessPos + 1);
          Message.Error(loc.ToNemerleLocation(), "Parse failed after this position.");
          return;
        }

        def fileAsts : SCG.List[G.Start.Ast] = Manager.GetListUserData();
        fileAsts.Add(start);
      }
      catch
      {
        | e is AstWalkerException =>
          def loc = N2.Location(source, e.Pos, e.Pos + 1);
          Message.Error(loc.ToNemerleLocation(), e.Message);
        | e =>
          def loc = N2.Location(source, 0, 1);
          Message.Error(loc.ToNemerleLocation(), e.Message);
      }
    }

    private LoadParsedSymbols(project : N2Project, fileAsts : SCG.List[G.Start.Ast]) : bool
    {
      def errorCount = project.ErrorCount;

      foreach (start in fileAsts)
        start.CollectGlobalSymbols(project.RootNamespace);

      project.ErrorCount == errorCount
    }

    private TypeSyntaxModules(project : N2Project, fileAsts : SCG.List[G.Start.Ast]) : bool
    {
      def errorCount   = project.ErrorCount;

      def context = RootContext(project, project.RootNamespace, Manager.CoreEnv);

      foreach (start in fileAsts)
        _ = start.MakeContext(context);

      foreach (start in fileAsts)
        start.Typing();

      project.ErrorCount == errorCount
    }

    private MakeEmitters(project : CompilingN2Project) : void
    {
      def environment = project.Environment;

      MakeEmitters.[ParsedSyntaxModuleSymbol, _](environment, SyntaxModuleEmitter);

      def astWalkerGenerator = AstWalkerGenerator(environment);
      def highlighterWalkerGenerator = HighlighterWalkerGenerator(environment);

      def walkerEmitters = Manager.GetListUserData.[WalkerEmitter]();
      foreach (syntaxModule in project.Environment.Root.GetDescendants.[ParsedSyntaxModuleSymbol]())
      {
        walkerEmitters.Add(WalkerEmitter(environment, syntaxModule, astWalkerGenerator));
        walkerEmitters.Add(WalkerEmitter(environment, syntaxModule, highlighterWalkerGenerator));
      }

      def externalSymbolEmitters = Manager.GetListUserData.[ExternalSymbolEmitter]();
      def serializationEmitter = Manager.CreateBinarySerializationEmitter(N2BinarySerializationMessageEmitter(), N2SymbolRefBinarySerializationEmitterExtention(environment));
      foreach (data in Manager.GetListUserData.[ExportableSymbolData]())
        externalSymbolEmitters.Add(ExternalSymbolEmitter(environment, data.TypeBuilder, data.ExportableSymbolType, serializationEmitter));
      ResetListUserData.[ExportableSymbolData]();
    }

    private MakeEmitters[SymbolType, EmitterType](environment : EmitterEnvironment, makeEmitter : EmitterEnvironment * SymbolType -> EmitterType) : void
      where SymbolType : Symbol
    {
      def emitters = environment.Manager.GetListUserData.[EmitterType]();
      foreach (symbol in environment.Root.GetDescendants.[SymbolType]())
        emitters.Add(makeEmitter(environment, symbol));
    }

    private DefineAst() : void
    {
      def syntaxModuleEmitters = Manager.GetListUserData.[SyntaxModuleEmitter]();
      foreach (emitter in syntaxModuleEmitters)
        emitter.DefineExtentionPointAstTypes();
      foreach (emitter in syntaxModuleEmitters)
        emitter.DefineOtherAstTypes();
      foreach (emitter in syntaxModuleEmitters)
        emitter.DefineAstMembers();
    }

    private DefineParsers() : void
    {
      def syntaxModuleEmitters = Manager.GetListUserData.[SyntaxModuleEmitter]();
      foreach (emitter in syntaxModuleEmitters)
        emitter.DefineParserTypes();
      foreach (emitter in syntaxModuleEmitters)
        emitter.DefineParserMethods();
    }

    private DefineOtherMembers() : void
    {
      def syntaxModuleEmitters = Manager.GetListUserData.[SyntaxModuleEmitter]();
      foreach (emitter in syntaxModuleEmitters)
        emitter.DefineMetadataMembers();
    }

    private DefineExternalSymbols() : void
    {
      def externalSymbolEmitters = Manager.GetListUserData.[ExternalSymbolEmitter]();
      foreach (emitter in externalSymbolEmitters)
        emitter.DefineMembers();
    }

    private DefineVisitorTypes() : void
    {
      def visitorTypeEmitters = Manager.GetListUserData.[VisitorTypeEmitter]();
      foreach (emitter in visitorTypeEmitters)
        emitter.DefineMembers();
    }

    private DefineVisitors() : void
    {
      def visitorEmitters = Manager.GetListUserData.[VisitorEmitter]();
      foreach (emitter in visitorEmitters)
        emitter.DefineMembers();
    }

    private DefineWalkers() : void
    {
      def walkerEmitters = Manager.GetListUserData.[WalkerEmitter]();
      foreach (emitter in walkerEmitters)
        emitter.DefineModule();
      foreach (emitter in walkerEmitters)
        emitter.DefineExtensibleRuleWalkers();
      foreach (emitter in walkerEmitters)
        emitter.DefineOtherRuleWalkers();
      foreach (emitter in walkerEmitters)
        emitter.DefineDescriptor();
    }

    private EmitExternalSymbols() : void
    {
      def externalSymbolEmitters = Manager.GetListUserData.[ExternalSymbolEmitter]();
      try
      {
        foreach (emitter in externalSymbolEmitters)
          emitter.Emit();
        when (!Manager.IsIntelliSenseMode && externalSymbolEmitters.Count > 0)
        {
          def buffer = SCG.List();
          foreach (emitter in externalSymbolEmitters)
            buffer.Add(<[ typeof($(emitter.TargetSymbolType.GetMemType() : typed)) ]>);
          Manager.Hierarchy.AddAssemblyAttribute(Manager.CoreEnv, <[ N2.Serialization.ExportableSymbolsAttribute(array[..$(buffer.ToNList())]) ]>);
        }
        Manager.DisposeBinarySerializationEmitter();
      }
      finally ResetListUserData.[ExternalSymbolEmitter]();
    }

    private EmitSyntaxModules() : void
    {
      def syntaxModuleEmitters = Manager.GetListUserData.[SyntaxModuleEmitter]();
      try
      {
        foreach (emitter in syntaxModuleEmitters)
          emitter.Emit();
        when (!Manager.IsIntelliSenseMode && syntaxModuleEmitters.Count > 0)
        {
          def buffer = SCG.List();
          foreach (emitter in syntaxModuleEmitters)
            buffer.Add(<[ typeof($(emitter.GrammarImplTB.GetMemType() : typed)) ]>);
          Manager.Hierarchy.AddAssemblyAttribute(Manager.CoreEnv, <[ N2.GrammarsAttribute(array[..$(buffer.ToNList())]) ]>);
        }
      }
      finally ResetListUserData.[SyntaxModuleEmitter]();
    }

    private EmitVisitorTypes() : void
    {
      def visitorTypeEmitters = Manager.GetListUserData.[VisitorTypeEmitter]();
      try
      {
        foreach (emitter in visitorTypeEmitters)
          emitter.Emit();
        when (!Manager.IsIntelliSenseMode && visitorTypeEmitters.Count > 0)
        {
          def buffer = SCG.List();
          foreach (emitter in visitorTypeEmitters)
            buffer.Add(<[ typeof($(emitter.VisitorTypeDescriptorTB.GetMemType() : typed)) ]>);
          Manager.Hierarchy.AddAssemblyAttribute(Manager.CoreEnv, <[ N2.VisitorAttribute(array[..$(buffer.ToNList())], array[]) ]>);
        }
      }
      finally ResetListUserData.[VisitorTypeEmitter]();
    }

    private EmitVisitors() : void
    {
      def visitorEmitters = Manager.GetListUserData.[VisitorEmitter]();
      try
      {
      foreach (emitter in visitorEmitters)
        emitter.Emit();
      }
      finally ResetListUserData.[VisitorEmitter]();
    }

    private EmitWalkers() : void
    {
      def walkerEmitters = Manager.GetListUserData.[WalkerEmitter]();
      try
      {
      foreach (emitter in walkerEmitters)
        emitter.Emit();
      }
      finally ResetListUserData.[WalkerEmitter]();
    }

    private ReadMetadata(project : N2Project) : bool
    {
      def errorCount = project.ErrorCount;

      def makeFakeSourceSnapshot(fileName)
      {
        def fileIndex = Nemerle.Compiler.Location.GetFileIndex(fileName);
        SourceSnapshot("", fileIndex, fileName);
      }

      def reportSymbolLoadFailure(e, location)
      {
        assert2(false);
        project.Warning(location, $"Failed to read metadata from referenced assembly: $(e.Message)", -1);
      }

      // step 0: lookup symbol constructors
      def registry = ExternalSymbolConstructorRegistry();
      registry.Register(typeof(SyntaxModuleSymbol).Assembly);

      def initialReaders = SCG.List();
      try
      {
        // step 1: create all symbol readers
        foreach (asm in Manager.ReferencedAssemblies)
        {
          def metadataStream = asm.Assembly.GetManifestResourceStream("N2.Metadata");
          when (metadataStream != null)
          {
            def assemblyId = project.GetAssemblyId(asm.Assembly.GetName());
            def location   = N2.Location(makeFakeSourceSnapshot(asm.Assembly.Location), 0, 0);
            def reader     = MetadataReader(metadataStream, registry, project, assemblyId, location);
            initialReaders.Add(reader, location);
          }
        }

        def readerWithCreatedSymbols = SCG.List();

        // step 2: create symbols from all readers
        foreach ((reader, location) in initialReaders)
          try
          {
            reader.CreateSymbols();
            readerWithCreatedSymbols.Add(reader, location);
          }
          catch { | e => reportSymbolLoadFailure(e, location); }

        // step 3: read symbol bodies from readers that succeeded symbol creation
        foreach ((reader, location) in readerWithCreatedSymbols)
          try reader.ReadSymbols();
          catch { | e => reportSymbolLoadFailure(e, location); }
      }
      finally
      {
        // step 4: dispose all readers
        foreach ((reader, _) in initialReaders)
          reader.Dispose();
      }

      project.ErrorCount == errorCount
    }

    private WriteMetadata(project : Project) : void
    {
      unless (Manager.IsIntelliSenseMode)
      {
        def matadataDirectory =
          if (string.IsNullOrEmpty(Manager.Options.OutputPath))
            Path.GetDirectoryName(Manager.Options.OutputFileName)
          else
            Manager.Options.OutputPath;

        def metadataFileName = Path.Combine(matadataDirectory, "N2.Metadata");
        using(symbolWriter = MetadataWriter(FileStream(metadataFileName, FileMode.Create, FileAccess.Write), project))
          symbolWriter.WriteSymbols();

        Manager.Options.EmbeddedResources ::= metadataFileName;
      }
    }

    public BeforeTypedMembers() : void
    {
      when (IsListUserDataPresent.[G.Start.Ast]())
        try
        {
          def project  = UpdateCurrentProjectContext();
          def fileAsts = Manager.GetListUserData.[G.Start.Ast]();

          unless (ReadMetadata(project))
            throw Recovery();
          unless (LoadParsedSymbols(project, fileAsts))
            throw Recovery();
          unless (TypeSyntaxModules(project, fileAsts))
            throw Recovery();

          MakeEmitters(project);

          DefineAst();
          DefineParsers();
          DefineOtherMembers();
          DefineWalkers();

          WriteMetadata(project);
        }
        finally ResetListUserData.[G.Start.Ast]();
    }

    public WithTypedMembers() : void
    {
      DefineExternalSymbols();

      EmitExternalSymbols();
      EmitSyntaxModules();
      EmitWalkers();
    }

    public SubscribeSourceChangedWithCounter(manager : ManagerClass, fileIndex : int, handler : ISource * int -> void) : void
    {
      mutable counter = 0;
      manager.SubscribeSourceChanged(fileIndex, source =>
      {
        counter += 1;
        handler(source, counter);
      });
    }
  }
}
