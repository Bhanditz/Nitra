using N2.Compiler;
using N2.Model;
using N2.ProjectSystem;
using N2.Typing;
using N2.Runtime;
using N2.Util;

using Nemerle;
using Nemerle.Collections;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Imperative;

using Nemerle.Utility;
using System;
using System.IO;
using System.Diagnostics;
using System.Linq;

using System.Reflection;
using SCG = System.Collections.Generic;
using G = GrammarParser2;
using PExpr = Nemerle.Compiler.Parsetree.PExpr;

namespace N2
{
  internal class N2SourceImpl
  {
    type SyntaxModuleInfos = list[string] * G.SyntaxModule.Ast;

    private Path          : string                 { get; }
    private Manager       : ManagerClass           { get; }
    private ParserHost    : ParserHost             = ParserHost();

    public this(path : string, manager : ManagerClass)
    {
      Path    = path;
      Manager = manager;
      UpdateCurrentProjectContext();
    }

    IsListUserDataPresent[T]() : bool
    {
      def map = Manager.UserData[typeof(SCG.List[T])];
      map != null
    }

    GetUserData[T](init : T -> void = null) : T
      where T: new(), class
    {
      def key = typeof(T);
      mutable result = Manager.UserData[key] :> T;
      when (result == null)
      {
        result = T();
        when (init != null)
          init(result);
        Manager.UserData[key] = result;
      }
      result
    }

    ResetListUserData[T]() : void
    {
      Manager.UserData[typeof(SCG.List[T])] = null
    }

    UpdateCurrentProjectContext() : void
    {
      Project.CurrentProject = GetUserData.[N2Project](p => 
        p.Init(Manager.ReferencedAssemblies.Select(a => a.Assembly.GetName())));
    }

    GetCurrentProjectContext() : N2Project
    {
      Project.CurrentProject :> N2Project
    }

    public static Instance(path : string, manager : ManagerClass) : N2SourceImpl
    {
      def projPath = manager.Options.ProjectPath;
      def projDir = 
        if (File.Exists(projPath))
          Path.GetFullPath(Path.GetDirectoryName(projPath))
        else if (Directory.Exists(projPath))
          Path.GetFullPath(projPath)
        else
          Environment.CurrentDirectory;
      def path = 
        if (IO.Path.IsPathRooted(path))
          path;
        else
          IO.Path.Combine(projDir, path);

      if (manager.UserData.Contains(path))
        manager.UserData[path] :> N2SourceImpl;
      else
      {
        def impl = N2SourceImpl(path, manager);
        manager.UserData[path] = impl;
        impl;
      }
    }

    public static AddExportableSymbol(tb : TypeBuilder) : void
    {
      tb.Manager.GetListUserData.[TypeBuilder]().Add(tb);
    }

    public BeforeInheritance() : void
    {
      when (!IO.File.Exists(Path))
      {
        Message.Error($<#The "$Path" not exists.#>);
        return;
      }

      def makeWrapperClass(source : ISource, processingCount : int) : void
      {
        // request rebuilding type tree when code changed
        if (processingCount > 1 && Manager.IsIntelliSenseMode)
          Manager.RequestOnBuildTypesTree();
        else
          try Parse(source) catch { | e => Message.Error(e.Message); }
      }
      SubscribeSourceChangedWithCounter(Manager, Location.GetFileIndex(Path), makeWrapperClass);
    }

    public Parse(source : ISource) : void
    {
      def source = SourceSnapshot(source.GetText(), source.FileIndex, Path);
      def parseResult = ParserHost.DoParsing(source, G.GrammarImpl.StartRuleDescriptor);
      if (parseResult.IsSuccess) 
      {
        def start = parseResult.CreateAst.[G.Start.Ast]();
        def fileAsts : SCG.List[G.Start.Ast] = Manager.GetListUserData();
        fileAsts.Add(start);
      }
      else
      {
        //def (pos, tokens) = parser.Parser.GetErrors();
        //def loc = N2.Location(parser.Parser.ParsingSource, pos, pos + 1).ToNemerleLocation();
        //foreach (token in tokens)
        //  Message.Error(loc, $"expected \"$(token.Name)\" in rule $(token.Rule.Grammar.Name).$(token.Rule.Name)");

        def errors = parseResult.CollectErrors();
        def pos = parseResult.Source.PositionToLineColumn(errors.Position);
        def loc = Nemerle.Compiler.Location(source.FileIndex, pos.Line, pos.Column);
        Message.Error(loc, $<#Parse failed: ..$(errors.Messages; ", ")#>);
      }
    }

    private LoadExternalSymbols(project : N2Project, rootNamespace : NamespaceSymbol) : bool
    {
      def errorCount = project.ErrorCount;
      
      foreach (asm in Manager.ReferencedAssemblies)
      {
        def foreachType(elems, fn)
        {
          foreach (<[ typeof($(PExpr.TypedType(FixedType.Class(elem is LibraryReference.ExternalTypeInfo, []))))]> in elems)
            fn(elem);
        }

        foreach (attrubute in asm.GetCustomAttributes())
        {
          | (<[ N2.GrammarsAttribute ]>, [<[ array[..$(elems)] ]>]) =>
            foreachType(elems, LoadExternalSyntaxModule(rootNamespace, _));

          | (<[ N2.VisitorAttribute]>, [<[ array[..$(types)] ]>, <[ array[..$(visitors)] ]>]) =>
            foreachType(types, LoadExternalVisitorType(rootNamespace, _));
            foreachType(visitors, LoadExternalVisitor(rootNamespace, _));

          | _ => ()
        }
      }
      
      project.ErrorCount == errorCount
    }

    public static FindMethods(this ti : LibraryReference.ExternalTypeInfo, name : string) : list[IMethod]
    {
      ti.GetMembers().OfType.[IMethod]().Where(method => (method.Name == name)).NToList()
    }

    private LoadExternalVisitorType(rootNamespace : NamespaceSymbol, visitorTypeTI : LibraryReference.ExternalTypeInfo) : void
    {
      def root = rootNamespace.Node;
      def defaultReturnType = match (visitorTypeTI.FindMethods("DefaultReturnType"))
      {
        | [method] => Some(<[ $(method.ReturnType : typed) ]>)
        | []       => None()
        | _        => Message.Error(visitorTypeTI.Location, $"$(visitorTypeTI.FullName) invalid visitor type."); None()
      }

      def parameters = match (visitorTypeTI.FindMethods("CommonParameters"))
      {
        | [method] => method.GetParameters().Map(tp => tp.AsParsed())
        | _        => Message.Error(visitorTypeTI.Location, $"$(visitorTypeTI.FullName) invalid visitor type."); []
      }
      def symbol = ExternalVisitorTypeSymbol(visitorTypeTI.Location.N2Location(), defaultReturnType, parameters);
      _ = root.AddAndReport(visitorTypeTI.NamespaceNode.Parent.FullName, symbol, symbol.FirstLocation);
    }

    private LoadExternalVisitor(rootNamespace : NamespaceSymbol, visitorTI : LibraryReference.ExternalTypeInfo) : void
    {
      ignore(rootNamespace, visitorTI)
    }

    private LoadExternalSyntaxModule(rootNamespace : NamespaceSymbol, grammarImplTI : LibraryReference.ExternalTypeInfo) : void
    {
      def root = rootNamespace.Node;
      def grammarTI   = grammarImplTI.BaseType;

      match (grammarImplTI.GetNestedSubtypes().Filter(ti => ti.Name == AssemblyConstants.GrammarDescriptorImplName))
      {
        | [grammarDescriptorImplTI] =>
          def tokenFieldNames = LoadExternalTokenFieldNames(grammarTI);
          def symbol = ExternalSyntaxModuleSymbol(grammarTI, grammarImplTI, tokenFieldNames);
          def node = root.AddAndReport(grammarTI.NamespaceNode.Parent.FullName, symbol, symbol.FirstLocation);
          LoadExternalMarkers(grammarImplTI, node);
          LoadExternalRules(grammarDescriptorImplTI, node);

        | _ => Message.Error(grammarTI.Location, $"$(grammarTI.FullName) not grammar.")
      }
    }

    private LoadExternalMarkers(type : TypeInfo, node : HierarchyNode) : void
    {
      foreach(<[ N2.MarkerAttribute($(name : string)) ]> as attr in type.GetModifiers().CustomAttributes)
      {
        def loc = attr.Location.N2Location();
        _ = node.AddAndReport([], MarkerSymbol(loc, name), loc);
      }
    }

    private LoadExternalRules(type : LibraryReference.ExternalTypeInfo, node : HierarchyNode) : void
    {
      foreach (ruleTI in type.GetNestedSubtypes())
      {
        when (Util.ParseRuleClassName(ruleTI) is Some((ruleSymbolCtor)))
        {
          def options = RuleDefinitionOptions();
          foreach(attr in ruleTI.GetModifiers().CustomAttributes)
          {
            | <[ N2.ExplicitSpacesAttribute() ]>         => options.SetExplicitSpaces(true);
            | <[ N2.SuppressTrailingSpacesAttribute() ]> => options.SetSuppressTrailingSpaces(true);
            | _ => ()
          }
          def symbol = ruleSymbolCtor(options);
          _ = node.AddAndReport([], symbol, ruleTI.Location.N2Location());
          when (Util.GetAstTypeInfoForExternalRuleSymbol(ruleTI) is Some(typeInfo))
            LoadExternalExtraFields(symbol, typeInfo);
        }
      }
    }

    private LoadExternalExtraFields(ruleSymbol : RuleSymbol, type : TypeInfo) : void
    {
      def reflectExtraFieldAttribute(member : IMember) : IMember * option[bool]
      {
        mutable attrValue = None();
        foreach(attr in member.GetModifiers().GetCustomAttributes())
        {
          | <[ N2.Runtime.ExtraFieldAttribute() ]>                   => attrValue = Some(false)
          | <[ N2.Runtime.ExtraFieldAttribute($(isCached : bool)) ]> => attrValue = Some(isCached)
          | _ => ()
        }
        (member, attrValue)
      }
      def reflectionResult = type.GetMembers(BindingFlags.Instance | BindingFlags.Public).Map(reflectExtraFieldAttribute);
      foreach((method is IMethod, Some(isCached)) in reflectionResult)
      {
        def loc        = method.NameLocation.N2Location();
        def parameters = method.Header.ParametersDeclarations;
        def type       = <[ $(method.ReturnType : typed) ]>;
        def signature  = ExtraField.ExtraFieldSignature(loc, parameters, type);

        def symbol     = if (method.IsAbstract)
          ExtraField.ExternalAbstractSymbol(loc, method.Name, ruleSymbol, isCached, signature);
        else
          ExtraField.ExternalDefSymbol(loc, method.Name, ruleSymbol, isCached, signature);

        _ = ruleSymbol.Node.AddAndReport([], symbol, loc);
      }
    }

    private LoadExternalTokenFieldNames(type : TypeInfo) : Map[string, Identifier]
    {
      def env      = type.Manager.CoreEnv;
      def attrType = env.BindFixedType(<[ N2.TokenFieldNameAttribute ]>);
      def loc      = LocationStack.Top();
      mutable tokenFieldNames = Map();

      foreach ((_, [<[ $(name : string) ]>, <[ array[..$tokens] ]>]) in type.GetModifiers().FindAttributesWithArgs(attrType.TypeInfo, env))
        foreach (<[ $(token : string) ]> in tokens)
          tokenFieldNames = tokenFieldNames.Replace(token, Identifier(loc.N2Location(), name));

      tokenFieldNames
    }

    private LoadParsedSymbols(project : N2Project, rootNamespace : NamespaceSymbol, fileAsts : SCG.List[G.Start.Ast]) : bool
    {
      def errorCount = project.ErrorCount;

      foreach (start in fileAsts)
        start.CollectGlobalSymbols(rootNamespace);

      project.ErrorCount == errorCount
    }

    private TypeSyntaxModules(project : N2Project, rootNamespace : NamespaceSymbol, fileAsts : SCG.List[G.Start.Ast]) : bool
    {
      def errorCount   = project.ErrorCount;

      def context = RootContext(Project.CurrentProject :> N2Project, rootNamespace, Manager.CoreEnv);

      foreach (start in fileAsts)
        _ = start.MakeContext(context);

      foreach (start in fileAsts)
        start.Typing();

      project.ErrorCount == errorCount
    }

    private DeclarationEmitters(rootNamespace : NamespaceSymbol) : void
    {
      def environment = EmitterEnvironment(Manager, rootNamespace.Node);
      MakeEmitters.[ParsedSyntaxModuleSymbol, _](environment, SyntaxModuleEmitter);
      MakeEmitters.[ParsedVisitorTypeSymbol,  _](environment, VisitorTypeEmitter);
      MakeEmitters.[ParsedVisitorSymbol,      _](environment, VisitorEmitter);

      def externalSymbolEmitters = Manager.GetListUserData.[ExternalSymbolEmitter]();
      when (externalSymbolEmitters.Count > 0)
      {
        def serializationEmitter = Manager.CreateBinarySerializationEmitter(
          emitWarning    = msg => <[ N2.ProjectSystem.N2Project.CurrentProject.Warning(N2.Location.Default, $msg, -1) ]>,
          emitFatalError = msg => <[ N2.ProjectSystem.N2Project.CurrentProject.FatalError(N2.Location.Default, $msg, -1) ]>);
        foreach (symbolType in Manager.GetListUserData.[TypeBuilder]())
          externalSymbolEmitters.Add(ExternalSymbolEmitter(environment, symbolType, serializationEmitter));
      }
      ResetListUserData.[TypeBuilder]();
    }

    private MakeEmitters[SymbolType, EmitterType](environment : EmitterEnvironment, makeEmitter : EmitterEnvironment * SymbolType -> EmitterType) : void
      where SymbolType : Symbol
    {
      def emitters = environment.Manager.GetListUserData.[EmitterType]();
      foreach (symbol in environment.Root.GetChildren.[SymbolType]())
        emitters.Add(makeEmitter(environment, symbol));
    }

    private DefineAst() : void
    {
      def syntaxModuleEmitters = Manager.GetListUserData.[SyntaxModuleEmitter]();
      foreach (emitter in syntaxModuleEmitters)
        emitter.DefineExtentionPointAstTypes();
      foreach (emitter in syntaxModuleEmitters)
        emitter.DefineOtherAstTypes();
      foreach (emitter in syntaxModuleEmitters)
        emitter.DefineAstMembers();
    }

    private DefineParsers() : void
    {
      def syntaxModuleEmitters = Manager.GetListUserData.[SyntaxModuleEmitter]();
      foreach (emitter in syntaxModuleEmitters)
        emitter.DefineParserTypes();
      foreach (emitter in syntaxModuleEmitters)
        emitter.DefineParserMethods();
    }

    private DefineOtherMembers() : void
    {
      def syntaxModuleEmitters = Manager.GetListUserData.[SyntaxModuleEmitter]();
      foreach (emitter in syntaxModuleEmitters)
        emitter.DefineMetadataMembers();
    }

    private DefineExternalSymbols() : void
    {
      def externalSymbolEmitters = Manager.GetListUserData.[ExternalSymbolEmitter]();
      foreach (emitter in externalSymbolEmitters)
        emitter.DefineMembers();
    }

    private DefineVisitorTypes() : void
    {
      def visitorTypeEmitters = Manager.GetListUserData.[VisitorTypeEmitter]();
      foreach (emitter in visitorTypeEmitters)
        emitter.DefineMembers();
    }

    private DefineVisitors() : void
    {
      def visitorEmitters = Manager.GetListUserData.[VisitorEmitter]();
      foreach (emitter in visitorEmitters)
        emitter.DefineMembers();
    }

    private EmitExternalSymbols() : void
    {
      def externalSymbolEmitters = Manager.GetListUserData.[ExternalSymbolEmitter]();
      foreach (emitter in externalSymbolEmitters)
        emitter.Emit();
      when (!Manager.IsIntelliSenseMode && externalSymbolEmitters.Count > 0)
      {
        def buffer = SCG.List();
        foreach (emitter in externalSymbolEmitters)
          buffer.Add(<[ typeof($(emitter.TargetSymbolType.GetMemType() : typed)) ]>);
        Manager.Hierarchy.AddAssemblyAttribute(Manager.CoreEnv, <[ N2.Serialization.ExportableSymbolsAttribute(array[..$(buffer.ToNList())]) ]>);
      }
      when (externalSymbolEmitters.Count > 0)
        Manager.DisposeBinarySerializationEmitter();
      ResetListUserData.[ExternalSymbolEmitter]();
    }

    private EmitSyntaxModules() : void
    {
      def syntaxModuleEmitters = Manager.GetListUserData.[SyntaxModuleEmitter]();
      foreach (emitter in syntaxModuleEmitters)
        emitter.Emit();
      when (!Manager.IsIntelliSenseMode && syntaxModuleEmitters.Count > 0)
      {
        def buffer = SCG.List();
        foreach (emitter in syntaxModuleEmitters)
          buffer.Add(<[ typeof($(emitter.GrammarImplTB.GetMemType() : typed)) ]>);
        Manager.Hierarchy.AddAssemblyAttribute(Manager.CoreEnv, <[ N2.GrammarsAttribute(array[..$(buffer.ToNList())]) ]>);
      }
      ResetListUserData.[SyntaxModuleEmitter]();
    }

    private EmitVisitorTypes() : void
    {
      def visitorTypeEmitters = Manager.GetListUserData.[VisitorTypeEmitter]();
      foreach (emitter in visitorTypeEmitters)
        emitter.Emit();
      when (!Manager.IsIntelliSenseMode && visitorTypeEmitters.Count > 0)
      {
        def buffer = SCG.List();
        foreach (emitter in visitorTypeEmitters)
          buffer.Add(<[ typeof($(emitter.VisitorTypeDescriptorTB.GetMemType() : typed)) ]>);
        Manager.Hierarchy.AddAssemblyAttribute(Manager.CoreEnv, <[ N2.VisitorAttribute(array[..$(buffer.ToNList())], array[]) ]>);
      }
      ResetListUserData.[VisitorTypeEmitter]();
    }

    private EmitVisitors() : void
    {
      def visitorEmitters = Manager.GetListUserData.[VisitorEmitter]();
      foreach (emitter in visitorEmitters)
        emitter.Emit();
      ResetListUserData.[VisitorEmitter]();
    }

    public BeforeTypedMembers() : void
    {
      when (IsListUserDataPresent.[G.Start.Ast]())
        try
        {
          UpdateCurrentProjectContext();
        
          def project       = GetCurrentProjectContext();
          def rootNamespace = project.RootNamespace;
          assert2(rootNamespace != null);
          
          def fileAsts = Manager.GetListUserData.[G.Start.Ast]();

          unless (LoadExternalSymbols(project, rootNamespace))
            throw Recovery();
          unless (LoadParsedSymbols  (project, rootNamespace, fileAsts))
            throw Recovery();
          unless (TypeSyntaxModules  (project, rootNamespace, fileAsts))
            throw Recovery();

          DeclarationEmitters(rootNamespace);
          DefineAst();
          DefineParsers();
          DefineOtherMembers();
          DefineVisitorTypes();
          DefineVisitors();
        }
        finally ResetListUserData.[G.Start.Ast]();
    }

    public WithTypedMembers() : void
    {
      DefineExternalSymbols();

      EmitExternalSymbols();
      EmitSyntaxModules();
      EmitVisitorTypes();
      EmitVisitors();
    }

    public SubscribeSourceChangedWithCounter(manager : ManagerClass, fileIndex : int, handler : ISource * int -> void) : void
    {
      mutable counter = 0;
      manager.SubscribeSourceChanged(fileIndex, source =>
      {
        counter += 1;
        handler(source, counter);
      });
    }

    internal static NextKeywordRegexId : void -> int = Util.CreateIdGenerator(0);//TODO Жестоко выпилить
  }
}
