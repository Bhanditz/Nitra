using Nemerle;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;

namespace N2
{
  [MacroUsage(MacroPhase.BeforeInheritance, MacroTargets.Assembly)]
  public macro N2Source(path : string)
  {
    //assert2(false);
    N2SourceImpl.Instance(path, Nemerle.Macros.ImplicitCTX().Manager).BeforeInheritance();
  }

  [MacroUsage(MacroPhase.BeforeTypedMembers, MacroTargets.Assembly)]
  public macro N2Source(path : string)
  {
    N2SourceImpl.Instance(path, Nemerle.Macros.ImplicitCTX().Manager).BeforeTypedMembers();
  }

  [MacroUsage(MacroPhase.WithTypedMembers, MacroTargets.Assembly)]
  public macro N2Source(path : string)
  {
    N2SourceImpl.Instance(path, Nemerle.Macros.ImplicitCTX().Manager).WithTypedMembers();
  }

  [MacroUsage(MacroPhase.BeforeInheritance, MacroTargets.Class)]
  public macro ExportableSymbol(tb : TypeBuilder, externalSymbolTypeName : PExpr = null)
  {
    tb.AddImplementedInterface(<[ N2.Serialization.IExportableSymbol ]>);
    def externalSymbolType =
      if (externalSymbolTypeName == null)
        None()
      else match (TypeVarEnv(tb.Manager).BindFixedType(tb.GlobalEnv, tb, externalSymbolTypeName, false))
      {
        | FixedType.Class(TypeBuilder as externalSymbolTb, []) =>
          externalSymbolTb.AddImplementedInterface(<[ N2.Serialization.IImportableSymbol ]>);
          externalSymbolTb.DisableImplicitConstructor();
          Some(externalSymbolTb)

        | _ =>
          Message.Error("Invalid external symbol type specified");
          None()
      };
    N2SourceImpl.AddExportableSymbol(tb, externalSymbolType);
  }
}
