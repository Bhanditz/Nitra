using Nemerle;
using Nemerle.Assertions;
using Nemerle.Collections;
using Nemerle.Compiler;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;

namespace N2.Typing
{
  [StructuralEquality]
  public class AmbiguousSymbol : Symbol
  {
    public this(ambiguousList : list[Symbol])
    {
      assert2(ambiguousList.Length > 1);
      def name = ambiguousList.Head.Name;
      assert2(ambiguousList.Tail.ForAll(x => x.Name == name));
      AmbiguousList = ambiguousList;
    }
    
    public AmbiguousList : list[Symbol] { get; }
    
    public GetAmbiguous[T](exclude : T = default(_)) : Seq[T]
      where T: Symbol
    {
      def result = AmbiguousList.OfType.[T]();
      
      if (exclude == null)
        result
      else
        result.Where(x => x : object != exclude)
    }
    
    public ReoprtAmbiguous[T](newSymbol : T) : void
      where T: Symbol
    {
      def ambiguousSyntaxModules = GetAmbiguous(exclude = newSymbol);
      Message.Error(syntaxModule.NLocation(), "The syntax module ");
    }
  }
}
