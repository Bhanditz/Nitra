using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Compiler.Typedtree;

using System;
using System.Linq;
using SCG = System.Collections.Generic;

namespace Nemerle.Parser
{
  partial internal class RuleCompiler
  {
    public CompileExtensionPrefix(rd : RuleDefinition.ExtentionPrefix) : void
    {
      def className = _grammarCompiller.DecorateRuleClassName(rd.Name.Id);
      def returnType = GetRuleType(rd);
      def makeBody(useResult)
      {
        def body = if (useResult)
        {
          def (varNames, setResult) = MakeHandlerCall(rd.rule);
          def subRulesCode = CompileRule(rd.rule, varNames);

          DefVars(varNames, <[
            def newPos = $subRulesCode;
            when (newPos > 0)
              $setResult;
            newPos
          ]>)
        }
        else
          <[
            $(CompileRule(rd.rule, []))
          ]>;

        <[
          unchecked // востановление после ошибок тут не нужно
          {         // оно будет произведено в точке расширения
            mutable c : char;
            _ = c; // eliminate warning "a local value c was never used"
            $body;
          }
        ]>
      }

      def implClass = <[decl:
        public class $(className : dyn) : ExtensionPrefixBase[$returnType]
        {
          private _grammar : $(_grammarCompiller.ImplTB.ParsedTypeName);
          public this(grammar : IGrammar)
          {
            base(char.MinValue, char.MaxValue);//TODO:FIXME
            _grammar = grammar :> $(_grammarCompiller.ImplTB.ParsedTypeName);
          }

          public override Descriptor : ExtensionRuleDescriptor[ExtensionPrefixBase[$returnType]] { get { null } }//TODO:FIXME
        }
      ]>;

      def tb = _grammarCompiller.ImplTB.DefineNestedType(implClass);
      //_ = tb.DefineWithSource(
      //  <[decl:
      //    public override Parse(pos : int, text : string) : int
      //    {
      //      $(makeBody(false))
      //    }
      //  ]>);

      _ = tb.DefineWithSource(
        <[decl:
          public override Parse(pos : int, text : string, curOffsets : Nemerle.Parser.Internal.ParsedOffsets, result : ref $returnType) : int
          {
            $(makeBody(true))
          }
        ]>);
      tb.Compile();
    }
  }
}
