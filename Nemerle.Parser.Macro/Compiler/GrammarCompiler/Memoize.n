using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;

using System;
using System.Linq;
using SCG = System.Collections.Generic;

namespace Nemerle.Parser
{
  partial internal class GrammarCompiler
  {
    public class MemoizeNames
    {
      public StartPos       : string { get; }
      public Result         : string { get; }
      public EndPos         : string { get; }
      public MaxRollbackPos : string { get; }
      public this(name : NameRef)
      {
        StartPos       = $"__GENERATED_PEG__Memeoize_StartPos______$(name.Id)__";
        EndPos         = $"__GENERATED_PEG__Memeoize_EndPos________$(name.Id)__";
        Result         = $"__GENERATED_PEG__Memeoize_Result________$(name.Id)__";
        MaxRollbackPos = $"__GENERATED_PEG__Memeoize_MaxRollback___$(name.Id)__";
      }
    }

    private _definedMemoize : Hashtable[NameRef, MemoizeNames] = Hashtable();
    public DefineMemoize(name : NameRef, ruleType : RuleType) : MemoizeNames
    {
      def ty = GrammarTyper.RuleTypeToNType(ruleType, _typer);
      match (_definedMemoize.Get(name))
      {
        | Some(res) => res
        | None =>
          def names = MemoizeNames(name);
          DefineWithSource(<[ decl:
            private mutable $(names.StartPos : dyn) : int = -1;
          ]>);
          DefineWithSource(<[ decl:
            private mutable $(names.Result : dyn) : $(ty : typed);
          ]>);
          DefineWithSource(<[ decl:
            private mutable $(names.EndPos : dyn) : int = -1;
          ]>);
          DefineWithSource(<[ decl:
            private mutable $(names.MaxRollbackPos : dyn) : int = -1;
          ]>);
          _definedMemoize.Add(name, names);
          names
      }
    }

    public class ExtensionPointMemoizeNames
    {
      public StartPos       : string { get; }
      public BindingPower   : string { get; }
      public Result         : string { get; }
      public EndPos         : string { get; }
      public PrefixResult   : string { get; }
      public PrefixEndPos   : string { get; }
      public MaxRollbackPos : string { get; }
      public PrefixRules    : string { get; }
      public PostfixRules   : string { get; }
      public this(name : NameRef)
      {
        StartPos       = $"__GENERATED_PEG__Memeoize_StartPos______$(name.Id)__";
        BindingPower   = $"__GENERATED_PEG__Memeoize_BindingPower__$(name.Id)__";
        Result         = $"__GENERATED_PEG__Memeoize_Result________$(name.Id)__";
        EndPos         = $"__GENERATED_PEG__Memeoize_EndPos________$(name.Id)__";
        PrefixResult   = $"__GENERATED_PEG__Memeoize_PrefixResult__$(name.Id)__";
        PrefixEndPos   = $"__GENERATED_PEG__Memeoize_PrefixEndPos__$(name.Id)__";
        MaxRollbackPos = $"__GENERATED_PEG__Memeoize_MaxRollback___$(name.Id)__";
        PrefixRules    = $"__GENERATED_PEG__Memeoize_PrefixRules___$(name.Id)__";
        PostfixRules   = $"__GENERATED_PEG__Memeoize_PostfixRules__$(name.Id)__";
      }
    }

    private _definedExtensionPointMemoize : Hashtable[NameRef, ExtensionPointMemoizeNames] = Hashtable();
    public DefineExtensionPointMemoizeNames(name : NameRef, ruleType : RuleType) : ExtensionPointMemoizeNames
    {
      def ty = GrammarTyper.RuleTypeToNType(ruleType, _typer);
      match (_definedExtensionPointMemoize.Get(name))
      {
        | Some(res) => res
        | None =>
          def names = ExtensionPointMemoizeNames(name);
          DefineWithSource(<[ decl:
            private mutable $(names.StartPos : dyn) : int = -1;
          ]>);
          DefineWithSource(<[ decl:
            private mutable $(names.BindingPower : dyn) : int = -1;
          ]>);
          DefineWithSource(<[ decl:
            private mutable $(names.Result : dyn) : $(ty : typed);
          ]>);
          DefineWithSource(<[ decl:
            private mutable $(names.EndPos : dyn) : int = -1;
          ]>);
          DefineWithSource(<[ decl:
            private mutable $(names.PrefixResult : dyn) : $(ty : typed);
          ]>);
          DefineWithSource(<[ decl:
            private mutable $(names.PrefixEndPos : dyn) : int = -1;
          ]>);
          DefineWithSource(<[ decl:
            private mutable $(names.MaxRollbackPos : dyn) : int = -1;
          ]>);
          DefineWithSource(<[ decl:
            private mutable $(names.PrefixRules : dyn) : array[ExtensionPrefixBase[$(ty : typed)]] = null;
          ]>);
          DefineWithSource(<[ decl:
            private mutable $(names.PostfixRules : dyn) : array[ExtensionPostfixBase[$(ty : typed)]] = null;
          ]>);
          _definedExtensionPointMemoize.Add(name, names);
          names
      }
    }
  }
}
