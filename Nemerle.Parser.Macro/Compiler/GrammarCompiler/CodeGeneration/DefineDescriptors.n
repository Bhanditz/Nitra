using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;

using System;
using System.Linq;
using SCG = System.Collections.Generic;

using Nemerle.Parser.Internal;

namespace Nemerle.Parser
{
  partial internal class GrammarCompiler
  {
    private _tokenDescriptors : Hashtable[RuleDefinition, list[string]] = Hashtable();
    [Memoize]
    public GetTokenDescriptor(name : string, rd : RuleDefinition) : PExpr
    {
      _ = _tokenDescriptors.Update(rd, [], names => name :: names);
      <[ $(GrammarImplTB.Name : dyn).$(GrammarDescriptorImplTB.Name : dyn).$(DecorateRuleClassName(rd) : dyn).$($"_token_$(name)_" : dyn) ]>
    }

    public DefineDescriptors() : void
    {
      foreach (rd in ParsedGrammar.Rules)
      {
        def define()
        {
          def descriptorClass = <[decl:
            public class $(DecorateRuleClassName(rd) : dyn) : RuleDescriptor
            {
              private this() {}
              public override Name : string { get { $(rd.Name.AsName : string) } }
              public override Grammar : GrammarDescriptor { get { $(GrammarImplTB.GetMemType() : typed).StaticDescriptor } }
              private static _staticDescriptor : $(DecorateRuleClassName(rd) : dyn) = $(DecorateRuleClassName(rd) : dyn)();
              public static StaticDescriptor : RuleDescriptor { get { _staticDescriptor } }
            }
          ]>;
          def tb = GrammarDescriptorImplTB.DefineNestedType(descriptorClass);
          when (_tokenDescriptors.Contains(rd))
            foreach (name in _tokenDescriptors[rd])
              tb.Define(<[decl: public static $($"_token_$(name)_" : dyn) : Nemerle.Parser.TokenDescriptor = Nemerle.Parser.TokenDescriptor(_staticDescriptor, $(name : string)) ]>);
          match (GetRuleType(rd.Name))
          {
            | RuleType.NType(type) => tb.Define(<[decl: public ResultType() : $(type : typed) { mutable res; res } ]>)
            | RuleType.Void        => tb.Define(<[decl: public ResultType() : void {} ]>)
            | RuleType.Chars       => ()
            | _                    => Message.Error(rd.Name.Location, "Implementation error. DefineDescriptors")
          }
          tb.Compile();
        }
        match (rd)
        {
          | RuleDefinition.ExtentionPrefix  => define()
          | RuleDefinition.ExtentionPostfix => define()
          | RuleDefinition.ExtentionPoint   => define()
          | RuleDefinition.Simple           => define()
          | RuleDefinition.Regular          => define()
          | RuleDefinition.ExternalRule     => ()
        }
      }
    }
  }
}
