using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;

using System;
using System.Linq;
using SCG = System.Collections.Generic;

using Nemerle.Parser.Internal;

namespace Nemerle.Parser
{
  partial internal class GrammarCompiler
  {
    private DefineParsingErrors() : void
    {
      def rules = ParsedGrammar.Rules.Filter(rd =>
        match (rd : RuleDefinition)
        {
          | ExtentionPoint
          | Regular
          | ExternalRule
            => false

          | ExtentionPrefix
          | ExtentionPostfix
          | Simple
            => true
        });

      def getErrors = rules.Map(rd =>
      {
        def name = DecorateRuleName(rd);
        <[
          when (pos < $(name : dyn))
          {
            pos = $(name : dyn);
            descriptors.Clear();
          }
          when (pos == $(name : dyn))
            descriptors.Add($(DecorateTokenDescriptor(rd) : dyn));
        ]>
      });
      def clear = rules.Map(rd => <[ $(DecorateRuleName(rd) : dyn) = -2; $(DecorateTokenDescriptor(rd) : dyn) = null; ]>);

      _ = ParsingErrorsTB.DefineWithSource(<[decl: 
        public override GetErrors(pos : ref int, descriptors : SCG.List[Nemerle.Parser.TokenDescriptor]) : void
        {
          _ = pos;
          _ = descriptors;
          { ..$getErrors }
        }
      ]>);

      _ = ParsingErrorsTB.DefineWithSource(<[decl: 
        public override Clear() : void
        {
          ..$clear
        }
      ]>);

      foreach (rd in rules)
      {
        _ = ParsingErrorsTB.DefineWithSource(<[decl: public mutable $(DecorateRuleName(rd) : dyn) : int ]>);
        _ = ParsingErrorsTB.DefineWithSource(<[decl: public mutable $(DecorateTokenDescriptor(rd) : dyn) : Nemerle.Parser.TokenDescriptor ]>);
      }
    }
  }
}