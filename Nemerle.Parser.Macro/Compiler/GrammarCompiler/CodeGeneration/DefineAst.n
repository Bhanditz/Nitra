using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Parser.Model;

using System;
using System.Linq;
using SCG = System.Collections.Generic;

using Nemerle.Parser.Internal;

namespace Nemerle.Parser
{
  partial internal class GrammarCompiler
  {
    [Memoize]
    public DefineAstType(rd : RuleDefinition) : TypeBuilder
    {
      assert(rd.IsAst);
      match (rd)
      {
        | RuleDefinition.ExtentionPoint(PType(basePType)) with baseType = BindFixedType(basePType)
        | RuleDefinition.ExtentionPoint(NType(baseType))
        | RuleDefinition.Simple(PType(basePType), _)      with baseType = BindFixedType(basePType)
        | RuleDefinition.Simple(NType(baseType), _)
        | RuleDefinition.ExtentionPrefix                  with baseType = GetBaseRuleNType(rd)
        | RuleDefinition.ExtentionPostfix                 with baseType = GetBaseRuleNType(rd) =>
          GrammarTB.DefineNestedType(<[decl:
            public partial class $(MakePublicRuleName(rd.Name) : dyn) : $(baseType : typed)
            {
              public this(location : Location, errors : list[ErrorInfo])
              {
                base(location, errors)
              }
            }
          ]>)

        | _ => assert(false)
      }
    }

    public DefineAst() : void
    {
      foreach (rd when rd.IsAst in TypedGrammar.Rules)
      {
        def tb = DefineAstType(rd);
        match (rd.Attributes.Find(_ is RuleAttribute.Ast), GetAstFieldsTypes(rd))
        {
          | (Some(RuleAttribute.Ast as ast), None) with args = []
          | (Some(RuleAttribute.Ast as ast), Some(args)) =>
            when (args.Length != ast.names.Length)
              Message.Error(ast.Location, $"Expected $(args.Length) member got $(ast.names.Length)");
            tb.DefineNestedType(<[decl: 
              public partial new class Error : $(tb.GetMemType() : typed)
              {
                public this(location : Location, errors : list[ErrorInfo])
                {
                  base(location, errors)
                }
              }
            ]>).Compile();

            tb.DefineNestedType(<[decl: 
              public partial new class Splice : $(tb.GetMemType() : typed)
              {
                public this(location : Location, errors : list[ErrorInfo])
                {
                  base(location, errors)
                }
              }
            ]>).Compile();

            match (rd)
            {
              | RuleDefinition.ExtentionPoint => ()
              | RuleDefinition.ExtentionPostfix
              | RuleDefinition.ExtentionPrefix
              | RuleDefinition.Simple =>
                def astTb = tb.DefineNestedType(<[decl: 
                  public partial new class Ast : $(tb.GetMemType() : typed)
                  {
                  }
                ]>);
                def members    = ast.names.Map(_.AsName).Zip(args);

                DefineAstFields(astTb, members);
                DefineAstCtor(astTb, members);
                DefineAstGetErrors(astTb, members);
                when (rd.GetRule() is Some(rule))
                  DefineAstGetSpans(astTb, ast, rule, rd);

                astTb.Compile();
              | RuleDefinition.ExternalRule
              | RuleDefinition.Regular => assert(false);
            }
          | _ => assert(false)
        }
        tb.Compile();
      }
    }

    private DefineAstFields(astTb : TypeBuilder, members : list[string * RuleType]) : void
    {
      def fields = members.Map((name, argType) => <[decl: public $(name : dyn) : $(RuleTypeToNType(argType) : typed); ]>);
      foreach (field in fields)
        astTb.Define(field);
    }

    private DefineAstCtor(astTb : TypeBuilder, members : list[string * RuleType]) : void
    {
      def locationName = <[ $(Nemerle.Compiler.Parsetree.Name("location") : name) ]>;
      def errorsName   = <[ $(Nemerle.Compiler.Parsetree.Name("error") : name) ]>;
      def args
        =  <[ $locationName : Location ]>
        :: <[ $errorsName : list[ErrorInfo] ]>
        :: members.Map((name, argType) => <[ $(name : dyn) : $(RuleTypeToNType(argType) : typed) ]>)
        ;
      _ = astTb.DefineWithSource(<[decl:
        public this(..$(args.Map(PParameter)))
        {
            base($locationName, $errorsName);
            { ..$(members.Map((name, _) => <[ this.$(name : dyn) = $(name : dyn); ]>)) }
        }
      ]>);
    }

    private DefineAstGetErrors(astTb : TypeBuilder, members : list[string * RuleType]) : void
    {
      def makeGetErrors(name, type) : PExpr // TODO: Оптимизировать списоки токенов.
      {
        match (type : RuleType)
        {
          | _ when RuleTypeToNType(type).TryUnify(_ntokenType)
          | Chars        => <[ () ]>
          | Tuple([_])   => <[ $(name : dyn).GetErrors(errors); ]>
          | PType        => <[ $(name : dyn).GetErrors(errors); ]>
          | NType        => <[ $(name : dyn).GetErrors(errors); ]>
          | List(type)   =>
            <[
              foreach (_item in $(name : dyn))
                $(makeGetErrors("_item", type));
            ]>

          | Option(type) =>
            <[
              match ($(name : dyn))
              {
                | Some(_item) => $(makeGetErrors("_item", type));
                | _ => ()
              }
            ]>

          | Tuple(types) =>
            def types = types.Filter(ty => !(ty is RuleType.Void));
            def fields = types.Length;
            def names = $[0..fields - 1].Map(n => $"_item$n");
            <[
              {
                def (..$(names.Map(name => <[ $(name : dyn) ]>))) = $(name : dyn);
                { ..$(names.Zip(types).Map(makeGetErrors)) };
              }
            ]>

          | Void         => assert(false)
        }
      }
      _ = astTb.DefineWithSource(<[decl:
        public override GetErrors(errors : System.Collections.Generic.List[ErrorInfo]) : void
        {
          base.GetErrors(errors);
          { ..$(members.Map(makeGetErrors)) }
        }
      ]>);
    }

    private DefineAstGetSpans(astTb : TypeBuilder, ast : RuleAttribute.Ast, rule : Rule, rd : RuleDefinition) : void
    {
      def nameMap = SCG.Dictionary();
      def rules = match (rule)
      {
        | Rule.Sequence(rules) =>
          rules.Filter(rule => !(rule.Type is RuleType.Void));
        | _ => assert(false);
      }
      assert(rules.Length == ast.names.Length);
      foreach ((name, rule) in ast.names.Zip(rules))
        nameMap[rule.Id] = name.AsName;
      def getName(rule)
      {
        def id = rule.Id;
        if (nameMap.ContainsKey(id))
          nameMap[id];
        else
          $"ast_$id"
      }
      def makeGetSpans(rule : Rule) : PExpr
      {
        def varName = getName(rule);
        match (rule : Rule)
        {
          | PrefixCall(ruleName, _)
          | Call(ruleName, _) =>
            def rd = TypedGrammar.GetRule(ruleName);
            if (rd.Attributes.Find(_ is RuleAttribute.SpanClass) is Some(RuleAttribute.SpanClass as spanClass))
            {
              if (rd is RuleDefinition.Regular)
                <[ spans.Add(Nemerle.Parser.SpanInfo($(varName : dyn), $(MakeSpanClassFieldName(spanClass.name) : dyn))) ]>
              else
                <[ $(varName : dyn).GetSpans(spans) ]>
            }
            else
            {
              if (rd is RuleDefinition.Regular)
                <[ spans.Add(Nemerle.Parser.SpanInfo($(varName : dyn), Nemerle.Parser.SpanClass.Default)) ]>
              else
                <[ $(varName : dyn).GetSpans(spans) ]>
            }

          | String(str) =>
            def spanClass = TypedGrammar.SpanClasses.Find(spanClass =>
            {
              match (spanClass.Match)
              {
                | Some(rr) =>
                  FSMMatch.MakeMatcher(ConvertRegularRuleToFsm(rr))(str)//TODO:Optimize
                | None => false;
              }
            });
            if (spanClass is Some(spanClass))
              <[ spans.Add(Nemerle.Parser.SpanInfo($(varName : dyn), $(MakeSpanClassFieldName(spanClass.Name) : dyn))) ]>
            else
              <[ spans.Add(Nemerle.Parser.SpanInfo($(varName : dyn), Nemerle.Parser.SpanClass.Default)) ]>

          | Sequence(rules) =>
            def rules = rules.Filter(rule => !(rule.Type is RuleType.Void));
            def names = rules.Map(getName).Map(name => <[ $(name : dyn)]>);
            match (names)
            {
              | [name] =>
                <[
                  {
                    def $name = $(varName : dyn);
                    { ..$(rules.Map(makeGetSpans)) }
                  }
                ]>
              | names =>
                <[
                  {
                    def (..$names) = $(varName : dyn);
                    { ..$(rules.Map(makeGetSpans)) }
                  }
                ]>
            }

          | Repeat(0, Some(1), subRule) =>
            <[
              match($(varName : dyn))
              {
                | Some($(getName(subRule) : dyn)) => $(makeGetSpans(subRule))
                | _ => ()
              }
            ]>

          | Repeat(_, _, subRule) =>
            <[
              foreach ($(getName(subRule) : dyn) in $(varName : dyn))
                $(makeGetSpans(subRule))
            ]>

          | RepeatWithSeparator(_, _, rule, separator) =>
            <[
              foreach ($(getName(rule) : dyn) in $(varName : dyn)[0])
                $(makeGetSpans(rule));
              foreach ($(getName(separator) : dyn) in $(varName : dyn)[1])
                $(makeGetSpans(separator));
            ]>

          | Scope(_, rule) =>
            <[
              def $(getName(rule) : dyn) = $(varName : dyn);
              $(makeGetSpans(rule));
            ]>

          | And | Not | Cut => assert(false);
        }
      }

      _ = astTb.DefineWithSource(<[decl:
        public override GetSpans(spans : System.Collections.Generic.List[Nemerle.Parser.SpanInfo]) : void
        {
          $(
            if (rd.Attributes.Find(_ is RuleAttribute.SpanClass) is Some(RuleAttribute.SpanClass as spanClass))
              <[ spans.Add(Nemerle.Parser.SpanInfo(this.Location.NToken, $(MakeSpanClassFieldName(spanClass.name) : dyn))) ]>
            else
              <[ () ]>
          );
          { ..$(rules.Map(makeGetSpans)) }
        }
      ]>);
    }
  }
}
