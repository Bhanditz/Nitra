using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;

using System;
using System.Linq;
using SCG = System.Collections.Generic;

using Nemerle.Parser.Internal;

namespace Nemerle.Parser
{
  partial internal class GrammarCompiler
  {
    [Memoize]
    public DefineAstType(rd : RuleDefinition) : TypeBuilder
    {
      assert(rd.IsAst);
      match (rd)
      {
        | RuleDefinition.ExtentionPoint(PType(basePType)) with baseType = BindFixedType(basePType)
        | RuleDefinition.ExtentionPoint(NType(baseType))
        | RuleDefinition.Simple(PType(basePType), _)      with baseType = BindFixedType(basePType)
        | RuleDefinition.Simple(NType(baseType), _)
        | RuleDefinition.ExtentionPrefix                  with baseType = GetBaseRuleNType(rd)
        | RuleDefinition.ExtentionPostfix                 with baseType = GetBaseRuleNType(rd) =>
          GrammarTB.DefineNestedType(<[decl:
            public partial class $(MakePublicRuleName(rd.Name) : dyn) : $(baseType : typed)
            {
              public this(location : Location, errors : list[ErrorInfo])
              {
                base(location, errors)
              }
            }
          ]>)

        | _ => assert(false)
      }
    }

    public DefineAst() : void
    {
      foreach (rd when rd.IsAst in TypedGrammar.Rules)
      {
        def tb = DefineAstType(rd);
        match (rd.Attributes.Find(_ is RuleAttribute.Ast), GetRuleHandlerArgs(rd, true))
        {
          | (Some(RuleAttribute.Ast as ast), None) with args = []
          | (Some(RuleAttribute.Ast as ast), Some(args)) =>
            when (args.Length != ast.names.Length)
              Message.Error(ast.Location, $"Expected $(args.Length) member got $(ast.names.Length)");
            tb.DefineNestedType(<[decl: 
              public partial new class Error : $(tb.GetMemType() : typed)
              {
                public this(location : Location, errors : list[ErrorInfo])
                {
                  base(location, errors)
                }
              }
            ]>).Compile();

            tb.DefineNestedType(<[decl: 
              public partial new class Splice : $(tb.GetMemType() : typed)
              {
                public this(location : Location, errors : list[ErrorInfo])
                {
                  base(location, errors)
                }
              }
            ]>).Compile();

            match (rd)
            {
              | RuleDefinition.ExtentionPoint => ()
              | RuleDefinition.ExtentionPostfix
              | RuleDefinition.ExtentionPrefix
              | RuleDefinition.Simple =>
                def astTb = tb.DefineNestedType(<[decl: 
                  public partial new class Ast : $(tb.GetMemType() : typed)
                  {
                  }
                ]>);
                def fields = args.Zip(ast.names).Map((argType, name) => <[decl: public $(name.AsName : dyn) : $(argType : typed); ]>);
                foreach (field in fields)
                  astTb.Define(field);

                def locationName = <[ $(Nemerle.Compiler.Parsetree.Name("location") : name) ]>;
                def errorsName   = <[ $(Nemerle.Compiler.Parsetree.Name("error") : name) ]>;
                def args = <[ $locationName : Location ]> :: <[ $errorsName : list[ErrorInfo] ]> :: args.Zip(ast.names).Map((argType, name) => <[ $(name.AsName : dyn) : $(argType : typed) ]>);
                def assignments = ast.names.Map(name => <[ this.$(name.AsName : dyn) = $(name.AsName : dyn); ]>);
                astTb.Define(<[decl:
                  public this(..$(args.Map(PParameter)))
                  {
                     base($locationName, $errorsName);
                     { ..$assignments }
                  }
                ]>);
                astTb.Compile();
              | RuleDefinition.ExternalRule
              | RuleDefinition.Regular => assert(false);
            }
          | _ => assert(false)
        }
        tb.Compile();
      }
    }
  }
}
