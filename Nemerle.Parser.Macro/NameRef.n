using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Compiler;

using System;
using System.Collections.Generic;
using System.Linq;

namespace Nemerle.Parser
{
  public class NameRef : Nemerle.Compiler.Located, IComparable[NameRef]
  {
    private _parts : list[string];

    public this(location : Nemerle.Compiler.Location, parts : list[string])
    {
      base(location);
      _parts = parts;
    }

    public this(location : Nemerle.Compiler.Location, part : string)
    {
      this(location, [part])
    }

    public this(pexpr : Parsetree.PExpr)
    {
      this(pexpr.Location, [pexpr.ToString()])
    }

    public PartsCount : int { get { _parts.Length } }

    public override ToString() : string
    {
      $<#..$(_parts; ".")#>
    }

    public CompareTo(that : NameRef) : int
    {
      def cmp(parts1, parst2)
      {
        | (part1 :: parts1, part2 :: parst2) =>
          def res = StringComparer.Ordinal.Compare(part1, part2);
          if (res == 0)
            cmp(parts1, parst2)
          else
            res
         | ([], []) => 0
         | (_ , []) => 1
         | _        => -1
      }
      cmp(_parts, (that?._parts) ?? []);
    }

    [Nemerle.OverrideObjectEquals]
    public Equals(that : NameRef) : bool
    {
      CompareTo(that) == 0
    }

    public EqualsToName(name : string) : bool
    {
      StringComparer.Ordinal.Compare(AsName, name) == 0
    }

    public AsName : string
    {
      get
      {
        match (_parts)
        {
          | [part] => part
          | _      => assert(false)
        }
      }
    }

    public override GetHashCode() : int
    {
      mutable hash = 0;
      foreach (part in _parts)
        hash = (hash >> 3) + hash + part.GetHashCode();
      hash
    }

    public static @==(name1 : NameRef, name2 : NameRef) : bool
    {
      if (object.ReferenceEquals(name1, name2))
        true
      else if (object.ReferenceEquals(name1, null) || object.ReferenceEquals(name2, null))
        false
      else
        name1.Equals(name2)
    }

    public static @!=(name1 : NameRef, name2 : NameRef) : bool
    {
      !(name1 == name2)
    }
  }
}
