using System;
using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Compiler.Parsetree.PExpr;
using Nemerle.Compiler.Token;

namespace Nemerle.Parser
{
  internal partial class GrammarParser
  {
    private ParseName(tok : Token) : NameRef * Token
    {
      def parseName(tok)
      {
        match (tok.Next)
        {
          | Operator(".") =>
            match (tok.Next.Next)
            {
              | Identifier(name) =>
                def (names, loc, next) = parseName(tok.Next.Next);
                (name :: names, loc, next)
              | _ => ReportCriticalUnexpected(tok.Next.Next, "identifier")
            }
          | _ => ([], tok.Location, tok.Next)
        }
      }
      match (tok)
      {
        | Identifier(name) =>
          def (names, location, nextTok) = parseName(tok);
          def ruleName = NameRef(tok.Location + location, name :: names);
          assert(ruleName.PartsCount <= 2);
          (ruleName, nextTok)

        | _ => assert(false);
      }
    }

    private ParserRoundGroup[RuleT]
      ( group               : RoundGroup
      , parse               : Token -> RuleT * Token
      , repeatWithSeparator : Compiler.Location * int * option[int] * RuleT * RuleT -> RuleT
      )                     : RuleT * Token
    {
      def (rule1, nextToken) = parse(group.Child);

      if (group.Child.Next != null)
      {
        def (rule2, nextToken) = parse(group.Child.Next);
        if (nextToken == null && group.Child.Next.Next == null)
        {
          match (group.Next)
          {
            | Operator("*") with min = 0
            | Operator("+") with min = 1 =>
              (repeatWithSeparator(group.Location, min, None(), rule1, rule2), group.Next.Next)
            | _ => ReportCriticalUnexpected(group.Next, "'*' or '+'");
          }
        }
        else
          ReportCriticalUnexpected(nextToken, "')'");
      }
      else
        if (nextToken == null)
          (rule1, group.Next)
        else
          ReportCriticalUnexpected(nextToken, "',' or ')'");
    }

    // SimpleRule      = FailureRecovery '(' Identifier,  OrderedChoice ')', RuleName '{' OrderedChoice '}' / RuleName / Range / Char / String / '(' OrderedChoice ')' / Empty
    private ParseSimpleRule(tok : Token) : Rule * Token
    {
      | Token.Operator("%")         => (Rule.Cut(tok.Location), tok.Next)
      | Identifier                  =>
        def (ruleName, nextTok) = ParseName(tok);
        match (nextTok)
        {
          | BracesGroup(LooseGroup(IntegerLiteral), _) 
                                 => (Rule.Call(ruleName.Location, ruleName, 0), nextTok)
          | BracesGroup as group => (Rule.Scope(ruleName.Location + group.Location, ruleName, ParseSequence(group.Child)[0]), group.Next)
          | Operator(":") as tok =>
            match (tok.Next)
            {
              | IntegerLiteral as tok =>
                match (tok.lit.AsInt)
                {
                  | Some(bp) => (Rule.Call(ruleName.Location, ruleName, bp), tok.Next)
                  | _        => ReportCriticalUnexpected(tok, "integer-literal")
                }
              | tok => ReportCriticalUnexpected(tok, "integer-literal")
            }
          | _                    => (Rule.Call(ruleName.Location, ruleName, 0), nextTok)
        }

      | RoundGroup as group         => ParserRoundGroup(group, ParseSequence, Rule.RepeatWithSeparator)
      | StringLiteral(value = str)  => (Rule.String(tok.Location, str), tok.Next)
      | CharLiteral(ch)             => (Rule.String(tok.Location, ch.ToString()), tok.Next)
      | null                        => (Rule.Sequence([]), null)
      | _                           => (null, tok)
    }

    private ParseRegularSimpleRule(tok : Token) : RegularRule * Token
    {
      | SquareGroup as group        => (ParseRange(group)[0], group.Next)
      | Identifier                  =>
        def (ruleName, nextTok) = ParseName(tok);
        (RegularRule.Call(ruleName.Location, ruleName), nextTok)
      | RoundGroup as group         => ParserRoundGroup(group, ParseRegularChoice, RegularRule.RepeatWithSeparator)
      | StringLiteral(value = str)  => (RegularRule.Chars(tok.Location, str.Map(ch => RangeSet().AddRange(ch, ch))), tok.Next)
      | CharLiteral(ch)             => (RegularRule.Chars(tok.Location, [RangeSet().AddRange(ch, ch)]), tok.Next)
      | null                        => (RegularRule.Sequence([]), null)
      | _                           => (null, tok)
    }
  }
}
