using Nitra.ProjectSystem;

using System;
using SCG = System.Collections.Generic;

using Nemerle;
using Nemerle.Assertions;
using Nemerle.Extensions;
using Nemerle.Utility;

namespace Nitra
{
  public class SourceSnapshot : IPrettyPrintSource
  {
    private sealed class FakeFile : ConcreteFile
    {
      private _source : SourceSnapshot;

      public this([NotNull] source : SourceSnapshot, fullName : string = null)
      {
        base(null);
        _source  = source;
        FullName = fullName ?? "<Temp>";
      }

      public override Project     : Project        { get { null } }
      public override Length      : int            { get { _source.Text.Length } }
      public override FullName    : string         { get }
      public override GetSource() : SourceSnapshot { _source }
    }

    public static @:(text : string) : SourceSnapshot { SourceSnapshot(text) }
    public static Default : SourceSnapshot { get; default SingleLineSourceSnapshot("", "<Default>") }

    public OriginalText : string { get; }
    public Text         : string { get; }
    public File         : File   { get; }

    private _lineIndexes : array[int];
    private _textOffset  : int;
    private _hashCode    : int;

    protected this([NotNull] originalText : string, [NotNull] text : string, [NotNull] lineIndexes : array[int], textOffset : int, file : File, fileName : string)
    {
      OriginalText = originalText;
      Text         = text;
      File         = if (file is FakeFile) FakeFile(this, file.FullName) else file ?? FakeFile(this, fileName);
      _lineIndexes = lineIndexes;
      _textOffset  = textOffset;
      _hashCode    = text.GetHashCode();
    }

    public this(text : string, file : File = null)
    {
      this(text, text, MakeLineIndexes(text), 0, file, null)
    }

    public this(text : string, fileName : string)
    {
      this(text, text, MakeLineIndexes(text), 0, null, fileName)
    }

    public PositionToLineColumn(pos : int) : LineColumn
    {
      def pos = _textOffset + pos;

      match (Array.BinarySearch(_lineIndexes, pos))
      {
        | index when index < 0 =>
          def index = ~index;
          if (index > 0)
            LineColumn(index, pos - _lineIndexes[index - 1] + 1)
          else
            LineColumn(1, 1)

        | index =>
          LineColumn(index + 1, pos - _lineIndexes[index] + 1)
      }
    }

    public GetSourceLine(pos : int) : Location
    {
      def pos = _textOffset + pos;
      def (line, col) = PositionToLineColumn(pos);
      def startPos = pos - col + 1;
      def endPos =
        if(line == _lineIndexes.Length)
          Text.Length
        else
          _lineIndexes[line];
      Location(this, startPos, endPos)
    }

    public WithText([NotNull] text : string) : SourceSnapshot
    {
      WithText(text, 0)
    }

    public WithText([NotNull] text : string, textOffset : int) : SourceSnapshot
      requires OriginalText.Length >= text.Length + textOffset
    {
      SourceSnapshot(OriginalText, text, _lineIndexes, textOffset, File, null)
    }

    public WithTextSubstring(pos : int, length : int) : SourceSnapshot
    {
      WithText(Text.Substring(pos, length), _textOffset + pos)
    }

    public GetGarbage(prevPos : int, pos : int) : NSpan
    {
      IgnoreParams();
      NSpan()
    }

    public override ToString() : string
    {
      def quoteLength = 200;
      if (Text.Length > quoteLength)
        $"$File: $(Text.Substring(0, quoteLength))..."
      else
        $"$File: $Text"
    }

    protected static MakeLineIndexes(text : string) : array[int]
    {
      def lineIndexesBuffer = SCG.List(text.Length / 25);
      lineIndexesBuffer.Add(0);
      mutable pos;
      while (pos < text.Length)
      {
        match (text[pos])
        {
          | '\r' =>
            ++pos;
            when (pos < text.Length && text[pos] == '\n')
              ++pos;
            lineIndexesBuffer.Add(pos);
          | '\n'
          | '\u2028'    /*  line separator       */
          | '\u2029' => /*  paragraph separator  */
            ++pos;
            lineIndexesBuffer.Add(pos);
          | _ =>
            ++pos;
        }
      }
      lineIndexesBuffer.ToArray()
    }

    #region Nitra.SourceSnapshot  Members

    public static @==(a : SourceSnapshot, b : SourceSnapshot) : bool { object.Equals(a, b) }
    public static @!=(a : SourceSnapshot, b : SourceSnapshot) : bool { !object.Equals(a, b) }

    [OverrideObjectEquals]
    public Equals(other : SourceSnapshot) : bool
    {
      other != null && _hashCode == other._hashCode && this.Text.Equals(other.Text, StringComparison.Ordinal)
    }

    public override GetHashCode() : int
    {
      _hashCode
    }

    #endregion
  }
}
