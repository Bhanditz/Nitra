using Nemerle;
using Nemerle.Collections;
using Nemerle.Imperative;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Compiler.Typedtree;

using Nitra.Internal;
using Nitra.Model;
using Nitra.Typing;

using System;
using System.Diagnostics;
using System.Linq;
using SCG = System.Collections.Generic;

namespace Nitra.Compiler
{
  internal partial class RuleAstEmitter
  {
    public DefineMembers() : void
    {
      when (_baseTb != null)
      {
        DefineBaseAstCreateMethod();
        DefineBaseAstRuleMethods();
      }
      when (_astTb != null)
      {
        DefineAstCtorAndFields();
        DefineAstPrettyPrint();
        DefineAstRuleMethods();
      }
      when (_spliceTb != null)
      {
        DefineSpliceRuleMethods();
      }
      when (_missingTb != null)
      {
        DefineMissingPrettyPrint();
        DefineMissingRuleMethods();
      }
      when (_ambiguousTb != null)
      {
        DefineAmbiguousPrettyPrint();
        DefineAmbiguousRuleMethods();
      }
    }

    private DefineBaseAstCreateMethod() : void
    {
      when (this.RuleSymbol is SimpleRuleSymbol)
      {
        _baseTb.DefineConditional(<[ decl:
          public static Create(pos : ref int, parseResult : Nitra.Internal.ParseResult) : $(_baseTb.GetMemType() : typed)
          {
            def ruleParser = parseResult.RuleParser.Grammar.GetSimpleRuleParser($(this.RuleSymbol.GetRuleDescriptorRef()));
            def astPtr = parseResult.TryGetAst(pos, ruleParser.RuleId);
            if (astPtr > 0)
              $(_baseTb.GetMemType() : typed).Ast(ref pos, astPtr, parseResult)
            else
              $(_baseTb.GetMemType() : typed).MissingAst(Nitra.Location(parseResult, pos, pos))
          }
        ]>);
      }
      when (this.RuleSymbol.Options.IsStart)
      {
        match (this.RuleSymbol)
        {
          | SimpleRuleSymbol =>
            _baseTb.DefineConditional(<[ decl:
              public static Create(parseResult : Nitra.Internal.ParseResult) : $(_baseTb.GetMemType() : typed)
              {
                mutable pos = parseResult.StartPos;
                Create(ref pos, parseResult);
              }
            ]>);

          | ExtensibleRuleSymbol =>
            _baseTb.DefineConditional(<[ decl:
              public static Create(parseResult : Nitra.Internal.ParseResult) : $(_baseTb.GetMemType() : typed)
              {
                mutable pos = parseResult.StartPos;
                Nitra.Internal.ExtensibleRuleAstConstructor.Create(ref pos, parseResult, 0, $(this.RuleSymbol.GetRuleDescriptorRef()));
              }
            ]>);

          | _ => assert2(false);
        }
      }
    }

    private DefineAstCtorAndFields() : void
    {
      def sequence = this.RuleSymbol.Sequence;
      def astPtr = AstPointer.Existing(sequence, this, "astPtr");

      def endPosStatements = SCG.List();
      foreach (subrule in sequence.NonMarkerSubrules)
        endPosStatements.Add(<[ endPos += $(astPtr.GetSize(subrule)) ]>);

      match (this.RuleSymbol)
      {
        | SimpleRuleSymbol
        | ExtensionRuleSymbol(ExtensionType = Prefix) =>
          _astTb.DefineConditional(<[decl:
            public this(pos : ref int, astPtr : int, parseResult : Nitra.Internal.ParseResult)
            {
              unchecked
              {
                mutable endPos = pos;
                { ..$endPosStatements }
                base(Nitra.Location(parseResult, pos, endPos));
                this.astPtr     = astPtr;
                pos = endPos;
              }
            }
          ]>);

        | ExtensionRuleSymbol(ExtensionType = Postfix) as symbol =>
          _astTb.DefineConditional(<[decl:
            public this(prefix : $(Environment.GetAstType(symbol.BaseRule.Value) : typed), prefixStartPos : int, pos : ref int, astPtr : int, parseResult : Nitra.Internal.ParseResult)
            {
              unchecked
              {
                mutable endPos = pos;
                { ..$endPosStatements }
                base(Nitra.Location(parseResult, prefixStartPos, endPos));
                this.startPos   = pos;
                this.astPtr     = astPtr;
                this.prefix     = prefix;
                pos = endPos;
              }
            }
          ]>);
          _astTb.DefineConditional(<[ decl: private startPos : int; ]>);
          _astTb.DefineConditional(<[ decl: private prefix : $(Environment.GetAstType(symbol.BaseRule.Value) : typed); ]>);

        | _ => assert(false)
      }

      _astTb.DefineConditional(<[ decl: private astPtr      : int; ]>);

      def ruleExprs = SCG.Dictionary.[Rule, FieldExpr]();

      when (this.RuleSymbol is ExtensionRuleSymbol(ExtensionType = Postfix(call, _)))
        ruleExprs.Add(call, FieldExpr.Prefix(<[ this.prefix ]>));

      def prevSubrules = SCG.List();
      foreach (subrule in this.RuleSymbol.Sequence.NonMarkerSubrules)
      {
        when (IsSubruleAcceptedForAst(subrule))
        {
          def parentAstPtr = AstPointerScope(astPtr);
          mutable needRuleParser;
          def valueExpr = GetSubruleValue(subrule, parentAstPtr, ref needRuleParser);

          def statements = SCG.List();
          statements.Add(<[ mutable pos = $(GetAstStartPos()); ]>);
          foreach (subrule in prevSubrules)
            statements.Add(WalkerGenerator.Skip(subrule, parentAstPtr));
          statements.Add(valueExpr);

          def expr =
            if (subrule.SrcRule.Type is RuleType.Chars)
              FieldExpr.NSpan(<[ { ..$statements } ]>, needRuleParser)
            else
              FieldExpr.Other(<[ { ..$statements } ]>, needRuleParser);

          ruleExprs.Add(subrule.SrcRule, expr);
        }
        prevSubrules.Add(subrule);
      }

      def makeFieldExpr(rule : Rule) : FieldExpr
      {
        if (rule is Rule.Sequence(Rules = rules))
        {
          def members = SCG.List();
          foreach (rule when !(rule.Type is RuleType.Void) in rules)
            members.Add(makeFieldExpr(rule));

          if(members.Count == 1)
            members[0]
          else
            FieldExpr.Tuple(members.ToNList())
        }
        else
        {
          mutable expr;
          unless (ruleExprs.TryGetValue(rule, out expr))
            assert3(false);
          expr
        }
      }

      foreach (rule in this.RuleSymbol.NonVoidSubRules)
        CreateField(rule, makeFieldExpr(rule))
    }

    private GetAstStartPos() : PExpr
    {
      match (this.RuleSymbol)
      {
        | SimpleRuleSymbol
        | ExtensionRuleSymbol(ExtensionType = Prefix)  => <[ this.Location.StartPos ]>
        | ExtensionRuleSymbol(ExtensionType = Postfix) => <[ this.startPos ]>
        | _ => assert(false)
      }
    }

    private variant FieldExpr
    {
      | NSpan  { Expr  : PExpr; NeedRuleParser : bool }
      | Tuple  { Items : list[FieldExpr] }
      | Prefix { Expr  : PExpr }
      | Other  { Expr  : PExpr; NeedRuleParser : bool }
    }

    private CreateField(rule : Rule, body : FieldExpr) : void
    {
      def statements = SCG.List();

      mutable needParseResult : bool;
      mutable needRuleParser  : bool;
      mutable needCaching     : bool;

      def analyzeFieldExpr(_ : FieldExpr) : void
      {
        | Prefix         => ()
        | Tuple(items)   => foreach (expr in items) analyzeFieldExpr(expr);
        | NSpan(_, true) => needParseResult = true; needRuleParser = true;
        | NSpan          => needParseResult = true;
        | Other(_, true) => needParseResult = true; needRuleParser = true; needCaching = true;
        | Other          => needParseResult = true;                        needCaching = true;
      }

      analyzeFieldExpr(body);

      when (needParseResult)
        statements.Add(<[ def parseResult = this.GetParseResultFromLocation(); ]>);
      when (needRuleParser)
        statements.Add(<[ def ruleParser = parseResult.GetRuleParser(astPtr) :> $(this.RuleSymbol.GetParserClassRef()) ]>);

      def compileFieldExpr(_ : FieldExpr) : PExpr
      {
        | Prefix(expr)
        | NSpan(expr, _)
        | Other(expr, _) => expr
        | Tuple(items)   => <[ (..$(items.Map(compileFieldExpr))) ]>
      }

      statements.Add(compileFieldExpr(body));

      def propertyType = Environment.GetAstType(rule.Type);
      def propertyCode =
        if (needCaching)
        {
          def backingFieldName = Util.tmpname(rule.FieldName);
          _astTb.DefineConditional(<[ decl: private mutable $(backingFieldName : usesite) : $(propertyType : typed); ]>);
          if (propertyType.IsValueType)
          {
            def loadedBit = _astTb.GetBitFieldManager().Allocate();
            <[
              unless ($(loadedBit.Read()))
              {
                $(backingFieldName : usesite) = { ..$statements };
                $(loadedBit.Set());
              }
              $(backingFieldName : usesite)
            ]>
          }
          else
          {
            <[
              when ($(backingFieldName : usesite) : object == null)
              {
                $(backingFieldName : usesite) = { ..$statements };
              }
              $(backingFieldName : usesite)
            ]>
          }
        }
        else
          <[ { ..$statements } ]>;

      _astTb.DefineConditional(<[decl:
        public new $(rule.FieldName : usesite) : $(propertyType : typed)
        {
          get { unchecked($propertyCode) }
        }
      ]>);
    }

    private GetSequenceValue(sequence : SequenceCompileInfo, name : string, needRuleParser : ref bool) : PExpr
    {
      def astPointer    = AstPointerScope(sequence, name, this);
      def statements    = SCG.List();
      def subruleValues = SCG.List();

      foreach (subrule in sequence.NonMarkerSubrules)
      {
        if (IsSubruleAcceptedForAst(subrule))
        {
          def varName = subrule.MakeVariableName("ast");
          statements.Add(<[ def $(varName : usesite) = $(GetSubruleValue(subrule, astPointer, ref needRuleParser)) ]>);
          subruleValues.Add(<[ $(varName : usesite) ]>);
        }
        else
          statements.Add(WalkerGenerator.Skip(subrule, astPointer));
      }

      match (subruleValues.Count)
      {
        | 0 => ()
        | 1 => statements.Add(subruleValues[0]);
        | _ => statements.Add(<[ (..$subruleValues)]>);
      }

      when (astPointer.IsAccessed())
        needRuleParser = true;

      astPointer.Compile(<[ { ..$statements } ]>)
    }

    private GetSubruleValue(subrule : SubruleCompileInfo, parentAstPointer : AstPointerScope, needRuleParser : ref bool) : PExpr
    {
      match (subrule)
      {
        | Empty      as subrule => WalkerGenerator.Skip(subrule, parentAstPointer)
        | SimpleCall as subrule =>
          if (subrule.Symbol.Type is RuleType.Void)
            WalkerGenerator.Skip(subrule, parentAstPointer)
          else if (subrule.CanParseEmptyString)
            <[
              pos += $(parentAstPointer.Access().GetSkip(subrule));
              $(Environment.GetAstType(subrule.Symbol) : typed).Create(ref pos, parseResult);
            ]>
          else
            <[
              pos += $(parentAstPointer.Access().GetSkip(subrule));
              if ($(parentAstPointer.Access().GetSize(subrule)) > 0)
                $(Environment.GetAstType(subrule.Symbol) : typed).Create(ref pos, parseResult);
              else
                $(Environment.GetAstType(subrule.Symbol) : typed).MissingAst(Nitra.Location(parseResult, pos, pos));
            ]>

        | ExtensibleCall as subrule =>
          if (subrule.Symbol.Type is RuleType.Void)
            WalkerGenerator.Skip(subrule, parentAstPointer)
          else
            <[
              pos += $(parentAstPointer.Access().GetSkip(subrule));
              if ($(parentAstPointer.Access().GetSize(subrule)) > 0)
                Nitra.Internal.ExtensibleRuleAstConstructor.[$(Environment.GetAstType(subrule.Symbol) : typed)].Create(ref pos, parseResult, $(subrule.BindingPower : int), $(subrule.Symbol.GetRuleDescriptorRef()));
              else
                $(Environment.GetAstType(subrule.Symbol) : typed).MissingAst(Nitra.Location(parseResult, pos, pos)); // No prefix
            ]>

        | RegularCall
        | List as lst when lst.IsSkipAnyPattern
        | TokenString => WalkerGenerator.GetTokenValue(subrule, parentAstPointer, <[ Nitra.NSpan(tokenPos, pos) ]>)
        | Option as subrule =>
          if (subrule.SrcRule.Type is RuleType.Void)
            WalkerGenerator.Skip(subrule, parentAstPointer)
          else
            WalkerGenerator.GetOptionValue(
              subrule          = subrule,
              parentAstPointer = parentAstPointer,
              hasValue         = <[ Some($(GetSequenceValue(subrule.Rule, "valuePointer", ref needRuleParser))) ]>,
              noValue          = <[ None() ]>)

        | List as lst =>
          if (subrule.SrcRule.Type is RuleType.Void)
            WalkerGenerator.Skip(subrule, parentAstPointer)
          else
            WalkerGenerator.GetListValue(
              subrule          = lst,
              parentAstPointer = parentAstPointer,
              init             = <[ def itemBuffer = System.Collections.Generic.List(16) ]>,
              item             = <[ itemBuffer.Add($(GetSequenceValue(lst.Rule, "itemPointer", ref needRuleParser))) ]>,
              returnCode       = <[ Nemerle.Collections.NList.ToList(itemBuffer) ]>,
              emptyCode        = <[ [] ]>);

        | ListWithSeparator as lst=>
          match (lst.Rule.SrcRule.Type, lst.Separator.SrcRule.Type)
          {
            | (Void, Void) => WalkerGenerator.Skip(subrule, parentAstPointer)
            | (_, Void) =>
                WalkerGenerator.GetListWithSeparatorValue(
                  subrule          = lst,
                  parentAstPointer = parentAstPointer,
                  init             = <[ def itemBuffer = System.Collections.Generic.List(16) ]>,
                  item             = <[ itemBuffer.Add($(GetSequenceValue(lst.Rule, "itemPointer", ref needRuleParser))) ]>,
                  separator        = <[ _ = $(GetSequenceValue(lst.Separator, "separatorPointer", ref needRuleParser)) ]>,
                  returnCode       = <[ Nemerle.Collections.NList.ToList(itemBuffer) ]>,
                  emptyCode        = <[ [] ]>);

            | (Void, _) =>
                WalkerGenerator.GetListWithSeparatorValue(
                  subrule          = lst,
                  parentAstPointer = parentAstPointer,
                  init             = <[ def separatorBuffer = System.Collections.Generic.List(16) ]>,
                  item             = <[ _ = $(GetSequenceValue(lst.Rule, "itemPointer", ref needRuleParser)) ]>,
                  separator        = <[ separatorBuffer.Add($(GetSequenceValue(lst.Separator, "separatorPointer", ref needRuleParser))) ]>,
                  returnCode       = <[ Nemerle.Collections.NList.ToList(separatorBuffer) ]>,
                  emptyCode        = <[ [] ]>);

            | _ =>
              WalkerGenerator.GetListWithSeparatorValue(
                subrule          = lst,
                parentAstPointer = parentAstPointer,
                init             = <[ def itemBuffer = System.Collections.Generic.List(16); def separatorBuffer = System.Collections.Generic.List(16); ]>,
                item             = <[ itemBuffer.Add($(GetSequenceValue(lst.Rule, "itemPointer", ref needRuleParser))) ]>,
                separator        = <[ separatorBuffer.Add($(GetSequenceValue(lst.Separator, "separatorPointer", ref needRuleParser))) ]>,
                returnCode       = <[ (Nemerle.Collections.NList.ToList(itemBuffer), Nemerle.Collections.NList.ToList(separatorBuffer)) ]>,
                emptyCode        = <[ ([], []) ]>);
          }

        | Marker => <[ () ]>
      }
    }

    public static IsSubruleAcceptedForAst(subrule : SubruleCompileInfo) : bool
    {
      | SubruleCompileInfo.SimpleCall(symbol)        when symbol.Type is RuleType.Void
      | SubruleCompileInfo.ExtensibleCall(symbol, _) when symbol.Type is RuleType.Void
      | SubruleCompileInfo.Empty
      | SubruleCompileInfo.Marker => false
      | _ => !(subrule.SrcRule.Type is RuleType.Void)
    }
  }
}
