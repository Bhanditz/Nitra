using Nemerle;
using Nemerle.Collections;
using Nemerle.Imperative;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Compiler.Typedtree;

using Nitra.Internal;
using Nitra.Model;
using Nitra.Typing;

using System;
using System.Diagnostics;
using System.Linq;
using SCG = System.Collections.Generic;

namespace Nitra.Compiler
{
  internal partial class RuleAstEmitter
  {
    public DefineMembers() : void
    {
      when (_baseTb != null)
      {
        DefineBaseAstCreateMethod();
        DefineBaseAstRuleMethods();
        DefineExtensibleAstReadMethod();
      }
      when (_astTb != null)
      {
        def fields = GetFields();
        DefineAstCtorAndFields(fields);
        DefineParsedAstCtorAndFields(fields);
        DefineChemicalAstCtorAndFields(fields);
        DefineAstWriteTo(fields);
        DefineAstReadMethod(fields);
        DefineAstPrettyPrint();
        DefineAstRuleMethods();
      }
      when (_missingTb != null)
      {
        DefineMissingWriteTo();
        DefineMissingPrettyPrint();
        DefineMissingRuleMethods();
      }
      when (_ambiguousTb != null)
      {
        DefineAmbiguousWriteTo();
        DefineAmbiguousPrettyPrint();
        DefineAmbiguousRuleMethods();
      }
    }

    private DefineBaseAstCreateMethod() : void
    {
      when (this.RuleSymbol is SimpleRuleSymbol)
      {
        _baseTb.DefineConditional(<[ decl:
          public static Create(pos : ref int, parseResult : Nitra.ParseResult) : $(_baseTb.GetMemType() : typed)
          {
            def ruleParser = parseResult.RuleParser.Grammar.GetSimpleRuleParser($(this.RuleSymbol.GetRuleDescriptorRef()));
            def astPtr = parseResult.TryGetAst(pos, ruleParser.RuleId);
            if (astPtr > 0)
              $(_baseTb.GetMemType() : typed).__Parsed__Ast(ref pos, astPtr, parseResult)
            else
              $(_baseTb.GetMemType() : typed).MissingAst(parseResult, pos)
          }
        ]>);
      }
      when (this.RuleSymbol.Options.IsStart)
      {
        match (this.RuleSymbol)
        {
          | SimpleRuleSymbol =>
            _baseTb.DefineConditional(<[ decl:
              public static Create(parseResult : Nitra.ParseResult) : $(_baseTb.GetMemType() : typed)
              {
                mutable pos = parseResult.StartPos;
                Create(ref pos, parseResult);
              }
            ]>);

          | ExtensibleRuleSymbol =>
            _baseTb.DefineConditional(<[ decl:
              public static Create(parseResult : Nitra.ParseResult) : $(_baseTb.GetMemType() : typed)
              {
                mutable pos = parseResult.StartPos;
                Nitra.Internal.ExtensibleRuleAstConstructor.Create(ref pos, parseResult, 0, $(this.RuleSymbol.GetRuleDescriptorRef()), Nitra.Internal.DefaultExtensibleRuleAstFactory.Instance);
              }
            ]>);

          | _ => assert2(false);
        }
      }
    }

    private DefineAstCtorAndFields(fields : SCG.List[FieldInfo]) : void
    {
      def traverse(ruleType : RuleType, obj : PExpr) : ChemicalRuleType * bool * PExpr
      {
        match (ruleType)
        {
          | Void         => assert3(false)
          | Ref(symbol)  => (ChemicalRuleType.Ast(symbol),    true,  obj)
          | Chars(Some)  => (ChemicalRuleType.StaticString(), false, <[ () ]>)
          | Chars(None)  => (ChemicalRuleType.String(),       false, <[ this.GetText($obj) ]>)
          | Option(type) =>
            def itemVariable = Util.tmpname("item");
            def (itemType, isUnchanged, itemExpr) = traverse(type, <[ $(itemVariable : usesite) ]>);
            if (isUnchanged)
              (ChemicalRuleType.Option(itemType), true, obj);
            else if (itemType is ChemicalRuleType.StaticString)
              (ChemicalRuleType.Bool(), false, <[ $obj.IsSome ]>)
            else
            {
              def expr =
              <[
                match ($obj)
                {
                  | Some($(itemVariable : usesite)) => Some($itemExpr)
                  | None                            => None()
                }
              ]>;
              (ChemicalRuleType.Option(itemType), false, expr)
            }

          | List(type) =>
            def itemVariable = Util.tmpname("item");
            def (itemType, isUnchanged, itemExpr) = traverse(type, <[ $(itemVariable : usesite) ]>);
            if (isUnchanged)
              (ChemicalRuleType.List(itemType), true, obj);
            else if (itemType is ChemicalRuleType.StaticString)
              (ChemicalRuleType.Int(), false, <[ $obj.Length ]>)
            else
            {
              def expr =
              <[
                def items = System.Collections.Generic.List();
                foreach ($(itemVariable : usesite) in $obj)
                  items.Add($itemExpr);
                Nemerle.Collections.NList.ToList(items);
              ]>;
              (ChemicalRuleType.List(itemType), false, expr)
            }

          | Tuple(types) =>
            def memberTypes  = SCG.List();
            def patterns     = SCG.List();
            def exprs        = SCG.List();
            mutable isAllUnchanged = true;

            foreach(t in types)
            {
              def memberVariable = Util.tmpname("member");
              def (memberType, isUnchanged, memberExpr) = traverse(t, <[ $(memberVariable : usesite) ]>);
              isAllUnchanged &= isUnchanged;
              if (memberType is ChemicalRuleType.StaticString)
                patterns.Add(<[ _ ]>)
              else
              {
                memberTypes.Add(memberType);
                patterns.Add(<[ $(memberVariable : usesite) ]>);
                exprs.Add(memberExpr);
              }
            }

            if (isAllUnchanged)
              (ChemicalRuleType.Tuple(memberTypes.NToList()), true, obj)
            else
              match (memberTypes.Count)
              {
                | 0 => (ChemicalRuleType.StaticString(),               false, <[ () ]>)
                | 1 => (memberTypes[0],                                false, <[ def (..$patterns) = $obj; $(exprs[0]) ]>)
                | _ => (ChemicalRuleType.Tuple(memberTypes.NToList()), false, <[ def (..$patterns) = $obj; (..$exprs) ]>)
              }
        }
      }

      foreach (field in fields)
      {
        _astTb.DefineConditional(<[ decl:
          public new abstract $(field.Name : usesite) : $(field.Type : typed)
          {
            get;
          }
        ]>);

        def (propertyType, isUnchanged, expr) = traverse(field.Rule.Type, <[ this.$(field.Name : usesite) ]>);
        unless (isUnchanged)
        unless (propertyType is ChemicalRuleType.StaticString)
        {
          _astTb.DefineConditional(<[ decl:
            public $(field.Name + "Data" : usesite) : $(Environment.GetAstType(propertyType) : typed)
            {
              get { unchecked ($expr) }
            }
          ]>);
        }
      }
    }

    private DefineParsedAstCtorAndFields(fields : SCG.List[FieldInfo]) : void
    {
      _parsedAstTb.DefineConditional(<[ decl: private parseResult : Nitra.ParseResult; ]>);
      _parsedAstTb.DefineConditional(<[ decl: private startPos    : int; ]>);
      _parsedAstTb.DefineConditional(<[ decl: private endPos      : int; ]>);
      _parsedAstTb.DefineConditional(<[ decl: private astPtr      : int; ]>);

      _parsedAstTb.DefineConditional(<[ decl:
        public override Location : Nitra.Location
        {
          get { Nitra.Location(this.parseResult.OriginalSource, this.startPos, this.endPos) }
        }
      ]>);

      _parsedAstTb.DefineConditional(<[ decl:
        protected override PrettyPrintSource : Nitra.IPrettyPrintSource
        {
          get { this.parseResult }
        }
      ]>);

      def astPtr = AstPointer.Existing(this.RuleSymbol.Sequence, this, "astPtr");

      def endPosExpr = this.RuleSymbol.Sequence.NonMarkerSubrules.Fold(<[ pos ]>, (subrule, acc) => <[ $acc + $(astPtr.GetSize(subrule)) ]>);

      match (this.RuleSymbol)
      {
        | SimpleRuleSymbol
        | ExtensionRuleSymbol(ExtensionType = Prefix) =>
          _parsedAstTb.DefineConditional(<[decl:
            public this(pos : ref int, astPtr : int, parseResult : Nitra.ParseResult)
            {
              unchecked
              {
                this.parseResult = parseResult;
                this.startPos    = pos;
                this.endPos      = $endPosExpr;
                this.astPtr      = astPtr;
                pos              = this.endPos;
              }
            }
          ]>);

        | ExtensionRuleSymbol(ExtensionType = Postfix) as symbol =>
          _parsedAstTb.DefineConditional(<[ decl: private astStartPos : int; ]>);
          _parsedAstTb.DefineConditional(<[ decl: private prefix      : $(Environment.GetAstType(symbol.BaseRule.Value) : typed); ]>);
          _parsedAstTb.DefineConditional(<[ decl:
            public this(prefix : $(Environment.GetAstType(symbol.BaseRule.Value) : typed), prefixStartPos : int, pos : ref int, astPtr : int, parseResult : Nitra.ParseResult)
            {
              unchecked
              {
                this.parseResult = parseResult;
                this.startPos    = prefixStartPos;
                this.endPos      = $endPosExpr;
                this.astPtr      = astPtr;
                this.astStartPos = pos;
                this.prefix      = prefix;
                pos              = this.endPos;
              }
            }
          ]>);

        | _ => assert(false)
      }

      foreach (field in fields)
      {
        def statements = SCG.List();

        mutable needRuleParser  : bool;
        mutable needCaching     : bool;

        def analyze(_ : FieldExpr) : void
        {
          | Prefix         => ()
          | Tuple(items)   => foreach (expr in items) analyze(expr);
          | Chars(_, true) => needRuleParser = true;
          | Chars          => ()
          | Other(_, true) => needRuleParser = true; needCaching = true;
          | Other          =>                        needCaching = true;
        }

        analyze(field.Expr);

        when (needRuleParser)
          statements.Add(<[ def ruleParser = parseResult.GetRuleParser(astPtr) :> $(this.RuleSymbol.GetParserClassRef()) ]>);

        def compile(_ : FieldExpr) : PExpr
        {
          | Prefix(expr)
          | Chars(expr, _)
          | Other(expr, _) => expr
          | Tuple(items)   => <[ (..$(items.Map(compile))) ]>
        }

        statements.Add(compile(field.Expr));

        def code =
          if (needCaching)
          {
            def backingFieldName = Util.tmpname(field.Name);
            _parsedAstTb.DefineConditional(<[ decl: private mutable $(backingFieldName : usesite) : $(field.Type : typed); ]>);
            if (field.Type.IsValueType)
            {
              def loadedBit = _parsedAstTb.GetBitFieldManager().Allocate();
              <[
                unless ($(loadedBit.Read()))
                {
                  $(backingFieldName : usesite) = { ..$statements };
                  $(loadedBit.Set());
                }
                $(backingFieldName : usesite)
              ]>
            }
            else
            {
              <[
                when ($(backingFieldName : usesite) : object == null)
                {
                  $(backingFieldName : usesite) = { ..$statements };
                }
                $(backingFieldName : usesite)
              ]>
            }
          }
          else
            <[ { ..$statements } ]>;

        _parsedAstTb.DefineConditional(<[ decl:
          public override $(field.Name : usesite) : $(field.Type : typed)
          {
            get { unchecked ($code) }
          }
        ]>);
      }
    }

    private DefineChemicalAstCtorAndFields(fields : SCG.List[FieldInfo]) : void
    {
      def traverse(ruleType : RuleType, obj : PExpr) : ChemicalRuleType * bool * PExpr
      {
        match (ruleType)
        {
          | Void                 => assert3(false)
          | Ref(symbol)          => (ChemicalRuleType.Ast(symbol),    true,  obj)
          | Chars(Some(keyword)) => (ChemicalRuleType.StaticString(), false, <[ context.GetKeywordSpan($(keyword : string)) ]>)
          | Chars(None)          => (ChemicalRuleType.String(),       false, <[ context.GetSpan($obj) ]>)
          | Option(type) =>
            def itemVariable = Util.tmpname("item");
            def (itemType, isUnchanged, itemExpr) = traverse(type, <[ $(itemVariable : usesite) ]>);
            if (isUnchanged)
              (ChemicalRuleType.Option(itemType), true, obj);
            else if (itemType is ChemicalRuleType.StaticString)
              (ChemicalRuleType.Bool(), false, <[ if ($obj) Some($itemExpr) else None() ]>)
            else
            {
              def expr =
              <[
                match ($obj)
                {
                  | Some($(itemVariable : usesite)) => Some($itemExpr)
                  | None                            => None()
                }
              ]>;
              (ChemicalRuleType.Option(itemType), false, expr)
            }

          | List(type) =>
            def itemVariable = Util.tmpname("item");
            def (itemType, isUnchanged, itemExpr) = traverse(type, <[ $(itemVariable : usesite) ]>);
            if (isUnchanged)
              (ChemicalRuleType.List(itemType), true, obj);
            else if (itemType is ChemicalRuleType.StaticString)
            {
              def expr =
              <[
                def items = array($obj);
                for (mutable i = 0; i < items.Length; ++i)
                  items[i] = $itemExpr;
                Nemerle.Collections.NList.ToList(items);
              ]>;
              (ChemicalRuleType.Int(), false, expr)
            }
            else
            {
              def expr =
              <[
                def items = System.Collections.Generic.List();
                foreach ($(itemVariable : usesite) in $obj)
                  items.Add($itemExpr);
                Nemerle.Collections.NList.ToList(items);
              ]>;
              (ChemicalRuleType.List(itemType), false, expr)
            }

          | Tuple(types) =>
            def memberTypes        = SCG.List();
            def patternVariables   = SCG.List();
            def exprs              = SCG.List();
            mutable isAllUnchanged = true;

            foreach(t in types)
            {
              def memberVariable = Util.tmpname("member");
              def (memberType, isUnchanged, memberExpr) = traverse(t, <[ $(memberVariable : usesite) ]>);
              isAllUnchanged &= isUnchanged;
              unless (memberType is ChemicalRuleType.StaticString)
              {
                memberTypes.Add(memberType);
                patternVariables.Add(memberVariable);
              }
              exprs.Add(memberExpr);
            }

            if (isAllUnchanged)
              (ChemicalRuleType.Tuple(memberTypes.NToList()), true, obj)
            else
              match (memberTypes.Count)
              {
                | 0 => (ChemicalRuleType.StaticString(),               false, <[ (..$exprs) ]>)
                | 1 => (memberTypes[0],                                false, <[ def $(patternVariables[0] : usesite) = $obj; (..$exprs) ]>)
                | _ => (ChemicalRuleType.Tuple(memberTypes.NToList()), false, <[ def (..$(patternVariables.MapToList(name => <[ $(name : usesite) ]>))) = $obj; (..$exprs) ]>)
              }
        }
      }

      _chemicalAstTb.DefineConditional(<[ decl:
        private context : Nitra.Runtime.ChemicalAstContext;
      ]>);
      _chemicalAstTb.DefineConditional(<[ decl:
        public override Location : Nitra.Location
        {
          get { Nitra.Location(context.GetSource(), 0, 0) }
        }
      ]>);

      def parameters = SCG.List();
      parameters.Add(<[ parameter: context : Nitra.Runtime.ChemicalAstContext ]>);

      def statements = SCG.List();
      statements.Add(<[ this.context = context; ]>);

      foreach (field in fields)
      {
        _chemicalAstTb.DefineConditional(<[ decl:
          public override $(field.Name : usesite) : $(field.Type : typed) { get; }
        ]>);

        def (parameterType, _, expr) = traverse(field.Rule.Type, <[ $(field.Name : usesite) ]>);
        unless (parameterType is ChemicalRuleType.StaticString)
          parameters.Add(<[ parameter: $(field.Name : usesite) : $(Environment.GetAstType(parameterType) : typed) ]>);
        statements.Add(<[ this.$(field.Name : usesite) = $expr ]>);
      }

      _chemicalAstTb.DefineConditional(<[ decl:
        public this(..$parameters) { unchecked { ..$statements } }
      ]>);

      match (this.RuleSymbol)
      {
        | SimpleRuleSymbol    with tb = _baseTb
        | ExtensionRuleSymbol with tb = _astTb =>
          tb.DefineConditional(<[ decl:
            public static Create(..$parameters) : $(_astTb.GetMemType() : typed)
            {
              $(_chemicalAstTb.GetMemType() : typed)(..$(parameters.Map(_.ReferencingExpr)));
            }
          ]>);

        | _ => assert3(false)
      }
    }

    private DefineAstReadMethod(fields : SCG.List[FieldInfo]) : void
    {
      def makeReadCode(ruleType : RuleType) : bool * PExpr
      {
        match (ruleType)
        {
          | Void             => assert(false)
          | Chars(Some(_))   => (true, <[ () ]>)
          | Chars(None)      => (false, <[ astReader.ReadText() ]>)
          | Ref(symbol)      => (false, <[ $(Environment.GetAstType(symbol) : typed).Read(astReader) ]>)
          | Option(itemType) =>
            def (isOptimized, itemExpr) = makeReadCode(itemType);
            def code = 
              if (isOptimized)
                <[ astReader.ReadOptionHeader() ]>
              else
              <[
                if (astReader.ReadOptionHeader())
                  Some($itemExpr)
                else
                  None()
              ]>;
            (false, code)

          | List(itemType) =>
            def (isOptimized, itemExpr) = makeReadCode(itemType);
            def code =
              if (isOptimized)
                <[ astReader.ReadListHeader() ]>
              else
              <[
                def buffer = array(astReader.ReadListHeader());
                for (mutable i = 0; i < buffer.Length; ++i)
                  buffer[i] = $itemExpr;
                Nemerle.Collections.NList.ToList(buffer)
              ]>;
            (false, code)

          | Tuple(memberTypes) =>
            def memberExprs = SCG.List();
            foreach (memberType in memberTypes)
            {
              def (isOptimized, memberExpr) = makeReadCode(memberType);
              unless (isOptimized)
                memberExprs.Add(memberExpr);
            }
            match (memberExprs.Count)
            {
              | 0 => (true, <[ () ]>)
              | 1 => (false, memberExprs[0])
              | _ => (false, <[ (..$memberExprs) ]>)
            }
        }
      }

      def createArguments = SCG.List();
      createArguments.Add(<[ astReader.Context ]>);

      foreach (field in fields)
      {
        def (isOptimized, expr) = makeReadCode(field.Rule.Type);
        unless (isOptimized)
          createArguments.Add(expr);
      }

      match (this.RuleSymbol)
      {
        | SimpleRuleSymbol =>
          _baseTb.DefineConditional(<[ decl:
            public static Read(astReader : Nitra.Serialization.IAstReader) : $(_baseTb.GetMemType() : typed)
            {
              match (astReader.ReadAstHeader())
              {
                | Ast          => Create(..$createArguments)
                | MissingAst   => $(_missingTb.GetMemType() : typed)(astReader.Context, 0)
                | AmbiguousAst => assert(false)
              }
            }
          ]>);

        | ExtensionRuleSymbol =>
          _astTb.DefineConditional(<[ decl:
            public static new Read(astReader : Nitra.Serialization.IAstReader) : $(_astTb.GetMemType() : typed)
            {
              Create(..$createArguments)
            }
          ]>);

        | _ => assert3(false)
      }
    }

    private DefineExtensibleAstReadMethod() : void
    {
      when (this.RuleSymbol is ExtensibleRuleSymbol)
      {
        _baseTb.DefineConditional(<[ decl:
          public static Read(astReader : Nitra.Serialization.IAstReader) : $(_baseTb.GetMemType() : typed)
          {
            match (astReader.ReadAstHeader())
            {
              | Ast          => astReader.ReadExtension()
              | MissingAst   => $(_missingTb.GetMemType() : typed)(astReader.Context, 0)
              | AmbiguousAst => $(_ambiguousTb.GetMemType() : typed)(astReader.Context, 0, 0, Nitra.Serialization.IAstReaderExtensions.ReadAmbiguities(astReader))
            }
          }
        ]>);
      }
    }
  }
}
