using Nemerle;
using Nemerle.Collections;
using Nemerle.Imperative;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Compiler.Typedtree;

using Nitra.Internal;
using Nitra.Model;
using Nitra.Typing;

using System;
using System.Diagnostics;
using System.Linq;
using SCG = System.Collections.Generic;

namespace Nitra.Compiler
{
  internal partial class RuleAstEmitter
  {
    public DefineMembers() : void
    {
      when (_baseTb != null)
      {
        DefineBaseAstCreateMethod();
        DefineBaseAstRuleMethods();
      }
      when (_astTb != null)
      {
        DefineAstCtorAndFields();
        DefineAstPrettyPrint();
        DefineAstRuleMethods();
      }
      when (_spliceTb != null)
      {
        DefineSpliceRuleMethods();
      }
      when (_missingTb != null)
      {
        DefineMissingPrettyPrint();
        DefineMissingRuleMethods();
      }
      when (_ambiguousTb != null)
      {
        DefineAmbiguousPrettyPrint();
        DefineAmbiguousRuleMethods();
      }
    }

    private DefineBaseAstCreateMethod() : void
    {
      when (this.RuleSymbol is SimpleRuleSymbol)
      {
        _baseTb.DefineConditional(<[ decl:
          public static Create(pos : ref int, parseResult : Nitra.Internal.ParseResult) : $(_baseTb.GetMemType() : typed)
          {
            def ruleParser = parseResult.RuleParser.Grammar.GetSimpleRuleParser($(this.RuleSymbol.GetRuleDescriptorRef()));
            def astPtr = parseResult.TryGetAst(pos, ruleParser.RuleId);
            if (astPtr > 0)
              $(_baseTb.GetMemType() : typed).Ast(astPtr, ref pos, parseResult)
            else
              $(_baseTb.GetMemType() : typed).MissingAst(Nitra.Location(parseResult, pos, pos))
          }
        ]>);
      }
    }

    private DefineAstCtorAndFields() : void
    {
      def sequence = this.RuleSymbol.Sequence;
      def astPtr = AstPointer.Existing(sequence, this, "astPtr");
      def endPos = SumSubruleSize(astPtr, sequence.NonMarkerSubrules, <[ pos ]>);

      _astTb.DefineConditional(<[decl:
        public this(astPtr : int, pos : ref int, parseResult : Nitra.Internal.ParseResult)
        {
          unchecked
          {
            def endPos = $endPos;
            base(Nitra.Location(parseResult, pos, endPos));
            pos = endPos;
            this.astPtr = astPtr;
          }
        }
      ]>);

      _astTb.DefineConditional(<[ decl: private astPtr : int; ]>);

      _astTb.DefineConditional(<[ decl:
        private parseResult : Nitra.Internal.ParseResult { get { this.Location.Source :> Nitra.Internal.ParseResult } }
      ]>);

      def ruleExprs = SCG.Dictionary.[Rule, PExpr]();

      when (this.RuleSymbol is ExtensionRuleSymbol(ExtensionType = Postfix(call, _)))
        ruleExprs.Add(call, <[ Fake() ]>);

      def prevSubrules = SCG.List();
      foreach (subrule in this.RuleSymbol.Sequence.NonMarkerSubrules)
      {
        when (IsSubruleAcceptedForAst(subrule))
          ruleExprs.Add(subrule.SrcRule, MakeSubruleExpr(astPtr, subrule, prevSubrules));
        prevSubrules.Add(subrule);
      }

      def makeFieldExpr(rule : Rule) : PExpr
      {
        if (rule is Rule.Sequence(Rules = rules, Type = RuleType.Tuple))
        {
          def members = SCG.List();
          foreach (rule when !(rule.Type is RuleType.Void) in rules)
            members.Add(makeFieldExpr(rule));

          if(members.Count == 1)
            members[0]
          else
            <[ (..$members) ]>
        }
        else
        {
          mutable expr;
          unless (ruleExprs.TryGetValue(rule, out expr))
            assert3(false);
          expr
        }
      }

      foreach (rule in this.RuleSymbol.NonVoidSubRules)
      {
        def propertyType = Environment.GetAstType(rule.Type);
        def body         = makeFieldExpr(rule);
        def memoizedBody = MemoizeFieldExpr(rule, propertyType, body);
        _astTb.DefineConditional(<[decl:
          public new $(rule.FieldName : usesite) : $(propertyType : typed)
          {
            get { unchecked { $memoizedBody } }
          }
        ]>);
      }

      _astTb.DefineConditional(<[ decl: private static Fake[T]() : T { throw System.NotImplementedException() } ]>);
    }

    private static SumSubruleSize(astPtr : AstPointer, subrules : SCG.IEnumerable[SubruleCompileInfo], init : PExpr) : PExpr
    {
      def buffer = SCG.List();
      buffer.Add(<[ mutable acc = $init; ]>);
      foreach (subrule in subrules)
        buffer.Add(<[ acc += $(astPtr.GetSize(subrule)) ]>);
      buffer.Add(<[ acc ]>);
      <[ { ..$buffer } ]>
    }

    private MemoizeFieldExpr(rule : Rule, fieldType : FixedType, body : PExpr) : PExpr
    {
      if (Environment.NSpanTypeVar.Equals(fieldType))
        body
      else
      {
        def backingFieldName = Util.tmpname(rule.FieldName);
        _astTb.DefineConditional(<[ decl: private mutable $(backingFieldName : usesite) : $(fieldType : typed); ]>);
        if (fieldType.IsValueType)
        {
          def loadedBit = _astTb.GetBitFieldManager().Allocate();
          <[
            unless ($(loadedBit.Read()))
            {
              $(backingFieldName : usesite) = $body;
              $(loadedBit.Set());
            }
            $(backingFieldName : usesite)
          ]>
        }
        else
        {
          <[
            when ($(backingFieldName : usesite) : object == null)
            {
              $(backingFieldName : usesite) = $body;
            }
            $(backingFieldName : usesite)
          ]>
        }
      }
    }

    private MakeSubruleExpr(astPtr : AstPointer, subrule : SubruleCompileInfo, prevSubrules : SCG.IEnumerable[SubruleCompileInfo]) : PExpr
    {
      match (subrule)
      {
        | RegularCall
        | List as lst when lst.IsSkipAnyPattern
        | TokenString =>
          def startPos = SumSubruleSize(astPtr, prevSubrules, <[ this.Location.StartPos ]>);
          <[
            mutable pos = $startPos;
            def (skip, size) = $(astPtr.GetSkipAndSize(subrule));
            pos += skip;
            Nitra.NSpan(pos, pos + size)
          ]>

        | SubruleCompileInfo.SimpleCall as subrule =>
          def startPos = SumSubruleSize(astPtr, prevSubrules, <[ this.Location.StartPos ]>);
          if (subrule.CanParseEmptyString)
            <[
              mutable pos = $startPos;
              pos += $(astPtr.GetSkip(subrule));
              $(Environment.GetAstType(subrule.Symbol) : typed).Create(ref pos, parseResult);
            ]>
          else
            <[
              mutable pos = $startPos;
              pos += $(astPtr.GetSkip(subrule));
              if ($(astPtr.GetSize(subrule)) > 0)
                $(Environment.GetAstType(subrule.Symbol) : typed).Create(ref pos, parseResult);
              else
                $(Environment.GetAstType(subrule.Symbol) : typed).MissingAst(Nitra.Location(parseResult, pos, pos));
            ]>

        | SubruleCompileInfo.ExtensibleCall as subrule =>
          def startPos = SumSubruleSize(astPtr, prevSubrules, <[ this.Location.StartPos ]>);
          <[
            mutable pos = $startPos;
            pos += $(astPtr.GetSkip(subrule));
            if ($(astPtr.GetSize(subrule)) > 0)
              Nitra.Internal.ExtensibleRuleAstConstructor.[$(Environment.GetAstType(subrule.Symbol) : typed)].Create(ref pos, parseResult, $(subrule.BindingPower : int), $(subrule.Symbol.GetRuleDescriptorRef()));
            else
              $(Environment.GetAstType(subrule.Symbol) : typed).MissingAst(Nitra.Location(parseResult, pos, pos)); // No prefix
          ]>

        | _ => <[ Fake() ]>
      }
    }

    public static IsSubruleAcceptedForAst(subrule : SubruleCompileInfo) : bool
    {
      | SubruleCompileInfo.SimpleCall(symbol)        when symbol.Type is RuleType.Void
      | SubruleCompileInfo.ExtensibleCall(symbol, _) when symbol.Type is RuleType.Void
      | SubruleCompileInfo.Empty
      | SubruleCompileInfo.Marker => false
      | _ => !(subrule.SrcRule.Type is RuleType.Void)
    }
  }
}
