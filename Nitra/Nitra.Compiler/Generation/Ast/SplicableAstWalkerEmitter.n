using Nitra.Model;
using Nitra.Typing;

using Nemerle;
using Nemerle.Collections;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using SCG = System.Collections.Generic;

namespace Nitra.Compiler
{
  public class SplicableAstWalkerEmitter : IConstantEmitter
  {
    public Environment  : EmitterEnvironment { get; }
    _syntaxModuleSymbol : SyntaxModuleSymbol;
    _tb                 : TypeBuilder;

    public this(environment : EmitterEnvironment, syntaxModuleSymbol : SyntaxModuleSymbol)
    {
      Environment         = environment;
      _syntaxModuleSymbol = syntaxModuleSymbol;
      _tb                 = Environment.NamespaceOfSymbol(syntaxModuleSymbol).Define(<[ decl:
        [System.ComponentModel.BrowsableAttribute(false),
         System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        public partial module $(_syntaxModuleSymbol.Name + "AstWalker" : usesite)
        {
        }
      ]>);
    }

    [Memoize]
    public CreateConstant(name : string, value : int) : string
    {
      Util.CreateConstant(_tb, name, value)
    }

    private static IsAcceptedForAst(subrule : SubruleCompileInfo) : bool
    {
      IsAcceptedForAst(subrule.SrcRule)
    }

    private static IsAcceptedForAst(rule : Rule) : bool
    {
      match (ChemicalRuleType.FromRuleType(rule.Type))
      {
        | Void | StaticString => false
        | _                   => true
      }
    }

    public DefineMembers() : void
    {
      foreach (ruleSymbol in _syntaxModuleSymbol.Node.GetDescendants.[SyntaxRuleSymbol]())
      {
        | SimpleRuleSymbol when ruleSymbol.Type is RuleType.Ref =>
          def statements = CompileRule(ruleSymbol);
          _tb.DefineConditional(<[ decl:
            public $(MakeRuleWalkMethodName(ruleSymbol) : usesite)[TAst](pos : ref int, parseResult : Nitra.ParseResult, builder : Nitra.Internal.ISplicableAstBuilder[TAst]) : TAst
            {
              unchecked
              {
                def startPos   = pos;
                _ = startPos;
                def ruleParser = parseResult.RuleParser.Grammar.GetSimpleRuleParser($(ruleSymbol.GetRuleDescriptorRef())) :> $(ruleSymbol.GetParserClassRef());
                _ = ruleParser;
                def astPtr     = parseResult.TryGetAst(pos, ruleParser.RuleId);
                if (astPtr > 0)
                {
                  ..$statements
                }
                else
                  builder.CreateMissing(parseResult, $(ruleSymbol.GetRuleDescriptorRef()), startPos)
              }
            }
          ]>)

        | ExtensionRuleSymbol(ExtensionType = Prefix) =>
          def statements = CompileRule(ruleSymbol);
          _tb.DefineConditional(<[ decl:
            public $(MakeRuleWalkMethodName(ruleSymbol) : usesite)[TAst](pos : ref int, astPtr : int, ruleParser : Nitra.Internal.ExtensionRuleParser, parseResult : ParseResult, builder : Nitra.Internal.ISplicableAstBuilder[TAst]) : TAst
            {
              unchecked
              {
                def startPos   = pos;
                _ = startPos;
                def ruleParser = ruleParser :> $(ruleSymbol.GetParserClassRef());
                _ = ruleParser;
                ..$statements;
              }
            }
          ]>)

        | ExtensionRuleSymbol(ExtensionType = Postfix) =>
          def statements = CompileRule(ruleSymbol);
          _tb.DefineConditional(<[ decl:
            public $(MakeRuleWalkMethodName(ruleSymbol) : usesite)[TAst](prefix : TAst, prefixStartPos : int, pos : ref int, astPtr : int, ruleParser : Nitra.Internal.ExtensionRuleParser, parseResult : ParseResult, builder : Nitra.Internal.ISplicableAstBuilder[TAst]) : TAst
            {
              unchecked
              {
                def startPos   = prefixStartPos;
                _ = startPos;
                def ruleParser = ruleParser :> $(ruleSymbol.GetParserClassRef());
                _ = ruleParser;
                ..$statements;
              }
            }
          ]>)

        | _ => ()
      }
    }

    public Emit() : void
    {
      _tb.Compile();
    }

    private CompileRule(ruleSymbol : SyntaxRuleSymbol) : SCG.List[PExpr]
    {
      def variableNames = SCG.Dictionary();

      when (ruleSymbol is ExtensionRuleSymbol(ExtensionType = Postfix(call, _)))
        variableNames.Add(call, "prefix");

      def astPtr = AstPointer.Existing(ruleSymbol.Sequence, this, "astPtr");

      def statements = SCG.List();
      foreach (subrule in ruleSymbol.Sequence.NonMarkerSubrules)
      {
        def parentAstPointer = AstPointerScope(astPtr);
        if (IsAcceptedForAst(subrule))
        {
          def varName = subrule.MakeVariableName("ast");
          statements.Add(<[ def $(varName : usesite) = $(GetSubruleValue(subrule, parentAstPointer)) ]>);
          variableNames.Add(subrule.SrcRule, varName);
        }
        else
          statements.Add(WalkerGenerator.Skip(subrule, parentAstPointer));
      }

      def foldVariables(rule : Rule) : PExpr
      {
        if (rule is Rule.Sequence(Rules = rules))
        {
          def members = SCG.List();
          foreach (rule when IsAcceptedForAst(rule) in rules)
            members.Add(foldVariables(rule));

          match (members.Count)
          {
            | 0 => assert3(false)
            | 1 => members[0]
            | _ => <[ builder.Tuple(parseResult, 0, 0, ..$members) ]> //TODO: set correct location
          }
        }
        else
        {
          mutable variableName;
          unless (variableNames.TryGetValue(rule, out variableName))
            assert3(false);
          <[ $(variableName : usesite) ]>
        }
      }


      def resultStatement = match (ruleSymbol)
      {
        | ExtensionRuleSymbol(SplicableType = Splice(syntaxModule)) =>
          statements.Insert(0, <[ def spliceGrammarDescriptor = $(syntaxModule.GetGrammarDescriptorRef()) ]>);

          def values = SCG.List();
          foreach (rule when IsAcceptedForAst(rule) in ruleSymbol.SubRules)
            values.Add(foldVariables(rule));

          match (values.Count)
          {
            | 0 => assert(false, "Splice rule must produce one value")
            | 1 => values[0]
            | _ => assert(false, "Splice rule produces more that one value")
          }

        | ExtensionRuleSymbol(SplicableType = Quote) =>
          def values = SCG.List();
          foreach (rule when IsAcceptedForAst(rule) in ruleSymbol.SubRules)
            values.Add(foldVariables(rule));

          match (values.Count)
          {
            | 0 => assert(false, "Quote rule must produce at least one value")
            | 1 => values[0]
            | _ => <[ builder.Tuple(parseResult, startPos, pos, ..$values) ]>
          }

        | ExtensionRuleSymbol(SplicableType = Normal, SpliceSource = Some(spliceSourceSymbol))
        | SimpleRuleSymbol(SpliceSource = Some(spliceSourceSymbol)) =>
          def isTextProperty(ruleType : RuleType) : bool
          {
            | List(item)   => isTextProperty(item)
            | Option(item) => isTextProperty(item)
            | Tuple(items) => items.FoldLeft(false, (item, acc) => acc || isTextProperty(item))
            | Ref          => false
            | Chars(Some)  => false
            | Chars(None)  => true
            | Void         => assert(false)
          }

          def members = SCG.List();
          foreach (rule when IsAcceptedForAst(rule) in ruleSymbol.SubRules)
          {
            def name  = if (isTextProperty(rule.Type)) rule.FieldName + "Text" else rule.FieldName; // TODO: придумать более надежный способ получения имени свойства AST
            def value = foldVariables(rule);
            members.Add(<[ Nitra.Internal.SplicableAstMember($(name : string), $value) ]>);
          }

          <[ builder.SyntaxRule(parseResult, $(spliceSourceSymbol.GetRuleDescriptorRef()), startPos, pos, ..$members) ]>

        | _ => assert(false)
      };

      statements.Add(resultStatement);
      statements
    }

    private static IsSpliceTextRule(ruleSymbol : SyntaxRuleSymbol) : bool
    {
      ruleSymbol.Name == "Splice" && ruleSymbol.DeclaringModule.Name == "SpliceExpressions"
    }

    private GetSubruleValue(subrule : SubruleCompileInfo, parentAstPointer : AstPointerScope) : PExpr
    {
      match (subrule)
      {
        | Empty      as subrule => WalkerGenerator.Skip(subrule, parentAstPointer)
        | SimpleCall as subrule =>
          if (IsSpliceTextRule(subrule.Symbol))
            <[
              pos += $(parentAstPointer.Access().GetSkip(subrule));
              def spliceStartPos = pos;
              pos += $(parentAstPointer.Access().GetSize(subrule));
              builder.Splice(parseResult, spliceGrammarDescriptor, spliceStartPos, pos)
            ]>
          else if (subrule.Symbol.Type is RuleType.Void)
            WalkerGenerator.Skip(subrule, parentAstPointer)
          else if (subrule.CanParseEmptyString)
            <[
              pos += $(parentAstPointer.Access().GetSkip(subrule));
              $(GetRuleWalkMethodRef(subrule.Symbol))(ref pos, parseResult, builder)
            ]>
          else
            <[
              pos += $(parentAstPointer.Access().GetSkip(subrule));
              if ($(parentAstPointer.Access().GetSize(subrule)) > 0)
                $(GetRuleWalkMethodRef(subrule.Symbol))(ref pos, parseResult, builder)
              else
                builder.CreateMissing(parseResult, $(subrule.Symbol.GetRuleDescriptorRef()), pos);
            ]>

        | ExtensibleCall as subrule =>
          if (subrule.Symbol.Type is RuleType.Void)
            WalkerGenerator.Skip(subrule, parentAstPointer)
          else
            <[
              pos += $(parentAstPointer.Access().GetSkip(subrule));
              if ($(parentAstPointer.Access().GetSize(subrule)) > 0)
                Nitra.Internal.ExtensibleRuleAstConstructor.Create(ref pos, parseResult, $(subrule.BindingPower : int), $(subrule.Symbol.GetRuleDescriptorRef()), builder);
              else
                builder.CreateMissing(parseResult, $(subrule.Symbol.GetRuleDescriptorRef()), pos); // No prefix
            ]>

        | RegularCall as subrule                => WalkerGenerator.GetTokenValue(subrule, parentAstPointer, <[ builder.RegularRule(parseResult, $(subrule.Symbol.GetRuleDescriptorRef()), tokenPos, pos) ]>)
        | List as lst when lst.IsSkipAnyPattern => WalkerGenerator.GetTokenValue(subrule, parentAstPointer, <[ builder.SkipAny(parseResult, tokenPos, pos) ]>)
        | TokenString as subrule                => WalkerGenerator.Skip(subrule, parentAstPointer)
        | Option as subrule =>
          def expr = match (ChemicalRuleType.FromRuleType(subrule.SrcRule.Type))
          {
            | Option =>
              WalkerGenerator.GetOptionValue(
                subrule          = subrule,
                parentAstPointer = parentAstPointer,
                hasValue         = <[ builder.OptionSome(parseResult, optionPos, pos, $(GetSequenceValue(subrule.Rule, "valuePointer"))) ]>,
                noValue          = <[ builder.OptionNone(parseResult, optionPos, pos) ]>)

            | Bool =>
              WalkerGenerator.GetOptionValue(
                subrule          = subrule,
                parentAstPointer = parentAstPointer,
                hasValue         = <[ $(SkipSequence(subrule.Rule, "valuePointer")); builder.OptimizedOption(parseResult, optionPos, pos, true) ]>,
                noValue          = <[ builder.OptimizedOption(parseResult, optionPos, pos, false) ]>)

            | _ => WalkerGenerator.Skip(subrule, parentAstPointer)
          };
          <[ def optionPos = pos; $expr ]>

        | List as lst =>
          def expr = match (ChemicalRuleType.FromRuleType(subrule.SrcRule.Type))
          {
            | List =>
              WalkerGenerator.GetListValue(
                subrule          = lst,
                parentAstPointer = parentAstPointer,
                init             = <[ def itemBuffer = System.Collections.Generic.List(16) ]>,
                item             = <[ itemBuffer.Add($(GetSequenceValue(lst.Rule, "itemPointer"))) ]>,
                returnCode       = <[ builder.List(parseResult, listPos, pos, itemBuffer) ]>,
                emptyCode        = <[ builder.List(parseResult, pos, pos, null) ]>)

            | Int =>
              WalkerGenerator.GetListValue(
                subrule          = lst,
                parentAstPointer = parentAstPointer,
                init             = <[ mutable itemCount; ]>,
                item             = <[ $(SkipSequence(lst.Rule, "itemPointer")); itemCount += 1 ]>,
                returnCode       = <[ builder.OptimizedList(parseResult, listPos, pos, itemCount) ]>,
                emptyCode        = <[ builder.OptimizedList(parseResult, pos, pos, 0) ]>)

            | _ => WalkerGenerator.Skip(subrule, parentAstPointer)
          };
          <[ def listPos = pos; $expr ]>

        | ListWithSeparator as lst =>
          def (itemIsVoid, itemInit, itemBody, itemReturn, itemEmpty) =
            match (ChemicalRuleType.FromRuleType(lst.Rule.SrcRule.Type))
            {
              | Void         => (true, <[ () ]>, <[ () ]>, <[ () ]>, <[ () ]>)
              | StaticString =>
                (
                  false,
                  <[ def itemListPos = pos; mutable itemCount; ]>,
                  <[ $(SkipSequence(lst.Separator, "itemPointer")); itemCount += 1 ]>,
                  <[ builder.OptimizedList(parseResult, itemListPos, pos, itemCount) ]>,
                  <[ builder.OptimizedList(parseResult, pos, pos, 0) ]>
                )

              | _ =>
                (
                  false,
                  <[ def itemListPos = pos; def itemBuffer = System.Collections.Generic.List(16); ]>,
                  <[ itemBuffer.Add($(GetSequenceValue(lst.Rule, "itemPointer"))) ]>,
                  <[ builder.List(parseResult, itemListPos, pos, itemBuffer) ]>,
                  <[ builder.List(parseResult, pos, pos, null) ]>
                )
            };

          def (separatorIsVoid, separatorInit, separatorBody, separatorReturn, separatorEmpty) =
            match (ChemicalRuleType.FromRuleType(lst.Separator.SrcRule.Type))
            {
              | Void         => (true, <[ () ]>, <[ () ]>, <[ () ]>, <[ () ]>)
              | StaticString =>
                (
                  false,
                  <[ def separatorListPos = pos; mutable separatorCount ]>,
                  <[ $(SkipSequence(lst.Separator, "separatorPointer")); separatorCount += 1 ]>,
                  <[ builder.OptimizedList(parseResult, separatorListPos, pos, separatorCount) ]>,
                  <[ builder.OptimizedList(parseResult, pos, pos, 0) ]>
                )

              | _ =>
                (
                  false,
                  <[ def separatorListPos = pos; def separatorBuffer = System.Collections.Generic.List(16) ]>,
                  <[ separatorBuffer.Add($(GetSequenceValue(lst.Separator, "separatorPointer"))) ]>,
                  <[ builder.List(parseResult, separatorListPos, pos, separatorBuffer) ]>,
                  <[ builder.List(parseResult, pos, pos, null) ]>
                )
            };

          def expr = match (itemIsVoid, separatorIsVoid)
          {
            | (true,  true) => WalkerGenerator.Skip(subrule, parentAstPointer)
            | (false, true) =>
              WalkerGenerator.GetListWithSeparatorValue(
                subrule          = lst,
                parentAstPointer = parentAstPointer,
                init             = itemInit,
                item             = itemBody,
                separator        = SkipSequence(lst.Separator, "separatorPointer"),
                returnCode       = itemReturn,
                emptyCode        = itemEmpty);

            | (true, false) =>
              WalkerGenerator.GetListWithSeparatorValue(
                subrule          = lst,
                parentAstPointer = parentAstPointer,
                init             = separatorInit,
                item             = separatorBody,
                separator        = SkipSequence(lst.Rule, "itemPointer"),
                returnCode       = separatorReturn,
                emptyCode        = separatorEmpty);

            | (false, false) =>
              WalkerGenerator.GetListWithSeparatorValue(
                subrule          = lst,
                parentAstPointer = parentAstPointer,
                init             = <[ $itemInit; $separatorInit; ]>,
                item             = itemBody,
                separator        = separatorBody,
                returnCode       = <[ builder.Tuple(parseResult, listPos, pos, $itemReturn, $separatorReturn) ]>,
                emptyCode        = <[ builder.Tuple(parseResult, listPos, pos, $itemEmpty, $separatorEmpty) ]>);
          };
          <[ def listPos = pos; $expr ]>

        | Marker => <[ () ]>
      }
    }

    private SkipSequence(sequence : SequenceCompileInfo, name : string) : PExpr
    {
      def astPointer    = AstPointerScope(sequence, name, this);
      def statements    = SCG.List();

      foreach (subrule in sequence.NonMarkerSubrules)
        statements.Add(WalkerGenerator.Skip(subrule, astPointer));

      astPointer.Compile(<[ { ..$statements } ]>)
    }

    private GetSequenceValue(sequence : SequenceCompileInfo, name : string) : PExpr
    {
      def astPointer    = AstPointerScope(sequence, name, this);
      def statements    = SCG.List();
      def subruleValues = SCG.List();

      foreach (subrule in sequence.NonMarkerSubrules)
      {
        if (IsAcceptedForAst(subrule))
        {
          def varName = subrule.MakeVariableName("ast");
          statements.Add(<[ def $(varName : usesite) = $(GetSubruleValue(subrule, astPointer)) ]>);
          subruleValues.Add(<[ $(varName : usesite) ]>);
        }
        else
          statements.Add(WalkerGenerator.Skip(subrule, astPointer));
      }

      match (subruleValues.Count)
      {
        | 0 => ()
        | 1 => statements.Add(subruleValues[0]);
        | _ =>
          statements.Insert(0, <[ def seqPos = pos ]>);
          statements.Add(<[ builder.Tuple(parseResult, seqPos, pos, ..$subruleValues)]>);
      }

      astPointer.Compile(<[ { ..$statements } ]>)
    }

    private static MakeRuleWalkMethodName(ruleSymbol : SyntaxRuleSymbol) : string
    {
      $<#..$(ruleSymbol.ModuleRelativeName; "_")#>
    }

    private static GetRuleWalkMethodRef(ruleSymbol : SyntaxRuleSymbol) : PExpr
    {
      def syntaxModule = ruleSymbol.DeclaringModule;
      def fullName     = syntaxModule.Node.Parent.FullNameParts + [syntaxModule.Name + "AstWalker", MakeRuleWalkMethodName(ruleSymbol)];
      PExprUtils.FromQualifiedIdentifier(fullName);
    }
  }
}
