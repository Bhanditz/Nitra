using Nitra.Model;
using Nitra.Typing;

using Nemerle;
using Nemerle.Collections;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using SCG = System.Collections.Generic;

namespace Nitra.Compiler
{
  public class SplicableAstWalkerEmitter : IConstantEmitter
  {
    public Environment  : EmitterEnvironment { get; }
    _syntaxModuleSymbol : SyntaxModuleSymbol;
    _tb                 : TypeBuilder;

    public this(environment : EmitterEnvironment, syntaxModuleSymbol : SyntaxModuleSymbol)
    {
      Environment         = environment;
      _syntaxModuleSymbol = syntaxModuleSymbol;
      _tb                 = Environment
        .NamespaceOfSymbol(syntaxModuleSymbol)
        .Define(<[ decl: public partial module $(_syntaxModuleSymbol.Name + "AstWalker" : usesite) {} ]>);
    }

    [Memoize]
    public CreateConstant(name : string, value : int) : string
    {
      Util.CreateConstant(_tb, name, value)
    }

    public DefineMembers() : void
    {
      foreach (ruleSymbol when ruleSymbol.Type is RuleType.Ref in _syntaxModuleSymbol.Node.GetDescendants.[SyntaxRuleSymbol]())
      {
        def astPtr = AstPointer.Existing(ruleSymbol.Sequence, this, "astPtr");

        def subruleValues = SCG.List();
        when (ruleSymbol is ExtensionRuleSymbol(ExtensionType = Postfix))
          subruleValues.Add(<[ prefix ]>);

        def statements    = SCG.List();
        foreach (subrule in ruleSymbol.Sequence.NonMarkerSubrules)
        {
          def parentAstPointer = AstPointerScope(astPtr);
          if (RuleAstEmitter.IsSubruleAcceptedForAst(subrule))
          {
            def varName = subrule.MakeVariableName("ast");
            statements.Add(<[ def $(varName : usesite) = $(GetSubruleValue(subrule, parentAstPointer)) ]>);
            subruleValues.Add(<[ $(varName : usesite) ]>);
          }
          else
            statements.Add(WalkerGenerator.Skip(subrule, parentAstPointer));
        }
        statements.Add(<[ builder.Syntax($(ruleSymbol.GetRuleDescriptorRef()), startPos, pos, array[..$subruleValues]) ]>);

        match (ruleSymbol)
        {
          | SimpleRuleSymbol =>
            _tb.DefineConditional(<[ decl:
              public $(MakeRuleWalkMethodName(ruleSymbol) : usesite)[TAst](pos : ref int, parseResult : Nitra.ParseResult, builder : Nitra.ISplicableAstBuilder[TAst]) : TAst
              {
                def startPos   = pos;
                def ruleParser = parseResult.RuleParser.Grammar.GetSimpleRuleParser($(ruleSymbol.GetRuleDescriptorRef()));
                def astPtr     = parseResult.TryGetAst(pos, ruleParser.RuleId);
                if (astPtr > 0)
                {
                  ..$statements
                }
                else
                  builder.Missing(startPos)
              }
            ]>)

          | ExtensionRuleSymbol(ExtensionType = Prefix) =>
            _tb.DefineConditional(<[ decl:
              public $(MakeRuleWalkMethodName(ruleSymbol) : usesite)[TAst](pos : ref int, astPtr : int, ruleParser : Nitra.Internal.ExtensionRuleParser, parseResult : ParseResult, builder : Nitra.ISplicableAstBuilder[TAst]) : TAst
              {
                def startPos = pos;
                ..$statements;
              }
            ]>)

          | ExtensionRuleSymbol(ExtensionType = Postfix) =>
            _tb.DefineConditional(<[ decl:
              public $(MakeRuleWalkMethodName(ruleSymbol) : usesite)[TAst](prefix : T, prefixStartPos : int, pos : ref int, astPtr : int, ruleParser : ExtensionRuleParser, parseResult : ParseResult, builder : Nitra.ISplicableAstBuilder[TAst]) : TAst
              {
                def startPos = prefixStartPos;
                ..$statements;
              }
            ]>)

          | ExtensibleRuleSymbol => ()
          | _ => assert(false)
        }
      }
    }

    public Emit() : void
    {
      _tb.Compile();
    }

    private GetSubruleValue(subrule : SubruleCompileInfo, parentAstPointer : AstPointerScope) : PExpr
    {
      match (subrule)
      {
        | Empty      as subrule => WalkerGenerator.Skip(subrule, parentAstPointer)
        | SimpleCall as subrule =>
          if (subrule.Symbol.Type is RuleType.Void)
            WalkerGenerator.Skip(subrule, parentAstPointer)
          else if (subrule.CanParseEmptyString)
            <[
              pos += $(parentAstPointer.Access().GetSkip(subrule));
              $(GetRuleWalkMethodRef(subrule.Symbol))(builder, parseResult, ref pos)
            ]>
          else
            <[
              pos += $(parentAstPointer.Access().GetSkip(subrule));
              if ($(parentAstPointer.Access().GetSize(subrule)) > 0)
                $(GetRuleWalkMethodRef(subrule.Symbol))(builder, parseResult, ref pos)
              else
                builder.Missing($(subrule.Symbol.GetRuleDescriptorRef()), pos);
            ]>

        | ExtensibleCall as subrule =>
          if (subrule.Symbol.Type is RuleType.Void)
            WalkerGenerator.Skip(subrule, parentAstPointer)
          else
            <[
              pos += $(parentAstPointer.Access().GetSkip(subrule));
              if ($(parentAstPointer.Access().GetSize(subrule)) > 0)
                Nitra.Internal.ExtensibleRuleAstConstructor.Create(ref pos, parseResult, $(subrule.BindingPower : int), $(subrule.Symbol.GetRuleDescriptorRef()), builder);
              else
                builder.Missing($(subrule.Symbol.GetRuleDescriptorRef()), pos); // No prefix
            ]>

        | RegularCall as subrule                => WalkerGenerator.GetTokenValue(subrule, parentAstPointer, <[ builder.Regular($(subrule.Symbol.GetRuleDescriptorRef()), tokenPos, pos) ]>)
        | List as lst when lst.IsSkipAnyPattern => WalkerGenerator.GetTokenValue(subrule, parentAstPointer, <[ builder.SkipAny(tokenPos, pos) ]>)
        | TokenString as subrule                => WalkerGenerator.GetTokenValue(subrule, parentAstPointer, <[ builder.Text($(subrule.String : string), tokenPos, pos) ]>)
        | Option as subrule =>
          if (subrule.SrcRule.Type is RuleType.Void)
            WalkerGenerator.Skip(subrule, parentAstPointer)
          else
            WalkerGenerator.GetOptionValue(
              subrule          = subrule,
              parentAstPointer = parentAstPointer,
              hasValue         = <[ builder.Some($(GetSequenceValue(subrule.Rule, "valuePointer"))) ]>,
              noValue          = <[ builder.None(pos) ]>)

        | List as lst =>
          if (subrule.SrcRule.Type is RuleType.Void)
            WalkerGenerator.Skip(subrule, parentAstPointer)
          else
            WalkerGenerator.GetListValue(
              subrule          = lst,
              parentAstPointer = parentAstPointer,
              init             = <[ def itemBuffer = System.Collections.Generic.List(16) ]>,
              item             = <[ itemBuffer.Add($(GetSequenceValue(lst.Rule, "itemPointer"))) ]>,
              returnCode       = <[ builder.List(itemBuffer) ]>,
              emptyCode        = <[ builder.EmptyList(pos) ]>);

        | ListWithSeparator as lst=>
          match (lst.Rule.SrcRule.Type, lst.Separator.SrcRule.Type)
          {
            | (Void, Void) => WalkerGenerator.Skip(subrule, parentAstPointer)
            | (_, Void) =>
                WalkerGenerator.GetListWithSeparatorValue(
                  subrule          = lst,
                  parentAstPointer = parentAstPointer,
                  init             = <[ def itemBuffer = System.Collections.Generic.List(16) ]>,
                  item             = <[ itemBuffer.Add($(GetSequenceValue(lst.Rule, "itemPointer"))) ]>,
                  separator        = <[ _ = $(GetSequenceValue(lst.Separator, "separatorPointer")) ]>,
                  returnCode       = <[ builder.List(itemBuffer) ]>,
                  emptyCode        = <[ builder.EmptyList(pos) ]>);

            | (Void, _) =>
                WalkerGenerator.GetListWithSeparatorValue(
                  subrule          = lst,
                  parentAstPointer = parentAstPointer,
                  init             = <[ def separatorBuffer = System.Collections.Generic.List(16) ]>,
                  item             = <[ _ = $(GetSequenceValue(lst.Rule, "itemPointer")) ]>,
                  separator        = <[ separatorBuffer.Add($(GetSequenceValue(lst.Separator, "separatorPointer"))) ]>,
                  returnCode       = <[ builder.List(separatorBuffer) ]>,
                  emptyCode        = <[ builder.EmptyList(pos) ]>);

            | _ =>
              WalkerGenerator.GetListWithSeparatorValue(
                subrule          = lst,
                parentAstPointer = parentAstPointer,
                init             = <[ def itemBuffer = System.Collections.Generic.List(16); def separatorBuffer = System.Collections.Generic.List(16); ]>,
                item             = <[ itemBuffer.Add($(GetSequenceValue(lst.Rule, "itemPointer"))) ]>,
                separator        = <[ separatorBuffer.Add($(GetSequenceValue(lst.Separator, "separatorPointer"))) ]>,
                returnCode       = <[ builder.Tuple(builder.List(itemBuffer), builder.List(separatorBuffer)) ]>,
                emptyCode        = <[ builder.Tuple(builder.EmptyList(pos), builder.EmptyList(pos)) ]>);
          }

        | Marker => <[ () ]>
      }
    }

    private GetSequenceValue(sequence : SequenceCompileInfo, name : string) : PExpr
    {
      def astPointer    = AstPointerScope(sequence, name, this);
      def statements    = SCG.List();
      def subruleValues = SCG.List();

      foreach (subrule in sequence.NonMarkerSubrules)
      {
        if (RuleAstEmitter.IsSubruleAcceptedForAst(subrule))
        {
          def varName = subrule.MakeVariableName("ast");
          statements.Add(<[ def $(varName : usesite) = $(GetSubruleValue(subrule, astPointer)) ]>);
          subruleValues.Add(<[ $(varName : usesite) ]>);
        }
        else
          statements.Add(WalkerGenerator.Skip(subrule, astPointer));
      }

      match (subruleValues.Count)
      {
        | 0 => ()
        | 1 => statements.Add(subruleValues[0]);
        | _ => statements.Add(<[ builder.Tuple(..$subruleValues)]>);
      }

      astPointer.Compile(<[ { ..$statements } ]>)
    }


    private static MakeRuleWalkMethodName(ruleSymbol : SyntaxRuleSymbol) : string
    {
      $<#..$(ruleSymbol.ModuleRelativeName; "_")#>
    }

    private static GetRuleWalkMethodRef(ruleSymbol : SyntaxRuleSymbol) : PExpr
    {
      def syntaxModule = ruleSymbol.DeclaringModule;
      def fullName     = syntaxModule.Node.Parent.FullNameParts + [syntaxModule.Name + "AstWalker", MakeRuleWalkMethodName(ruleSymbol)];
      PExprUtils.FromQualifiedIdentifier(fullName);
    }
  }
}
