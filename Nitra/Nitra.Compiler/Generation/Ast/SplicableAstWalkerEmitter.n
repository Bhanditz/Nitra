using Nitra.Model;
using Nitra.Typing;

using Nemerle;
using Nemerle.Collections;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using SCG = System.Collections.Generic;

namespace Nitra.Compiler
{
  public class SplicableAstWalkerEmitter
  {
    _environment        : EmitterEnvironment;
    _syntaxModuleSymbol : SyntaxModuleSymbol;
    _tb                 : TypeBuilder;

    public this(environment : EmitterEnvironment, syntaxModuleSymbol : SyntaxModuleSymbol)
    {
      _environment        = environment;
      _syntaxModuleSymbol = syntaxModuleSymbol;
      _tb                 = _environment
        .NamespaceOfSymbol(syntaxModuleSymbol)
        .Define(<[ decl: public partial module $(_syntaxModuleSymbol.Name + "AstWalker" : usesite) {} ]>);
    }

    public DefineMembers() : void
    {
      foreach (ruleSymbol when ruleSymbol.Type is RuleType.Ref in _syntaxModuleSymbol.Node.GetDescendants.[SyntaxRuleSymbol]())
      {
        def body = SCG.List();
        foreach (subrule when RuleAstEmitter.IsSubruleAcceptedForAst(subrule) in ruleSymbol.Sequence.NonMarkerSubrules)
        {
          
        }
        _tb.DefineConditional(<[ decl:
          public $(MakeRuleWalkMethodName(ruleSymbol) : usesite)() : void
          {
            ..$body
          }
        ]>)
      }
    }

    public Emit() : void
    {
      _tb.Compile();
    }
    
    private static MakeRuleWalkMethodName(ruleSymbol : SyntaxRuleSymbol) : string
    {
      $<#..$(ruleSymbol.ModuleRelativeName; "_")#>
    }

    private static GetRuleWalkMethodRef(ruleSymbol : SyntaxRuleSymbol) : PExpr
    {
      def moduleRef = PExprUtils.FromQualifiedIdentifier(ruleSymbol.DeclaringModule.Node.FullNameParts);
      <[ $moduleRef.$(MakeRuleWalkMethodName(ruleSymbol) : usesite) ]>
    }
  }
}
