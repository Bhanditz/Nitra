using Nitra.Model;
using Nitra.Typing;

using Nemerle;
using Nemerle.Collections;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using SCG = System.Collections.Generic;

namespace Nitra.Compiler
{
  public class SplicableAstWalkerEmitter : IConstantEmitter
  {
    public Environment  : EmitterEnvironment { get; }
    _syntaxModuleSymbol : SyntaxModuleSymbol;
    _tb                 : TypeBuilder;

    public this(environment : EmitterEnvironment, syntaxModuleSymbol : SyntaxModuleSymbol)
    {
      Environment         = environment;
      _syntaxModuleSymbol = syntaxModuleSymbol;
      _tb                 = Environment
        .NamespaceOfSymbol(syntaxModuleSymbol)
        .Define(<[ decl: public partial module $(_syntaxModuleSymbol.Name + "AstWalker" : usesite) {} ]>);
    }

    [Memoize]
    public CreateConstant(name : string, value : int) : string
    {
      Util.CreateConstant(_tb, name, value)
    }

    private variant ChemicalRuleType
    {
      | Void
      | Ast
      | Tuple { members : list[ChemicalRuleType] }
      | StaticString
      | String
      | Bool
      | Option { item : ChemicalRuleType }
      | Int
      | List   { item : ChemicalRuleType }
    }

    private static GetChemicalRuleType(ruleType : RuleType) : ChemicalRuleType
    {
      | Void        => ChemicalRuleType.Void()
      | Chars(Some) => ChemicalRuleType.StaticString()
      | Chars(None) => ChemicalRuleType.String()
      | Ref         => ChemicalRuleType.Ast()
      | List(t) =>
        match (GetChemicalRuleType(t))
        {
          | Void             => ChemicalRuleType.Void()
          | StaticString     => ChemicalRuleType.Int()
          | any              => ChemicalRuleType.List(any)
        }

      | Option(t)   =>
        match (GetChemicalRuleType(t))
        {
          | Void             => ChemicalRuleType.Void()
          | StaticString     => ChemicalRuleType.Bool()
          | any              => ChemicalRuleType.Option(any)
        }

      | Tuple(ts) =>
        def members = SCG.List();
        mutable hasStaticString;
        foreach (t in ts)
          match (GetChemicalRuleType(t))
          {
            | Void          => ()
            | StaticString  => hasStaticString = true;
            | any           => members.Add(any);
          }
        match (members.Count)
        {
          | 0 => 
            if (hasStaticString)
              ChemicalRuleType.StaticString()
            else
              ChemicalRuleType.Void()

          | 1 => members[0]
          | _ => ChemicalRuleType.Tuple(members.ToNList())
        }
    }

    private static IsSubruleAcceptedForAst(subrule : SubruleCompileInfo) : bool
    {
      match (GetChemicalRuleType(subrule.SrcRule.Type))
      {
        | Void | StaticString => false
        | _                   => true
      }
    }

    public DefineMembers() : void
    {
      def compileRule(ruleSymbol : SyntaxRuleSymbol)
      {
        def astPtr = AstPointer.Existing(ruleSymbol.Sequence, this, "astPtr");

        def subruleValues = SCG.List();
        when (ruleSymbol is ExtensionRuleSymbol(ExtensionType = Postfix))
          subruleValues.Add(<[ prefix ]>);

        def statements    = SCG.List();
        foreach (subrule in ruleSymbol.Sequence.NonMarkerSubrules)
        {
          def parentAstPointer = AstPointerScope(astPtr);
          if (IsSubruleAcceptedForAst(subrule))
          {
            def varName = subrule.MakeVariableName("ast");
            statements.Add(<[ def $(varName : usesite) = $(GetSubruleValue(subrule, parentAstPointer)) ]>);
            subruleValues.Add(<[ $(varName : usesite) ]>);
          }
          else
            statements.Add(WalkerGenerator.Skip(subrule, parentAstPointer));
        }
        statements.Add(<[ builder.Syntax($(ruleSymbol.GetRuleDescriptorRef()), startPos, pos, array[..$subruleValues]) ]>);
        statements
      }

      foreach (ruleSymbol in _syntaxModuleSymbol.Node.GetDescendants.[SyntaxRuleSymbol]())
      {
        | SimpleRuleSymbol when ruleSymbol.Type is RuleType.Ref =>
          def statements = compileRule(ruleSymbol);
          _tb.DefineConditional(<[ decl:
            public $(MakeRuleWalkMethodName(ruleSymbol) : usesite)[TAst](pos : ref int, parseResult : Nitra.ParseResult, builder : Nitra.Internal.ISplicableAstBuilder[TAst]) : TAst
            {
              unchecked
              {
                def startPos   = pos;
                def ruleParser = parseResult.RuleParser.Grammar.GetSimpleRuleParser($(ruleSymbol.GetRuleDescriptorRef()));
                _ = ruleParser;
                def astPtr     = parseResult.TryGetAst(pos, ruleParser.RuleId);
                if (astPtr > 0)
                {
                  ..$statements
                }
                else
                  builder.Missing($(ruleSymbol.GetRuleDescriptorRef()), startPos)
              }
            }
          ]>)

        | ExtensionRuleSymbol(ExtensionType = Prefix) =>
          def statements = compileRule(ruleSymbol);
          _tb.DefineConditional(<[ decl:
            public $(MakeRuleWalkMethodName(ruleSymbol) : usesite)[TAst](pos : ref int, astPtr : int, ruleParser : Nitra.Internal.ExtensionRuleParser, parseResult : ParseResult, builder : Nitra.Internal.ISplicableAstBuilder[TAst]) : TAst
            {
              unchecked
              {
                def startPos = pos;
                def ruleParser = ruleParser :> $(ruleSymbol.GetParserClassRef());
                _ = ruleParser;
                ..$statements;
              }
            }
          ]>)

        | ExtensionRuleSymbol(ExtensionType = Postfix) =>
          def statements = compileRule(ruleSymbol);
          _tb.DefineConditional(<[ decl:
            public $(MakeRuleWalkMethodName(ruleSymbol) : usesite)[TAst](prefix : T, prefixStartPos : int, pos : ref int, astPtr : int, ruleParser : ExtensionRuleParser, parseResult : ParseResult, builder : Nitra.Internal.ISplicableAstBuilder[TAst]) : TAst
            {
              unchecked
              {
                def startPos = prefixStartPos;
                def ruleParser = ruleParser :> $(ruleSymbol.GetParserClassRef());
                _ = ruleParser;
                ..$statements;
              }
            }
          ]>)

        | _ => ()
      }
    }

    public Emit() : void
    {
      _tb.Compile();
    }

    private GetSubruleValue(subrule : SubruleCompileInfo, parentAstPointer : AstPointerScope) : PExpr
    {
      match (subrule)
      {
        | Empty      as subrule => WalkerGenerator.Skip(subrule, parentAstPointer)
        | SimpleCall as subrule =>
          if (subrule.Symbol.Type is RuleType.Void)
            WalkerGenerator.Skip(subrule, parentAstPointer)
          else if (subrule.CanParseEmptyString)
            <[
              pos += $(parentAstPointer.Access().GetSkip(subrule));
              $(GetRuleWalkMethodRef(subrule.Symbol))(ref pos, parseResult, builder)
            ]>
          else
            <[
              pos += $(parentAstPointer.Access().GetSkip(subrule));
              if ($(parentAstPointer.Access().GetSize(subrule)) > 0)
                $(GetRuleWalkMethodRef(subrule.Symbol))(ref pos, parseResult, builder)
              else
                builder.Missing($(subrule.Symbol.GetRuleDescriptorRef()), pos);
            ]>

        | ExtensibleCall as subrule =>
          if (subrule.Symbol.Type is RuleType.Void)
            WalkerGenerator.Skip(subrule, parentAstPointer)
          else
            <[
              pos += $(parentAstPointer.Access().GetSkip(subrule));
              if ($(parentAstPointer.Access().GetSize(subrule)) > 0)
                Nitra.Internal.ExtensibleRuleAstConstructor.Create(ref pos, parseResult, $(subrule.BindingPower : int), $(subrule.Symbol.GetRuleDescriptorRef()), builder);
              else
                builder.Missing($(subrule.Symbol.GetRuleDescriptorRef()), pos); // No prefix
            ]>

        | RegularCall as subrule                => WalkerGenerator.GetTokenValue(subrule, parentAstPointer, <[ builder.Regular($(subrule.Symbol.GetRuleDescriptorRef()), tokenPos, pos) ]>)
        | List as lst when lst.IsSkipAnyPattern => WalkerGenerator.GetTokenValue(subrule, parentAstPointer, <[ builder.SkipAny(tokenPos, pos) ]>)
        | TokenString as subrule                => WalkerGenerator.Skip(subrule, parentAstPointer)
        | Option as subrule =>
          match (GetChemicalRuleType(subrule.SrcRule.Type))
          {
            | Option =>
              WalkerGenerator.GetOptionValue(
                subrule          = subrule,
                parentAstPointer = parentAstPointer,
                hasValue         = <[ builder.OptionSome($(GetSequenceValue(subrule.Rule, "valuePointer"))) ]>,
                noValue          = <[ builder.OptionNone(pos) ]>)

            | Bool =>
              WalkerGenerator.GetOptionValue(
                subrule          = subrule,
                parentAstPointer = parentAstPointer,
                hasValue         = <[ $(SkipSequence(subrule.Rule, "valuePointer")); builder.OptimizedOption(true) ]>,
                noValue          = <[ builder.OptimizedOption(false) ]>)

            | _ => WalkerGenerator.Skip(subrule, parentAstPointer)
          }

        | List as lst =>
          match (GetChemicalRuleType(subrule.SrcRule.Type))
          {
            | List =>
              WalkerGenerator.GetListValue(
                subrule          = lst,
                parentAstPointer = parentAstPointer,
                init             = <[ def itemBuffer = System.Collections.Generic.List(16) ]>,
                item             = <[ itemBuffer.Add($(GetSequenceValue(lst.Rule, "itemPointer"))) ]>,
                returnCode       = <[ builder.List(itemBuffer) ]>,
                emptyCode        = <[ builder.EmptyList(pos) ]>)

            | Int =>
              WalkerGenerator.GetListValue(
                subrule          = lst,
                parentAstPointer = parentAstPointer,
                init             = <[ mutable itemCount; ]>,
                item             = <[ $(SkipSequence(lst.Rule, "itemPointer")); itemCount += 1 ]>,
                returnCode       = <[ builder.OptimizedList(itemCount) ]>,
                emptyCode        = <[ builder.OptimizedList(0) ]>)

            | _ => WalkerGenerator.Skip(subrule, parentAstPointer)
          }

        | ListWithSeparator as lst =>
          def (itemIsVoid, itemInit, itemBody, itemReturn, itemEmpty) =
            match (GetChemicalRuleType(lst.Rule.SrcRule.Type))
            {
              | Void         => (true, <[ () ]>, <[ () ]>, <[ () ]>, <[ () ]>)
              | StaticString =>
                (
                  false,
                  <[ mutable itemCount ]>,
                  <[ $(SkipSequence(lst.Separator, "itemPointer")); itemCount += 1 ]>,
                  <[ builder.OptimizedList(itemCount) ]>,
                  <[ builder.OptimizedList(0) ]>
                )

              | _ =>
                (
                  false,
                  <[ def itemBuffer = System.Collections.Generic.List(16); ]>,
                  <[ itemBuffer.Add($(GetSequenceValue(lst.Rule, "itemPointer"))) ]>,
                  <[ builder.List(itemBuffer) ]>,
                  <[ builder.EmptyList(pos) ]>
                )
            };

          def (separatorIsVoid, separatorInit, separatorBody, separatorReturn, separatorEmpty) =
            match (GetChemicalRuleType(lst.Separator.SrcRule.Type))
            {
              | Void         => (true, <[ () ]>, <[ () ]>, <[ () ]>, <[ () ]>)
              | StaticString =>
                (
                  false,
                  <[ mutable separatorCount ]>,
                  <[ $(SkipSequence(lst.Separator, "separatorPointer")); separatorCount += 1 ]>,
                  <[ builder.OptimizedList(separatorCount) ]>,
                  <[ builder.OptimizedList(0) ]>
                )

              | _ =>
                (
                  false,
                  <[ def separatorBuffer = System.Collections.Generic.List(16) ]>,
                  <[ separatorBuffer.Add($(GetSequenceValue(lst.Separator, "separatorPointer"))) ]>,
                  <[ builder.List(separatorBuffer) ]>,
                  <[ builder.EmptyList(pos) ]>
                )
            };

          match (itemIsVoid, separatorIsVoid)
          {
            | (true,  true) => WalkerGenerator.Skip(subrule, parentAstPointer)
            | (false, true) =>
              WalkerGenerator.GetListWithSeparatorValue(
                subrule          = lst,
                parentAstPointer = parentAstPointer,
                init             = itemInit,
                item             = itemBody,
                separator        = SkipSequence(lst.Separator, "separatorPointer"),
                returnCode       = itemReturn,
                emptyCode        = itemEmpty);

            | (true, false) =>
              WalkerGenerator.GetListWithSeparatorValue(
                subrule          = lst,
                parentAstPointer = parentAstPointer,
                init             = separatorInit,
                item             = separatorBody,
                separator        = SkipSequence(lst.Rule, "itemPointer"),
                returnCode       = separatorReturn,
                emptyCode        = separatorEmpty);

            | (false, false) =>
              WalkerGenerator.GetListWithSeparatorValue(
                subrule          = lst,
                parentAstPointer = parentAstPointer,
                init             = <[ $itemInit; $separatorInit; ]>,
                item             = itemBody,
                separator        = separatorBody,
                returnCode       = <[ builder.Tuple($itemReturn, $separatorReturn) ]>,
                emptyCode        = <[ builder.Tuple($itemEmpty, $separatorEmpty) ]>);
          }

        | Marker => <[ () ]>
      }
    }

    private SkipSequence(sequence : SequenceCompileInfo, name : string) : PExpr
    {
      def astPointer    = AstPointerScope(sequence, name, this);
      def statements    = SCG.List();

      foreach (subrule in sequence.NonMarkerSubrules)
        statements.Add(WalkerGenerator.Skip(subrule, astPointer));

      astPointer.Compile(<[ { ..$statements } ]>)
    }

    private GetSequenceValue(sequence : SequenceCompileInfo, name : string) : PExpr
    {
      def astPointer    = AstPointerScope(sequence, name, this);
      def statements    = SCG.List();
      def subruleValues = SCG.List();

      foreach (subrule in sequence.NonMarkerSubrules)
      {
        if (IsSubruleAcceptedForAst(subrule))
        {
          def varName = subrule.MakeVariableName("ast");
          statements.Add(<[ def $(varName : usesite) = $(GetSubruleValue(subrule, astPointer)) ]>);
          subruleValues.Add(<[ $(varName : usesite) ]>);
        }
        else
          statements.Add(WalkerGenerator.Skip(subrule, astPointer));
      }

      match (subruleValues.Count)
      {
        | 0 => ()
        | 1 => statements.Add(subruleValues[0]);
        | _ => statements.Add(<[ builder.Tuple(..$subruleValues)]>);
      }

      astPointer.Compile(<[ { ..$statements } ]>)
    }


    private static MakeRuleWalkMethodName(ruleSymbol : SyntaxRuleSymbol) : string
    {
      $<#..$(ruleSymbol.ModuleRelativeName; "_")#>
    }

    private static GetRuleWalkMethodRef(ruleSymbol : SyntaxRuleSymbol) : PExpr
    {
      def syntaxModule = ruleSymbol.DeclaringModule;
      def fullName     = syntaxModule.Node.Parent.FullNameParts + [syntaxModule.Name + "AstWalker", MakeRuleWalkMethodName(ruleSymbol)];
      PExprUtils.FromQualifiedIdentifier(fullName);
    }
  }
}
