using Nitra.Typing;
using Nitra.Model;

using Nemerle;
using Nemerle.Collections;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Compiler.Typedtree;
using Nemerle.Imperative;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Linq;
using SCG = System.Collections.Generic;

namespace Nitra.Compiler
{
  internal abstract partial class AstEmitter
  {
    [Record]
    internal sealed class ListEmitter : CollectionEmitter
    {
      protected override CreateBaseTb(ownerTb : TypeBuilder, itemType : FixedType) : TypeBuilder
      {
        ownerTb.DefineNestedType(<[ decl:
          new public interface IAstList : Nitra.Declarations.IAstList[$(itemType : typed)]
          {
          }
        ]>);
      }

      protected override CreateConcreteTb(ownerTb : TypeBuilder, itemType : FixedType, baseType : FixedType) : TypeBuilder
      {
        ownerTb.DefineNestedType(<[ decl:
          new public sealed class AstList : Nitra.Declarations.AstList[$(itemType : typed)], $(baseType : typed)
          {
            public this(loc : Nitra.Located, params items : array[$(itemType : typed)])
            {
              base(loc, items);
            }

            public this(file : $(FileType : typed), span : $(SpanType : typed), params items : array[$(itemType : typed)])
            {
              base(file, span, items);
            }
          }
        ]>);
      }

      protected override CreateAmbiguousTb(ownerTb : TypeBuilder, itemType : FixedType, baseType : FixedType) : TypeBuilder
      {
        ownerTb.DefineNestedType(<[ decl:
          new public sealed class AmbiguousAstList : Nitra.Declarations.AmbiguousAstList[$(itemType : typed)], $(baseType : typed)
          {
            public this(ambiguities : array[$(baseType : typed)])
            {
              base((ambiguities : object) :> array[Nitra.Declarations.IAstList[$(itemType : typed)]]);
            }
            public new Ambiguities : array[$(baseType : typed)] { get { base.Ambiguities :> array[$(baseType : typed)] } }
          }
        ]>);
      }

      protected override MakeEvalPropertiesBody(setFirstItemInputs : SCG.List[PExpr], linkEachItemProperties : SCG.List[PExpr], readLastItemOutputs : SCG.List[PExpr], setEmptyListOutputs : SCG.List[PExpr]) : PExpr
      {
        <[
          if (_items.Length > 0)
          {
            mutable item = _items[0];
            ..$setFirstItemInputs;
            item.EvalProperties(context);
            for (mutable i = 1; i < _items.Length; ++i)
            {
              def prevItem = item;
              _ = prevItem;
              item = _items[i];
              ..$linkEachItemProperties;
              item.EvalProperties(context);
            }
            ..$readLastItemOutputs
          }
          else
          {
            ..$setEmptyListOutputs
          }
        ]>
      }
    }
  }
}
