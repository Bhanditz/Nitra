using Nitra.Model;
using Nitra.Typing;

using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using SCG = System.Collections.Generic;

namespace Nitra.Compiler
{
  internal variant ChemicalRuleType
  {
    | Void
    | Ast
    | Tuple { members : list[ChemicalRuleType] }
    | StaticString
    | String
    | Bool
    | Option { item : ChemicalRuleType }
    | Int
    | List   { item : ChemicalRuleType }

    public static FromRuleType(ruleType : RuleType) : ChemicalRuleType
    {
      | Void        => ChemicalRuleType.Void()
      | Chars(Some) => ChemicalRuleType.StaticString()
      | Chars(None) => ChemicalRuleType.String()
      | Ref         => ChemicalRuleType.Ast()
      | List(t) =>
        match (FromRuleType(t))
        {
          | Void             => ChemicalRuleType.Void()
          | StaticString     => ChemicalRuleType.Int()
          | any              => ChemicalRuleType.List(any)
        }

      | Option(t)   =>
        match (FromRuleType(t))
        {
          | Void             => ChemicalRuleType.Void()
          | StaticString     => ChemicalRuleType.Bool()
          | any              => ChemicalRuleType.Option(any)
        }

      | Tuple(ts) =>
        def members = SCG.List();
        mutable hasStaticString;
        foreach (t in ts)
          match (FromRuleType(t))
          {
            | Void          => ()
            | StaticString  => hasStaticString = true;
            | any           => members.Add(any);
          }
        match (members.Count)
        {
          | 0 => 
            if (hasStaticString)
              ChemicalRuleType.StaticString()
            else
              ChemicalRuleType.Void()

          | 1 => members[0]
          | _ => ChemicalRuleType.Tuple(members.ToNList())
        }
    }
  }
}
