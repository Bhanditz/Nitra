using Nitra.Typing;
using Nitra.Model;

using Nemerle;
using Nemerle.Collections;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Compiler.Typedtree;
using Nemerle.Imperative;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Linq;
using SCG = System.Collections.Generic;

namespace Nitra.Compiler
{
  internal abstract partial class AstEmitter
  {
    internal abstract class CollectionEmitter
    {
      public Owner  : AstEmitter;
      public Symbol : AstSymbol;

      public this(owner : AstEmitter, symbol : AstSymbol)
      {
        Owner  = owner;
        Symbol = symbol;
      }

      protected FileType : FixedType { get { Owner.Environment.FileTypeVar;  } }
      protected SpanType : FixedType { get { Owner.Environment.NSpanTypeVar; } }

      mutable _baseTb        : TypeBuilder;
      mutable _concreteTb    : TypeBuilder;
      mutable _ambiguousTb   : TypeBuilder;

      protected abstract CreateBaseTb(ownerTb : TypeBuilder, itemType : FixedType) : TypeBuilder;
      protected abstract CreateConcreteTb(ownerTb : TypeBuilder, itemType : FixedType,  baseType : FixedType) : TypeBuilder;
      protected abstract CreateAmbiguousTb(ownerTb : TypeBuilder, itemType : FixedType, baseType : FixedType) : TypeBuilder;
      protected abstract MakeEvalPropertiesBody(setFirstItemInputs : SCG.List[PExpr], linkEachItemProperties : SCG.List[PExpr], readLastItemOutputs : SCG.List[PExpr], setEmptyListOutputs : SCG.List[PExpr]) : PExpr;

      public DefineTypes(ownerTb : TypeBuilder) : void
      {
        Util.locate(Symbol.FirstLocation.NLocation(),
        {
          def itemType = Owner.Environment.GetAstType(Symbol);

          assert(_baseTb == null);
          _baseTb = CreateBaseTb(ownerTb, itemType);
          def baseType = _baseTb.GetMemType();

          assert(_concreteTb == null);
          _concreteTb = CreateConcreteTb(ownerTb, itemType, baseType);

          assert(_ambiguousTb == null);
          _ambiguousTb = CreateAmbiguousTb(ownerTb, itemType, baseType);
        })
      }

      public DefineMembers(astProperties : SCG.Dictionary[DependentAstPropertySymbol, DependentAstPropertyRef]) : void
      {
        assert(_baseTb != null);

        def define()
        {
          def dependentProperties = Symbol.AllProperties.OfType.[DependentAstPropertySymbol]().ToArray();
          when (dependentProperties.Length == 0)
            return;

          def bits                 = _concreteTb.GetBitFieldManager();
          def collectionProperties = SCG.Dictionary();
          foreach (propertySymbol in dependentProperties)
          {
            Owner.DefineInterfaceDependentProperty(propertySymbol, _baseTb);
            def bit          = bits.Allocate();
            def propertyRef = DependentAstPropertyRef.Compiling(propertySymbol, bit.Index, bit);
            Owner.DefineDependentProperty(_concreteTb, propertyRef, NemerleModifiers.Public);
            DefineAmbiguousDependentProperty(_ambiguousTb, propertyRef, NemerleModifiers.Public);

            collectionProperties.Add(propertySymbol, propertyRef);
          }

          DefineIsPropertyEvaluatedMethod(_concreteTb, NemerleModifiers.Override);
          DefineResetPropertiesMethod(_concreteTb, null);
          DefineIsAllPropertiesEvaluatedProperty(_concreteTb, null);

          def linkProperties(body : SCG.List[PExpr], sourceObj : PExpr, source : DependentAstPropertyRef, targetObj : PExpr, target : DependentAstPropertyRef) : void
          {
            body.Add(<[
              when ($(GenerateHasValueCheck(sourceObj, source)) && ! $(GenerateHasValueCheck(targetObj, target)))
              {
                $targetObj.$(target.Symbol.Name : usesite) = $sourceObj.$(source.Symbol.Name : usesite)
              }
            ]>);
          }

          def setFirstItemInputs     = SCG.List();
          def linkEachItemProperties = SCG.List();
          def readLastItemOutputs    = SCG.List();
          def setEmptyListOutputs    = SCG.List();

          foreach (propertySymbol in dependentProperties)
          {
            match (propertySymbol.Direction)
            {
              | In =>
                def listInputRef = collectionProperties[propertySymbol];
                def itemInputRef = astProperties[propertySymbol];
                linkProperties(setFirstItemInputs, <[ this ]>, listInputRef, <[ item ]>, itemInputRef);

                if (propertySymbol.LinkedProperty is SymbolRef.Some(linkedProperty))
                {
                  def itemOutputRef = astProperties[linkedProperty];
                  linkProperties(linkEachItemProperties, <[ prevItem ]>, itemOutputRef, <[ item ]>, itemInputRef);
                }
                else
                  linkProperties(linkEachItemProperties, <[ this ]>, listInputRef, <[ item ]>, itemInputRef);

              | Out =>
                def itemOutputRef = astProperties[propertySymbol];
                def listOutputRef = collectionProperties[propertySymbol];
                linkProperties(readLastItemOutputs, <[ item ]>, itemOutputRef, <[ this ]>, listOutputRef);

                when (propertySymbol.LinkedProperty is SymbolRef.Some(linkedProperty))
                {
                  def listInputRef = collectionProperties[linkedProperty];
                  linkProperties(setEmptyListOutputs, <[ this ]>, listInputRef, <[ this ]>, listOutputRef);
                }
            }
          }

          def body = MakeEvalPropertiesBody(setFirstItemInputs, linkEachItemProperties, readLastItemOutputs, setEmptyListOutputs);

          _concreteTb.Define(<[ decl:
            public override EvalProperties(context : Nitra.Declarations.DependentPropertyEvalContext) : void
            {
              $body
            }
          ]>);
        }

        Util.locate(Symbol.FirstLocation.NLocation(), Owner.Environment.Manager.MacroColors.InGlobalColor(define))
      }

      private DefineAmbiguousDependentProperty(tb : TypeBuilder, propertyRef : DependentAstPropertyRef, modifiers : NemerleModifiers) : void
      {
        def propertyType = Owner.Environment.TypeCompiler.CompileDependentPropertyType(propertyRef.Symbol);
        def name         = propertyRef.Symbol.Name;
        def mods         = AttributesAndModifiers(modifiers, [MakeDependentPropertyAttribute(propertyRef.Symbol, propertyRef.Index)]);
        match (propertyRef.Symbol.Direction)
        {
          | In  =>
            tb.Define(<[ decl:
              ..$mods $(name : usesite) : $(propertyType : typed)
              {
                get { this.Ambiguities[0].$(name : usesite) }
                set { foreach (ambiguity in this.Ambiguities) ambiguity.$(name : usesite) = value; }
              }
            ]>);

          | Out =>
            tb.Define(<[ decl:
              ..$mods $(name : usesite) : $(propertyType : typed)
              {
                get { this.Ambiguities[0].$(name : usesite) }
              }
            ]>);
        }

        def isEvaluatedName = GetIsEvaluatedPropertyName(propertyRef.Symbol);
        def isEvaluatedMods = AttributesAndModifiers(modifiers, []);
        tb.Define(<[ decl:
          ..$isEvaluatedMods $(isEvaluatedName : usesite) : bool
          {
            get { this.Ambiguities[0].$(isEvaluatedName : usesite) }
          }
        ]>);
      }

      public Emit() : void
      {
        assert(_baseTb != null);

        _baseTb.Compile();
        _concreteTb.Compile();
        _ambiguousTb.Compile();
      }
    }
  }
}
