using Nitra.Model;
using Nitra.Typing;

using Nemerle;
using Nemerle.Collections;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using SCG = System.Collections.Generic;

namespace Nitra.Compiler
{
  internal sealed class ExtensionAstEmitter : AstEmitter
  {
    private         _parent            : AstEmitter;
    private         _symbol            : ExtensionAstSymbol;
    private mutable _tb                : TypeBuilder;
    private mutable _ambiguousTb       : TypeBuilder;
    private         _listEmitter       : ListAstEmitter;
    private         _optionEmitter     : OptionAstEmitter;
    private mutable _symbolTb          : TypeBuilder;

    public this(parent : AstEmitter, symbol : ExtensionAstSymbol)
    {
      base(parent.Environment, parent.NemerleEnv);
      this._parent        = parent;
      this._symbol        = symbol;
      this._listEmitter   = ListAstEmitter(parent.Environment, symbol);
      this._optionEmitter = OptionAstEmitter(parent.Environment, symbol);
    }

    public override DefineTypes() : void
    {
      Util.locate(_symbol.FirstLocation.NLocation(),
      {
        assert(_tb == null);

        def baseTypes = SCG.List();
        foreach (baseAst in _symbol.BaseAsts)
          baseTypes.Add(<[ $(Environment.GetAstType(baseAst) : typed) ]>);

        _tb = _parent.DefineNestedType(<[ decl:
          public partial class $(_symbol.Name : usesite) : ..$baseTypes
          {
            private this() {}
          }
        ]>);

        assert(_ambiguousTb == null);
        _ambiguousTb = DefineAmbiguousAst(_tb);

        _listEmitter.DefineTypes(_tb);
        _optionEmitter.DefineTypes(_tb);

        when (_symbol.IsDeclaration)
        {
          _symbolTb = _parent.NemerleEnv.Define(<[ decl:
            public partial class $(_symbol.SymbolClassName : usesite) : ..$(MakeSymbolClassBaseTypes(_symbol))
            {
              public this(name : Nitra.Declarations.IName) { base(name) }
            }
          ]>);
        }
      })
    }

    public override DefineMembers() : void
    {
      assert(_tb != null);

      def thisType = _tb.GetMemType();

      def initParameters = SCG.List();
      initParameters.Add(<[ parameter: File : $(Environment.FileTypeVar : typed) ]>);
      initParameters.Add(<[ parameter: Span : $(Environment.NSpanTypeVar : typed) ]>);

      def initStatements = SCG.List();
      initStatements.Add(<[ this.File = File ]>);
      initStatements.Add(<[ mutable isSpanSet ]>);
      initStatements.Add(<[ unless (TryEvalSpan) { this.Span = Span; isSpanSet = true } ]>);

      def acceptBody = SCG.List();
      acceptBody.Add(<[ base.Accept(visitor) ]>);

      def missingBody = SCG.List();
      missingBody.Add(<[ this.File = file ]>);
      missingBody.Add(<[ this.Span = span ]>);

      def dependentProps = SCG.Dictionary();

      def defineSimpleProperty(propertySymbol : SimpleAstPropertySymbol) : void
      {
        def name         = propertySymbol.Name;
        def propertyType = TypeCompiler.CompileSimplePropertyType(propertySymbol);

        initParameters.Add(<[ parameter : $(name : usesite) : $(propertyType.Type : typed) ]>);
        initStatements.Add(<[ this.$(name : usesite) = $(name : usesite) ]>);

        when (propertySymbol.DeclaringAst == _symbol)
          DefineSimpleProperty(name, propertyType.Type, _tb, _ambiguousTb);

        match (propertyType)
        {
          | Ast         =>
            initStatements.Add(<[ when ($(name : usesite).File : object == File) UpdateSpan(ref isSpanSet, $(name : usesite).Span) ]>);
            when (propertySymbol.DeclaringAst == _symbol)
              acceptBody.Add(<[ visitor.Visit(this.$(name : usesite)); ]>);

            if (propertyType.Type.Equals(thisType))
              missingBody.Add(<[ this.$(name : usesite) = this ]>);
            else unless (propertySymbol.AstType.IsVoid)
              missingBody.Add(<[ this.$(name : usesite) = $(GetMissingAstCtor(Environment, propertySymbol.AstType))(file, span) ]>);

          | ParsedValue =>
            initStatements.Add(<[ UpdateSpan(ref isSpanSet, $(name : usesite).Span) ]>);
            missingBody.Add(<[ this.$(name : usesite) = Nitra.ParsedValue(span.StartPos) ]>);

          | Span        =>
            initStatements.Add(<[ UpdateSpan(ref isSpanSet, $(name : usesite)) ]>);
            missingBody.Add(<[ this.$(name : usesite) = span ]>);
        }
      }

      mutable inheritedFieldsCount;

      def defineDependentProperty(propertySymbol : DependentAstPropertySymbol) : void
      {
        def index = dependentProps.Count;

        if (propertySymbol.DeclaringAst == _symbol)
        {
          if (propertySymbol.OverrideProperty.HasValue)
          {
            inheritedFieldsCount += 1;

            def propertyRef = DependentAstPropertyRef.Reflected(propertySymbol, index);
            dependentProps.Add(propertySymbol, propertyRef);

            DefineDependentPropertyOverride(propertyRef);
            DefineAmbiguousDependentProperty(_ambiguousTb, propertyRef, NemerleModifiers.Public | NemerleModifiers.Override);
          }
          else
          {
            def bit         = _tb.GetBitFieldManager().Allocate();
            def propertyRef = DependentAstPropertyRef.Compiling(propertySymbol, index, bit);
            DefineDependentProperty(_tb, propertyRef, NemerleModifiers.Public | NemerleModifiers.Virtual);
            DefineAmbiguousDependentProperty(_ambiguousTb, propertyRef, NemerleModifiers.Public | NemerleModifiers.Override);

            dependentProps.Add(propertySymbol, propertyRef);
          }
        }
        else
        {
          inheritedFieldsCount += 1;

          def propertyRef = DependentAstPropertyRef.Reflected(propertySymbol, index);
          dependentProps.Add(propertySymbol, propertyRef);

          DefineAmbiguousDependentProperty(_ambiguousTb, propertyRef, NemerleModifiers.Public | NemerleModifiers.Override);
        }
      }

      def projectedProps = SCG.List();

      def defineProjectedProperty(propertySymbol : ProjectedAstPropertySymbol) : void
      {
        def name         = propertySymbol.Name;
        def propertyType = TypeCompiler.CompileProjectedPropertyType(propertySymbol);
        when (propertySymbol.DeclaringAst == _symbol)
          DefineSimpleProperty(name, propertyType, _tb, _ambiguousTb);
        projectedProps.Add(propertySymbol);

        if (propertyType.Equals(thisType))
          missingBody.Add(<[ this.$(name : usesite) = this ]>);
        else when (propertySymbol.ProjectionType is Some(projectionType))
          missingBody.Add(<[ this.$(name : usesite) = $(GetMissingAstCtor(Environment, projectionType))(file, span) ]>);
      }

      // inherited properties comes first!
      foreach (propertySymbol in _symbol.AllProperties)
      {
        | SimpleAstPropertySymbol    as s => defineSimpleProperty(s)
        | DependentAstPropertySymbol as s => defineDependentProperty(s)
        | ProjectedAstPropertySymbol as s => defineProjectedProperty(s)
        | _ => ()
      }

      initParameters.Add(<[ parameter: TryEvalSpan : bool = false ]>);
      initStatements.Add(<[ unless (isSpanSet) this.Span = Span ]>);

      CompileProjection(projectedProps, initStatements);

      _tb.Define(<[ decl:
        public this(..$initParameters) { ..$initStatements }
      ]>);

      _ambiguousTb.Define(<[ decl:
        public this(file : $(Environment.FileTypeVar : typed), span : $(Environment.NSpanTypeVar : typed)) { ..$missingBody }
      ]>);

      DefineIsPropertyEvaluatedMethod(_tb, inheritedFieldsCount);
      DefineResetPropertiesMethod(_tb, _ambiguousTb, inheritedFieldsCount);
      DefineIsAllPropertiesEvaluatedProperty(_tb, _ambiguousTb, inheritedFieldsCount);
      DefineDependentPropertiesEvaluation(_tb, _symbol, _symbol.IsDeclaration);

      _listEmitter.DefineMembers(dependentProps);
      _optionEmitter.DefineMembers(dependentProps);

      when (acceptBody.Count > 1)
        _tb.Define(<[ decl: public override Accept(visitor : Nitra.Declarations.IAstVisitor) : void { ..$acceptBody } ]>);

      when (_symbol.IsDeclaration)
        _tb.Define(<[ decl:
          public CreateSymbol(name : Nitra.Declarations.IName) : Nitra.Runtime.Binding.ISymbol2
          {
            $(GetSymbolClassRef(_symbol))(name)
          }
        ]>);
    }

    public override Emit() : void
    {
      assert(_tb != null);
      _tb.Compile();

      assert(_ambiguousTb != null);
      _ambiguousTb.Compile();

      _listEmitter.Emit();
      _optionEmitter.Emit();

      when (_symbolTb != null)
        _symbolTb.Compile();
    }

    private DefineDependentPropertyOverride(propertyRef : DependentAstPropertyRef) : void
    {
      def propertyType     = TypeCompiler.CompileDependentPropertyType(propertyRef.Symbol);
      Util.locate(propertyRef.Symbol.FirstLocation.NLocation(),
      {
        def setterMods    =
          match (propertyRef.Symbol.Direction)
          {
            | In  => AttributesAndModifiers(NemerleModifiers.None,      [])
            | Out => AttributesAndModifiers(NemerleModifiers.Protected, [])
          };
        _tb.Define(<[ decl:
          [$(MakeDependentPropertyAttribute(propertyRef.Symbol, propertyRef.Index))]
          public new virtual $(propertyRef.Symbol.Name : usesite) : $(propertyType : typed)
          {
            get
            {
              base.$(propertyRef.Symbol.Name : usesite) :> $(propertyType : typed)
            }
            ..$setterMods
            set
            {
              base.$(propertyRef.Symbol.Name : usesite) = value
            }
          }
        ]>);
      });
    }
  }
}
