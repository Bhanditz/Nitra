using Nitra.Model;
using Nitra.Typing;

using Nemerle;
using Nemerle.Collections;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Linq;
using SCG = System.Collections.Generic;

namespace Nitra.Compiler
{
  internal sealed class AbstractAstEmitter : AstEmitter
  {
    private         _symbol            : AbstractAstSymbol;
    private mutable _tb                : TypeBuilder;
    private mutable _ambiguousTb       : TypeBuilder;
    private         _collectionEmitter : CollectionEmitter;

    public this(environment : EmitterEnvironment, symbol : AbstractAstSymbol)
    {
      base(environment, environment.NamespaceOfSymbol(symbol));
      this._symbol = symbol;
      this._collectionEmitter = CollectionEmitter(this, symbol);
    }

    public override DefineTypes() : void
    {
      Util.locate(_symbol.FirstLocation.NLocation(),
      {
        assert(_tb == null);

        def parentType = Environment.TypeCompiler.CompileParentType(_symbol);

        def baseTypes = SCG.List();
        if (_symbol.IsDeclaration)
          baseTypes.Add(<[ $(Environment.DeclarationTypeVar : typed) ]>)
        else
          baseTypes.Add(<[ $(Environment.AstTypeVar : typed) ]>);
        foreach (baseAst in _symbol.BaseAsts)
          baseTypes.Add(<[ $(Environment.GetAstType(baseAst) : typed) ]>);

        _tb = NemerleEnv.Define(<[ decl:
          public partial interface $(_symbol.Name : usesite) : ..$baseTypes
          {
          }
        ]>);

        assert(_ambiguousTb == null);
        _ambiguousTb = DefineAmbiguousAst(_tb, parentType);

        _collectionEmitter.DefineTypes(_tb);
      })
    }

    public override DefineMembers() : void
    {
      assert(_tb != null);

      def dependentProps = SCG.Dictionary();

      foreach (s in _symbol.AllProperties)
      {
        | SimpleAstPropertySymbol as propertySymbol =>
          def propertyType = Environment.TypeCompiler.CompileSimplePropertyType(propertySymbol);

          when (propertySymbol.DeclaringAst == _symbol)
            _tb.Define(<[ decl: $(propertySymbol.Name : usesite) : $(propertyType : typed) { get; } ]>);

          _ambiguousTb.Define(<[ decl:
            public $(propertySymbol.Name : usesite) : $(propertyType : typed)
            {
              get { this.Ambiguities[0].$(propertySymbol.Name : usesite) }
            }
          ]>);

        | ProjectedAstPropertySymbol as propertySymbol =>
          def propertyType = Environment.TypeCompiler.CompileProjectedPropertyType(propertySymbol);

          when (propertySymbol.DeclaringAst == _symbol)
            _tb.Define(<[ decl: $(propertySymbol.Name : usesite) : $(propertyType : typed) { get; } ]>);

          _ambiguousTb.Define(<[ decl:
              public $(propertySymbol.Name : usesite) : $(propertyType : typed)
              {
                get { this.Ambiguities[0].$(propertySymbol.Name : usesite) } 
              }
          ]>);

        | DependentAstPropertySymbol as propertySymbol =>
          def propertyRef = DependentAstPropertyRef.Reflected(propertySymbol, -1);
          dependentProps.Add(propertySymbol, propertyRef);

          when (propertySymbol.DeclaringAst == _symbol)
            DefineInterfaceDependentProperty(propertySymbol, _tb);

          DefineAmbiguousDependentProperty(propertyRef);

        | _ => assert(false)
      }

      _collectionEmitter.DefineMembers(dependentProps);
    }

    private DefineAmbiguousDependentProperty(propertyRef : DependentAstPropertyRef) : void
    {
      def propertyType    = Environment.TypeCompiler.CompileDependentPropertyType(propertyRef.Symbol);
      def name            = propertyRef.Symbol.Name;
      def isEvaluatedName = GetIsEvaluatedPropertyName(propertyRef.Symbol);
      def mods            = AttributesAndModifiers(NemerleAttributes.Public, [MakeDependentPropertyAttribute(propertyRef.Symbol, propertyRef.Index)]);
      match (propertyRef.Symbol.Direction)
      {
        | In  =>
          def backingFieldName = Util.tmpname(propertyRef.Symbol.Name);
          def hasValueBit = _ambiguousTb.GetBitFieldManager().Allocate();
          _ambiguousTb.Define(<[ decl:  private mutable $(backingFieldName : usesite) : $(propertyType : typed) ]>);
          _ambiguousTb.Define(<[ decl:
            ..$mods $(name : usesite) : $(propertyType : typed)
            {
              get
              {
                if (this.IsAmbiguous)
                  this.Ambiguities[0].$(name : usesite)
                else
                {
                  unless ($(hasValueBit.Read()))
                    $(MakeAccessAssertion(propertyRef));
                  this.$(backingFieldName : usesite)
                }
              }
              set
              {
                if (this.IsAmbiguous)
                  foreach (ambiguity in this.Ambiguities)
                    ambiguity.$(name : usesite) = value;
                else unless ($(hasValueBit.Read()))
                {
                  this.$(backingFieldName : usesite) = value;
                  $(hasValueBit.Set());
                }
              }
            }
          ]>);

          _ambiguousTb.Define(<[ decl:
            public $(isEvaluatedName : usesite) : bool
            {
              get
              {
                if (this.IsAmbiguous)
                  this.Ambiguities[0].$(isEvaluatedName : usesite)
                else
                  $(hasValueBit.Read())
              }
            }
          ]>);

        | Out =>
          _ambiguousTb.Define(<[ decl:
            ..$mods $(name : usesite) : $(propertyType : typed)
            {
              get
              {
                if (this.IsAmbiguous)
                  this.Ambiguities[0].$(name : usesite)
                else
                  $(MakeAccessAssertion(propertyRef));
              }
            }
          ]>);

          _ambiguousTb.Define(<[ decl:
            public $(isEvaluatedName : usesite) : bool
            {
              get
              {
                if (this.IsAmbiguous)
                  this.Ambiguities[0].$(isEvaluatedName : usesite)
                else
                  false
              }
            }
          ]>);
      }
    }

    public override Emit() : void
    {
      assert(_tb != null);
      _tb.Compile();

      assert(_ambiguousTb != null);
      _ambiguousTb.Compile();

      _collectionEmitter.Emit();
    }
  }
}
