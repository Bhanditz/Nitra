using Nitra.Typing;
using Nitra.Model;

using Nemerle;
using Nemerle.Collections;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Compiler.Typedtree;
using Nemerle.Imperative;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Linq;
using SCG = System.Collections.Generic;

namespace Nitra.Compiler
{
  internal abstract partial class AstEmitter
  {
    protected DefineDependentPropertiesEvaluation(tb : TypeBuilder, symbol : AstSymbol) : void
    {
      Util.locate(symbol.FirstLocation.NLocation(),
      tb.Manager.MacroColors.InGlobalColor(fun()
      {
        def body = SCG.List();
        when ((symbol : object) is IDependentPropertyAssignmentContainer as container)
        {
          def initializedOutProperties = SCG.HashSet(symbol.InitializedOutProperties);
          when (symbol is ExtensionAstSymbol(BaseAst = SymbolRef.Some(baseSymbol)))
            initializedOutProperties.UnionWith(baseSymbol.InitializedOutProperties);

          foreach (p in symbol.AllProperties)
          {
            | DependentAstPropertySymbol(Direction = Out, LinkedProperty = SymbolRef.Some(inPropertySymbol)) as outPropertySymbol when symbol is ExtensibleAstSymbol =>
              unless (initializedOutProperties.Contains(outPropertySymbol))
              {
                def loc = if (outPropertySymbol.DeclaringAst == symbol) outPropertySymbol.FirstLocation else symbol.FirstLocation;
                container.AddAssignment(DependentPropertyAssignment(loc, [Identifier(symbol.FirstLocation, outPropertySymbol.Name)], <[ this.$(inPropertySymbol.Name : usesite) ]>))
              }

            | DependentAstPropertySymbol(Direction = Out) as outPropertySymbol =>
              unless (initializedOutProperties.Contains(outPropertySymbol))
              unless (symbol is ExtensibleAstSymbol)
              {
                def loc = if (outPropertySymbol.DeclaringAst == symbol) outPropertySymbol.FirstLocation else symbol.FirstLocation;
                Message.Error(loc.NLocation(), $"Output dependent property '$(outPropertySymbol.Name)' is never assigned to");
              }

            | _ => ()
          }

          foreach (assignment in container.GetAssignments())
            body.Add(Util.locate(assignment.Location.NLocation(), <[ $(PExprUtils.FromQualifiedIdentifier(assignment.Path)) = $(assignment.Expression) ]>));
        }

        DefineEvalPropertiesMethod(tb, <[ { ..$body } ]>);

        def compileGraph(methodBuilder : MethodBuilder, graphNodes : Seq[Node]) : void
        {
          def cycled = Node.Sort(graphNodes);
          if (cycled)
          {
            def cycledNodes = Node.FindCycling(graphNodes);
            foreach (cycledNode in cycledNodes)
              Message.Error(cycledNode.Location, "Is cycled.");
            otherwise assert(false, "Cycled nodes not found");
          }
          else
          {
            def props = SCG.List();
            foreach (s is SimpleAstPropertySymbol in symbol.AllProperties)
            {
              if (tb.LookupMember(s.Name).Find(m => m is IProperty) is Some(m))
                props.Add(m :> IProperty);
              else
                assert(false, $"IProperty for symbol $s not found");
            }
            def graphNodes2 = AddDependencyOnAstProperties(graphNodes, props);
            CheckStageDependencies(graphNodes2);
            //CheckOutputPropertiesAssignment(symbol, newGraphNodes);
            def code          = GenerateCode(tb, graphNodes2);
            if (symbol is ExtensionAstSymbol)
              methodBuilder.Body = <[ $code; base.EvalProperties($("context" : usesite)); ]>
            else
              methodBuilder.Body = code;
            throw RestartRunBodyTyperException()
          }
        }

        def typingHandler(_ : object, args : StageEventArgs) : void
        {
          def func = args.Typer.CurrentFunction;
          when (func.Name == "EvalProperties")
          {
            try
            {
              match (func.Body)
              {
                | FunBody.Typed(TExpr.Block(_, TExpr.Literal(Literal.Void))) =>
                  compileGraph(args.Typer.CurrentMethodBuilder, [])

                | FunBody.Typed(TExpr.Block(_, bodyExpr)) =>
                  def expr       = ValidateEvalFieldsCode(bodyExpr);
                  def nodesMap   = MakeDependencyGraph(expr);
                  def graphNodes = nodesMap.Values.ToArray();
                  compileGraph(args.Typer.CurrentMethodBuilder, graphNodes)

                | _ => Message.Error(args.Typer.CurrentFunction.Location, "Unsupported dependent properties syntax.")
              }
            }
            finally
              tb.MethodBeforeStage2 -= typingHandler
          }
        }
        tb.MethodBeforeStage2 += typingHandler
      }));
    }

    private static ErrorUnexpectedExpr(expr : TExpr) : void
    {
      Message.FatalError(expr.Location, $"Unexpected expression '$expr' $(expr.GetType().Name)")
    }

    private static ValidateEvalFieldsCode(expr : TExpr) : TExpr
    {
      def walker = ExprWalker();
      def checkInvalidExpre(info : ExprWalkInfo) : void
      {
        match (info.Node)
        {
          | TExpr.DefFunctionsIn as e 
          | TExpr.DefValIn       as e 
          | TExpr.Block          as e
          | TExpr.Error          as e
          | TExpr.SelfTailCall   as e
          | TExpr.MultipleAssign as e
          | TExpr.StaticEventRef as e
          | TExpr.EventMember    as e => ErrorUnexpectedExpr(e);
          | _ => ()
        }
      }
      walker.Walk(expr, checkInvalidExpre);

      def removeDelayed(expr : TExpr) : TExpr
      {
        | PropertyMember as e => 
          def newObj = e.obj.Walk(removeDelayed);
          if (newObj : object != e.obj)
          {
            def res = TExpr.PropertyMember(e.Type, newObj, e.prop);
            res.Location = e.Location;
            res
          }
          else
            e
            
        | Typedtree.TExpr.StaticPropertyRef as e => e
        | TExpr.Delayed as d when d.susp.IsResolved => d.susp.ResolutionResult
        | _ => null
      }

      //assert2(false);
      expr.Walk(removeDelayed)
    }

    private MakeDependencyGraph(expr : TExpr) : Hashtable[list[IProperty], Node]
    {
      def nodesMap = Hashtable();
      def toKey(expr : TExpr, acc : list[IProperty] = []) : list[IProperty]
      {
        match (expr)
        {
          | TExpr.PropertyMember as e => toKey(e.obj, e.prop :: acc)
          | TExpr.Base => acc
          | TExpr.This => acc
          | _ =>  ErrorUnexpectedExpr(expr); null
        }
      }

      def addNodesDependentOnAssignedProperty(expr : TExpr, node : Node) : void
      {
        def walker = ExprWalker();
        def walk(info : ExprWalkInfo) : void
        {
            match (info.Node)
            {
              | TExpr.PropertyMember as e =>
                def propertyRef = Environment.LookupAstPropertySymbol(e.prop);
                when (propertyRef != null)
                {
                  def nodesMap = nodesMap;
                  def key = toKey(e);
                  mutable to;
                  unless (nodesMap.TryGetValue(key, out to))
                  {
                    to = Node.UseProp(e, propertyRef);
                    nodesMap[key] = to;
                  }
                  node.DependendOn.Add(to);
                }

              | TExpr.Delayed => 
                // мы не можем производить преобразование, если у нас остались объкты отложенной типизации
                assert(false);

              | _ => ()
            }
        }
        walker.Walk(expr, walk);
      }
      def addKey(assign : TExpr.Assign, debug : TExpr = null) : void
      {
        match (assign.target)
        {
          | TExpr.PropertyMember as e =>
            def propertyRef = Environment.LookupAstPropertySymbol(e.prop);
            if (propertyRef != null)
            {
              def key = toKey(e);
              mutable existingNode;
              if (nodesMap.TryGetValue(key, out existingNode))
              {
                Message.Warning(existingNode.Location, "Related message: First assingment of dependent property.");
                Message.FatalError(e.Location, "Multiple assign of dependent property.");
              }
              else
              {
                def node = Node.AssignProp(assign, debug, e, propertyRef);
                nodesMap[key] = node;
              }
            }
            else
              Message.FatalError(e.Location, "You can assign only a dependent property.");

          | TExpr.Delayed => assert(false);
          | _ => Message.FatalError(assign.target.Location, "You can assign only a dependent property.");
        }
      }
      def processAssignProp(assign : TExpr.Assign) : void
      {
        match (assign.target)
        {
          | TExpr.PropertyMember as e =>
            def propertyRef = Environment.LookupAstPropertySymbol(e.prop);
            if (propertyRef != null)
            {
              def nodesMap = nodesMap;
              def key = toKey(e);
              def node = nodesMap[key] :> Node.AssignProp;
              addNodesDependentOnAssignedProperty(assign.source, node);
            }
            else
              Message.FatalError(e.Location, "You can assign only a dependent property.");

          | TExpr.Delayed => assert(false);
          | _ => Message.FatalError(assign.target.Location, "You can assign only a dependent property.");
        }
      }
      def addAssigns(expr : TExpr, debug : TExpr = null) : void
      {
        match (expr)
        {
          | TExpr.Delayed => assert(false);
          | TExpr.DebugInfo as e => addAssigns(e.expr, e)
          | TExpr.Sequence as e => addAssigns(e.e1); addAssigns(e.e2);
          | TExpr.Assign as e => addKey(e, debug);
          | e => ErrorUnexpectedExpr(e)
        }
      }
      def calcDependents(expr : TExpr) : void
      {
        | TExpr.Delayed => assert(false);
        | TExpr.DebugInfo as e => calcDependents(e.expr)
        | TExpr.Sequence as e => calcDependents(e.e1); calcDependents(e.e2);
        | TExpr.Assign as e => processAssignProp(e);
        | e => ErrorUnexpectedExpr(e)
      }

      addAssigns(expr);
      calcDependents(expr);
      nodesMap
    }

    private static AddDependencyOnAstProperties(dependencyGraph : Seq[Node], declaredProperties : Seq[IProperty]) : Seq[Node]
    {
      def declaredPropNodes = SCG.List();
      foreach (p in declaredProperties)
        declaredPropNodes.Add(Node.DeclaredProp(p));

      def newDependencyGraph = SCG.List(dependencyGraph);
      newDependencyGraph.AddRange(declaredPropNodes);

      def getRootProp(expr : TExpr) : IProperty
      {
        | TExpr.PropertyMember as p => if (p.obj is TExpr.Base || p.obj is TExpr.This) p.prop else getRootProp(p.obj)
        | _ => Message.FatalError(expr.Location, "Properties must only be used.")
      }

      //Node.Visualize(nodesMap.Values, "После добавления Node.DeclaredProp()");

      def synthesizedProps = newDependencyGraph.OfType.[Node.UseProp]();
      foreach (synthesizedProp in synthesizedProps)
      {
        def prop = getRootProp(synthesizedProp.Expr);
        foreach (astProp in declaredPropNodes)
          when (prop : object == astProp.Prop)
            synthesizedProp.DependendOn.Add(astProp);
      }

      //visualize(": После добавления зависимостей с синтизируемых свойств");

      def inheritedProps = newDependencyGraph.OfType.[Node.AssignProp]();
      foreach (inheritedProp in inheritedProps)
      {
        def prop = getRootProp(inheritedProp.Expr.target);
        foreach (astProp in declaredPropNodes)
          when (prop : object == astProp.Prop)
            astProp.DependendOn.Add(inheritedProp);
      }

      //Node.Visualize(nodesMap.Values, "После добавления зависимостей на наследуемые свойства");

      def cycled2 = Node.Sort(newDependencyGraph);
      when (cycled2)
      {
        foreach (astProp when astProp.State == NodeState.Cycling in declaredPropNodes)
          _ = astProp.DependendOn.RemoveAll(inheritedProp => inheritedProp.State == NodeState.Cycling);
      }
      def cycled3 = Node.Sort(newDependencyGraph);

      //visualize(": После удаления ЗАЦИКЛИВАЮЩИХСЯ зависимостей на наследуемые свойства");

      assert2(!cycled3);

      newDependencyGraph
    }

    private CheckStageDependencies(dependencyGraph : Seq[Node]) : void
    {
      foreach (a in dependencyGraph)
      {
        | AssignProp as a =>
          def target = a.PropertyRef.Symbol;
          foreach (d in a.DependendOn)
          {
            def source = d.PropertyRef.Symbol;
            when (target.Stage < source.Stage)
            {
              Message.Error(a.Location, $"Reversing stage dependency detected: property '$(target.FullName)' from stage '$(target.Stage)' value depends on property '$(source.FullName)' from stage '$(source.Stage)'.");
              when (target.AssemblyId == AssemblyIds.CurrentAssembly)
                Message.Hint(target.FirstLocation.NLocation(), $"Assigned property from stage '$(target.Stage)'.");
              when (source.AssemblyId == AssemblyIds.CurrentAssembly)
                Message.Hint(source.FirstLocation.NLocation(), $"Dependend property from stage '$(source.Stage)'.");
            }
          }

        | _ => ()
      }
    }

    private GenerateCode(tb : TypeBuilder, dependencyGraph : Seq[Node]) : PExpr
    {
      def orderedNodes = dependencyGraph.ToArray();
      Array.Sort(orderedNodes, (l, r) => l.Order - r.Order);

      //Node.Visualize(nodesMap.Values, typeBuilder.Name);

      // Rendering code
      def result = SCG.List();
      result.Add(<[ _ = context ]>);
      foreach (node in orderedNodes)
      {
        | AssignProp    as a => 
          def code =
            if (a.DependendOn.Count > 0)
            {
              def conditions = a.DependendOn.Fold(<[ true ]>, (p, acc) =>  <[ $acc && $(GenerateHasValueCheck(p.Obj, p.PropertyRef)) ]>);
              <[
                unless ($(GenerateHasValueCheck(a.Obj, a.PropertyRef)))
                  if ($conditions)
                  {
                    $(a.Debug ?? a.Expr : typed);
                    context.CalculatedCountInc();
                  }
                  else
                    context.DeferredCountInc();
              ]>
            }
            else
            {
              <[
                unless ($(GenerateHasValueCheck(a.Obj, a.PropertyRef)))
                {
                  $(a.Expr : typed);
                  context.CalculatedCountInc();
                }
              ]>
            };

          def propertyStage = a.PropertyRef.Symbol.Stage;
          def code =
            if (propertyStage > 0)
              <[ when (context.Stage >= $propertyStage) $code ]>
            else
              code;

          result.Add(code);

        | UseProp         => ()
        | DeclaredProp(p) =>
          def propertyType = tb.GetMemType().TypeOfMember(p);
          when (propertyType.TryRequire(Environment.AstTypeVar))
            result.Add(<[ this.$(p.Name : global).EvalProperties(context) ]>);
      }

      def code = <[ { ..$result } ]>;
      code
    }
  }
}
