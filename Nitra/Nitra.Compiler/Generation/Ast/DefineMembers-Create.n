using Nemerle;
using Nemerle.Collections;
using Nemerle.Imperative;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Compiler.Typedtree;

using Nitra.Internal;
using Nitra.Model;
using Nitra.Typing;

using System;
using System.Diagnostics;
using System.Linq;
using SCG = System.Collections.Generic;

namespace Nitra.Compiler
{
  internal partial class RuleAstEmitter
  {
    private DefineBaseAstCreateMethod() : void
    {
      when (this.RuleSymbol is SimpleRuleSymbol)
      {
        _baseTb.DefineConditional(<[ decl:
          [Nemerle.Diagnostics.CompileStatistic("Ast")]
          public static Create(pos : ref int, size : int, parseResult : Nitra.ParseResult) : $(_baseTb.GetMemType() : typed)
          {
            def ruleParser = parseResult.RuleParser.Grammar.GetSimpleRuleParser($(this.RuleSymbol.GetRuleDescriptorRef()));
            if (size > 0 || ruleParser.CanParseEmptyString)
            {
              def astPtr = parseResult.TryGetAst(pos, ruleParser.RuleId);
              assert(astPtr > 0);
              $(_baseTb.GetMemType() : typed).__Parsed__Ast(ref pos, astPtr, parseResult)
            }
            else
              $(_baseTb.GetMemType() : typed).MissingAst(parseResult, pos)
          }
        ]>);

        _baseTb.DefineConditional(<[ decl:
          [Nemerle.Diagnostics.CompileStatistic("Ast")]
          public static Create(startPos : int, endPos : int, parseResult : Nitra.ParseResult) : $(_baseTb.GetMemType() : typed)
          {
            def ruleParser = parseResult.RuleParser.Grammar.GetSimpleRuleParser($(this.RuleSymbol.GetRuleDescriptorRef()));
            if (startPos < endPos || ruleParser.CanParseEmptyString)
            {
              match (parseResult.TryGetRecoveredSequence(startPos, endPos, ruleParser.ParsingSequence))
              {
                | null =>
                  mutable pos = startPos;
                  def astPtr = parseResult.TryGetAst(pos, ruleParser.RuleId);
                  def ast = $(_baseTb.GetMemType() : typed).__Parsed__Ast(ref pos, astPtr, parseResult);
                  assert(pos == endPos);
                  ast

                | Unambiguous(recoveredSubrulesIndex) => $(_baseTb.GetMemType() : typed).__Parsed__Ast(startPos, endPos, recoveredSubrulesIndex, parseResult)
                | Ambiguous(indexes)                  =>
                  def ambiguities = array(indexes.Length);
                  foreach (recoveredSubrulesIndex in indexes with i)
                    ambiguities[i] = $(_baseTb.GetMemType() : typed).__Parsed__Ast(startPos, endPos, recoveredSubrulesIndex, parseResult);
                  $(_ambiguousTb.GetMemType() : typed)(ambiguities)
              }
            }
            else
              $(_baseTb.GetMemType() : typed).MissingAst(parseResult, startPos)
          }
        ]>);
      }
      when (this.RuleSymbol.Options.IsStart)
      {
        match (this.RuleSymbol)
        {
          | SimpleRuleSymbol =>
            _baseTb.DefineConditional(<[ decl:
              [Nemerle.Diagnostics.CompileStatistic("Ast")]
              public static Create(parseResult : Nitra.ParseResult) : $(_baseTb.GetMemType() : typed)
              {
                Create(parseResult.StartPos, parseResult.Text.Length, parseResult);
              }
            ]>);

          | ExtensibleRuleSymbol =>
            _baseTb.DefineConditional(<[ decl:
              [Nemerle.Diagnostics.CompileStatistic("Ast")]
              public static Create(parseResult : Nitra.ParseResult) : $(_baseTb.GetMemType() : typed)
              {
                Nitra.Internal.ExtensibleRuleAstConstructor.Create(parseResult.StartPos, parseResult.Text.Length, parseResult, 0, $(this.RuleSymbol.GetRuleDescriptorRef()), Nitra.Internal.DefaultExtensibleRuleAstFactory.Instance);
              }
            ]>);

          | _ => assert2(false);
        }
      }
    }
  }
}
