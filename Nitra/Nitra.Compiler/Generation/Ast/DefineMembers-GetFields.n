using Nemerle;
using Nemerle.Collections;
using Nemerle.Imperative;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Compiler.Typedtree;

using Nitra.Internal;
using Nitra.Model;
using Nitra.Typing;

using System;
using System.Diagnostics;
using System.Linq;
using SCG = System.Collections.Generic;

namespace Nitra.Compiler
{
  internal partial class RuleAstEmitter
  {
    private variant FieldExpr
    {
      | Chars  { ExprStandardMode  : PExpr; ExprRecoveryMode : PExpr; }
      | Tuple  { Items : list[FieldExpr] }
      | Prefix { Expr  : PExpr }
      | Other  { ExprStandardMode  : PExpr; ExprRecoveryMode : PExpr; }
    }

    [Record]
    private class FieldInfo
    {
      public Name : string;
      public Rule : Rule;
      public Type : FixedType;
      public Expr : FieldExpr;
    }

    private GetFields() : SCG.List[FieldInfo]
    {
      def astPtr = AstPointer.Existing(this.RuleSymbol.Sequence, this, "astPtr");

      def ruleExprs = SCG.Dictionary.[Rule, FieldExpr](Rule.ReferenceEqualityComparer);

      when (this.RuleSymbol is ExtensionRuleSymbol(ExtensionType = Postfix(call, _)))
        ruleExprs.Add(call, FieldExpr.Prefix(<[ this.prefix ]>));

      def prevSubrules = SCG.List();
      foreach (subrule in this.RuleSymbol.Sequence.NonMarkerSubrules)
      {
        when (IsSubruleAcceptedForAst(subrule))
        {
          def parentAstPtr = AstPointerScope(astPtr);
          def valueExpr = CompileSubruleValueStandardMode(subrule, parentAstPtr);

          def statementsStandardMode = SCG.List();
          foreach (subrule in prevSubrules)
            statementsStandardMode.Add(WalkerGenerator.Skip(subrule, parentAstPtr));
          statementsStandardMode.Add(valueExpr);

          def statementsRecoveryMode = SCG.List();
          statementsRecoveryMode.Add(<[ def recoveredSubrulesIndex = ~this.astPtr ]>);
          statementsRecoveryMode.Add(CompileSubruleValueRecoveryMode(subrule));

          def expr =
            if (subrule.SrcRule.Type is RuleType.Chars)
              FieldExpr.Chars(<[ { ..$statementsStandardMode } ]>, <[ { ..$statementsRecoveryMode } ]>)
            else
              FieldExpr.Other(<[ { ..$statementsStandardMode } ]>, <[ { ..$statementsRecoveryMode } ]>);

          ruleExprs.Add(subrule.SrcRule, expr);
        }
        prevSubrules.Add(subrule);
      }

      def makeFieldExpr(rule : Rule) : FieldExpr
      {
        if (rule is Rule.Sequence(Rules = rules))
        {
          def members = SCG.List();
          foreach (rule when !(rule.Type is RuleType.Void) in rules)
            members.Add(makeFieldExpr(rule));

          if(members.Count == 1)
            members[0]
          else
            FieldExpr.Tuple(members.ToNList())
        }
        else
        {
          mutable expr;
          unless (ruleExprs.TryGetValue(rule, out expr))
            assert3(false);
          expr
        }
      }

      def fields = SCG.List();
      foreach (rule in this.RuleSymbol.NonVoidSubRules)
        fields.Add(FieldInfo(rule.FieldName, rule, Environment.GetAstType(rule.Type), makeFieldExpr(rule)));
      fields
    }

    private DefineReadSequenceMethod() : void
    {
      assert(_parsedAstTb != null);

      def astValues(cr : SequenceCompilationResult) : bool { !cr.IsSpan }

      def spanValues(cr : SequenceCompilationResult) : bool { cr.IsSpan }

      def makeIdSwitch(pred : SequenceCompilationResult -> bool, selector : SequenceCompilationResult -> PExpr) : PExpr
      {
        def cases = SCG.List();
        foreach (copilationResult when pred(copilationResult) in _sequenceCompilationResults.Values with index)
        {
          def code = selector(copilationResult);
          cases.Add(<[ case: | $(index : int) => $code ]>);
        }
        if (cases.Count > 0)
        {
          cases.Add(<[ case: | _ => throw System.ArgumentOutOfRangeException("id") ]>);
          <[ match (id) { ..$cases } ]>
        }
        else
          <[ throw System.ArgumentOutOfRangeException("id") ]>;
      }

      _parsedAstTb.DefineConditional(<[ decl:
        private __ReadSequenceAstStandardMode(id : int, pos : ref int) : Nitra.Ast
          implements Nitra.Internal.IAstSequenceLoader[Nitra.Ast].ReadSequence
        {
          unchecked { _ = id; _ = pos; $(makeIdSwitch(astValues, _.CodeStandardMode)) }
        }
      ]>);

      _parsedAstTb.DefineConditional(<[ decl:
        private __ReadSequenceSpanStandardMode(id : int, pos : ref int) : Nitra.NSpan
          implements Nitra.Internal.IAstSequenceLoader[Nitra.NSpan].ReadSequence
        {
          unchecked { _ = id; _ = pos; $(makeIdSwitch(spanValues, _.CodeStandardMode)) }
        }
      ]>);

      _parsedAstTb.DefineConditional(<[ decl:
        private __ReadSequenceAstRecoveryMode(id : int, recoveredSubrulesIndex : int) : Nitra.Ast
          implements Nitra.Internal.IAstSequenceLoader[Nitra.Ast].ReadSequence
        {
          unchecked { _ = id; _ = recoveredSubrulesIndex; $(makeIdSwitch(astValues, _.CodeRecoveryMode)) }
        }
      ]>);

      _parsedAstTb.DefineConditional(<[ decl:
        private __ReadSequenceSpanRecoveryMode(id : int, recoveredSubrulesIndex : int) : Nitra.NSpan
          implements Nitra.Internal.IAstSequenceLoader[Nitra.NSpan].ReadSequence
        {
          unchecked { _ = id; _ = recoveredSubrulesIndex; $(makeIdSwitch(spanValues, _.CodeRecoveryMode)) }
        }
      ]>);

      _parsedAstTb.DefineConditional(<[ decl:
        private __ReadEmptySequenceAst(id : int, _subruleStartPos : int) : Nitra.Ast
          implements Nitra.Internal.IAstSequenceLoader[Nitra.Ast].ReadEmptySequence
        {
          unchecked { _ = id; $(makeIdSwitch(astValues, _.EmptyCodeRecoveryMode)) }
        }
      ]>);

      _parsedAstTb.DefineConditional(<[ decl:
        private __ReadEmptySequenceSpan(id : int, _subruleStartPos : int) : Nitra.NSpan
          implements Nitra.Internal.IAstSequenceLoader[Nitra.NSpan].ReadEmptySequence
        {
          unchecked { _ = id; $(makeIdSwitch(spanValues, _.EmptyCodeRecoveryMode)) }
        }
      ]>);
    }

    [RecordIgnore]
    private _sequenceCompilationResults : SCG.Dictionary[SequenceCompileInfo, SequenceCompilationResult] = SCG.Dictionary();

    [Record]
    private sealed class SequenceCompilationResult
    {
      public Sequence : SequenceCompileInfo;
      public Id : int;
      public IsSpan : bool;
      public CodeStandardMode : PExpr;
      public CodeRecoveryMode : PExpr;
      public EmptyCodeRecoveryMode : PExpr;
    }

    private CompileSequence(sequence : SequenceCompileInfo) : SequenceCompilationResult
    {
      mutable compilationResult;
      unless (_sequenceCompilationResults.TryGetValue(sequence, out compilationResult))
      {
        def nameToExpr(varName : string, _ : SubruleCompileInfo) : PExpr { <[ $(varName : usesite) ]> }

        def astPointer                  = AstPointerScope(sequence, "p", this);
        def subruleValues               = SCG.List();
        def statementsStandardMode      = SCG.List();
        def statementsRecoveryMode      = SCG.List();
        def statementsEmptyRecoveryMode = SCG.List();

        foreach (subrule in sequence.NonMarkerSubrules)
        {
          if (IsSubruleAcceptedForAst(subrule))
          {
            def varName = subrule.MakeVariableName("ast");
            subruleValues.Add(varName, subrule);

            statementsStandardMode.Add(<[ def $(varName : usesite) = $(CompileSubruleValueStandardMode(subrule, astPointer)) ]>);
            statementsRecoveryMode.Add(<[ def $(varName : usesite) = $(CompileSubruleValueRecoveryMode(subrule)) ]>);
            statementsEmptyRecoveryMode.Add(<[ def $(varName : usesite) = $(CompileEmptySubruleValueRecoveryMode(subrule, false)) ]>);
          }
          else
            statementsStandardMode.Add(WalkerGenerator.Skip(subrule, astPointer));
        }

        match (subruleValues.Count)
        {
          | 0 =>
            statementsStandardMode.Add(<[ null ]>);
            statementsRecoveryMode.Add(<[ null ]>);
            statementsEmptyRecoveryMode.Add(<[ null ]>);

          | 1 =>
            statementsStandardMode.Add(nameToExpr(subruleValues[0]));
            statementsRecoveryMode.Add(nameToExpr(subruleValues[0]));
            statementsEmptyRecoveryMode.Add(nameToExpr(subruleValues[0]));

          | _ =>
            statementsStandardMode.Insert(0, <[ def sequenceStartPos = pos; ]>);
            statementsStandardMode.Add(<[ Nitra.SequenceAst(Nitra.Location(parseResult.OriginalSource, sequenceStartPos, pos), ..$(subruleValues.MapToList(nameToExpr))) ]>);

            statementsRecoveryMode.Add(<[ def (sequenceStartPos, sequenceEndPos) = parseResult.GetRecoveredSubruleSpan(recoveredSubrulesIndex); ]>);
            statementsRecoveryMode.Add(<[ Nitra.SequenceAst(Nitra.Location(parseResult.OriginalSource, sequenceStartPos, sequenceEndPos), ..$(subruleValues.MapToList(nameToExpr))) ]>);

            statementsEmptyRecoveryMode.Add(<[ Nitra.SequenceAst(Nitra.Location(parseResult.OriginalSource, _subruleStartPos, _subruleStartPos), ..$(subruleValues.MapToList(nameToExpr))) ]>);
        }

        def id               = _sequenceCompilationResults.Count;
        def isSpan           = subruleValues.Count == 1 && subruleValues[0][1].SrcRule.Type is RuleType.Chars;

        def codeStandardMode =
        {
          def codeWithoutRuleParser = astPointer.Compile(<[ { ..$statementsStandardMode } ]>);
          if (astPointer.IsAccessed())
            <[
              def ruleParser = parseResult.GetRuleParser(astPtr) :> $(this.RuleSymbol.GetParserClassRef());
              $codeWithoutRuleParser
            ]>
          else
            codeWithoutRuleParser;
        };

        def codeRecoveryMode      = <[ { ..$statementsRecoveryMode } ]>;

        def emptyCodeRecoveryMode = <[ { ..$statementsEmptyRecoveryMode } ]>;

        compilationResult = SequenceCompilationResult(sequence, id, isSpan, codeStandardMode, codeRecoveryMode, emptyCodeRecoveryMode);
        _sequenceCompilationResults[sequence] = compilationResult;
      }
      compilationResult
    }

    private GetArgumentsForCreateAst(compilationResult : SequenceCompilationResult) : PExpr * PExpr * int * PExpr
    {
      if (compilationResult.IsSpan)
      {
        def spanType = Environment.NSpanTypeVar;
        (<[ $(spanType : typed) ]>, <[ $(spanType : typed) ]>, compilationResult.Id, <[ Nitra.Internal.NSpanCast.Instance ]>)
      }
      else
      {
        def loaderType = Environment.AstTypeVar;
        def astType    = Environment.GetAstType(compilationResult.Sequence.SrcRule.Type);
        (<[ $(loaderType : typed) ]>, <[ $(astType : typed) ]>, compilationResult.Id, <[ Nitra.Internal.AstCast.[$(astType : typed)].Instance ]>)
      }
    }

    private CompileSubruleValueStandardMode(subrule : SubruleCompileInfo, parentAstPointer : AstPointerScope) : PExpr
    {
      match (subrule)
      {
        | Empty      as subrule => WalkerGenerator.Skip(subrule, parentAstPointer)
        | SimpleCall as subrule =>
          if (subrule.Symbol.Type is RuleType.Void)
            WalkerGenerator.Skip(subrule, parentAstPointer)
          else if (subrule.CanParseEmptyString)
            <[
              pos += $(parentAstPointer.Access().GetSkip(subrule));
              $(Environment.GetAstType(subrule.Symbol) : typed).Create(ref pos, parseResult);
            ]>
          else
            <[
              pos += $(parentAstPointer.Access().GetSkip(subrule));
              if ($(parentAstPointer.Access().GetSize(subrule)) > 0)
                $(Environment.GetAstType(subrule.Symbol) : typed).Create(ref pos, parseResult);
              else
                $(Environment.GetAstType(subrule.Symbol) : typed).MissingAst(parseResult, pos);
            ]>

        | ExtensibleCall as subrule =>
          if (subrule.Symbol.Type is RuleType.Void)
            WalkerGenerator.Skip(subrule, parentAstPointer)
          else
            <[
              pos += $(parentAstPointer.Access().GetSkip(subrule));
              if ($(parentAstPointer.Access().GetSize(subrule)) > 0)
                Nitra.Internal.ExtensibleRuleAstConstructor.Create.[$(Environment.GetAstType(subrule.Symbol) : typed)](ref pos, parseResult, $(subrule.BindingPower : int), $(subrule.Symbol.GetRuleDescriptorRef()), Nitra.Internal.DefaultExtensibleRuleAstFactory.Instance);
              else
                $(Environment.GetAstType(subrule.Symbol) : typed).MissingAst(parseResult, pos); // No prefix
            ]>

        | RegularCall
        | List(IsSkipAnyPattern = true)
        | TokenString => WalkerGenerator.GetTokenValue(subrule, parentAstPointer, <[ Nitra.NSpan(tokenPos, pos) ]>)
        | Option(itemSequence) as subrule =>
          if (subrule.SrcRule.Type is RuleType.Void)
            WalkerGenerator.Skip(subrule, parentAstPointer)
          else
          {
            def (loaderType, itemType, id, converter) = GetArgumentsForCreateAst(CompileSequence(itemSequence));
            <[ Nitra.Internal.AstFactory.CreateOption.[$loaderType, $itemType](this.parseResult, this, $(id : int), $converter, this.astPtr, $(subrule.Offset), ref pos) ]>
          }

        | List(Rule = itemSequence) =>
          if (subrule.SrcRule.Type is RuleType.Void)
            WalkerGenerator.Skip(subrule, parentAstPointer)
          else
          {
            def (loaderType, itemType, id, converter) = GetArgumentsForCreateAst(CompileSequence(itemSequence));
            <[ Nitra.Internal.AstFactory.CreateList.[$loaderType, $itemType](this.parseResult, this, $(id : int), $converter, this.astPtr, $(subrule.Offset), ref pos) ]>
          }

        | ListWithSeparator(Rule = itemSequence, Separator = separatorSequence)=>
          match (itemSequence.SrcRule.Type, separatorSequence.SrcRule.Type)
          {
            | (Void, Void) => WalkerGenerator.Skip(subrule, parentAstPointer)
            | (_, Void) =>
              def (itemLoaderType, itemType, itemSequenceId, itemConverter) = GetArgumentsForCreateAst(CompileSequence(itemSequence));
              def (separatorLoaderType, _, separatorSequenceId, _)          = GetArgumentsForCreateAst(CompileSequence(separatorSequence));
              <[ Nitra.Internal.AstFactory.CreateListWithSeparatorOnlyItems.[$itemLoaderType, $itemType, $separatorLoaderType](this.parseResult, this, $(itemSequenceId : int), $itemConverter, this, $(separatorSequenceId : int), this.astPtr, $(subrule.Offset), ref pos) ]>

            | (Void, _) =>
              def (itemLoaderType, _, itemSequenceId, _)                                        = GetArgumentsForCreateAst(CompileSequence(itemSequence));
              def (separatorLoaderType, separatorType, separatorSequenceId, separatorConverter) = GetArgumentsForCreateAst(CompileSequence(separatorSequence));
              <[ Nitra.Internal.AstFactory.CreateListWithSeparatorOnlySeparators.[$itemLoaderType, $separatorLoaderType, $separatorType](this.parseResult, this, $(itemSequenceId : int), this, $(separatorSequenceId : int), $separatorConverter, this.astPtr, $(subrule.Offset), ref pos) ]>

            | _ =>
              def (itemLoaderType, itemType, itemSequenceId, itemConverter)                     = GetArgumentsForCreateAst(CompileSequence(itemSequence));
              def (separatorLoaderType, separatorType, separatorSequenceId, separatorConverter) = GetArgumentsForCreateAst(CompileSequence(separatorSequence));
              <[ Nitra.Internal.AstFactory.CreateListWithSeparator.[$itemLoaderType, $itemType, $separatorLoaderType, $separatorType](this.parseResult, this, $(itemSequenceId : int), $itemConverter, this, $(separatorSequenceId : int), $separatorConverter, this.astPtr, $(subrule.Offset), ref pos) ]>
          }

        | Marker => <[ () ]>
      }
    }

    private CompileSubruleValueRecoveryMode(subrule : SubruleCompileInfo) : PExpr
    {
      def recoveredValue = match (subrule)
      {
        | Empty => <[ () ]>
        | SimpleCall as subrule =>
          if (subrule.Symbol.Type is RuleType.Void)
            <[ () ]>
          else if (subrule.CanParseEmptyString)
            <[ $(Environment.GetAstType(subrule.Symbol) : typed).Create(_subruleStartPos, _subruleEndPos, parseResult) ]>
          else
            <[
              if (_subruleStartPos < _subruleEndPos)
                $(Environment.GetAstType(subrule.Symbol) : typed).Create(_subruleStartPos, _subruleEndPos, parseResult)
              else
                $(Environment.GetAstType(subrule.Symbol) : typed).MissingAst(parseResult, _subruleStartPos);
            ]>

        | ExtensibleCall as subrule =>
          if (subrule.Symbol.Type is RuleType.Void)
            <[ () ]>
          else
            <[
              if (_subruleStartPos < _subruleEndPos)
                Nitra.Internal.ExtensibleRuleAstConstructor.Create.[$(Environment.GetAstType(subrule.Symbol) : typed)](_subruleStartPos, _subruleEndPos, parseResult, $(subrule.BindingPower : int), $(subrule.Symbol.GetRuleDescriptorRef()), Nitra.Internal.DefaultExtensibleRuleAstFactory.Instance);
              else
                $(Environment.GetAstType(subrule.Symbol) : typed).MissingAst(parseResult, _subruleStartPos); // No prefix
            ]>

        | RegularCall
        | List as lst when lst.IsSkipAnyPattern
        | TokenString    => <[ Nitra.NSpan(_subruleStartPos, _subruleEndPos) ]>
        | Option(Rule = itemSequence) =>
          if (subrule.SrcRule.Type is RuleType.Void)
            <[ () ]>
          else
          {
            def (loaderType, itemType, id, converter) = GetArgumentsForCreateAst(CompileSequence(itemSequence));
            <[ Nitra.Internal.AstFactory.CreateOption.[$loaderType, $itemType](this.parseResult, this, $(id : int), $converter, parsingSequence, state, _subruleStartPos, _subruleEndPos) ]>
          }

        | List(Rule = itemSequence) =>
          if (subrule.SrcRule.Type is RuleType.Void)
            <[ () ]>
          else
          {
            def (loaderType, itemType, id, converter) = GetArgumentsForCreateAst(CompileSequence(itemSequence));
            <[ Nitra.Internal.AstFactory.CreateList.[$loaderType, $itemType](this.parseResult, this, $(id : int), $converter, parsingSequence, state, _subruleStartPos, _subruleEndPos) ]>
          }

        | ListWithSeparator(Rule = itemSequence, Separator = separatorSequence) =>
          match (itemSequence.SrcRule.Type, separatorSequence.SrcRule.Type)
          {
            | (Void, Void) => <[ () ]>
            | (_, Void)    =>
              def (itemLoaderType, itemType, itemSequenceId, itemConverter) = GetArgumentsForCreateAst(CompileSequence(itemSequence));
              <[
                Nitra.Internal.AstFactory.CreateListWithSeparatorOnlyItems.[$itemLoaderType, $itemType](
                  this.parseResult, this, $(itemSequenceId : int), $itemConverter, parsingSequence, state, _subruleStartPos, _subruleEndPos)
              ]>

            | (Void, _)    =>
              def (separatorLoaderType, separatorType, separatorSequenceId, separatorConverter) = GetArgumentsForCreateAst(CompileSequence(separatorSequence));
              <[
                Nitra.Internal.AstFactory.CreateListWithSeparatorOnlySeparators.[$separatorLoaderType, $separatorType](
                  this.parseResult, this, $(separatorSequenceId : int), $separatorConverter, parsingSequence, state, _subruleStartPos, _subruleEndPos)
              ]>

            | _ =>
              def (itemLoaderType, itemType, itemSequenceId, itemConverter)                     = GetArgumentsForCreateAst(CompileSequence(itemSequence));
              def (separatorLoaderType, separatorType, separatorSequenceId, separatorConverter) = GetArgumentsForCreateAst(CompileSequence(separatorSequence));
              <[
                Nitra.Internal.AstFactory.CreateListWithSeparator.[$itemLoaderType, $itemType, $separatorLoaderType, $separatorType](
                  this.parseResult, this, $(itemSequenceId : int), $itemConverter, this, $(separatorSequenceId : int), $separatorConverter, parsingSequence, state, _subruleStartPos, _subruleEndPos)
              ]>
          }

        | Marker => <[ () ]>
      };

      def skippedValue = CompileEmptySubruleValueRecoveryMode(subrule, true);

      <[
        def (subruleStarts, parsingSequence) = parseResult.RecoveredSubrules[recoveredSubrulesIndex];
        def state = parsingSequence.GetEarleyState($(subrule.State : int));
        match (this.parseResult.FindRecoveredSubrule(subruleStarts, state))
        {
          | (true, _subruleStartPos, _subruleEndPos)  => $recoveredValue
          | (false, _subruleStartPos, _subruleEndPos) => $skippedValue
        }
      ]>
    }

    private CompileEmptySubruleValueRecoveryMode(subrule : SubruleCompileInfo, allowEmptySpan : bool) : PExpr
    {
      match (subrule)
      {
        | Empty => <[ () ]>
        | SimpleCall as subrule =>
          if (subrule.Symbol.Type is RuleType.Void)
            <[ () ]>
          else if (allowEmptySpan && subrule.CanParseEmptyString)
            <[ $(Environment.GetAstType(subrule.Symbol) : typed).Create(_subruleStartPos, _subruleStartPos, parseResult) ]>
          else
            <[ $(Environment.GetAstType(subrule.Symbol) : typed).MissingAst(parseResult, _subruleStartPos); ]>

        | ExtensibleCall as subrule =>
          if (subrule.Symbol.Type is RuleType.Void)
            <[ () ]>
          else
            <[ $(Environment.GetAstType(subrule.Symbol) : typed).MissingAst(parseResult, _subruleStartPos); ]>

        | RegularCall
        | List as lst when lst.IsSkipAnyPattern
        | TokenString => <[ Nitra.NSpan(_subruleStartPos, _subruleStartPos) ]>

        | Option as subrule =>
          if (subrule.SrcRule.Type is RuleType.Void)
            <[ () ]>
          else
            <[ Nitra.OptionAst.None(Nitra.Location(parseResult.OriginalSource, _subruleStartPos, _subruleStartPos)) ]>

        | List as lst =>
          if (lst.SrcRule.Type is RuleType.Void)
            <[ () ]>
          else
            <[ Nitra.ListAst(Nitra.Location(parseResult.OriginalSource, _subruleStartPos, _subruleStartPos)) ]>

        | ListWithSeparator as lst =>
          match (lst.Rule.SrcRule.Type, lst.Separator.SrcRule.Type)
          {
            | (Void, Void) => <[ () ]>
            | (_, Void)    => <[ Nitra.ListAst(Nitra.Location(parseResult.OriginalSource, _subruleStartPos, _subruleStartPos)) ]>
            | (Void, _)    => <[ Nitra.ListAst(Nitra.Location(parseResult.OriginalSource, _subruleStartPos, _subruleStartPos)) ]>
            | _            =>
              <[
                Nitra.SequenceAst(
                  Nitra.Location(parseResult.OriginalSource, _subruleStartPos, _subruleStartPos),
                  Nitra.ListAst(Nitra.Location(parseResult.OriginalSource, _subruleStartPos, _subruleStartPos)),
                  Nitra.ListAst(Nitra.Location(parseResult.OriginalSource, _subruleStartPos, _subruleStartPos)))
              ]>
          }

        | Marker => <[ () ]>
      }
    }

    public static IsSubruleAcceptedForAst(subrule : SubruleCompileInfo) : bool
    {
      | SimpleCall(symbol)        when symbol.Type is RuleType.Void
      | ExtensibleCall(symbol, _) when symbol.Type is RuleType.Void
      | Empty
      | Marker => false
      | _ => !(subrule.SrcRule.Type is RuleType.Void)
    }
  }
}
