using Nemerle;
using Nemerle.Collections;
using Nemerle.Imperative;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Compiler.Typedtree;

using Nitra.Internal;
using Nitra.Model;
using Nitra.Typing;

using System;
using System.Diagnostics;
using System.Linq;
using SCG = System.Collections.Generic;

namespace Nitra.Compiler
{
  internal partial class RuleAstEmitter
  {
    private variant FieldExpr
    {
      | Chars  { ExprStandardMode  : PExpr; NeedRuleParser : bool; ExprRecoveryMode : PExpr; }
      | Tuple  { Items : list[FieldExpr] }
      | Prefix { Expr  : PExpr }
      | Other  { ExprStandardMode  : PExpr; NeedRuleParser : bool; ExprRecoveryMode : PExpr; }
    }

    [Record]
    private class FieldInfo
    {
      public Name : string;
      public Rule : Rule;
      public Type : FixedType;
      public Expr : FieldExpr;
    }

    private GetFields() : SCG.List[FieldInfo]
    {
      def astPtr = AstPointer.Existing(this.RuleSymbol.Sequence, this, "astPtr");

      def ruleExprs = SCG.Dictionary.[Rule, FieldExpr](Rule.ReferenceEqualityComparer);

      when (this.RuleSymbol is ExtensionRuleSymbol(ExtensionType = Postfix(call, _)))
        ruleExprs.Add(call, FieldExpr.Prefix(<[ this.prefix ]>));

      def prevSubrules = SCG.List();
      foreach (subrule in this.RuleSymbol.Sequence.NonMarkerSubrules)
      {
        when (IsSubruleAcceptedForAst(subrule))
        {
          def parentAstPtr = AstPointerScope(astPtr);
          def valueExpr = CompileSubruleValueStandardMode(subrule, parentAstPtr);

          def statementsStandardMode = SCG.List();
          foreach (subrule in prevSubrules)
            statementsStandardMode.Add(WalkerGenerator.Skip(subrule, parentAstPtr));
          statementsStandardMode.Add(valueExpr);

          def statementsRecoveryMode = SCG.List();
          statementsRecoveryMode.Add(<[ def recoveredSubrulesIndex = ~this.astPtr ]>);
          statementsRecoveryMode.Add(GetSubruleValueRecoveryMode(subrule));

          def expr =
            if (subrule.SrcRule.Type is RuleType.Chars)
              FieldExpr.Chars(<[ { ..$statementsStandardMode } ]>, false, <[ { ..$statementsRecoveryMode } ]>)
            else
              FieldExpr.Other(<[ { ..$statementsStandardMode } ]>, false, <[ { ..$statementsRecoveryMode } ]>);

          ruleExprs.Add(subrule.SrcRule, expr);
        }
        prevSubrules.Add(subrule);
      }

      def makeFieldExpr(rule : Rule) : FieldExpr
      {
        if (rule is Rule.Sequence(Rules = rules))
        {
          def members = SCG.List();
          foreach (rule when !(rule.Type is RuleType.Void) in rules)
            members.Add(makeFieldExpr(rule));

          if(members.Count == 1)
            members[0]
          else
            FieldExpr.Tuple(members.ToNList())
        }
        else
        {
          mutable expr;
          unless (ruleExprs.TryGetValue(rule, out expr))
            assert3(false);
          expr
        }
      }

      def fields = SCG.List();
      foreach (rule in this.RuleSymbol.NonVoidSubRules)
        fields.Add(FieldInfo(rule.FieldName, rule, Environment.GetAstType(rule.Type), makeFieldExpr(rule)));
      fields
    }

    private DefineReadSequenceMethod() : void
    {
      assert(_parsedAstTb != null);

      def readSequenceAstBody =
        if (_sequencesAstStandardMode.Count > 0)
        {
          def cases = SCG.List();
          foreach (code in _sequencesAstStandardMode with index)
            cases.Add(<[ case: | $(index : int) => $code ]>);
          cases.Add(<[ case: | _ => throw System.ArgumentOutOfRangeException("id") ]>);
          <[ match (id) { ..$cases } ]>
        }
        else
          <[ throw System.ArgumentOutOfRangeException("id") ]>;

      _parsedAstTb.DefineConditional(<[ decl:
        private __ReadSequenceAst(id : int, pos : ref int) : Nitra.Ast
          implements Nitra.Internal.IAstSequenceLoader[Nitra.Ast].ReadSequence
        {
          unchecked { _ = id; _ = pos; $readSequenceAstBody }
        }
      ]>);

      def readSequenceSpanBody =
        if (_sequencesSpanStandardMode.Count > 0)
        {
          def cases = SCG.List();
          foreach (code in _sequencesSpanStandardMode with index)
            cases.Add(<[ case: | $(index : int) => $code ]>);
          cases.Add(<[ case: | _ => throw System.ArgumentOutOfRangeException("id") ]>);
          <[ match (id) { ..$cases } ]>
        }
        else
          <[ throw System.ArgumentOutOfRangeException("id") ]>;


      _parsedAstTb.DefineConditional(<[ decl:
        private __ReadSequenceSpan(id : int, pos : ref int) : Nitra.NSpan
          implements Nitra.Internal.IAstSequenceLoader[Nitra.NSpan].ReadSequence
        {
          unchecked { _ = id; _ = pos; $readSequenceSpanBody }
        }
      ]>)
    }

    [RecordIgnore]
    private _sequencesAstStandardMode  : SCG.List[PExpr] = SCG.List();

    [RecordIgnore]
    private _sequencesSpanStandardMode : SCG.List[PExpr] = SCG.List();

    private CompileSequenceValueStandardMode(sequence : SequenceCompileInfo, name : string) : PExpr * PExpr * int
    {
      def astPointer    = AstPointerScope(sequence, name, this);
      def statements    = SCG.List();
      def subrules      = SCG.List();
      def subruleValues = SCG.List();

      foreach (subrule in sequence.NonMarkerSubrules)
      {
        if (IsSubruleAcceptedForAst(subrule))
        {
          def varName = subrule.MakeVariableName("ast");
          statements.Add(<[ def $(varName : usesite) = $(CompileSubruleValueStandardMode(subrule, astPointer)) ]>);
          subruleValues.Add(<[ $(varName : usesite) ]>);
          subrules.Add(subrule);
        }
        else
          statements.Add(WalkerGenerator.Skip(subrule, astPointer));
      }

      match (subruleValues.Count)
      {
        | 0 => statements.Add(<[ null ]>);
        | 1 => statements.Add(subruleValues[0]);
        | _ =>
          statements.Insert(0, <[ def sequenceStartPos = pos; ]>);
          statements.Add(<[ Nitra.SequenceAst(Nitra.Location(parseResult.OriginalSource, sequenceStartPos, pos), ..$subruleValues) ]>);
      }

      def code = astPointer.Compile(<[ { ..$statements } ]>);
      def codeWithRuleParser = if (astPointer.IsAccessed())
        <[  def ruleParser = parseResult.GetRuleParser(astPtr) :> $(this.RuleSymbol.GetParserClassRef()); $code ]>
      else
        code;

      if (subrules.Count == 1 && subrules[0].SrcRule.Type is RuleType.Chars)
      {
        def id = _sequencesSpanStandardMode.Count();
        _sequencesSpanStandardMode.Add(codeWithRuleParser);
        (<[ $(Environment.NSpanTypeVar : typed) ]>, <[ $(Environment.GetAstType(sequence.SrcRule.Type) : typed) ]>, id)
      }
      else
      {
        def id = _sequencesAstStandardMode.Count();
        _sequencesAstStandardMode.Add(codeWithRuleParser);
        (<[ $(Environment.AstTypeVar : typed) ]>, <[ $(Environment.GetAstType(sequence.SrcRule.Type) : typed) ]>, id)
      }
    }

    private CompileSubruleValueStandardMode(subrule : SubruleCompileInfo, parentAstPointer : AstPointerScope) : PExpr
    {
      match (subrule)
      {
        | Empty      as subrule => WalkerGenerator.Skip(subrule, parentAstPointer)
        | SimpleCall as subrule =>
          if (subrule.Symbol.Type is RuleType.Void)
            WalkerGenerator.Skip(subrule, parentAstPointer)
          else if (subrule.CanParseEmptyString)
            <[
              pos += $(parentAstPointer.Access().GetSkip(subrule));
              $(Environment.GetAstType(subrule.Symbol) : typed).Create(ref pos, parseResult);
            ]>
          else
            <[
              pos += $(parentAstPointer.Access().GetSkip(subrule));
              if ($(parentAstPointer.Access().GetSize(subrule)) > 0)
                $(Environment.GetAstType(subrule.Symbol) : typed).Create(ref pos, parseResult);
              else
                $(Environment.GetAstType(subrule.Symbol) : typed).MissingAst(parseResult, pos);
            ]>

        | ExtensibleCall as subrule =>
          if (subrule.Symbol.Type is RuleType.Void)
            WalkerGenerator.Skip(subrule, parentAstPointer)
          else
            <[
              pos += $(parentAstPointer.Access().GetSkip(subrule));
              if ($(parentAstPointer.Access().GetSize(subrule)) > 0)
                Nitra.Internal.ExtensibleRuleAstConstructor.Create.[$(Environment.GetAstType(subrule.Symbol) : typed)](ref pos, parseResult, $(subrule.BindingPower : int), $(subrule.Symbol.GetRuleDescriptorRef()), Nitra.Internal.DefaultExtensibleRuleAstFactory.Instance);
              else
                $(Environment.GetAstType(subrule.Symbol) : typed).MissingAst(parseResult, pos); // No prefix
            ]>

        | RegularCall
        | List(IsSkipAnyPattern = true)
        | TokenString => WalkerGenerator.GetTokenValue(subrule, parentAstPointer, <[ Nitra.NSpan(tokenPos, pos) ]>)
        | Option(itemSequence) as subrule =>
          if (subrule.SrcRule.Type is RuleType.Void)
            WalkerGenerator.Skip(subrule, parentAstPointer)
          else
          {
            def (loaderType, itemType, id) = CompileSequenceValueStandardMode(itemSequence, "valuePointer");
            <[ Nitra.Internal.AstFactory.CreateOption.[$loaderType, $itemType](this, this.parseResult, this.astPtr, $(subrule.Offset), $(id : int), ref pos) ]>
          }

        | List(Rule = itemSequence) =>
          if (subrule.SrcRule.Type is RuleType.Void)
            WalkerGenerator.Skip(subrule, parentAstPointer)
          else
          {
            def (loaderType, itemType, id) = CompileSequenceValueStandardMode(itemSequence, "valuePointer");
            <[ Nitra.Internal.AstFactory.CreateList.[$loaderType, $itemType](this, this.parseResult, this.astPtr, $(subrule.Offset), $(id : int), ref pos) ]>
          }

        | ListWithSeparator(Rule = itemSequence, Separator = separatorSequence)=>
          match (itemSequence.SrcRule.Type, separatorSequence.SrcRule.Type)
          {
            | (Void, Void) => WalkerGenerator.Skip(subrule, parentAstPointer)
            | (_, Void) =>
              def (itemLoaderType, itemType, itemSequenceId)    = CompileSequenceValueStandardMode(itemSequence, "itemPointer");
              def (separatorLoaderType, _, separatorSequenceId) = CompileSequenceValueStandardMode(separatorSequence, "separatorPointer");
              <[ Nitra.Internal.AstFactory.CreateListWithSeparatorOnlyItems.[$itemLoaderType, $itemType, $separatorLoaderType](this, this, this.parseResult, this.astPtr, $(subrule.Offset), $(itemSequenceId : int), $(separatorSequenceId : int), ref pos) ]>

            | (Void, _) =>
              def (itemLoaderType, _, itemSequenceId)                       = CompileSequenceValueStandardMode(itemSequence, "itemPointer");
              def (separatorLoaderType, separatorType, separatorSequenceId) = CompileSequenceValueStandardMode(separatorSequence, "separatorPointer");
              <[ Nitra.Internal.AstFactory.CreateListWithSeparatorOnlySeparators.[$itemLoaderType, $separatorLoaderType, $separatorType](this, this, this.parseResult, this.astPtr, $(subrule.Offset), $(itemSequenceId : int), $(separatorSequenceId : int), ref pos) ]>

            | _ =>
              def (itemLoaderType, itemType, itemSequenceId)                = CompileSequenceValueStandardMode(itemSequence, "itemPointer");
              def (separatorLoaderType, separatorType, separatorSequenceId) = CompileSequenceValueStandardMode(separatorSequence, "separatorPointer");
              <[ Nitra.Internal.AstFactory.CreateListWithSeparator.[$itemLoaderType, $itemType, $separatorLoaderType, $separatorType](this, this, this.parseResult, this.astPtr, $(subrule.Offset), $(itemSequenceId : int), $(separatorSequenceId : int), ref pos) ]>
          }

        | Marker => <[ () ]>
      }
    }

    private GetSequenceValueRecoveryMode(sequence : SequenceCompileInfo) : PExpr
    {
      def statements    = SCG.List();
      def subruleValues = SCG.List();

      foreach (subrule when IsSubruleAcceptedForAst(subrule) in sequence.NonMarkerSubrules)
      {
        def varName = subrule.MakeVariableName("ast");
        statements.Add(<[ def $(varName : usesite) = $(GetSubruleValueRecoveryMode(subrule)) ]>);
        subruleValues.Add(<[ $(varName : usesite) ]>);
      }

      match (subruleValues.Count)
      {
        | 0 => ()
        | 1 => statements.Add(subruleValues[0]);
        | _ =>
          statements.Insert(0, <[ def sequenceStartPos = _subruleStartPos; ]>);
          statements.Insert(1, <[ def sequenceEndPos   = _subruleEndPos; ]>);
          statements.Add(<[ Nitra.SequenceAst(Nitra.Location(parseResult.OriginalSource, sequenceStartPos, sequenceEndPos), ..$subruleValues) ]>);
      }

      <[
        mutable recoveredSequence;
        if (parseResult.RecoveredSequences.TryGetValue((_subruleStartPos, _subruleEndPos, parsingSequence), out recoveredSequence))
        {
          match (recoveredSequence)
          {
            | Unambiguous(recoveredSubrulesIndex) => { ..$statements }
            | Ambiguous                           => throw System.NotImplementedException("Ambiguous recovery mode AST reading not implemented")
          }
        }
        else throw System.NotImplementedException("Fallback to standard mode AST reading not implemented")
      ]>
    }

    private GetSubruleValueRecoveryMode(subrule : SubruleCompileInfo) : PExpr
    {
      def recoveredValue = match (subrule)
      {
        | Empty => <[ () ]>
        | SimpleCall as subrule =>
          if (subrule.Symbol.Type is RuleType.Void)
            <[ () ]>
          else if (subrule.CanParseEmptyString)
            <[ $(Environment.GetAstType(subrule.Symbol) : typed).Create(_subruleStartPos, _subruleEndPos, parseResult) ]>
          else
            <[
              if (_subruleStartPos < _subruleEndPos)
                $(Environment.GetAstType(subrule.Symbol) : typed).Create(_subruleStartPos, _subruleEndPos, parseResult)
              else
                $(Environment.GetAstType(subrule.Symbol) : typed).MissingAst(parseResult, _subruleStartPos);
            ]>

        | ExtensibleCall as subrule =>
          if (subrule.Symbol.Type is RuleType.Void)
            <[ () ]>
          else
            <[
              if (_subruleStartPos < _subruleEndPos)
                Nitra.Internal.ExtensibleRuleAstConstructor.Create.[$(Environment.GetAstType(subrule.Symbol) : typed)](_subruleStartPos, _subruleEndPos, parseResult, $(subrule.BindingPower : int), $(subrule.Symbol.GetRuleDescriptorRef()), Nitra.Internal.DefaultExtensibleRuleAstFactory.Instance);
              else
                $(Environment.GetAstType(subrule.Symbol) : typed).MissingAst(parseResult, _subruleStartPos); // No prefix
            ]>

        | RegularCall
        | List as lst when lst.IsSkipAnyPattern
        | TokenString    => <[ Nitra.NSpan(_subruleStartPos, _subruleEndPos) ]>
        | Option as subrule =>
          if (subrule.SrcRule.Type is RuleType.Void)
            <[ () ]>
          else
            <[
              if (_subruleStartPos < _subruleEndPos)
              {
                def parsingSequence = (parsingSequence.States[state].Subrule :> Nitra.Runtime.Reflection.SubruleInfo.Option).Rule.ParsingSequence;
                Nitra.OptionAst.Some(Nitra.Location(parseResult.OriginalSource, _subruleStartPos, _subruleEndPos), $(GetSequenceValueRecoveryMode(subrule.Rule)))
              }
              else
              {
                Nitra.OptionAst.None(Nitra.Location(parseResult.OriginalSource, _subruleStartPos, _subruleEndPos))
              }
            ]>

        | List as lst =>
          if (subrule.SrcRule.Type is RuleType.Void)
            <[ () ]>
          else
            <[
              this.parseResult.ReadListAst(parsingSequence, state, _subruleStartPos, _subruleEndPos, fun(parsingSequence, _subruleStartPos, _subruleEndPos) {
                if (_subruleStartPos < _subruleEndPos)
                  $(GetSequenceValueRecoveryMode(lst.Rule))
                else
                  $(GetEmptySequenceValueRecoveryMode(lst.Rule))
              })
            ]>

        | ListWithSeparator as lst =>
          match (lst.Rule.SrcRule.Type, lst.Separator.SrcRule.Type)
          {
            | (Void, Void) => <[ () ]>
            | (_, Void)    =>
              <[
                this.parseResult.ReadListWithSeparatorOnlyItemsAst(parsingSequence, state, _subruleStartPos, _subruleEndPos,
                  fun(parsingSequence, _subruleStartPos, _subruleEndPos)
                  {
                    if (_subruleStartPos < _subruleEndPos)
                      $(GetSequenceValueRecoveryMode(lst.Rule))
                    else
                      $(GetEmptySequenceValueRecoveryMode(lst.Rule))
                  })
              ]>

            | (Void, _)    =>
              <[
                this.parseResult.ReadListWithSeparatorOnlySeparatorsAst(parsingSequence, state, _subruleStartPos, _subruleEndPos,
                  fun(parsingSequence, _subruleStartPos, _subruleEndPos)
                  {
                    if (_subruleStartPos < _subruleEndPos)
                      $(GetSequenceValueRecoveryMode(lst.Separator))
                    else
                      $(GetEmptySequenceValueRecoveryMode(lst.Separator))
                  })
              ]>

            | _ =>
              <[
                this.parseResult.ReadListWithSeparatorAst(parsingSequence, state, _subruleStartPos, _subruleEndPos,
                  fun(parsingSequence, _subruleStartPos, _subruleEndPos)
                  {
                    if (_subruleStartPos < _subruleEndPos)
                      $(GetSequenceValueRecoveryMode(lst.Rule))
                    else
                      $(GetEmptySequenceValueRecoveryMode(lst.Rule))
                  },
                  fun(parsingSequence, _subruleStartPos, _subruleEndPos)
                  {
                    if (_subruleStartPos < _subruleEndPos)
                      $(GetSequenceValueRecoveryMode(lst.Separator))
                    else
                      $(GetEmptySequenceValueRecoveryMode(lst.Separator))
                  })
              ]>
          }

        | Marker => <[ () ]>
      };

      def skippedValue = GetEmptySubruleValueRecoveryMode(subrule, true);

      <[
        def (subruleStarts, parsingSequence) = parseResult.RecoveredSubrules[recoveredSubrulesIndex];
        def state = parsingSequence.GetEarleyState($(subrule.State : int));
        match (this.parseResult.FindRecoveredSubrule(subruleStarts, state))
        {
          | (true, _subruleStartPos, _subruleEndPos)  => $recoveredValue
          | (false, _subruleStartPos, _subruleEndPos) => $skippedValue
        }
      ]>
    }

    private GetEmptySequenceValueRecoveryMode(sequence : SequenceCompileInfo) : PExpr
    {
      def statements    = SCG.List();
      def subruleValues = SCG.List();

      foreach (subrule when IsSubruleAcceptedForAst(subrule) in sequence.NonMarkerSubrules)
      {
        def varName = subrule.MakeVariableName("ast");
        statements.Add(<[ def $(varName : usesite) = $(GetEmptySubruleValueRecoveryMode(subrule, false)) ]>);
        subruleValues.Add(<[ $(varName : usesite) ]>);
      }

      match (subruleValues.Count)
      {
        | 0 => ()
        | 1 => statements.Add(subruleValues[0]);
        | _ => statements.Add(<[ Nitra.SequenceAst(Nitra.Location(parseResult.OriginalSource, _subruleStartPos, _subruleEndPos), ..$subruleValues) ]>);
      }

      <[ { ..$statements } ]>
    }

    private GetEmptySubruleValueRecoveryMode(subrule : SubruleCompileInfo, allowEmptySpan : bool) : PExpr
    {
      match (subrule)
      {
        | Empty => <[ () ]>
        | SimpleCall as subrule =>
          if (subrule.Symbol.Type is RuleType.Void)
            <[ () ]>
          else if (allowEmptySpan && subrule.CanParseEmptyString)
            <[ $(Environment.GetAstType(subrule.Symbol) : typed).Create(_subruleStartPos, _subruleEndPos, parseResult) ]>
          else
            <[ $(Environment.GetAstType(subrule.Symbol) : typed).MissingAst(parseResult, _subruleStartPos); ]>

        | ExtensibleCall as subrule =>
          if (subrule.Symbol.Type is RuleType.Void)
            <[ () ]>
          else
            <[ $(Environment.GetAstType(subrule.Symbol) : typed).MissingAst(parseResult, _subruleStartPos); ]>

        | RegularCall
        | List as lst when lst.IsSkipAnyPattern
        | TokenString => <[ Nitra.NSpan(_subruleStartPos, _subruleEndPos) ]>

        | Option as subrule =>
          if (subrule.SrcRule.Type is RuleType.Void)
            <[ () ]>
          else
            <[ Nitra.OptionAst.None(Nitra.Location(parseResult.OriginalSource, _subruleStartPos, _subruleEndPos)) ]>

        | List as lst =>
          if (lst.SrcRule.Type is RuleType.Void)
            <[ () ]>
          else
            <[ Nitra.ListAst(Nitra.Location(parseResult.OriginalSource, _subruleStartPos, _subruleEndPos)) ]>

        | ListWithSeparator as lst =>
          match (lst.Rule.SrcRule.Type, lst.Separator.SrcRule.Type)
          {
            | (Void, Void) => <[ () ]>
            | (_, Void)    => <[ Nitra.ListAst(Nitra.Location(parseResult.OriginalSource, _subruleStartPos, _subruleEndPos)) ]>
            | (Void, _)    => <[ Nitra.ListAst(Nitra.Location(parseResult.OriginalSource, _subruleStartPos, _subruleEndPos)) ]>
            | _            =>
              <[
                Nitra.SequenceAst(
                  Nitra.Location(parseResult.OriginalSource, _subruleStartPos, _subruleEndPos),
                  Nitra.ListAst(Nitra.Location(parseResult.OriginalSource, _subruleStartPos, _subruleEndPos)),
                  Nitra.ListAst(Nitra.Location(parseResult.OriginalSource, _subruleStartPos, _subruleEndPos)))
              ]>
          }

        | Marker => <[ () ]>
      }
    }

    public static IsSubruleAcceptedForAst(subrule : SubruleCompileInfo) : bool
    {
      | SimpleCall(symbol)        when symbol.Type is RuleType.Void
      | ExtensibleCall(symbol, _) when symbol.Type is RuleType.Void
      | Empty
      | Marker => false
      | _ => !(subrule.SrcRule.Type is RuleType.Void)
    }
  }
}
