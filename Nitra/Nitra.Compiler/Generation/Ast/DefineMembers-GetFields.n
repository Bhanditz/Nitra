using Nemerle;
using Nemerle.Collections;
using Nemerle.Imperative;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Compiler.Typedtree;

using Nitra.Internal;
using Nitra.Model;
using Nitra.Typing;

using System;
using System.Diagnostics;
using System.Linq;
using SCG = System.Collections.Generic;

namespace Nitra.Compiler
{
  internal partial class RuleAstEmitter
  {
    private variant FieldExpr
    {
      | Chars  { ExprStandardMode  : PExpr; NeedRuleParser : bool; ExprRecoveryMode : PExpr; }
      | Tuple  { Items : list[FieldExpr] }
      | Prefix { Expr  : PExpr }
      | Other  { ExprStandardMode  : PExpr; NeedRuleParser : bool; ExprRecoveryMode : PExpr; }
    }

    [Record]
    private class FieldInfo
    {
      public Name : string;
      public Rule : Rule;
      public Type : FixedType;
      public Expr : FieldExpr;
    }

    private GetFields() : SCG.List[FieldInfo]
    {
      def astPtr = AstPointer.Existing(this.RuleSymbol.Sequence, this, "astPtr");

      def ruleExprs = SCG.Dictionary.[Rule, FieldExpr](Rule.ReferenceEqualityComparer);

      when (this.RuleSymbol is ExtensionRuleSymbol(ExtensionType = Postfix(call, _)))
        ruleExprs.Add(call, FieldExpr.Prefix(<[ this.prefix ]>));

      def prevSubrules = SCG.List();
      foreach (subrule in this.RuleSymbol.Sequence.NonMarkerSubrules)
      {
        when (IsSubruleAcceptedForAst(subrule))
        {
          def parentAstPtr = AstPointerScope(astPtr);
          mutable needRuleParser;
          def valueExpr = GetSubruleValueStandardMode(subrule, parentAstPtr, ref needRuleParser);

          def statementsStandardMode = SCG.List();
          foreach (subrule in prevSubrules)
            statementsStandardMode.Add(WalkerGenerator.Skip(subrule, parentAstPtr));
          statementsStandardMode.Add(valueExpr);

          def statementsRecoveryMode = SCG.List();
          statementsRecoveryMode.Add(<[ def recoveredSubrulesIndex = ~this.astPtr ]>);
          statementsRecoveryMode.Add(GetSubruleValueRecoveryMode(subrule));

          def expr =
            if (subrule.SrcRule.Type is RuleType.Chars)
              FieldExpr.Chars(<[ { ..$statementsStandardMode } ]>, needRuleParser, <[ { ..$statementsRecoveryMode } ]>)
            else
              FieldExpr.Other(<[ { ..$statementsStandardMode } ]>, needRuleParser, <[ { ..$statementsRecoveryMode } ]>);

          ruleExprs.Add(subrule.SrcRule, expr);
        }
        prevSubrules.Add(subrule);
      }

      def makeFieldExpr(rule : Rule) : FieldExpr
      {
        if (rule is Rule.Sequence(Rules = rules))
        {
          def members = SCG.List();
          foreach (rule when !(rule.Type is RuleType.Void) in rules)
            members.Add(makeFieldExpr(rule));

          if(members.Count == 1)
            members[0]
          else
            FieldExpr.Tuple(members.ToNList())
        }
        else
        {
          mutable expr;
          unless (ruleExprs.TryGetValue(rule, out expr))
            assert3(false);
          expr
        }
      }

      def fields = SCG.List();
      foreach (rule in this.RuleSymbol.NonVoidSubRules)
        fields.Add(FieldInfo(rule.FieldName, rule, Environment.GetAstType(rule.Type), makeFieldExpr(rule)));
      fields
    }

    private GetSequenceValueStandardMode(sequence : SequenceCompileInfo, name : string, needRuleParser : ref bool) : PExpr
    {
      def astPointer    = AstPointerScope(sequence, name, this);
      def statements    = SCG.List();
      def subruleValues = SCG.List();

      foreach (subrule in sequence.NonMarkerSubrules)
      {
        if (IsSubruleAcceptedForAst(subrule))
        {
          def varName = subrule.MakeVariableName("ast");
          statements.Add(<[ def $(varName : usesite) = $(GetSubruleValueStandardMode(subrule, astPointer, ref needRuleParser)) ]>);
          subruleValues.Add(<[ $(varName : usesite) ]>);
        }
        else
          statements.Add(WalkerGenerator.Skip(subrule, astPointer));
      }

      match (subruleValues.Count)
      {
        | 0 => ()
        | 1 => statements.Add(subruleValues[0]);
        | _ =>
          statements.Insert(0, <[ def sequenceStartPos = pos; ]>);
          statements.Add(<[ Nitra.SequenceAst(Nitra.Location(parseResult.OriginalSource, sequenceStartPos, pos), ..$subruleValues) ]>);
      }

      when (astPointer.IsAccessed())
        needRuleParser = true;

      astPointer.Compile(<[ { ..$statements } ]>)
    }

    private GetSubruleValueStandardMode(subrule : SubruleCompileInfo, parentAstPointer : AstPointerScope, needRuleParser : ref bool) : PExpr
    {
      match (subrule)
      {
        | Empty      as subrule => WalkerGenerator.Skip(subrule, parentAstPointer)
        | SimpleCall as subrule =>
          if (subrule.Symbol.Type is RuleType.Void)
            WalkerGenerator.Skip(subrule, parentAstPointer)
          else if (subrule.CanParseEmptyString)
            <[
              pos += $(parentAstPointer.Access().GetSkip(subrule));
              $(Environment.GetAstType(subrule.Symbol) : typed).Create(ref pos, parseResult);
            ]>
          else
            <[
              pos += $(parentAstPointer.Access().GetSkip(subrule));
              if ($(parentAstPointer.Access().GetSize(subrule)) > 0)
                $(Environment.GetAstType(subrule.Symbol) : typed).Create(ref pos, parseResult);
              else
                $(Environment.GetAstType(subrule.Symbol) : typed).MissingAst(parseResult, pos);
            ]>

        | ExtensibleCall as subrule =>
          if (subrule.Symbol.Type is RuleType.Void)
            WalkerGenerator.Skip(subrule, parentAstPointer)
          else
            <[
              pos += $(parentAstPointer.Access().GetSkip(subrule));
              if ($(parentAstPointer.Access().GetSize(subrule)) > 0)
                Nitra.Internal.ExtensibleRuleAstConstructor.Create.[$(Environment.GetAstType(subrule.Symbol) : typed)](ref pos, parseResult, $(subrule.BindingPower : int), $(subrule.Symbol.GetRuleDescriptorRef()), Nitra.Internal.DefaultExtensibleRuleAstFactory.Instance);
              else
                $(Environment.GetAstType(subrule.Symbol) : typed).MissingAst(parseResult, pos); // No prefix
            ]>

        | RegularCall
        | List as lst when lst.IsSkipAnyPattern
        | TokenString => WalkerGenerator.GetTokenValue(subrule, parentAstPointer, <[ Nitra.NSpan(tokenPos, pos) ]>)
        | Option as subrule =>
          if (subrule.SrcRule.Type is RuleType.Void)
            WalkerGenerator.Skip(subrule, parentAstPointer)
          else
            WalkerGenerator.GetOptionValue(
              subrule          = subrule,
              parentAstPointer = parentAstPointer,
              hasValue         = <[
                def optionStartPos = pos;
                Nitra.OptionAst.Some(Nitra.Location(parseResult.OriginalSource, optionStartPos, pos), $(GetSequenceValueStandardMode(subrule.Rule, "valuePointer", ref needRuleParser)))
              ]>,
              noValue          = <[ Nitra.OptionAst.None(Nitra.Location(parseResult.OriginalSource, pos, pos)) ]>)

        | List as lst =>
          if (subrule.SrcRule.Type is RuleType.Void)
            WalkerGenerator.Skip(subrule, parentAstPointer)
          else
            WalkerGenerator.GetListValue(
              subrule          = lst,
              parentAstPointer = parentAstPointer,
              init             = <[ def itemBuffer = System.Collections.Generic.List(16); def listStartPos = pos; ]>,
              item             = <[ itemBuffer.Add($(GetSequenceValueStandardMode(lst.Rule, "itemPointer", ref needRuleParser))) ]>,
              returnCode       = <[ Nitra.ListAst(Nitra.Location(parseResult.OriginalSource, listStartPos, pos), itemBuffer) ]>,
              emptyCode        = <[ Nitra.ListAst(Nitra.Location(parseResult.OriginalSource, pos, pos)) ]>);

        | ListWithSeparator as lst=>
          match (lst.Rule.SrcRule.Type, lst.Separator.SrcRule.Type)
          {
            | (Void, Void) => WalkerGenerator.Skip(subrule, parentAstPointer)
            | (_, Void) =>
                WalkerGenerator.GetListWithSeparatorValue(
                  subrule          = lst,
                  parentAstPointer = parentAstPointer,
                  init             = <[ def itemBuffer = System.Collections.Generic.List(16); def listStartPos = pos; ]>,
                  item             = <[ itemBuffer.Add($(GetSequenceValueStandardMode(lst.Rule, "itemPointer", ref needRuleParser))) ]>,
                  separator        = <[ _ = $(GetSequenceValueStandardMode(lst.Separator, "separatorPointer", ref needRuleParser)) ]>,
                  returnCode       = <[ Nitra.ListAst(Nitra.Location(parseResult.OriginalSource, listStartPos, pos), itemBuffer) ]>,
                  emptyCode        = <[ Nitra.ListAst(Nitra.Location(parseResult.OriginalSource, pos, pos)) ]>);

            | (Void, _) =>
                WalkerGenerator.GetListWithSeparatorValue(
                  subrule          = lst,
                  parentAstPointer = parentAstPointer,
                  init             = <[ def separatorBuffer = System.Collections.Generic.List(16); def listStartPos = pos; ]>,
                  item             = <[ _ = $(GetSequenceValueStandardMode(lst.Rule, "itemPointer", ref needRuleParser)) ]>,
                  separator        = <[ separatorBuffer.Add($(GetSequenceValueStandardMode(lst.Separator, "separatorPointer", ref needRuleParser))) ]>,
                  returnCode       = <[ Nitra.ListAst(Nitra.Location(parseResult.OriginalSource, listStartPos, pos), separatorBuffer) ]>,
                  emptyCode        = <[Nitra.ListAst(Nitra.Location(parseResult.OriginalSource, pos, pos)) ]>);

            | _ =>
              WalkerGenerator.GetListWithSeparatorValue(
                subrule          = lst,
                parentAstPointer = parentAstPointer,
                init             = <[ def itemBuffer = System.Collections.Generic.List(16); def separatorBuffer = System.Collections.Generic.List(16); def listStartPos = pos; ]>,
                item             = <[ itemBuffer.Add($(GetSequenceValueStandardMode(lst.Rule, "itemPointer", ref needRuleParser))) ]>,
                separator        = <[ separatorBuffer.Add($(GetSequenceValueStandardMode(lst.Separator, "separatorPointer", ref needRuleParser))) ]>,
                returnCode       = <[ Nitra.SequenceAst(Nitra.Location(parseResult.OriginalSource, listStartPos, pos), Nitra.ListAst(Nitra.Location(parseResult.OriginalSource, listStartPos, pos), itemBuffer), Nitra.ListAst(Nitra.Location(parseResult.OriginalSource, listStartPos, pos), separatorBuffer)) ]>,
                emptyCode        = <[ Nitra.SequenceAst(Nitra.Location(parseResult.OriginalSource, pos, pos),          Nitra.ListAst(Nitra.Location(parseResult.OriginalSource, pos, pos)),                      Nitra.ListAst(Nitra.Location(parseResult.OriginalSource, pos, pos))) ]>);
          }

        | Marker => <[ () ]>
      }
    }

    private GetSequenceValueRecoveryMode(sequence : SequenceCompileInfo) : PExpr
    {
      def statements    = SCG.List();
      def subruleValues = SCG.List();

      foreach (subrule when IsSubruleAcceptedForAst(subrule) in sequence.NonMarkerSubrules)
      {
        def varName = subrule.MakeVariableName("ast");
        statements.Add(<[ def $(varName : usesite) = $(GetSubruleValueRecoveryMode(subrule)) ]>);
        subruleValues.Add(<[ $(varName : usesite) ]>);
      }

      match (subruleValues.Count)
      {
        | 0 => ()
        | 1 => statements.Add(subruleValues[0]);
        | _ =>
          statements.Insert(0, <[ def sequenceStartPos = subruleStartPos; ]>);
          statements.Insert(1, <[ def sequenceEndPos   = subruleEndPos; ]>);
          statements.Add(<[ Nitra.SequenceAst(Nitra.Location(parseResult.OriginalSource, sequenceStartPos, sequenceEndPos), ..$subruleValues) ]>);
      }

      <[
        mutable recoveredSequence;
        if (parseResult.RecoveredSequences.TryGetValue((subruleStartPos, subruleEndPos, parsingSequence), out recoveredSequence))
        {
          match (recoveredSequence)
          {
            | Unambiguous(recoveredSubrulesIndex) => { ..$statements }
            | Ambiguous                           => throw System.NotImplementedException("Ambiguous recovery mode AST reading not implemented")
          }
        }
        else throw System.NotImplementedException("Fallback to standard mode AST reading not implemented")
      ]>
    }

    private GetSubruleValueRecoveryMode(subrule : SubruleCompileInfo) : PExpr
    {
      def recoveredValue = match (subrule)
      {
        | Empty => <[ () ]>
        | SimpleCall as subrule =>
          if (subrule.Symbol.Type is RuleType.Void)
            <[ () ]>
          else if (subrule.CanParseEmptyString)
            <[ $(Environment.GetAstType(subrule.Symbol) : typed).Create(subruleStartPos, subruleEndPos, parseResult) ]>
          else
            <[
              if (subruleStartPos < subruleEndPos)
                $(Environment.GetAstType(subrule.Symbol) : typed).Create(subruleStartPos, subruleEndPos, parseResult)
              else
                $(Environment.GetAstType(subrule.Symbol) : typed).MissingAst(parseResult, subruleStartPos);
            ]>

        | ExtensibleCall as subrule =>
          if (subrule.Symbol.Type is RuleType.Void)
            <[ () ]>
          else
            <[
              if (subruleStartPos < subruleEndPos)
                Nitra.Internal.ExtensibleRuleAstConstructor.Create.[$(Environment.GetAstType(subrule.Symbol) : typed)](subruleStartPos, subruleEndPos, parseResult, $(subrule.BindingPower : int), $(subrule.Symbol.GetRuleDescriptorRef()), Nitra.Internal.DefaultExtensibleRuleAstFactory.Instance);
              else
                $(Environment.GetAstType(subrule.Symbol) : typed).MissingAst(parseResult, subruleStartPos); // No prefix
            ]>

        | RegularCall
        | List as lst when lst.IsSkipAnyPattern
        | TokenString    => <[ Nitra.NSpan(subruleStartPos, subruleEndPos) ]>
        | Option as subrule =>
          if (subrule.SrcRule.Type is RuleType.Void)
            <[ () ]>
          else
            <[
              if (subruleStartPos < subruleEndPos)
              {
                Nitra.OptionAst.Some(Nitra.Location(parseResult.OriginalSource, subruleStartPos, subruleEndPos), $(GetSequenceValueRecoveryMode(subrule.Rule)))
              }
              else
              {
                Nitra.OptionAst.None(Nitra.Location(parseResult.OriginalSource, subruleStartPos, subruleEndPos))
              }
            ]>

        | List as lst =>
          if (subrule.SrcRule.Type is RuleType.Void)
            <[ () ]>
          else
            <[
              this.parseResult.ReadListAst(parsingSequence, state, subruleStartPos, subruleEndPos, fun(parsingSequence, subruleStartPos, subruleEndPos) {
                $(GetSequenceValueRecoveryMode(lst.Rule))
              })
            ]>

        | ListWithSeparator => <[ throw System.NotImplementedException("Recovery mode AST reading: ListWithSeparator") ]>
        | Marker => <[ () ]>
      };
      def skippedValue = match (subrule)
      {
        | Empty => <[ () ]>
        | SimpleCall as subrule =>
          if (subrule.Symbol.Type is RuleType.Void)
            <[ () ]>
          else if (subrule.CanParseEmptyString)
            <[ $(Environment.GetAstType(subrule.Symbol) : typed).Create(subruleStartPos, subruleEndPos, parseResult) ]>
          else
            <[ $(Environment.GetAstType(subrule.Symbol) : typed).MissingAst(parseResult, subruleStartPos); ]>

        | ExtensibleCall as subrule =>
          if (subrule.Symbol.Type is RuleType.Void)
            <[ () ]>
          else
            <[ $(Environment.GetAstType(subrule.Symbol) : typed).MissingAst(parseResult, subruleStartPos); ]>

        | RegularCall
        | List as lst when lst.IsSkipAnyPattern
        | TokenString => <[ Nitra.NSpan(subruleStartPos, subruleEndPos) ]>

        | Option as subrule =>
          if (subrule.SrcRule.Type is RuleType.Void)
            <[ () ]>
          else
            <[ Nitra.OptionAst.None(Nitra.Location(parseResult.OriginalSource, subruleStartPos, subruleEndPos)) ]>

        | List as lst =>
          if (lst.SrcRule.Type is RuleType.Void)
            <[ () ]>
          else
            <[ Nitra.ListAst(Nitra.Location(parseResult.OriginalSource, subruleStartPos, subruleEndPos)) ]>

        | ListWithSeparator as lst =>
          match (lst.Rule.SrcRule.Type, lst.Separator.SrcRule.Type)
          {
            | (Void, Void) => <[ () ]>
            | (_, Void)    => <[ Nitra.ListAst(Nitra.Location(parseResult.OriginalSource, subruleStartPos, subruleEndPos)) ]>
            | (Void, _)    => <[ Nitra.ListAst(Nitra.Location(parseResult.OriginalSource, subruleStartPos, subruleEndPos)) ]>
            | _            =>
              <[
                Nitra.SequenceAst(
                  Nitra.Location(parseResult.OriginalSource, subruleStartPos, subruleEndPos),
                  Nitra.ListAst(Nitra.Location(parseResult.OriginalSource, subruleStartPos, subruleEndPos)),
                  Nitra.ListAst(Nitra.Location(parseResult.OriginalSource, subruleStartPos, subruleEndPos)))
              ]>
          }

        | Marker => <[ () ]>
      };
      <[
        def (subruleStarts, parsingSequence) = parseResult.RecoveredSubrules[recoveredSubrulesIndex];
        def state = parsingSequence.GetEarleyState($(subrule.State : int));
        mutable subruleStartPos;
        mutable subruleEndPos;
        if (this.parseResult.FindRecoveredSubrule(subruleStarts, state, out subruleStartPos, out subruleEndPos))
        {
          $recoveredValue
        }
        else
        {
          $skippedValue
        }
      ]>
    }

    public static IsSubruleAcceptedForAst(subrule : SubruleCompileInfo) : bool
    {
      | SimpleCall(symbol)        when symbol.Type is RuleType.Void
      | ExtensibleCall(symbol, _) when symbol.Type is RuleType.Void
      | Empty
      | Marker => false
      | _ => !(subrule.SrcRule.Type is RuleType.Void)
    }
  }
}
