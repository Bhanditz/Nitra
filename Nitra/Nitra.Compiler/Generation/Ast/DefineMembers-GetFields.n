using Nemerle;
using Nemerle.Collections;
using Nemerle.Imperative;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Compiler.Typedtree;

using Nitra.Internal;
using Nitra.Model;
using Nitra.Typing;

using System;
using System.Diagnostics;
using System.Linq;
using SCG = System.Collections.Generic;

namespace Nitra.Compiler
{
  internal partial class RuleAstEmitter
  {
    private variant FieldExpr
    {
      | Chars  { ExprStandardMode  : PExpr; ExprRecoveryMode : PExpr; }
      | Tuple  { Items : list[FieldExpr] }
      | Prefix { Expr  : PExpr }
      | Other  { ExprStandardMode  : PExpr; ExprRecoveryMode : PExpr; }
    }

    [Record]
    private class FieldInfo
    {
      public Name : string;
      public Rule : Rule;
      public Type : FixedType;
      public Expr : FieldExpr;
    }

    private GetFields() : SCG.List[FieldInfo]
    {
      def astPtr = AstPointer.Existing(this.RuleSymbol.Sequence, this, "astPtr");

      def ruleExprs = SCG.Dictionary.[Rule, FieldExpr](Rule.ReferenceEqualityComparer);

      when (this.RuleSymbol is ExtensionRuleSymbol(ExtensionType = Postfix(call, _)))
        ruleExprs.Add(call, FieldExpr.Prefix(<[ this.prefix ]>));

      def prevSubrules = SCG.List();
      foreach (subrule in this.RuleSymbol.Sequence.NonMarkerSubrules)
      {
        when (IsSubruleAcceptedForAst(subrule))
        {
          def parentAstPtr = AstPointerScope(astPtr);
          def valueExpr = CompileSubruleValueStandardMode(subrule, parentAstPtr);

          def statementsStandardMode = SCG.List();
          foreach (subrule in prevSubrules)
            statementsStandardMode.Add(WalkerGenerator.Skip(subrule, parentAstPtr));
          statementsStandardMode.Add(valueExpr);

          def statementsRecoveryMode = SCG.List();
          statementsRecoveryMode.Add(<[ def recoveredSubrulesIndex = ~this.astPtr ]>);
          statementsRecoveryMode.Add(CompileSubruleValueRecoveryMode(subrule));

          def expr =
            if (subrule.SrcRule.Type is RuleType.Chars)
              FieldExpr.Chars(<[ { ..$statementsStandardMode } ]>, <[ { ..$statementsRecoveryMode } ]>)
            else
              FieldExpr.Other(<[ { ..$statementsStandardMode } ]>, <[ { ..$statementsRecoveryMode } ]>);

          ruleExprs.Add(subrule.SrcRule, expr);
        }
        prevSubrules.Add(subrule);
      }

      def makeFieldExpr(rule : Rule) : FieldExpr
      {
        if (rule is Rule.Sequence(Rules = rules))
        {
          def members = SCG.List();
          foreach (rule when !(rule.Type is RuleType.Void) in rules)
            members.Add(makeFieldExpr(rule));

          if(members.Count == 1)
            members[0]
          else
            FieldExpr.Tuple(members.ToNList())
        }
        else
        {
          mutable expr;
          unless (ruleExprs.TryGetValue(rule, out expr))
            assert3(false);
          expr
        }
      }

      def fields = SCG.List();
      foreach (rule in this.RuleSymbol.NonVoidSubRules)
        fields.Add(FieldInfo(rule.FieldName, rule, Environment.GetAstType(rule.Type), makeFieldExpr(rule)));
      fields
    }

    private DefineReadSequenceMethod() : void
    {
      assert(_parsedAstTb != null);

      def makeIdSwitch(codeItems : SCG.List[PExpr], f : PExpr -> PExpr) : PExpr
      {
        if (codeItems.Count > 0)
        {
          def cases = SCG.List();
          foreach (code in codeItems with index)
            cases.Add(<[ case: | $(index : int) => $code ]>);
          cases.Add(<[ case: | _ => throw System.ArgumentOutOfRangeException("id") ]>);
          f(<[ match (id) { ..$cases } ]>)
        }
        else
          <[ throw System.ArgumentOutOfRangeException("id") ]>;
      }

      def makeStandardModeBody(codeItems : SCG.List[PExpr]) : PExpr
      {
        makeIdSwitch(codeItems, x => x)
      }

      _parsedAstTb.DefineConditional(<[ decl:
        private __ReadSequenceAstStandardMode(id : int, pos : ref int) : Nitra.Ast
          implements Nitra.Internal.IAstSequenceLoader[Nitra.Ast].ReadSequence
        {
          unchecked { _ = id; _ = pos; $(makeStandardModeBody(_sequencesAstStandardMode)) }
        }
      ]>);

      _parsedAstTb.DefineConditional(<[ decl:
        private __ReadSequenceSpanStandardMode(id : int, pos : ref int) : Nitra.NSpan
          implements Nitra.Internal.IAstSequenceLoader[Nitra.NSpan].ReadSequence
        {
          unchecked { _ = id; _ = pos; $(makeStandardModeBody(_sequencesSpanStandardMode)) }
        }
      ]>);

      def makeRecoveryModeBody(codeItems : SCG.List[PExpr], fallbackMethod : PExpr) : PExpr
      {
        makeIdSwitch(codeItems, body =>
        <[
          mutable recoveredSequence;
          if (parseResult.RecoveredSequences.TryGetValue((_subruleStartPos, _subruleEndPos, parsingSequence), out recoveredSequence))
          {
            match (recoveredSequence)
            {
              | Unambiguous(recoveredSubrulesIndex) => $body
              | Ambiguous                           => throw System.NotImplementedException("Ambiguous recovery mode AST reading not implemented")
            }
          }
          else
          {
            mutable pos = _subruleStartPos;
            $fallbackMethod(id, ref pos); // BUG: DOES NOT WORK NOW
          }
        ]>)
      }

      _parsedAstTb.DefineConditional(<[ decl:
        private __ReadSequenceAstRecoveryMode(id : int, _subruleStartPos : int, _subruleEndPos : int, parsingSequence : Nitra.Internal.Recovery.ParsingSequence) : Nitra.Ast
          implements Nitra.Internal.IAstSequenceLoader[Nitra.Ast].ReadSequence
        {
          unchecked { _ = id; _ = parsingSequence; $(makeRecoveryModeBody(_sequencesAstRecoveryMode, <[ this.__ReadSequenceAstStandardMode ]>)) }
        }
      ]>);

      _parsedAstTb.DefineConditional(<[ decl:
        private __ReadSequenceSpanRecoveryMode(id : int, _subruleStartPos : int, _subruleEndPos : int, parsingSequence : Nitra.Internal.Recovery.ParsingSequence) : Nitra.NSpan
          implements Nitra.Internal.IAstSequenceLoader[Nitra.NSpan].ReadSequence
        {
          unchecked { _ = id; _ = parsingSequence; $(makeRecoveryModeBody(_sequencesSpanRecoveryMode, <[ this.__ReadSequenceSpanStandardMode ]>)) }
        }
      ]>);

      _parsedAstTb.DefineConditional(<[ decl:
        private __ReadEmptySequenceAst(id : int, _subruleStartPos : int) : Nitra.Ast
          implements Nitra.Internal.IAstSequenceLoader[Nitra.Ast].ReadEmptySequence
        {
          unchecked { _ = id; $(makeStandardModeBody(_sequencesEmptyAstRecoveryMode)) }
        }
      ]>);

      _parsedAstTb.DefineConditional(<[ decl:
        private __ReadEmptySequenceSpan(id : int, _subruleStartPos : int) : Nitra.NSpan
          implements Nitra.Internal.IAstSequenceLoader[Nitra.NSpan].ReadEmptySequence
        {
          unchecked { _ = id; $(makeStandardModeBody(_sequencesEmptySpanRecoveryMode)) }
        }
      ]>);
    }

    [RecordIgnore]
    private _sequencesAstStandardMode  : SCG.List[PExpr] = SCG.List();

    [RecordIgnore]
    private _sequencesSpanStandardMode : SCG.List[PExpr] = SCG.List();

    [RecordIgnore]
    private _sequencesAstRecoveryMode  : SCG.List[PExpr] = SCG.List();

    [RecordIgnore]
    private _sequencesSpanRecoveryMode : SCG.List[PExpr] = SCG.List();

    [RecordIgnore]
    private _sequencesEmptyAstRecoveryMode  : SCG.List[PExpr] = SCG.List();

    [RecordIgnore]
    private _sequencesEmptySpanRecoveryMode : SCG.List[PExpr] = SCG.List();

    private CompileSequenceValueStandardMode(sequence : SequenceCompileInfo, name : string) : PExpr * PExpr * int
    {
      def astPointer    = AstPointerScope(sequence, name, this);
      def statements    = SCG.List();
      def subrules      = SCG.List();
      def subruleValues = SCG.List();

      foreach (subrule in sequence.NonMarkerSubrules)
      {
        if (IsSubruleAcceptedForAst(subrule))
        {
          def varName = subrule.MakeVariableName("ast");
          statements.Add(<[ def $(varName : usesite) = $(CompileSubruleValueStandardMode(subrule, astPointer)) ]>);
          subruleValues.Add(<[ $(varName : usesite) ]>);
          subrules.Add(subrule);
        }
        else
          statements.Add(WalkerGenerator.Skip(subrule, astPointer));
      }

      match (subruleValues.Count)
      {
        | 0 => statements.Add(<[ null ]>);
        | 1 => statements.Add(subruleValues[0]);
        | _ =>
          statements.Insert(0, <[ def sequenceStartPos = pos; ]>);
          statements.Add(<[ Nitra.SequenceAst(Nitra.Location(parseResult.OriginalSource, sequenceStartPos, pos), ..$subruleValues) ]>);
      }

      def code = astPointer.Compile(<[ { ..$statements } ]>);
      def codeWithRuleParser = if (astPointer.IsAccessed())
        <[  def ruleParser = parseResult.GetRuleParser(astPtr) :> $(this.RuleSymbol.GetParserClassRef()); $code ]>
      else
        code;

      if (subrules.Count == 1 && subrules[0].SrcRule.Type is RuleType.Chars)
      {
        def id = _sequencesSpanStandardMode.Count;
        _sequencesSpanStandardMode.Add(codeWithRuleParser);
        (<[ $(Environment.NSpanTypeVar : typed) ]>, <[ $(Environment.GetAstType(sequence.SrcRule.Type) : typed) ]>, id)
      }
      else
      {
        def id = _sequencesAstStandardMode.Count;
        _sequencesAstStandardMode.Add(codeWithRuleParser);
        (<[ $(Environment.AstTypeVar : typed) ]>, <[ $(Environment.GetAstType(sequence.SrcRule.Type) : typed) ]>, id)
      }
    }

    private CompileSubruleValueStandardMode(subrule : SubruleCompileInfo, parentAstPointer : AstPointerScope) : PExpr
    {
      match (subrule)
      {
        | Empty      as subrule => WalkerGenerator.Skip(subrule, parentAstPointer)
        | SimpleCall as subrule =>
          if (subrule.Symbol.Type is RuleType.Void)
            WalkerGenerator.Skip(subrule, parentAstPointer)
          else if (subrule.CanParseEmptyString)
            <[
              pos += $(parentAstPointer.Access().GetSkip(subrule));
              $(Environment.GetAstType(subrule.Symbol) : typed).Create(ref pos, parseResult);
            ]>
          else
            <[
              pos += $(parentAstPointer.Access().GetSkip(subrule));
              if ($(parentAstPointer.Access().GetSize(subrule)) > 0)
                $(Environment.GetAstType(subrule.Symbol) : typed).Create(ref pos, parseResult);
              else
                $(Environment.GetAstType(subrule.Symbol) : typed).MissingAst(parseResult, pos);
            ]>

        | ExtensibleCall as subrule =>
          if (subrule.Symbol.Type is RuleType.Void)
            WalkerGenerator.Skip(subrule, parentAstPointer)
          else
            <[
              pos += $(parentAstPointer.Access().GetSkip(subrule));
              if ($(parentAstPointer.Access().GetSize(subrule)) > 0)
                Nitra.Internal.ExtensibleRuleAstConstructor.Create.[$(Environment.GetAstType(subrule.Symbol) : typed)](ref pos, parseResult, $(subrule.BindingPower : int), $(subrule.Symbol.GetRuleDescriptorRef()), Nitra.Internal.DefaultExtensibleRuleAstFactory.Instance);
              else
                $(Environment.GetAstType(subrule.Symbol) : typed).MissingAst(parseResult, pos); // No prefix
            ]>

        | RegularCall
        | List(IsSkipAnyPattern = true)
        | TokenString => WalkerGenerator.GetTokenValue(subrule, parentAstPointer, <[ Nitra.NSpan(tokenPos, pos) ]>)
        | Option(itemSequence) as subrule =>
          if (subrule.SrcRule.Type is RuleType.Void)
            WalkerGenerator.Skip(subrule, parentAstPointer)
          else
          {
            def (loaderType, itemType, id) = CompileSequenceValueStandardMode(itemSequence, "valuePointer");
            <[ Nitra.Internal.AstFactory.CreateOption.[$loaderType, $itemType](this, this.parseResult, this.astPtr, $(subrule.Offset), $(id : int), ref pos) ]>
          }

        | List(Rule = itemSequence) =>
          if (subrule.SrcRule.Type is RuleType.Void)
            WalkerGenerator.Skip(subrule, parentAstPointer)
          else
          {
            def (loaderType, itemType, id) = CompileSequenceValueStandardMode(itemSequence, "valuePointer");
            <[ Nitra.Internal.AstFactory.CreateList.[$loaderType, $itemType](this, this.parseResult, this.astPtr, $(subrule.Offset), $(id : int), ref pos) ]>
          }

        | ListWithSeparator(Rule = itemSequence, Separator = separatorSequence)=>
          match (itemSequence.SrcRule.Type, separatorSequence.SrcRule.Type)
          {
            | (Void, Void) => WalkerGenerator.Skip(subrule, parentAstPointer)
            | (_, Void) =>
              def (itemLoaderType, itemType, itemSequenceId)    = CompileSequenceValueStandardMode(itemSequence, "itemPointer");
              def (separatorLoaderType, _, separatorSequenceId) = CompileSequenceValueStandardMode(separatorSequence, "separatorPointer");
              <[ Nitra.Internal.AstFactory.CreateListWithSeparatorOnlyItems.[$itemLoaderType, $itemType, $separatorLoaderType](this, this, this.parseResult, this.astPtr, $(subrule.Offset), $(itemSequenceId : int), $(separatorSequenceId : int), ref pos) ]>

            | (Void, _) =>
              def (itemLoaderType, _, itemSequenceId)                       = CompileSequenceValueStandardMode(itemSequence, "itemPointer");
              def (separatorLoaderType, separatorType, separatorSequenceId) = CompileSequenceValueStandardMode(separatorSequence, "separatorPointer");
              <[ Nitra.Internal.AstFactory.CreateListWithSeparatorOnlySeparators.[$itemLoaderType, $separatorLoaderType, $separatorType](this, this, this.parseResult, this.astPtr, $(subrule.Offset), $(itemSequenceId : int), $(separatorSequenceId : int), ref pos) ]>

            | _ =>
              def (itemLoaderType, itemType, itemSequenceId)                = CompileSequenceValueStandardMode(itemSequence, "itemPointer");
              def (separatorLoaderType, separatorType, separatorSequenceId) = CompileSequenceValueStandardMode(separatorSequence, "separatorPointer");
              <[ Nitra.Internal.AstFactory.CreateListWithSeparator.[$itemLoaderType, $itemType, $separatorLoaderType, $separatorType](this, this, this.parseResult, this.astPtr, $(subrule.Offset), $(itemSequenceId : int), $(separatorSequenceId : int), ref pos) ]>
          }

        | Marker => <[ () ]>
      }
    }

    private CompileSequenceValueRecoveryMode(sequence : SequenceCompileInfo) : PExpr * PExpr * int
    {
      def statements    = SCG.List();
      def subrules      = SCG.List();
      def subruleValues = SCG.List();

      foreach (subrule when IsSubruleAcceptedForAst(subrule) in sequence.NonMarkerSubrules)
      {
        def varName = subrule.MakeVariableName("ast");
        statements.Add(<[ def $(varName : usesite) = $(CompileSubruleValueRecoveryMode(subrule)) ]>);
        subruleValues.Add(<[ $(varName : usesite) ]>);
        subrules.Add(subrule);
      }

      match (subruleValues.Count)
      {
        | 0 => statements.Add(<[ null ]>);
        | 1 => statements.Add(subruleValues[0]);
        | _ =>
          statements.Insert(0, <[ def sequenceStartPos = _subruleStartPos; ]>);
          statements.Insert(1, <[ def sequenceEndPos   = _subruleEndPos; ]>);
          statements.Add(<[ Nitra.SequenceAst(Nitra.Location(parseResult.OriginalSource, sequenceStartPos, sequenceEndPos), ..$subruleValues) ]>);
      }

      def code = <[ { ..$statements }]>;

      if (subrules.Count == 1 && subrules[0].SrcRule.Type is RuleType.Chars)
      {
        def id = _sequencesSpanRecoveryMode.Count;
        _sequencesSpanRecoveryMode.Add(code);
        (<[ $(Environment.NSpanTypeVar : typed) ]>, <[ $(Environment.GetAstType(sequence.SrcRule.Type) : typed) ]>, id)
      }
      else
      {
        def id = _sequencesAstRecoveryMode.Count;
        _sequencesAstRecoveryMode.Add(code);
        (<[ $(Environment.AstTypeVar : typed) ]>, <[ $(Environment.GetAstType(sequence.SrcRule.Type) : typed) ]>, id)
      }
    }

    private CompileSubruleValueRecoveryMode(subrule : SubruleCompileInfo) : PExpr
    {
      def recoveredValue = match (subrule)
      {
        | Empty => <[ () ]>
        | SimpleCall as subrule =>
          if (subrule.Symbol.Type is RuleType.Void)
            <[ () ]>
          else if (subrule.CanParseEmptyString)
            <[ $(Environment.GetAstType(subrule.Symbol) : typed).Create(_subruleStartPos, _subruleEndPos, parseResult) ]>
          else
            <[
              if (_subruleStartPos < _subruleEndPos)
                $(Environment.GetAstType(subrule.Symbol) : typed).Create(_subruleStartPos, _subruleEndPos, parseResult)
              else
                $(Environment.GetAstType(subrule.Symbol) : typed).MissingAst(parseResult, _subruleStartPos);
            ]>

        | ExtensibleCall as subrule =>
          if (subrule.Symbol.Type is RuleType.Void)
            <[ () ]>
          else
            <[
              if (_subruleStartPos < _subruleEndPos)
                Nitra.Internal.ExtensibleRuleAstConstructor.Create.[$(Environment.GetAstType(subrule.Symbol) : typed)](_subruleStartPos, _subruleEndPos, parseResult, $(subrule.BindingPower : int), $(subrule.Symbol.GetRuleDescriptorRef()), Nitra.Internal.DefaultExtensibleRuleAstFactory.Instance);
              else
                $(Environment.GetAstType(subrule.Symbol) : typed).MissingAst(parseResult, _subruleStartPos); // No prefix
            ]>

        | RegularCall
        | List as lst when lst.IsSkipAnyPattern
        | TokenString    => <[ Nitra.NSpan(_subruleStartPos, _subruleEndPos) ]>
        | Option(Rule = itemSequence) =>
          if (subrule.SrcRule.Type is RuleType.Void)
            <[ () ]>
          else
          {
            def (loaderType, itemType, id) = CompileSequenceValueRecoveryMode(itemSequence);
            <[ Nitra.Internal.AstFactory.CreateOption.[$loaderType, $itemType](this, this.parseResult, parsingSequence, state, $(id : int), _subruleStartPos, _subruleEndPos) ]>
          }

        | List(Rule = itemSequence) =>
          if (subrule.SrcRule.Type is RuleType.Void)
            <[ () ]>
          else
          {
            def (loaderType, itemType, id) = CompileSequenceValueRecoveryMode(itemSequence);
            def emptyId                    = CompileEmptySequenceValueRecoveryMode(itemSequence);
            <[ Nitra.Internal.AstFactory.CreateList.[$loaderType, $itemType](this, this.parseResult, parsingSequence, state, $(id : int), $(emptyId : int), _subruleStartPos, _subruleEndPos) ]>
          }

        | ListWithSeparator(Rule = itemSequence, Separator = separatorSequence) =>
          match (itemSequence.SrcRule.Type, separatorSequence.SrcRule.Type)
          {
            | (Void, Void) => <[ () ]>
            | (_, Void)    =>
              def (itemLoaderType, itemType, itemSequenceId)                = CompileSequenceValueRecoveryMode(itemSequence);
              def emptyItemSequenceId                                       = CompileEmptySequenceValueRecoveryMode(itemSequence);
              <[
                Nitra.Internal.AstFactory.CreateListWithSeparatorOnlyItems.[$itemLoaderType, $itemType](
                  this, this, this.parseResult, parsingSequence, state, $(itemSequenceId : int), $(emptyItemSequenceId : int), _subruleStartPos, _subruleEndPos)
              ]>

            | (Void, _)    =>
              def (separatorLoaderType, separatorType, separatorSequenceId) = CompileSequenceValueRecoveryMode(separatorSequence);
              def emptySeparatorSequenceId                                  = CompileEmptySequenceValueRecoveryMode(separatorSequence);
              <[
                Nitra.Internal.AstFactory.CreateListWithSeparatorOnlySeparators.[$separatorLoaderType, $separatorType](
                  this, this, this.parseResult, parsingSequence, state, $(separatorSequenceId : int), $(emptySeparatorSequenceId : int), _subruleStartPos, _subruleEndPos)
              ]>

            | _ =>
              def (itemLoaderType, itemType, itemSequenceId)                = CompileSequenceValueRecoveryMode(itemSequence);
              def emptyItemSequenceId                                       = CompileEmptySequenceValueRecoveryMode(itemSequence);
              def (separatorLoaderType, separatorType, separatorSequenceId) = CompileSequenceValueRecoveryMode(separatorSequence);
              def emptySeparatorSequenceId                                  = CompileEmptySequenceValueRecoveryMode(separatorSequence);
              <[
                Nitra.Internal.AstFactory.CreateListWithSeparator.[$itemLoaderType, $itemType, $separatorLoaderType, $separatorType](
                  this, this, this.parseResult, parsingSequence, state, $(itemSequenceId : int), $(emptyItemSequenceId : int), $(separatorSequenceId : int), $(emptySeparatorSequenceId : int), _subruleStartPos, _subruleEndPos)
              ]>
          }

        | Marker => <[ () ]>
      };

      def skippedValue = CompileEmptySubruleValueRecoveryMode(subrule, true);

      <[
        def (subruleStarts, parsingSequence) = parseResult.RecoveredSubrules[recoveredSubrulesIndex];
        def state = parsingSequence.GetEarleyState($(subrule.State : int));
        match (this.parseResult.FindRecoveredSubrule(subruleStarts, state))
        {
          | (true, _subruleStartPos, _subruleEndPos)  => $recoveredValue
          | (false, _subruleStartPos, _subruleEndPos) => $skippedValue
        }
      ]>
    }

    private CompileEmptySequenceValueRecoveryMode(sequence : SequenceCompileInfo) : int
    {
      def statements    = SCG.List();
      def subrules      = SCG.List();
      def subruleValues = SCG.List();

      foreach (subrule when IsSubruleAcceptedForAst(subrule) in sequence.NonMarkerSubrules)
      {
        def varName = subrule.MakeVariableName("ast");
        statements.Add(<[ def $(varName : usesite) = $(CompileEmptySubruleValueRecoveryMode(subrule, false)) ]>);
        subruleValues.Add(<[ $(varName : usesite) ]>);
        subrules.Add(subrule);
      }

      match (subruleValues.Count)
      {
        | 0 => statements.Add(<[ null ]>);
        | 1 => statements.Add(subruleValues[0]);
        | _ => statements.Add(<[ Nitra.SequenceAst(Nitra.Location(parseResult.OriginalSource, _subruleStartPos, _subruleEndPos), ..$subruleValues) ]>);
      }

      def code = <[ { ..$statements }]>;

      if (subrules.Count == 1 && subrules[0].SrcRule.Type is RuleType.Chars)
      {
        def id = _sequencesEmptySpanRecoveryMode.Count;
        _sequencesEmptySpanRecoveryMode.Add(code);
        id
      }
      else
      {
        def id = _sequencesEmptyAstRecoveryMode.Count;
        _sequencesEmptyAstRecoveryMode.Add(code);
        id
      }
    }

    private CompileEmptySubruleValueRecoveryMode(subrule : SubruleCompileInfo, allowEmptySpan : bool) : PExpr
    {
      match (subrule)
      {
        | Empty => <[ () ]>
        | SimpleCall as subrule =>
          if (subrule.Symbol.Type is RuleType.Void)
            <[ () ]>
          else if (allowEmptySpan && subrule.CanParseEmptyString)
            <[ $(Environment.GetAstType(subrule.Symbol) : typed).Create(_subruleStartPos, _subruleStartPos, parseResult) ]>
          else
            <[ $(Environment.GetAstType(subrule.Symbol) : typed).MissingAst(parseResult, _subruleStartPos); ]>

        | ExtensibleCall as subrule =>
          if (subrule.Symbol.Type is RuleType.Void)
            <[ () ]>
          else
            <[ $(Environment.GetAstType(subrule.Symbol) : typed).MissingAst(parseResult, _subruleStartPos); ]>

        | RegularCall
        | List as lst when lst.IsSkipAnyPattern
        | TokenString => <[ Nitra.NSpan(_subruleStartPos, _subruleStartPos) ]>

        | Option as subrule =>
          if (subrule.SrcRule.Type is RuleType.Void)
            <[ () ]>
          else
            <[ Nitra.OptionAst.None(Nitra.Location(parseResult.OriginalSource, _subruleStartPos, _subruleStartPos)) ]>

        | List as lst =>
          if (lst.SrcRule.Type is RuleType.Void)
            <[ () ]>
          else
            <[ Nitra.ListAst(Nitra.Location(parseResult.OriginalSource, _subruleStartPos, _subruleStartPos)) ]>

        | ListWithSeparator as lst =>
          match (lst.Rule.SrcRule.Type, lst.Separator.SrcRule.Type)
          {
            | (Void, Void) => <[ () ]>
            | (_, Void)    => <[ Nitra.ListAst(Nitra.Location(parseResult.OriginalSource, _subruleStartPos, _subruleStartPos)) ]>
            | (Void, _)    => <[ Nitra.ListAst(Nitra.Location(parseResult.OriginalSource, _subruleStartPos, _subruleStartPos)) ]>
            | _            =>
              <[
                Nitra.SequenceAst(
                  Nitra.Location(parseResult.OriginalSource, _subruleStartPos, _subruleStartPos),
                  Nitra.ListAst(Nitra.Location(parseResult.OriginalSource, _subruleStartPos, _subruleStartPos)),
                  Nitra.ListAst(Nitra.Location(parseResult.OriginalSource, _subruleStartPos, _subruleStartPos)))
              ]>
          }

        | Marker => <[ () ]>
      }
    }

    public static IsSubruleAcceptedForAst(subrule : SubruleCompileInfo) : bool
    {
      | SimpleCall(symbol)        when symbol.Type is RuleType.Void
      | ExtensibleCall(symbol, _) when symbol.Type is RuleType.Void
      | Empty
      | Marker => false
      | _ => !(subrule.SrcRule.Type is RuleType.Void)
    }
  }
}
