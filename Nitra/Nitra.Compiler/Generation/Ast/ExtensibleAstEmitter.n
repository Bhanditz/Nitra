using Nitra.Model;
using Nitra.Typing;

using Nemerle;
using Nemerle.Collections;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using SCG = System.Collections.Generic;

namespace Nitra.Compiler
{
  internal sealed class ExtensibleAstEmitter : AstEmitter
  {
    private         _symbol            : ExtensibleAstSymbol;
    private mutable _baseTb            : TypeBuilder;
    private mutable _ambiguousTb       : TypeBuilder;
    private         _listEmitter       : ListAstEmitter;
    private         _optionEmitter     : OptionAstEmitter;
    private mutable _symbolTb          : TypeBuilder;

    public this(environment : EmitterEnvironment, symbol : ExtensibleAstSymbol)
    {
      base(environment, environment.NamespaceOfSymbol(symbol));
      this._symbol        = symbol;
      this._listEmitter   = ListAstEmitter(environment, symbol);
      this._optionEmitter = OptionAstEmitter(environment, symbol);
    }

    public override DefineTypes() : void
    {
      Util.locate(_symbol.FirstLocation.NLocation(),
      {
        assert(_baseTb == null);

        def baseTypes = SCG.List();
        baseTypes.Add(<[ Nitra.Declarations.AstBase ]>);
        foreach (baseAst in _symbol.BaseAsts)
          baseTypes.Add(<[ $(Environment.GetAstType(baseAst) : typed) ]>);
        when (_symbol.IsDeclaration)
          baseTypes.Add(<[ $(Environment.DeclarationTypeVar : typed) ]>);

        _baseTb = NemerleEnv.Define(<[ decl:
          public abstract partial class $(_symbol.Name : usesite) : ..$baseTypes
          {
            protected this() { }
          }
        ]>);

        assert(_ambiguousTb == null);
        _ambiguousTb = DefineAmbiguousAst(_baseTb);

        _listEmitter.DefineTypes(_baseTb);
        _optionEmitter.DefineTypes(_baseTb);

        when (_symbol.IsDeclaration)
        {
          def baseSymbolTypes = SCG.List();
          baseSymbolTypes.Add(<[ Nitra.Runtime.Binding.Symbol2 ]>);
          foreach (baseAst in _symbol.BaseAsts)
            baseSymbolTypes.Add(GetSymbolClassRef(baseAst));

          _symbolTb = NemerleEnv.Define(<[ decl:
            public abstract partial class $(Environment.GetSymbolClassName(_symbol) : usesite) : ..$baseSymbolTypes
            {
            }
          ]>);
        }
      })
    }

    public override DefineMembers() : void
    {
      assert(_baseTb != null);

      def thisType = _baseTb.GetMemType();

      def acceptBody = SCG.List();

      def missingBody = SCG.List();
      missingBody.Add(<[ this.File = file ]>);
      missingBody.Add(<[ this.Span = span ]>);

      def dependentProps = SCG.Dictionary();

      def defineSimpleProperty(propertySymbol : SimpleAstPropertySymbol) : void
      {
        def name         = propertySymbol.Name;
        def propertyType = TypeCompiler.CompileSimplePropertyType(propertySymbol);
        DefineSimpleProperty(name, propertyType.Type, _baseTb, _ambiguousTb);

        match (propertyType)
        {
          | Ast         =>
            acceptBody.Add(<[ visitor.Visit(this.$(name : usesite)); ]>);

            if (propertyType.Type.Equals(thisType))
              missingBody.Add(<[ this.$(name : usesite) = this ]>);
            else unless (propertySymbol.AstType.IsVoid)
              missingBody.Add(<[ this.$(name : usesite) = $(GetMissingAstCtor(Environment, propertySymbol.AstType))(file, span) ]>);

          | ParsedValue => missingBody.Add(<[ this.$(name : usesite) = Nitra.ParsedValue(span.StartPos) ]>);
          | Span        => missingBody.Add(<[ this.$(name : usesite) = span ]>);
        }
      }

      def defineDependentProperty(propertySymbol : DependentAstPropertySymbol) : void
      {
        def index = dependentProps.Count;
        def bit   = _baseTb.GetBitFieldManager().Allocate();
        assert(bit.Index == index);

        def propertyRef = DependentAstPropertyRef.Compiling(propertySymbol, index, bit);
        dependentProps.Add(propertySymbol, propertyRef);

        DefineDependentProperty(_baseTb, propertyRef, NemerleModifiers.Public | NemerleModifiers.Virtual);
        DefineAmbiguousDependentProperty(_ambiguousTb, propertyRef, NemerleModifiers.Public | NemerleModifiers.Override);
      }

      def defineProjectedProperty(propertySymbol : ProjectedAstPropertySymbol) : void
      {
        def name         = propertySymbol.Name;
        def propertyType = TypeCompiler.CompileProjectedPropertyType(propertySymbol);
        DefineSimpleProperty(name, propertyType, _baseTb, _ambiguousTb);

        if (propertyType.Equals(thisType))
          missingBody.Add(<[ this.$(name : usesite) = this ]>);
        else when (propertySymbol.ProjectionType is Some(projectionType))
          missingBody.Add(<[ this.$(name : usesite) = $(GetMissingAstCtor(Environment, projectionType))(file, span) ]>);
      }

      foreach (propertySymbol in _symbol.AllProperties)
      {
        | SimpleAstPropertySymbol    as s => defineSimpleProperty(s)
        | DependentAstPropertySymbol as s => defineDependentProperty(s)
        | ProjectedAstPropertySymbol as s => defineProjectedProperty(s)
        | _ => ()
      }

      DefineIsPropertyEvaluatedMethod(_baseTb, NemerleModifiers.Override);
      DefineResetPropertiesMethod(_baseTb, _ambiguousTb);
      DefineIsAllPropertiesEvaluatedProperty(_baseTb, _ambiguousTb);
      DefineDependentPropertiesEvaluation(_baseTb, _symbol);

      _listEmitter.DefineMembers(dependentProps);
      _optionEmitter.DefineMembers(dependentProps);

      _ambiguousTb.Define(<[ decl:
        public this(file : $(Environment.FileTypeVar : typed), span : $(Environment.NSpanTypeVar : typed)) { ..$missingBody; }
      ]>);

      when (acceptBody.Count > 0)
        _baseTb.Define(<[ decl: public override Accept(visitor : Nitra.Declarations.IAstVisitor) : void { ..$acceptBody } ]>);
    }

    public override DefineNestedType(td : ClassMember.TypeDeclaration) : TypeBuilder
    {
      assert(_baseTb != null);
      _baseTb.DefineNestedType(td);
    }

    public override Emit() : void
    {
      assert(_baseTb != null);
      _baseTb.Compile();

      assert(_ambiguousTb != null);
      _ambiguousTb.Compile();

      _listEmitter.Emit();
      _optionEmitter.Emit();

      when (_symbolTb != null)
        _symbolTb.Compile();
    }
  }
}
