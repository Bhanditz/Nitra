using Nitra.Typing;
using Nitra.Model;

using Nemerle;
using Nemerle.Collections;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Compiler.Typedtree;
using Nemerle.Imperative;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Surround;

using System;
using System.Linq;
using SCG = System.Collections.Generic;

[assembly: DefineSurround("related_messages", true, Environment.Manager.BeginRelatedMessageSequence(), Environment.Manager.EndRelatedMessageSequence())]

namespace Nitra.Compiler
{
  internal abstract partial class BaseAstEmitter
  {
    protected DefineDependentPropertiesInheritableEvaluation(tb : TypeBuilder, symbol : PropertyContainerSymbol) : void
    {
      Util.locate(symbol.FirstLocation.NLocation(),
      {
        def graph =
          if (symbol.HasEvaluations)
          {
            tb.Manager.MacroColors.InGlobalColor(fun()
            {
              def body = SCG.List();
              foreach (assignment in (symbol :> IDependentPropertyAssignmentContainer).GetAssignments())
              {
                mutable unused;
                def expr = PrepareExprForInheritableEvaluation(symbol, assignment.Expression, false, ref unused);
                body.Add(Util.locate(assignment.NLocation(), <[ $(PExprUtils.FromQualifiedMember(<[ self ]>, assignment.Path)) = $expr ]>));
              }

              def evalMethod = tb.DefineAndReturn(<[ decl:
                public static $(" fake " : usesite)($("self" : global) : this, $("context" : global) : Nitra.Declarations.DependentPropertyEvalContext) : void
                {
                  ..$body
                }
              ]>) :> MethodBuilder;

              def graph = TypeDependentEvaluation(evalMethod, symbol);
              evalMethod.Body = <[ () ]>;
              graph
            });
          }
          else array(0);

        PropertyDependencyNode.Save(graph, symbol);
      });
    }

    protected DefineDependentPropertiesSealedEvaluation(tb : TypeBuilder, symbol : PropertyContainerSymbol, dependentProperties : SCG.Dictionary[DependentPropertySymbol, BitField]) : void
    {
      Util.locate(symbol.FirstLocation.NLocation(), tb.Manager.MacroColors.InGlobalColor(fun()
      {
        def body = SCG.List();
        foreach (assignment in (symbol :> IDependentPropertyAssignmentContainer).GetAssignments())
          body.Add(Util.locate(assignment.NLocation(), <[ $(PExprUtils.FromQualifiedMember(<[ this ]>, assignment.Path)) = $(assignment.Expression) ]>));

        def evalMethod = tb.DefineAndReturn(<[ decl:
          public override EvalProperties($("context" : global) : Nitra.Declarations.DependentPropertyEvalContext) : void
          {
            ..$body
          }
        ]>) :> MethodBuilder;

        def graph = TypeDependentEvaluation(evalMethod, symbol);
        evalMethod.Body = GenerateCode(symbol, graph, dependentProperties);
      }));
    }

    private TypeDependentEvaluation(evalMethod : MethodBuilder, symbol : PropertyContainerSymbol) : array[PropertyDependencyNode]
    {
      assert2(evalMethod.DeclaringType.Name != "Simple");

      def errorCount = Message.ErrorCount;
      def typer = Typer(evalMethod);
      typer.StopAfterPhase = 1;
      typer.RunFullTyping();
      when (errorCount != Message.ErrorCount)
        throw Recovery();

      match (evalMethod.GetHeader().Body)
      {
        | FunBody.Typed(TExpr.Block(_, TExpr.Literal(Literal.Void))) => array(0)
        | FunBody.Typed(TExpr.Block(_, bodyExpr)) =>
          def expr      = ValidateEvalFieldsCode(bodyExpr);
          def localMap  = MakeLocalDependencyGraph(evalMethod.DeclaringType, symbol, expr);
          def fullGraph = MakeFullDepencyGraph(symbol, localMap);
          CheckStageDependencies(fullGraph);
          when (fullGraph.Length >= 5)
            PropertyDependencyNode.Visualize(symbol, fullGraph, symbol.Name);
          fullGraph

        | _ =>
          assert2(false, $"Failed typing of dependent evaluations in method '$(evalMethod.Name)'");
          array(0)
      }
    }

    private static ErrorUnexpectedExpr(expr : TExpr) : void
    {
      Message.FatalError(expr.Location, $"Unexpected expression '$expr' $(expr.GetType().Name)")
    }

    private static ValidateEvalFieldsCode(expr : TExpr) : TExpr
    {
      def walker = ExprWalker();
      def checkInvalidExpre(info : ExprWalkInfo) : void
      {
        match (info.Node)
        {
          | TExpr.DefFunctionsIn as e
          | TExpr.DefValIn       as e
          | TExpr.Block          as e
          | TExpr.Error          as e
          | TExpr.SelfTailCall   as e
          | TExpr.MultipleAssign as e
          | TExpr.StaticEventRef as e
          | TExpr.EventMember    as e => ErrorUnexpectedExpr(e);
          | _ => ()
        }
      }
      walker.Walk(expr, checkInvalidExpre);

      def removeDelayed(expr : TExpr) : TExpr
      {
        | PropertyMember as e => 
          def newObj = e.obj.Walk(removeDelayed);
          if (newObj : object != e.obj)
          {
            def res = TExpr.PropertyMember(e.Type, newObj, e.prop);
            res.Location = e.Location;
            res
          }
          else
            e
            
        | TExpr.StaticPropertyRef as e => e
        | TExpr.Delayed as d when d.susp.IsResolved => d.susp.ResolutionResult
        | _ => null
      }

      //assert2(false);
      expr.Walk(removeDelayed)
    }

    private MakeFullDepencyGraph(symbol : PropertyContainerSymbol, map : Hashtable[DependencyPath, PropertyDependencyNode]) : array[PropertyDependencyNode]
    {
      def replacementList = SCG.List();

      foreach (parent in symbol.GetParents())
      {
        def parentGraph = PropertyDependencyNode.Load(parent);
        foreach (node in parentGraph)
        {
          mutable existingNode;
          if (map.TryGetValue(node.Path, out existingNode))
          {
            when (existingNode.DeclaredIn : object == node.DeclaredIn)
              continue;

            match (node, existingNode)
            {
              | (Use    as use,    Assign as assign) => replacementList.Add(use, assign);
              | (Assign as assign, Use    as use) =>
                map[assign.Path] = assign;
                replacementList.Add(use, assign);

              | (Use, Use) =>
                existingNode.DependendOn.UnionWith(node.DependendOn);
                replacementList.Add(node, existingNode);

              | (Assign, Assign) =>
                if (existingNode.DeclaredIn : object == symbol)
                  replacementList.Add(node, existingNode);
                else
                {
                  def pathText = node.Path.ToString();
                  def name1    = existingNode.DeclaredIn.FullName;
                  def name2    = node.DeclaredIn.FullName;
                  surroundwith (related_messages)
                  {
                    Message.Error(symbol.FirstLocation.NLocation(), $"Multiple assignment of property '$pathText' in parents: '$name1' and '$name2'.");
                    Message.Hint(existingNode.Location, $"First assignment of '$pathText' from '$name1'.");
                    Message.Hint(node.Location,         $"Second assignment of '$pathText' from '$name2'.");
                  }
                }
            }
          }
          else
            map.Add(node.Path, node);
        }

        foreach ((oldNode, newNode) in replacementList)
        {
          foreach (pair in map)
          {
            def dependendOn = pair.Value.DependendOn;
            when (dependendOn.Remove(oldNode))
              _ = dependendOn.Add(newNode);
          }
        }
        replacementList.Clear();
      }

      def result = map.Values.ToArray();
      SortGraphAndReport(result);
      result
    }

    private MakeLocalDependencyGraph(tb : TypeBuilder, symbol : PropertyContainerSymbol, expr : TExpr) : Hashtable[DependencyPath, PropertyDependencyNode]
    {
      def nodesMap = Hashtable();
      def makePath(expr : TExpr) : DependencyPath
      {
        match (expr)
        {
          | TExpr.PropertyMember as e =>
            def path = makePath(e.obj);
            match (Environment.LookupPropertySymbol(e.prop))
            {
              | VSome((propertySymbol, propertyIndex)) => DependencyPath.DeclaredProperty(path, propertySymbol, propertyIndex)
              | VNone                                  => DependencyPath.CustomProperty(path, e.prop.Name)
            }

          | TExpr.Base
          | TExpr.This
          | TExpr.LocalRef(LocalValue(Name = "self", ValKind = LocalValue.Kind.FunParm)) => DependencyPath.This()
          | _ =>  ErrorUnexpectedExpr(expr); null
        }
      }
      def nodeForPropertySymbol(propAccess : TExpr.PropertyMember) : PropertyDependencyNode
      {
        def nodesMap = nodesMap;
        def path = makePath(propAccess);
        mutable to;
        unless (nodesMap.TryGetValue(path, out to))
        {
          to = PropertyDependencyNode.Use(symbol, path, propAccess.Location);
          nodesMap[path] = to;
        }
        to
      }
      def addUseDependence(expr : TExpr, node : PropertyDependencyNode) : void
      {
        match (expr)
        {
          | TExpr.PropertyMember as e =>
            def to = nodeForPropertySymbol(e);
            // Зависимость присвоения зависимого свойства от структурного не имеет смысла. Зато имеет смысл вычислить внутренности
            // структорного свойства после установки "на нем" зависимго свойства. Для этого, разворачиваем зависимости:
            if (node is PropertyDependencyNode.Assign && to is PropertyDependencyNode.Use(IsDependent = false) && to.Path.IsSinglePropertyPath)
              when (to.DependendOn.Add(node))
                addUseDependence(e.obj, to);
            else when (node.DependendOn.Add(to))
              addUseDependence(e.obj, to);

          | TExpr.Base
          | TExpr.This
          | TExpr.LocalRef(LocalValue(Name = "self", ValKind = LocalValue.Kind.FunParm)) => () // OK
          | _ => ErrorUnexpectedExpr(expr); // not a property in member acess
        }
      }
      def addNodesDependentOnAssignedProperty(expr : TExpr, node : PropertyDependencyNode) : void
      {
        def walker = ExprWalker();
        def walk(info : ExprWalkInfo) : void
        {
          def loop(expr)
          {
            | TExpr.PropertyMember as propAccess =>
              addUseDependence(propAccess, node);
              info.Skip();

            | TExpr.Delayed as e when e.susp.IsResolved => loop(e.susp.ResolutionResult)
            | TExpr.Delayed as e => Message.FatalError(e.Location, "Delayed typing detected: " + e)
            | _ => ()
          }

          loop(info.Node)
        }
        walker.Walk(expr, walk);
      }
      def addKey(assign : TExpr.Assign) : void
      {
        match (assign.target)
        {
          | TExpr.PropertyMember as e =>
            if (Environment.LookupPropertySymbol(e.prop).IsSome) //  is VSome((propertySymbol, propertyIndex))
            {
              def path = makePath(e);
              mutable existingNode;
              if (nodesMap.TryGetValue(path, out existingNode))
              {
                Message.Warning(existingNode.Location, "Related message: First assingment of dependent property.");
                Message.FatalError(e.Location, "Multiple assign of dependent property.");
              }
              else if (symbol.IsAbstract)
              {
                def methodName = GetEvalMethodName(path);
                tb.Define(<[ decl: 
                  public static $(methodName : global)(self : this, context : Nitra.Declarations.DependentPropertyEvalContext) : $(assign.source.Type : typed)
                  {
                    $(assign.source : typed)
                  }
                ]>);
                def expr = Util.locate(assign.Location, <[ $(assign.target : typed) = $(methodName : usesite)(this, context) ]>);
                nodesMap[path] = PropertyDependencyNode.Assign(symbol, path, assign.Location, expr);
              }
              else
              {
                def expr = Util.locate(assign.Location, <[ $(assign : typed) ]>);
                nodesMap[path] = PropertyDependencyNode.Assign(symbol, path, assign.Location, expr);
              }
            }
            else
              Message.FatalError(e.Location, "You can assign only a dependent property.");

          | TExpr.Delayed => assert(false);
          | _ => Message.FatalError(assign.target.Location, "You can assign only a dependent property.");
        }
      }
      def processAssign(assign : TExpr.Assign) : void
      {
        match (assign.target)
        {
          | TExpr.PropertyMember as e =>
            if (Environment.LookupPropertySymbol(e.prop).IsSome)
            {
              def nodesMap = nodesMap;
              def path = makePath(e);
              def node = nodesMap[path] :> PropertyDependencyNode.Assign;
              addNodesDependentOnAssignedProperty(assign.source, node);
              addNodesDependentOnAssignedProperty(e.obj, node);
            }
            else
              Message.FatalError(e.Location, "You can assign only a dependent property.");

          | TExpr.Delayed => assert(false);
          | _ => Message.FatalError(assign.target.Location, "You can assign only a dependent property.");
        }
      }
      def addAssigns(expr : TExpr) : void
      {
        match (expr)
        {
          | TExpr.Delayed => assert(false);
          | TExpr.DebugInfo as e => addAssigns(e.expr)
          | TExpr.Sequence as e => addAssigns(e.e1); addAssigns(e.e2);
          | TExpr.Assign as e => addKey(e);
          | e => ErrorUnexpectedExpr(e)
        }
      }
      def calcDependents(expr : TExpr) : void
      {
        | TExpr.Delayed => assert(false);
        | TExpr.DebugInfo as e => calcDependents(e.expr)
        | TExpr.Sequence as e => calcDependents(e.e1); calcDependents(e.e2);
        | TExpr.Assign as e => processAssign(e);
        | e => ErrorUnexpectedExpr(e)
      }

      addAssigns(expr);
      calcDependents(expr);
      //assert2(nodesMap.Count < 5);
      nodesMap
    }

    private CheckStageDependencies(dependencyGraph : array[PropertyDependencyNode]) : void
    {
      foreach (a in dependencyGraph)
      {
        | Assign(Path = DependencyPath.DeclaredProperty(_, DependentPropertySymbol(Direction = DependentPropertyDirection.Out) as target, _)) as a =>
          foreach (d in a.DependendOn)
          {
            when (d.Path is DependencyPath.DeclaredProperty(_, DependentPropertySymbol as source, _))
            when (target.Stage < source.Stage)
            {
              Message.Error(a.Location, $"Reversing stage dependency detected: property '$(target.FullName)' from stage '$(target.Stage)' value depends on property '$(source.FullName)' from stage '$(source.Stage)'.");
              when (target.AssemblyId == AssemblyIds.CurrentAssembly)
                Message.Hint(target.FirstLocation.NLocation(), $"Assigned property from stage '$(target.Stage)'.");
              when (source.AssemblyId == AssemblyIds.CurrentAssembly)
                Message.Hint(source.FirstLocation.NLocation(), $"Dependend property from stage '$(source.Stage)'.");
            }
          }

        | _ => ()
      }
    }

    private GenerateCode(symbol : PropertyContainerSymbol, dependencyGraph : array[PropertyDependencyNode], dependentProperties : SCG.Dictionary[DependentPropertySymbol, BitField]) : PExpr
    {
      def result = SCG.List();
      result.Add(<[ _ = context ]>);

      foreach (node in dependencyGraph)
      {
        | Assign    as a =>
          def code =
            if (a.DependendOn.Count > 0)
            {
              def makeCondition(node : PropertyDependencyNode) : PExpr
              {
                def makeDependentCheck(node : PropertyDependencyNode, properties : SCG.List[DependencyPath], visited : SCG.HashSet[PropertyDependencyNode]) : void
                {
                  unless (visited.Add(node))
                    return;

                  foreach (p in node.DependendOn)
                  {
                    makeDependentCheck(p, properties, visited);
                    properties.Add(p.Path);
                  }
                }

                def properties = SCG.List();
                makeDependentCheck(node, properties, SCG.HashSet());
                GenerateHasValueCheck(properties, dependentProperties)
              }
              <[
                if ($(makeCondition(a)))
                {
                  unless ($(GenerateHasValueCheck(a.Path, dependentProperties)))
                  {
                    $(a.Expr);
                    context.CalculatedCountInc();
                  }
                }
                else
                  context.DeferredCountInc();
              ]>
            }
            else
            {
              <[
                unless ($(GenerateHasValueCheck(a.Path, dependentProperties)))
                {
                  $(a.Expr);
                  context.CalculatedCountInc();
                }
              ]>
            };

          def code =
            if (a.Path is DependencyPath.DeclaredProperty(_, DependentPropertySymbol(Stage = propertyStage), _) when propertyStage > 0)
              <[ when (context.Stage >= $propertyStage) $code ]>
            else
              code;

          result.Add(code);

        | Use => ()
      }

      when (symbol is AstSymbol(IsDeclaration = true))
      when (symbol.LookupProperty("Symbol") is VSome(symbolProperty is DependentPropertySymbol))
      {
        result.Add(<[
          when ($(GenerateHasValueCheck(DependencyPath.DeclaredProperty(DependencyPath.This(), symbolProperty, -1), dependentProperties)))
            this.$(symbolProperty.Name : usesite).EvalProperties(context);
        ]>);
      }

      <[ { ..$result } ]>
    }

    private static SortGraphAndReport(dependencyGraph : array[PropertyDependencyNode]) : void
    {
      def cycled = PropertyDependencyNode.Sort(dependencyGraph);
      if (cycled)
      {
        def cycledNodes = PropertyDependencyNode.FindCycling(dependencyGraph);
        foreach (cycledNode in cycledNodes)
          Message.Error(cycledNode.Location, "Is cycled.");
        otherwise assert(false, "Cycled nodes not found");
      }
      else
        Array.Sort(dependencyGraph, PropertyDependencyNode.Compare);
    }
  }
}
