using Nitra.Typing;
using Nitra.Model;

using Nemerle;
using Nemerle.Collections;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Compiler.Typedtree;
using Nemerle.Imperative;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Linq;
using SCG = System.Collections.Generic;

namespace Nitra.Compiler
{
  internal abstract partial class AstEmitter
  {
    [Record]
    internal sealed class OptionEmitter : CollectionEmitter
    {
      protected override CreateBaseTb(ownerTb : TypeBuilder, itemType : FixedType) : TypeBuilder
      {
        ownerTb.DefineNestedType(<[ decl:
          new public interface IAstOption : Nitra.Declarations.IAstOption[$(itemType : typed)]
          {
          }
        ]>)
      }

      protected override CreateConcreteTb(ownerTb : TypeBuilder, itemType : FixedType, baseType : FixedType) : TypeBuilder
      {
        ownerTb.DefineNestedType(<[ decl:
          new public sealed class AstOption : Nitra.Declarations.AstOption[$(itemType : typed)], $(baseType : typed)
          {
            public this(loc : Nitra.Located)
            {
              base(loc);
            }
            public this(file : $(FileType : typed), span : $(SpanType : typed))
            {
              base(file, span);
            }
            public this(loc : Nitra.Located, value : $(itemType : typed))
            {
              base(loc, value);
            }
            public this(file : $(FileType : typed), span : $(SpanType : typed), value : $(itemType : typed))
            {
              base(file, span, value);
            }
          }
        ]>)
      }

      protected override CreateAmbiguousTb(ownerTb : TypeBuilder, itemType : FixedType, baseType : FixedType) : TypeBuilder
      {
        ownerTb.DefineNestedType(<[ decl:
          new public sealed class AmbiguousAstOption : Nitra.Declarations.AmbiguousAstOption[$(itemType : typed)], $(baseType : typed)
          {
            public this(ambiguities : array[$(baseType : typed)])
            {
              base((ambiguities : object) :> array[Nitra.Declarations.IAstOption[$(itemType : typed)]]);
            }
            public new Ambiguities : array[$(baseType : typed)] { get { base.Ambiguities :> array[$(baseType : typed)] } }
          }
        ]>)
      }

      protected override MakeEvalPropertiesBody(setFirstItemInputs : SCG.List[PExpr], _linkEachItemProperties : SCG.List[PExpr], readLastItemOutputs : SCG.List[PExpr], setEmptyListOutputs : SCG.List[PExpr]) : PExpr
      {
        <[
          if (this.HasValue)
          {
            def item = this._value;
            ..$setFirstItemInputs;
            item.EvalProperties(context);
            ..$readLastItemOutputs;
          }
          else { ..$setEmptyListOutputs }
        ]>
      }
    }
  }
}
