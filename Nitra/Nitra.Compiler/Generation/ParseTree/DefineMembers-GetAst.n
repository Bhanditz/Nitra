using Nemerle;
using Nemerle.Collections;
using Nemerle.Imperative;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Compiler.Typedtree;

using Nitra.ProjectSystem;
using Nitra.Internal;
using Nitra.Model;
using Nitra.Typing;
using Nitra.Compiler.PatternMatching;

using System;
using System.Diagnostics;
using System.Linq;
using SCG = System.Collections.Generic;

namespace Nitra.Compiler
{
  internal abstract partial class RuleParseTreeEmitter
  {
    protected DefineExtensibleRuleGetAstMethod(_baseTb : TypeBuilder) : void
    {
      assert(_baseTb != null);

      foreach (syntaxMapping in this.RuleSymbol.SyntaxMappings)
      {
        def returnType = Environment.GetAstType(syntaxMapping.ReturnType);
        def parms      = syntaxMapping.Parameters.Map(p => Util.locate(p.Location.NLocation(), <[ parameter: $(p.Name.Value : usesite) : $(Environment.GetAstType(p.Type)) ]>));
        _baseTb.Define(<[ decl: public abstract $(syntaxMapping.Name : usesite)(..$parms) : $returnType ]>);
      }
    }

    private static MakeParseTreeMemberAccess(path : ParseTreePath) : PExpr
    {
      Util.locate(path.Location.NLocation(),
        match(path)
        {
          | This                       => <[ this ]>
          | Variable(name, _)          => <[ $(name.Value : usesite) ]>
          | Member(qualifier, name, _) => <[ $(MakeParseTreeMemberAccess(qualifier)).$(name.Value : usesite) ]>
        })
    }

    private CompileParseTreeMemberAccess(path : ParseTreePath, tb : TypeBuilder, astType : AstType, compile : PExpr -> PExpr) : PExpr
    {
      def needsBuffer(_ : ParseTreePath) : bool
      {
        | This               => false
        | Variable           => false
        | Member(This, _, _) => false
        | Member(_, _, _)    => true
      }

      def compileAccess(path : ParseTreePath, compile : PExpr -> PExpr) : PExpr
      {
        def loc = path.Location.NLocation();
        match (path)
        {
          | This                       => compile(Util.locate(loc, <[ this ]>))
          | Variable(name, _)          => compile(Util.locate(loc, <[ $(name.Value : usesite) ]>))
          | Member(This, name, _)      => compile(Util.locate(loc, <[ this.$(name.Value : usesite) ]>))
          | Member(qualifier, name, _) =>
            def parseTreeType = Environment.GetParseTreeType(qualifier.Type);
            def methodName    = Util.tmpname("Get_" + name);
            tb.Define(<[ decl:
              private $(methodName : usesite)(parseTree : $(parseTreeType : typed), buffer : ref Nemerle.Collections.LightList[$(Environment.GetAstType(astType))]) : void
              {
                if (parseTree.IsAmbiguous)
                {
                  foreach (item in (parseTree :> Nitra.IAmbiguousParseTree).Ambiguities :> array[$(parseTreeType : typed)])
                    $(methodName : usesite)(item, ref buffer)
                }
                else unless (parseTree.IsMissing)
                  $(compile(<[ parseTree.$(name.Value : usesite) ]>))
              }
            ]>);
            compileAccess(qualifier, expr => Util.locate(loc, <[ $(methodName : usesite)($expr, ref buffer) ]>))
        }
      }

      if (needsBuffer(path))
      {
        def code = compileAccess(path, expr => <[ buffer.Add($(compile(expr))) ]>);
        <[
          mutable buffer = Nemerle.Collections.LightList();
          $code;
          match (buffer.Count)
          {
            | 0 => $(AstEmitter.GetMissingAstCtor(Environment, astType))(this.File, this.Span)
            | 1 => buffer.FirstItem
            | _ => $(AstEmitter.GetAmbiguousAstCtor(Environment, astType))(buffer.ToArray())
          }
        ]>
      }
      else
        compileAccess(path, compile)
    }

    private CompileSyntaxMapping(expr : SyntaxMappingExpr, tb : TypeBuilder, loc : void -> PExpr) : PExpr
    {
      assert(expr != null);

      def compileField(field : SyntaxMappingField) : PExpr
      {
        def name  = field.Property.Name;
        def value = CompileSyntaxMapping(field.Expr, tb, loc);
        <[ $(name : usesite) = $value ]>
      }

      def nodeLoc() : PExpr { <[ node ]> }

      def callGetAst(args : list[SyntaxMappingExpr], loc : void -> PExpr) : PExpr -> PExpr
      {
        fun (obj) { <[ $obj.GetAst(..$(args.Map(CompileSyntaxMapping(_, tb, loc)))) ]> }
      }

      def compileMatch(path : ParseTreePath, cases : list[SyntaxMappingCase]) : PExpr
      {
        def compileAccess(_ : Access) : PExpr
        {
          | Obj                            => MakeParseTreeMemberAccess(path) // TODO: rewrite with CompileParseTreeMemberAccess approach
          | Sel(ListCons,   0,     access) => <[ $(compileAccess(access)).Head ]>
          | Sel(ListCons,   1,     access) => <[ $(compileAccess(access)).Tail ]>
          | Sel(OptionSome, 0,     access) => <[ $(compileAccess(access)).Value ]>
          | Sel(Tuple,      index, access) => <[ $(compileAccess(access)).$("Item" + (index + 1) : usesite) ]>
          | Sel(ParseTree,  index, access) => <[ $(compileAccess(access)).$(RuleSymbol.NonVoidSubRules.Nth(index).FieldName : usesite) ]>
          | _ => assert(false, "Invalid access path")
        }

        def compileTest(n : string, ctor : ParseTreeCtor) : PExpr
        {
          match (ctor)
          {
            | ListCons   => <[ $(n : usesite).Count > 0 ]>
            | ListNil    => <[ $(n : usesite).Count == 0 ]>
            | OptionSome => <[ $(n : usesite).HasValue ]>
            | OptionNone => <[ ! $(n : usesite).HasValue ]>
            | Tuple
            | ParseTree  => assert(false, "Check is redundant")
          }
        }

        def     redundantCases : SCG.HashSet[_] = SCG.HashSet(cases);
        mutable canFail        : bool;
        def compileDecision(d : Decision[SyntaxMappingCase], loc : void -> PExpr) : PExpr
        {
          match (d)
          {
            | Failure =>
              canFail = true;
              <[ assert(false, "Match failed") ]>

            | Success(case)                     =>
              _ = redundantCases.Remove(case);
              CompileSyntaxMapping(case.Expr, tb, loc)

            | Variable(name, access, continuation) =>
              <[
                def $(name.Value : global) = $(compileAccess(access));
                $(compileDecision(continuation, loc))
              ]>.FlattenPExpr()

            | IfEq(access, ctor, t, f) =>
              def n = Util.tmpname("parseTree");
              def loc () { <[ $(n : usesite) ]> }
              <[
                def $(n : usesite) = $(compileAccess(access));
                if ($(compileTest(n, ctor)))
                  $(compileDecision(t, loc))
                else
                  $(compileDecision(f, loc))
              ]>
          }
        }

        def rules      = cases.Map(c => (c.Pattern, c));
        def decision   = MatchCompiler.Compile(rules);
        def code       = compileDecision(decision, loc);
        when (canFail)
          Environment.Project.Warning(expr, "Matching is not exhaustive.");
        foreach (case in redundantCases)
          Environment.Project.Warning(case, "Match case is redundant.");
        code
      }

      Util.locate(expr.Location.NLocation(),
      {
        match (expr)
        {
          | Error                              => assert(false)
          | Code(code)                         => code
          | ParameterRef(par)                  => <[ $(par.Name.Value : usesite) ]>
          | PropertyRef(targetExpr, symbol)    => <[ $(CompileSyntaxMapping(targetExpr, tb, loc)).$(symbol.Name : usesite) ]> // TODO: may hide AST ambiguitys
          | AstCtor(astSymbol, args)           => <[ $(Environment.GetAstType(astSymbol) : typed)(File = $(loc()).File, Span = $(loc()).Span, ..$(args.Map(compileField))) ]>
          | ListCtor(astSymbol, [])            => <[ $(Environment.GetAstType(astSymbol) : typed).AstList($(loc())) ]>
          | ListCtor(astSymbol, items)         => <[ $(Environment.GetAstType(astSymbol) : typed).AstList($(loc()), ..$(items.Map(CompileSyntaxMapping(_, tb, loc)))) ]>
          | OptionCtor(astSymbol, Some(value)) => <[ $(Environment.GetAstType(astSymbol) : typed).AstOption($(loc()), $(CompileSyntaxMapping(value, tb, loc))) ]>
          | OptionCtor(astSymbol, None())      => <[ $(Environment.GetAstType(astSymbol) : typed).AstOption($(loc())) ]>
          | Match(path, cases)                 => compileMatch(path, cases)
          | Call(path, args, returnType)       => CompileParseTreeMemberAccess(path, tb, returnType, callGetAst(args, loc))
          | ConvertList(path, args, astSymbol, itemPath) =>
            def astType     = Environment.GetAstType(astSymbol);
            def itemExpr    = CompileParseTreeMemberAccess(itemPath, tb, AstType.Ast(expr.Location, astSymbol), callGetAst(args, nodeLoc));
            def callConvert = DefineConvertMethod(tb, path.Type, AstType.List(expr.Location, astSymbol),
              <[
                def items = array(parseTree.Count);
                foreach (node in parseTree with index)
                  items[index] = $itemExpr;
                $(astType : typed).AstList(parseTree, items)
              ]>);
            CompileParseTreeMemberAccess(path, tb, AstType.List(expr.Location, astSymbol), callConvert)

          | ConvertOption(path, args, astSymbol, valuePath) =>
            def astType     = Environment.GetAstType(astSymbol);
            def valueExpr   = CompileParseTreeMemberAccess(valuePath, tb, AstType.Ast(expr.Location, astSymbol), callGetAst(args, nodeLoc));
            def callConvert = DefineConvertMethod(tb, path.Type, AstType.Option(expr.Location, astSymbol),
              <[
                if (parseTree.HasValue)
                {
                  def node = parseTree.Value;
                  $(astType : typed).AstOption(parseTree, $valueExpr)
                }
                else
                  $(astType : typed).AstOption(parseTree)
              ]>);
            CompileParseTreeMemberAccess(path, tb, AstType.Option(expr.Location, astSymbol), callConvert)

          | ConcatLists(path, args, astSymbol, itemPath) =>
            def astType     = Environment.GetAstType(astSymbol);
            def itemExpr    = CompileParseTreeMemberAccess(itemPath, tb, AstType.List(expr.Location, astSymbol), callGetAst(args, nodeLoc));
            def callConvert = DefineConvertMethod(tb, path.Type, AstType.List(expr.Location, astSymbol),
              <[
                def items = System.Collections.Generic.List();
                foreach (node in parseTree)
                  items.AddRange($itemExpr);
                $(astType : typed).AstList(parseTree, items.ToArray())
              ]>);
            CompileParseTreeMemberAccess(path, tb, AstType.List(expr.Location, astSymbol), callConvert)

          | ConcatOptions(path, args, astSymbol, itemPath) =>
            def astType     = Environment.GetAstType(astSymbol);
            def itemExpr    = CompileParseTreeMemberAccess(itemPath, tb, AstType.Option(expr.Location, astSymbol), callGetAst(args, nodeLoc));
            def callConvert = DefineConvertMethod(tb, path.Type, AstType.List(expr.Location, astSymbol),
              <[
                def items = System.Collections.Generic.List();
                foreach (node in parseTree)
                {
                  def ast = $itemExpr;
                  when (ast.HasValue)
                    items.Add(ast.Value);
                }
                $(astType : typed).AstList(parseTree, items.ToArray())
              ]>);
            CompileParseTreeMemberAccess(path, tb, AstType.List(expr.Location, astSymbol), callConvert)
        }
      });
    }

    private DefineConvertMethod(tb : TypeBuilder, ruleType : RuleType, returnType : AstType, body : PExpr) : PExpr -> PExpr
    {
      def parseTreeType = Environment.GetParseTreeType(ruleType);
      def name          = Util.tmpname("Convert_" + ruleType.ToString());
      tb.Define(<[ decl:
        private $(name : usesite)(parseTree : $(parseTreeType : typed)) : $(Environment.GetAstType(returnType))
        {
          unchecked
          {
            if (parseTree.IsAmbiguous)
            {
              def ambiguities  = Nitra.Internal.AstUtils.GetAstAmbiguities(parseTree :> Nitra.IAmbiguousParseTree, $(name : usesite));
              $(AstEmitter.GetAmbiguousAstCtor(Environment, returnType))(ambiguities)
            }
            else
              $body
          }
        }
      ]>);
      fun (obj) { <[ $(name : usesite)($obj) ]> }
    }

    private DefineGetAstMethod(tb : TypeBuilder, syntaxMapping : SyntaxMappingSymbol, modifiers : NemerleModifiers, code : PExpr) : void
    {
      def returnType = Environment.GetAstType(syntaxMapping.ReturnType);
      def mods       = AttributesAndModifiers(modifiers, []);
      def parms      = syntaxMapping.Parameters.Map(p => Util.locate(p.Location.NLocation(), <[ parameter: $(p.Name.Value : usesite) : $(Environment.GetAstType(p.Type)) ]>));
      def isOverride = modifiers %&& NemerleModifiers.Override;
      if (parms.IsEmpty && !isOverride)
        tb.Define(<[ decl: ..$mods $(syntaxMapping.Name : usesite)(..$parms) : $returnType implements Nitra.IMappedParseTree.GetAst { $code } ]>)
      else
        tb.Define(<[ decl: ..$mods $(syntaxMapping.Name : usesite)(..$parms) : $returnType $code ]>);
    }

    protected DefineSimpleRuleGetAstMethod(_nodeTb : TypeBuilder) : void
    {
      assert(_nodeTb != null);

      foreach (syntaxMapping in this.RuleSymbol.SyntaxMappings)
      {
        def code = CompileSyntaxMapping(syntaxMapping.Expression, _nodeTb, () => <[ this ]>);
        DefineGetAstMethod(_nodeTb, syntaxMapping, NemerleModifiers.Public %| NemerleModifiers.Virtual, code)
      }
    }

    protected DefineExtensionRuleGetAstMethod(_nodeTb : TypeBuilder) : void
    {
      assert(_nodeTb != null);

      foreach (syntaxMapping in this.RuleSymbol.SyntaxMappings)
      {
        def code = CompileSyntaxMapping(syntaxMapping.Expression, _nodeTb, () => <[ this ]>);
        DefineGetAstMethod(_nodeTb, syntaxMapping, NemerleModifiers.Public %| NemerleModifiers.Override, code)
      }
    }

    protected DefineAmbiguousOrMissingGetAstMethod(_ambiguousOrMissingTb : TypeBuilder) : void
    {
      assert(_ambiguousOrMissingTb != null);

      foreach (syntaxMapping in this.RuleSymbol.SyntaxMappings)
      {
        def getAmbigs =
          if (syntaxMapping.Parameters.IsEmpty)
            <[ Nitra.Internal.AstUtils.GetAstAmbiguities(this.ambiguities) ]>
          else
            <[
              def astAmbiguities = array(this.ambiguities.Length);
              foreach (node in this.ambiguities with index)
                astAmbiguities[index] = node.GetAst(..$(syntaxMapping.Parameters.Map(p => <[ $(p.Name.Value : usesite) ]>)));
              astAmbiguities
            ]>;
        def code =
          <[
            if (this.IsAmbiguous)
              $(AstEmitter.GetAmbiguousAstCtor(Environment, syntaxMapping.ReturnType))($getAmbigs)
            else
              $(AstEmitter.GetMissingAstCtor(Environment, syntaxMapping.ReturnType))(this.File, $(Environment.NSpanTypeVar : typed)(this.pos))
          ]>;
        DefineGetAstMethod(_ambiguousOrMissingTb, syntaxMapping, NemerleModifiers.Public %| NemerleModifiers.Override, code)
      }
    }
  }
}
