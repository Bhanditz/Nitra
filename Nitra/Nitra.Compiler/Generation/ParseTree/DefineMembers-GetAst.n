using Nemerle;
using Nemerle.Collections;
using Nemerle.Imperative;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Compiler.Typedtree;

using Nitra.ProjectSystem;
using Nitra.Internal;
using Nitra.Model;
using Nitra.Typing;
using Nitra.Compiler.PatternMatching;

using System;
using System.Diagnostics;
using System.Linq;
using SCG = System.Collections.Generic;

namespace Nitra.Compiler
{
  internal abstract partial class RuleParseTreeEmitter
  {
    protected GetBaseDeclarationType(declarationSymbol : DeclarationSymbol) : PExpr
    {
      | ExtensionDeclarationSymbol(BaseDeclaration = baseDeclaration) => GetBaseDeclarationType(baseDeclaration.GetValue(Environment.Project))
      | ExtensibleDeclarationSymbol
      | SimpleDeclarationSymbol => <[ $(Environment.GetDeclarationType(declarationSymbol) : typed) ]>
      | _ => assert(false, "Invalid declaration symbol")
    }

    protected GetConcreteDeclarationType(declarationSymbol : DeclarationSymbol) : PExpr
    {
      | ExtensibleDeclarationSymbol
      | ExtensionDeclarationSymbol  => <[ $(Environment.GetDeclarationType(declarationSymbol) : typed) ]>
      | SimpleDeclarationSymbol     => <[ $(Environment.GetDeclarationType(declarationSymbol) : typed).Concrete ]>
      | _ => assert(false, "Invalid declaration symbol")
    }

    protected GetAmbiguousDeclarationType(declarationSymbol : DeclarationSymbol) : PExpr
    {
      | ExtensionDeclarationSymbol(BaseDeclaration = baseDeclaration) => GetAmbiguousDeclarationType(baseDeclaration.GetValue(Environment.Project))
      | ExtensibleDeclarationSymbol
      | SimpleDeclarationSymbol     => <[ $(Environment.GetDeclarationType(declarationSymbol) : typed).Ambiguous ]>
      | _ => assert(false, "Invalid declaration symbol")
    }

    protected DefineExtensibleRuleGetAstMethod(_baseTb : TypeBuilder) : void
    {
      assert(_baseTb != null);

      def syntaxMappingBody = this.RuleSymbol.GetSyntaxMappingBody();
      when (syntaxMappingBody != null)
      {
        def declarationSymbol   = syntaxMappingBody.Declaration.GetValue(Environment.Project);
        def baseDeclarationType = GetBaseDeclarationType(declarationSymbol);
        _baseTb.DefineConditional(<[ decl:
          public abstract GetAst() : $baseDeclarationType
        ]>);
      }
    }

    private static MakeParseTreeMemberAccess(path : ParseTreePath) : PExpr
    {
      Util.locate(path.Location.ToNemerleLocation(),
        match(path)
        {
          | This                       => <[ this ]>
          | Variable(name, _)          => <[ $(name.Id : usesite) ]>
          | Member(qualifier, name, _) => <[ $(MakeParseTreeMemberAccess(qualifier)).$(name.Id : usesite) ]>
        })
    }

    [Record]
    private struct BuildAstResult
    {
      public Code            : PExpr;
      public DeclarationType : FixedType;

      public this(code : PExpr)
      {
        this(code, null)
      }

      public List            : PExpr
      {
        get { if (DeclarationType != null) <[ $(DeclarationType : typed).IAstList ]>           else <[ Nitra.Declarations.IAstList[Nitra.Declarations.IAst] ]> }
      }

      public ConcreteList    : PExpr
      {
        get { if (DeclarationType != null) <[ $(DeclarationType : typed).AstList ]>            else <[ Nitra.Declarations.AstList[Nitra.Declarations.IAst] ]> }
      }

      public AmbiguousList   : PExpr
      {
        get { if (DeclarationType != null) <[ $(DeclarationType : typed).AmbiguousAstList ]>   else <[ Nitra.Declarations.AmbiguousAstList[Nitra.Declarations.IAst] ]> }
      }

      public Option          : PExpr
      {
        get { if (DeclarationType != null) <[ $(DeclarationType : typed).IAstOption ]>         else <[ Nitra.Declarations.IAstOption[Nitra.Declarations.IAst] ]> }
      }

      public ConcreteOption  : PExpr
      {
        get { if (DeclarationType != null) <[ $(DeclarationType : typed).AstOption ]>          else <[ Nitra.Declarations.AstOption[Nitra.Declarations.IAst] ]> }
      }

      public AmbiguousOption : PExpr
      {
        get { if (DeclarationType != null) <[ $(DeclarationType : typed).AmbiguousAstOption ]> else <[ Nitra.Declarations.AmbiguousAstOption[Nitra.Declarations.IAst] ]> }
      }
    }

    private DefineGetAstMethod(tb : TypeBuilder, syntaxMappingBody : SyntaxMappingBody, modifiers : NemerleModifiers) : void
    {
      def declarationSymbol = syntaxMappingBody.Declaration.GetValue(Environment.Project);

      def buildAst(mappingType : SyntaxMappingType, obj : PExpr) : BuildAstResult
      {
        match (mappingType)
        {
          | List(item, ruleType) =>
            def parseTreeType     = Environment.GetParseTreeType(ruleType);
            def itemResult        = buildAst(item, <[ node ]>);
            def getAstListName    = Util.tmpname("GetAstList");
            tb.Define(<[ decl:
              private static $(getAstListName : usesite)(lst : $(parseTreeType : typed)) : $(itemResult.List)
              {
                unchecked
                {
                  if (lst.IsAmbiguous)
                  {
                    def ambiguities  = Nitra.Internal.AstUtils.GetAstAmbiguities(lst :> Nitra.IAmbiguousParseTree, $(getAstListName : usesite));
                    $(itemResult.AmbiguousList)(ambiguities)
                  }
                  else
                  {
                    def items = array(lst.Count);
                    foreach (node in lst with index)
                      items[index] = $(itemResult.Code);
                    $(itemResult.ConcreteList)(lst.Location.Span, items)
                  }
                }
              }
            ]>);
            BuildAstResult(<[ $(getAstListName : usesite)($obj) ]>)

          | Option(item, ruleType) =>
            def parseTreeType      = Environment.GetParseTreeType(ruleType);
            def itemResult         = buildAst(item, <[ opt.Value ]>);
            def getAstOptionName   = Util.tmpname("GetAstOption");
            tb.Define(<[ decl:
              private static $(getAstOptionName : usesite)(opt : $(parseTreeType : typed)) : $(itemResult.Option)
              {
                unchecked
                {
                  if (opt.IsAmbiguous)
                  {
                    def ambiguities  = Nitra.Internal.AstUtils.GetAstAmbiguities(opt :> Nitra.IAmbiguousParseTree, $(getAstOptionName : usesite));
                    $(itemResult.AmbiguousOption)(ambiguities)
                  }
                  else if (opt.HasValue)
                    $(itemResult.ConcreteOption)(opt.Location.Span, $(itemResult.Code))
                  else
                    $(itemResult.ConcreteOption)(opt.Location.Span)
                }
              }
            ]>);
            BuildAstResult(<[ $(getAstOptionName : usesite)( $obj) ]>)

          | Ref(declarationSymbol) => BuildAstResult(<[ $obj.GetAst() ]>, Environment.GetDeclarationType(declarationSymbol))
          | Tuple(index, item)     => buildAst(item, <[ $obj.$("Item" + index.ToString() : usesite) ]>)
        }
      }

      def compileField(field : SyntaxMappingField) : PExpr
      {
        def declarationPropertySymbol = field.DeclarationProperty.GetValue(Environment.Project);
        Util.locate(field.Location.ToNemerleLocation(),
          match (field)
          {
            | Error        => assert(false, "Syntax mapping field is not valid")
            | Inline(code) => <[ $(declarationPropertySymbol.Name : usesite) = $code ]>
            | Automatic(path, mappingType) =>
              def parseTreeMember = MakeParseTreeMemberAccess(path);
              <[ $(declarationPropertySymbol.Name : usesite) = unchecked ($(buildAst(mappingType, parseTreeMember).Code)) ]>
          });
      }

      def compileFields(declarationSymbol : DeclarationSymbol, fields : list[SyntaxMappingField]) : PExpr
      {
        def concreteDeclarationType = GetConcreteDeclarationType(declarationSymbol);
        def values                  = <[ Span = this.Location.Span ]> :: fields.Map(compileField);
        <[ $concreteDeclarationType(..$values) ]>
      }

      def makeTopPattern(case : SyntaxMappingCase) : ParseTreePattern * SyntaxMappingCase
      {
        def args = case.Patterns;
        def ctor = ParseTreeCtor.Tuple(args.Length);
        def topPattern = ParseTreePattern.Ctor(case.Location, RuleType.Ref(RuleSymbol), ctor, args);
        (topPattern, case)
      }

      def compileDecision(obj : PExpr, decision : Decision[_]) : PExpr
      {
        match (decision)
        {
          | Failure       => <[ assert("Match failed") ]>
          | Success(case) =>
            def caseDeclarationSymbol = case.Declaration.GetValue(Environment.Project);
            compileFields(caseDeclarationSymbol, case.Fields)

          | IfEq(access, ctor, t, f) =>
            assert(false, "TODO")
        }
      }

      Util.locate(syntaxMappingBody.Location.ToNemerleLocation(),
      {
        def code =
          match (syntaxMappingBody)
          {
            | Error            => assert(false, "Syntax mapping body is not valid")
            | CallMember(path) => <[ $(MakeParseTreeMemberAccess(path)).GetAst() ]>
            | PerField(fields) => compileFields(declarationSymbol, fields)
            | Inline(code)     => code
            | Match(cases)     =>
              def rules    = cases.Map(makeTopPattern);
              def decision = MatchCompiler.Compile(rules);
              compileDecision(<[ this ]>, decision)
          };

        def baseDeclarationType = GetBaseDeclarationType(declarationSymbol);
        def mods                = AttributesAndModifiers(modifiers, []);
        tb.Define(<[ decl: ..$mods GetAst() : $baseDeclarationType { $code } ]>);
      });
    }

    protected DefineSimpleRuleGetAstMethod(_nodeTb : TypeBuilder) : void
    {
      assert(_nodeTb != null);

      def syntaxMappingBody = this.RuleSymbol.GetSyntaxMappingBody();
      when (syntaxMappingBody != null)
        DefineGetAstMethod(_nodeTb, syntaxMappingBody, NemerleModifiers.Public %| NemerleModifiers.Virtual)
    }

    protected DefineExtensionRuleGetAstMethod(_nodeTb : TypeBuilder) : void
    {
      assert(_nodeTb != null);

      def syntaxMappingBody = this.RuleSymbol.GetSyntaxMappingBody();
      when (syntaxMappingBody != null)
        DefineGetAstMethod(_nodeTb, syntaxMappingBody, NemerleModifiers.Public %| NemerleModifiers.Override)
    }

    protected DefineAmbiguousGetAstMethod(_ambiguousTb : TypeBuilder) : void
    {
      assert(_ambiguousTb != null);

      def syntaxMappingBody = this.RuleSymbol.GetSyntaxMappingBody();
      when (syntaxMappingBody != null)
      {
        def declarationSymbol        = syntaxMappingBody.Declaration.GetValue(Environment.Project);
        def baseDeclarationType      = GetBaseDeclarationType(declarationSymbol);
        def ambiguousDeclarationType = GetAmbiguousDeclarationType(declarationSymbol);
        _ambiguousTb.Define(<[ decl:
          public override GetAst() : $baseDeclarationType
          {
            def ambiguities = Nitra.Internal.AstUtils.GetAstAmbiguities(this.Ambiguities);
            $ambiguousDeclarationType(ambiguities)
          }
        ]>);
      }
    }

    protected DefineMissingGetAstMethod(_missingTb : TypeBuilder) : void
    {
      assert(_missingTb != null);

      def syntaxMappingBody = this.RuleSymbol.GetSyntaxMappingBody();
      when (syntaxMappingBody != null)
      {
        def declarationSymbol   = syntaxMappingBody.Declaration.GetValue(Environment.Project);
        def baseDeclarationType = GetBaseDeclarationType(declarationSymbol);
        _missingTb.Define(<[ decl:
          public override GetAst() : $baseDeclarationType
          {
            null
          }
        ]>);
      }
    }
  }
}
