using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Compiler.Typedtree;

using Nitra.ProjectSystem;
using Nitra.Internal;
using Nitra.Model;
using Nitra.Typing;
using Nitra.Compiler.PatternMatching;

using System;
using System.Diagnostics;
using System.Linq;
using SCG = System.Collections.Generic;

namespace Nitra.Compiler
{
  internal abstract partial class RuleParseTreeEmitter
  {
    protected DefineExtensibleRuleGetAstMethod(_baseTb : TypeBuilder) : void
    {
      assert(_baseTb != null);

      foreach (syntaxMapping in this.RuleSymbol.SyntaxMappings)
      {
        def returnType = Environment.GetAstType(syntaxMapping.ReturnType);
        def parms      = syntaxMapping.Parameters.Map(p => Util.locate(p.Location.NLocation(), <[ parameter: $(p.Name.Value : usesite) : $(Environment.GetAstType(p.Type)) ]>));
        _baseTb.Define(<[ decl: public abstract $(syntaxMapping.Name : usesite)(..$parms) : $returnType ]>);
      }
    }

    private static MakeParseTreeMemberAccess(path : ParseTreePath) : PExpr
    {
      Util.locate(path.Location.NLocation(),
        match(path)
        {
          | This                       => <[ this ]>
          | Variable(name, _)          => <[ $(name.Value : usesite) ]>
          | Member(qualifier, name, _) => <[ $(MakeParseTreeMemberAccess(qualifier)).$(name.Value : usesite) ]>
        })
    }

    private CompileParseTreeMemberAccess(path : ParseTreePath, astType : AstType, needsParseTreeCheck : bool, compile : PExpr -> PExpr) : PExpr
    {
      def missingLocName = Util.tmpname("missingLoc");
      mutable needsBuffer : bool;

      def checkParseTree(ruleType : RuleType, expr : PExpr, compile : PExpr -> PExpr) : PExpr
      {
        needsBuffer = true;
        def parseTreeType = Environment.GetParseTreeType(ruleType);
        <[
          def parseTree = $expr;
          if (parseTree.IsMissing)
            $(missingLocName : usesite) = parseTree;
          else
          {
            def loop(item : $(parseTreeType : typed) * int) : void
            {
              $(compile(<[ item[0] ]>));
              when (item[1] > 0)
                loop(Nitra.Internal.AstUtils.GetNextAmbiguity(parseTree, item[1]));
            }
            loop(Nitra.Internal.AstUtils.GetFirstAmbiguity(parseTree))
          }
        ]>
      }

      def compileAccess(path : ParseTreePath, needsParseTreeCheck : bool, compile : PExpr -> PExpr) : PExpr
      {
        def loc = path.Location.NLocation();
        match (path)
        {
          | This                       => compile(Util.locate(loc, <[ this ]>))
          | Variable(name, _)          =>
            def varAccess = Util.locate(loc, <[ $(name.Value : usesite) ]>);
            if (needsParseTreeCheck)
              checkParseTree(path.Type, varAccess, compile)
            else
              compile(varAccess)

          | Member(qualifier, name, _) =>
            if (needsParseTreeCheck)
              compileAccess(qualifier, true, expr => checkParseTree(path.Type, Util.locate(loc, <[ $expr.$(name.Value : usesite) ]>), compile))
            else
              compileAccess(qualifier, true, expr => compile(Util.locate(loc, <[ $expr.$(name.Value : usesite) ]>)))
        }
      }

      def code =
        compileAccess(path, needsParseTreeCheck, fun (expr)
        {
          if (needsBuffer)
            <[ buffer.Add($(compile(expr))) ]>
          else
            compile(expr)
        });

      if (needsBuffer)
      <[
        mutable $(missingLocName : usesite) : Nitra.Located; // avoid warning about multiple mutable variable declaration
        def buffer = Nemerle.Collections.LightList();
        $code;
        match (buffer.Count)
        {
          | 0 => $(AstEmitter.GetMissingAstCtor(Environment, astType))($(missingLocName : usesite).File, $(missingLocName : usesite).Span)
          | 1 => buffer.FirstItem
          | _ => $(AstEmitter.GetAmbiguousAstCtor(Environment, astType))(buffer.ToArray())
        }
      ]>
      else
        code
    }

    private CompileSyntaxMapping(expr : SyntaxMappingExpr, loc : void -> PExpr) : PExpr
    {
      assert(expr != null);

      def compileField(field : SyntaxMappingField) : PExpr
      {
        def name  = field.Property.Name;
        def value = CompileSyntaxMapping(field.Expr, loc);
        <[ $(name : usesite) = $value ]>
      }

      def callItemGetAst(args : list[SyntaxMappingExpr], path : ParseTreePath, astType : AstType) : SCG.List[PExpr] * PExpr
      {
        def parseTreeLoc() { <[ parseTree ]> }
        def argExprs = SCG.List();
        def argRefs  = SCG.List();
        foreach (arg in args)
        {
          def varName = Util.tmpname("arg");
          argExprs.Add(<[ def $(varName : usesite) = $(CompileSyntaxMapping(arg, parseTreeLoc)) ]>);
          argRefs.Add(<[ $(varName : usesite) ]>)
        }
        def expr = CompileParseTreeMemberAccess(path, astType, false, obj => <[ $obj.GetAst(..$argRefs) ]>);
        (argExprs, expr)
      }

      def compileMatch(path : ParseTreePath, cases : list[SyntaxMappingCase]) : PExpr
      {
        def compileAccess(_ : Access) : PExpr
        {
          | Obj                            => MakeParseTreeMemberAccess(path) // TODO: rewrite with CompileParseTreeMemberAccess approach
          | Sel(ListCons,   0,     access) => <[ $(compileAccess(access)).Head ]>
          | Sel(ListCons,   1,     access) => <[ $(compileAccess(access)).Tail ]>
          | Sel(OptionSome, 0,     access) => <[ $(compileAccess(access)).Value ]>
          | Sel(Tuple,      index, access) => <[ $(compileAccess(access)).$("Item" + (index + 1) : usesite) ]>
          | Sel(ParseTree,  index, access) => <[ $(compileAccess(access)).$(RuleSymbol.NonVoidSubRules.Nth(index).FieldName : usesite) ]>
          | _ => assert(false, "Invalid access path")
        }

        def compileTest(n : string, ctor : ParseTreeCtor) : PExpr
        {
          match (ctor)
          {
            | ListCons   => <[ $(n : usesite).Count > 0 ]>
            | ListNil    => <[ $(n : usesite).Count == 0 ]>
            | OptionSome => <[ $(n : usesite).HasValue ]>
            | OptionNone => <[ ! $(n : usesite).HasValue ]>
            | Tuple
            | ParseTree  => assert(false, "Check is redundant")
          }
        }

        def     redundantCases : SCG.HashSet[_] = SCG.HashSet(cases);
        mutable canFail        : bool;
        def compileDecision(d : Decision[SyntaxMappingCase], loc : void -> PExpr) : PExpr
        {
          match (d)
          {
            | Failure =>
              canFail = true;
              <[ assert(false, "Match failed") ]>

            | Success(case)                     =>
              _ = redundantCases.Remove(case);
              CompileSyntaxMapping(case.Expr, loc)

            | Variable(name, access, continuation) =>
              <[
                def $(name.Value : global) = $(compileAccess(access));
                $(compileDecision(continuation, loc))
              ]>.FlattenPExpr()

            | IfEq(access, ctor, t, f) =>
              def n = Util.tmpname("parseTree");
              def loc () { <[ $(n : usesite) ]> }
              <[
                def $(n : usesite) = $(compileAccess(access));
                if ($(compileTest(n, ctor)))
                  $(compileDecision(t, loc))
                else
                  $(compileDecision(f, loc))
              ]>
          }
        }

        def rules      = cases.Map(c => (c.Pattern, c));
        def decision   = MatchCompiler.Compile(rules);
        def code       = compileDecision(decision, loc);
        when (canFail)
          Environment.Project.Warning(expr, "Matching is not exhaustive.");
        foreach (case in redundantCases)
          Environment.Project.Warning(case, "Match case is redundant.");
        code
      }

      Util.locate(expr.Location.NLocation(),
      {
        match (expr)
        {
          | Error                              => assert(false)
          | Code(code)                         => code
          | ParameterRef(par)                  => <[ $(par.Name.Value : usesite) ]>
          | PropertyRef(targetExpr, symbol)    => <[ $(CompileSyntaxMapping(targetExpr, loc)).$(symbol.Name : usesite) ]> // TODO: may hide AST ambiguitys
          | AstCtor(astSymbol, args)           => <[ $(Environment.GetAstType(astSymbol) : typed)(File = $(loc()).File, Span = $(loc()).Span, ..$(args.Map(compileField))) ]>
          | ListCtor(astSymbol, [])            => <[ $(Environment.GetAstType(astSymbol) : typed).AstList($(loc())) ]>
          | ListCtor(astSymbol, items)         => <[ $(Environment.GetAstType(astSymbol) : typed).AstList($(loc()), ..$(items.Map(CompileSyntaxMapping(_, loc)))) ]>
          | OptionCtor(astSymbol, Some(value)) => <[ $(Environment.GetAstType(astSymbol) : typed).AstOption($(loc()), $(CompileSyntaxMapping(value, loc))) ]>
          | OptionCtor(astSymbol, None())      => <[ $(Environment.GetAstType(astSymbol) : typed).AstOption($(loc())) ]>
          | Match(path, cases)                 => compileMatch(path, cases)
          | Call(path, args, returnType)       => CompileParseTreeMemberAccess(path, returnType, false, obj => <[ $obj.GetAst(..$(args.Map(CompileSyntaxMapping(_, loc)))) ]>)
          | ConvertList(path, args, astSymbol, itemPath) =>
            CompileParseTreeMemberAccess(path, AstType.List(expr.Location, astSymbol), true, fun(obj)
            {
              def (argExprs, itemExpr) = callItemGetAst(args, itemPath, AstType.Ast(expr.Location, astSymbol));
              // NB: sometimes compiler does not inline loop function with 'foreach' statement inside
              <[
                def parseTree = $obj;
                def e         = parseTree.GetEnumerator();
                def items     =
                  if (e.MoveNext())
                  {
                    ..$argExprs;
                    def buffer = array(parseTree.Count);
                    def loop(index : int) : void
                    {
                      def node = e.Current;
                      buffer[index] = $itemExpr;
                      when (e.MoveNext())
                        loop(index + 1);
                    }
                    loop(0);
                    buffer
                  }
                  else null;
                $(Environment.GetAstType(astSymbol) : typed).AstList(parseTree : Nitra.Located, items)
              ]>
            })

          | ConvertOption(path, args, astSymbol, valuePath) =>
            CompileParseTreeMemberAccess(path, AstType.Option(expr.Location, astSymbol), true, fun (obj)
            {
              def astType               = Environment.GetAstType(astSymbol);
              def (argExprs, valueExpr) = callItemGetAst(args, valuePath, AstType.Ast(expr.Location, astSymbol));
              <[
                def parseTree  = $obj;
                if (parseTree.HasValue)
                {
                  ..$argExprs;
                  def node = parseTree.Value;
                  $(astType : typed).AstOption(parseTree, $valueExpr)
                }
                else
                  $(astType : typed).AstOption(parseTree)
              ]>
            })

          | ConcatLists(path, args, astSymbol, itemPath) =>
            CompileParseTreeMemberAccess(path, AstType.List(expr.Location, astSymbol), true, fun (obj)
            {
              def (argExprs, itemExpr) = callItemGetAst(args, itemPath, AstType.List(expr.Location, astSymbol));
              // NB: sometimes compiler does not inline loop function with 'foreach' statement inside
              <[
                def parseTree = $obj;
                def e         = parseTree.GetEnumerator();
                def items     =
                  if (e.MoveNext())
                  {
                    ..$argExprs;
                    def buffer = System.Collections.Generic.List(parseTree.Count * 2);
                    do
                    {
                      def node = e.Current;
                      // TODO: what if AstList is ambiguous?
                      buffer.AddRange($itemExpr);
                    }
                    while (e.MoveNext());
                    buffer.ToArray()
                  }
                  else null;
                $(Environment.GetAstType(astSymbol) : typed).AstList(parseTree : Nitra.Located, items)
              ]>
            })

          | ConcatOptions(path, args, astSymbol, itemPath) =>
            CompileParseTreeMemberAccess(path, AstType.List(expr.Location, astSymbol), true, fun (obj)
            {
              def (argExprs, itemExpr) = callItemGetAst(args, itemPath, AstType.Option(expr.Location, astSymbol));
              // NB: sometimes compiler does not inline loop function with 'foreach' statement inside
              <[
                def parseTree = $obj;
                def e         = parseTree.GetEnumerator();
                def items     =
                  if (e.MoveNext())
                  {
                    ..$argExprs;
                    def buffer = System.Collections.Generic.List(parseTree.Count);
                    do
                    {
                      def node = e.Current;
                      // TODO: what if AstOption is ambiguous?
                      def ast = $itemExpr;
                      when (ast.HasValue)
                        buffer.Add(ast.Value);
                    }
                    while (e.MoveNext());
                    buffer.ToArray()
                  }
                  else null;
                $(Environment.GetAstType(astSymbol) : typed).AstList(parseTree : Nitra.Located, items)
              ]>
            })
        }
      });
    }

    private DefineGetAstMethod(tb : TypeBuilder, syntaxMapping : SyntaxMappingSymbol, modifiers : NemerleModifiers, code : PExpr) : void
    {
      def returnType = Environment.GetAstType(syntaxMapping.ReturnType);
      def mods       = AttributesAndModifiers(modifiers, []);
      def parms      = syntaxMapping.Parameters.Map(p => Util.locate(p.Location.NLocation(), <[ parameter: $(p.Name.Value : usesite) : $(Environment.GetAstType(p.Type)) ]>));
      def isOverride = modifiers %&& NemerleModifiers.Override;
      if (parms.IsEmpty && !isOverride)
        tb.Define(<[ decl: ..$mods $(syntaxMapping.Name : usesite)(..$parms) : $returnType implements Nitra.IMappedParseTree.GetAst { unchecked { $code } } ]>)
      else
        tb.Define(<[ decl: ..$mods $(syntaxMapping.Name : usesite)(..$parms) : $returnType { unchecked { $code } } ]>);
    }

    protected DefineSimpleRuleGetAstMethod(_nodeTb : TypeBuilder) : void
    {
      assert(_nodeTb != null);

      foreach (syntaxMapping in this.RuleSymbol.SyntaxMappings)
      {
        def code = CompileSyntaxMapping(syntaxMapping.Expression, () => <[ this ]>);
        DefineGetAstMethod(_nodeTb, syntaxMapping, NemerleModifiers.Public %| NemerleModifiers.Virtual, code)
      }
    }

    protected DefineExtensionRuleGetAstMethod(_nodeTb : TypeBuilder) : void
    {
      assert(_nodeTb != null);

      foreach (syntaxMapping in this.RuleSymbol.SyntaxMappings)
      {
        def code = CompileSyntaxMapping(syntaxMapping.Expression, () => <[ this ]>);
        DefineGetAstMethod(_nodeTb, syntaxMapping, NemerleModifiers.Public %| NemerleModifiers.Override, code)
      }
    }

    protected DefineAmbiguousOrMissingGetAstMethod(_ambiguousOrMissingTb : TypeBuilder) : void
    {
      assert(_ambiguousOrMissingTb != null);

      foreach (syntaxMapping in this.RuleSymbol.SyntaxMappings)
      {
        def makeAmbiguous = 
          if (syntaxMapping.Parameters.IsEmpty)
            <[ $(AstEmitter.GetAmbiguousAstCtor(Environment, syntaxMapping.ReturnType))(Nitra.Internal.AstUtils.GetAstAmbiguities(this.ambiguities)) ]>
          else
            <[
              def astAmbiguities = array(this.ambiguities.Length);
              foreach (node in this.ambiguities with index)
                astAmbiguities[index] = node.GetAst(..$(syntaxMapping.Parameters.Map(p => <[ $(p.Name.Value : usesite) ]>)));
              $(AstEmitter.GetAmbiguousAstCtor(Environment, syntaxMapping.ReturnType))(astAmbiguities)
            ]>;

        def makeMissing =
          if (syntaxMapping.Parameters.IsEmpty || this.RuleSymbol is ExtensibleRuleSymbol)
            <[ $(AstEmitter.GetMissingAstCtor(Environment, syntaxMapping.ReturnType))(this.File, $(Environment.NSpanTypeVar : typed)(this.pos)) ]>
          else
            <[ base.GetAst(..$(syntaxMapping.Parameters.Map(p => <[ $(p.Name.Value : usesite) ]>))) ]>;

        DefineGetAstMethod(_ambiguousOrMissingTb, syntaxMapping, NemerleModifiers.Public %| NemerleModifiers.Override,
          <[ if (this.IsAmbiguous) $makeAmbiguous else $makeMissing ]>)
      }
    }
  }
}
