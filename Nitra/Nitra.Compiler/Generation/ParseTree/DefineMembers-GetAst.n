using Nemerle;
using Nemerle.Collections;
using Nemerle.Imperative;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Compiler.Typedtree;

using Nitra.ProjectSystem;
using Nitra.Internal;
using Nitra.Model;
using Nitra.Typing;
using Nitra.Compiler.PatternMatching;

using System;
using System.Diagnostics;
using System.Linq;
using SCG = System.Collections.Generic;

namespace Nitra.Compiler
{
  internal abstract partial class RuleParseTreeEmitter
  {
    protected DefineExtensibleRuleGetAstMethod(_baseTb : TypeBuilder) : void
    {
      assert(_baseTb != null);

      def expr = this.RuleSymbol.GetSyntaxMappingExpr();
      when (expr != null)
      {
        def astType = GetGetAstMethodReturnType();
        _baseTb.DefineConditional(<[ decl:
          public abstract GetAst() : $astType
        ]>);
      }
    }

    private static MakeParseTreeMemberAccess(path : ParseTreePath) : PExpr
    {
      Util.locate(path.Location.NLocation(),
        match(path)
        {
          | This                       => <[ this ]>
          | Variable(name, _)          => <[ $(name.Id : usesite) ]>
          | Member(qualifier, name, _) => <[ $(MakeParseTreeMemberAccess(qualifier)).$(name.Id : usesite) ]>
        })
    }

    [Record]
    private struct BuildAstResult
    {
      public Code    : PExpr;
      public AstType : FixedType;

      public this(code : PExpr) { this(code, null) }

      public List            : PExpr { get { if (AstType != null) <[ $(AstType : typed).IAstList ]>           else <[ Nitra.Declarations.IAstList[Nitra.Declarations.IAst] ]> } }
      public ConcreteList    : PExpr { get { if (AstType != null) <[ $(AstType : typed).AstList ]>            else <[ Nitra.Declarations.AstList[Nitra.Declarations.IAst] ]> } }
      public AmbiguousList   : PExpr { get { if (AstType != null) <[ $(AstType : typed).AmbiguousAstList ]>   else <[ Nitra.Declarations.AmbiguousAstList[Nitra.Declarations.IAst] ]> } }

      public Option          : PExpr { get { if (AstType != null) <[ $(AstType : typed).IAstOption ]>         else <[ Nitra.Declarations.IAstOption[Nitra.Declarations.IAst] ]> } }
      public ConcreteOption  : PExpr { get { if (AstType != null) <[ $(AstType : typed).AstOption ]>          else <[ Nitra.Declarations.AstOption[Nitra.Declarations.IAst] ]> } }
      public AmbiguousOption : PExpr { get { if (AstType != null) <[ $(AstType : typed).AmbiguousAstOption ]> else <[ Nitra.Declarations.AmbiguousAstOption[Nitra.Declarations.IAst] ]> } }
    }

    private CompileSyntaxMapping(expr : SyntaxMappingExpr, tb : TypeBuilder) : PExpr
    {
      def compileConversion(mappingType : SyntaxMappingType, obj : PExpr) : BuildAstResult
      {
        match (mappingType)
        {
          | List(item, ruleType) =>
            def parseTreeType     = Environment.GetParseTreeType(ruleType);
            def itemResult        = compileConversion(item, <[ node ]>);
            def getAstListName    = Util.tmpname("GetAstList");
            tb.Define(<[ decl:
              private static $(getAstListName : usesite)(lst : $(parseTreeType : typed)) : $(itemResult.List)
              {
                unchecked
                {
                  if (lst.IsAmbiguous)
                  {
                    def ambiguities  = Nitra.Internal.AstUtils.GetAstAmbiguities(lst :> Nitra.IAmbiguousParseTree, $(getAstListName : usesite));
                    $(itemResult.AmbiguousList)(ambiguities)
                  }
                  else
                  {
                    def items = array(lst.Count);
                    foreach (node in lst with index)
                      items[index] = $(itemResult.Code);
                    $(itemResult.ConcreteList)(lst.Span, items)
                  }
                }
              }
            ]>);
            BuildAstResult(<[ $(getAstListName : usesite)($obj) ]>)

          | Option(item, ruleType) =>
            def parseTreeType      = Environment.GetParseTreeType(ruleType);
            def itemResult         = compileConversion(item, <[ opt.Value ]>);
            def getAstOptionName   = Util.tmpname("GetAstOption");
            tb.Define(<[ decl:
              private static $(getAstOptionName : usesite)(opt : $(parseTreeType : typed)) : $(itemResult.Option)
              {
                unchecked
                {
                  if (opt.IsAmbiguous)
                  {
                    def ambiguities  = Nitra.Internal.AstUtils.GetAstAmbiguities(opt :> Nitra.IAmbiguousParseTree, $(getAstOptionName : usesite));
                    $(itemResult.AmbiguousOption)(ambiguities)
                  }
                  else if (opt.HasValue)
                    $(itemResult.ConcreteOption)(opt.Span, $(itemResult.Code))
                  else
                    $(itemResult.ConcreteOption)(opt.Span)
                }
              }
            ]>);
            BuildAstResult(<[ $(getAstOptionName : usesite)( $obj) ]>)

          | Ref(astSymbol)     => BuildAstResult(<[ $obj.GetAst() ]>, Environment.GetAstType(astSymbol))
          | Tuple(index, item) => compileConversion(item, <[ $obj.$("Item" + index.ToString() : usesite) ]>)
        }
      }

      def compileField(field : SyntaxMappingField) : PExpr
      {
        def name  = field.Property.Name;
        def value = CompileSyntaxMapping(field.Expr, tb);
        <[ $(name : usesite) = $value ]>
      }

      def compileMatch(path : ParseTreePath, cases : list[SyntaxMappingCase]) : PExpr
      {
        def compileAccess(_ : Access) : PExpr
        {
          | Obj                            => MakeParseTreeMemberAccess(path)
          | Sel(ListCons,   0,     access) => <[ $(compileAccess(access)).Head ]>
          | Sel(ListCons,   1,     access) => <[ $(compileAccess(access)).Tail ]>
          | Sel(OptionSome, 0,     access) => <[ $(compileAccess(access)).Value ]>
          | Sel(Tuple,      index, access) => <[ $(compileAccess(access)).$("Item" + (index + 1) : usesite) ]>
          | Sel(ParseTree,  index, access) => <[ $(compileAccess(access)).$(RuleSymbol.NonVoidSubRules.Nth(index).FieldName : usesite) ]>
          | _ => assert(false, "Invalid access path")
        }

        def compileTest(n : string, ctor : ParseTreeCtor) : PExpr
        {
          match (ctor)
          {
            | ListCons   => <[ $(n : usesite).Count > 0 ]>
            | ListNil    => <[ $(n : usesite).Count == 0 ]>
            | OptionSome => <[ $(n : usesite).HasValue ]>
            | OptionNone => <[ ! $(n : usesite).HasValue ]>
            | Tuple
            | ParseTree  => assert(false, "Check is redundant")
          }
        }

        def     redundantCases : SCG.HashSet[_] = SCG.HashSet(cases);
        mutable canFail        : bool;
        def compileDecision(_ : Decision[SyntaxMappingCase]) : PExpr
        {
          | Failure =>
            canFail = true;
            <[ assert(false, "Match failed") ]>

          | Success(case)                     =>
            _ = redundantCases.Remove(case);
            CompileSyntaxMapping(case.Expr, tb)

          | Variable(name, access, continuation) =>
            <[
              def $(name.Id : global) = $(compileAccess(access));
              $(compileDecision(continuation))
            ]>.FlattenPExpr()

          | IfEq(access, ctor, t, f) =>
            def n = Util.tmpname("parseTree");
            <[
              def $(n : usesite) = $(compileAccess(access));
              if ($(compileTest(n, ctor)))
                $(compileDecision(t))
              else
                $(compileDecision(f))
            ]>
        }

        def rules      = cases.Map(c => (c.Pattern, c));
        def decision   = MatchCompiler.Compile(rules);
        def code       = compileDecision(decision);
        when (canFail)
          Environment.Project.Warning(expr, "Matching is not exhaustive.");
        foreach (case in redundantCases)
          Environment.Project.Warning(case, "Match case is redundant.");
        code
      }

      Util.locate(expr.Location.NLocation(),
      {
        match (expr)
        {
          | Code(code)                               => code
          | AstCtor(path, astSymbol, args)           => <[ $(Environment.GetAstType(astSymbol) : typed)(Span = $(MakeParseTreeMemberAccess(path)).Span, ..$(args.Map(compileField))) ]>
          | ListCtor(path, astSymbol, [])            => <[ $(Environment.GetAstType(astSymbol) : typed).AstList($(MakeParseTreeMemberAccess(path)).Span) ]>
          | ListCtor(path, astSymbol, items)         => <[ $(Environment.GetAstType(astSymbol) : typed).AstList($(MakeParseTreeMemberAccess(path)).Span, ..$(items.Map(CompileSyntaxMapping(_, tb)))) ]>
          | OptionCtor(path, astSymbol, Some(value)) => <[ $(Environment.GetAstType(astSymbol) : typed).AstOption($(MakeParseTreeMemberAccess(path)).Span, $(CompileSyntaxMapping(value, tb))) ]>
          | OptionCtor(path, astSymbol, None())      => <[ $(Environment.GetAstType(astSymbol) : typed).AstOption($(MakeParseTreeMemberAccess(path)).Span) ]>
          | Conversion(path, mappingType)            => compileConversion(mappingType, MakeParseTreeMemberAccess(path)).Code
          | Match(path, cases)                       => compileMatch(path, cases)
        }
      });
    }

    private DefineGetAstMethod(tb : TypeBuilder, expr : SyntaxMappingExpr, modifiers : NemerleModifiers) : void
    {
      def astType = GetGetAstMethodReturnType();
      def mods    = AttributesAndModifiers(modifiers, []);
      def code    = CompileSyntaxMapping(expr, tb);
      tb.Define(<[ decl: ..$mods GetAst() : $astType { $code } ]>);
    }

    protected DefineSimpleRuleGetAstMethod(_nodeTb : TypeBuilder) : void
    {
      assert(_nodeTb != null);

      def expr = this.RuleSymbol.GetSyntaxMappingExpr();
      when (expr != null)
        DefineGetAstMethod(_nodeTb, expr, NemerleModifiers.Public %| NemerleModifiers.Virtual)
    }

    protected DefineExtensionRuleGetAstMethod(_nodeTb : TypeBuilder) : void
    {
      assert(_nodeTb != null);

      def expr = this.RuleSymbol.GetSyntaxMappingExpr();
      when (expr != null)
        DefineGetAstMethod(_nodeTb, expr, NemerleModifiers.Public %| NemerleModifiers.Override)
    }

    protected DefineAmbiguousOrMissingGetAstMethod(_ambiguousOrMissingTb : TypeBuilder) : void
    {
      assert(_ambiguousOrMissingTb != null);

      def expr = this.RuleSymbol.GetSyntaxMappingExpr();
      when (expr != null)
      {
        def astType = GetGetAstMethodReturnType();
        _ambiguousOrMissingTb.Define(<[ decl:
          public override GetAst() : $astType
          {
            if (this.IsAmbiguous)
            {
              def astAmbiguities = Nitra.Internal.AstUtils.GetAstAmbiguities(this.ambiguities);
              $astType.$(AstEmitter.AmbiguousOrMissingAstName : usesite)(astAmbiguities)
            }
            else
              $astType.$(AstEmitter.AmbiguousOrMissingAstName : usesite)($(Environment.NSpanTypeVar : typed)(this.pos))
          }
        ]>);
      }
    }
  }
}
