using Nemerle;
using Nemerle.Collections;
using Nemerle.Imperative;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Compiler.Typedtree;

using Nitra.ProjectSystem;
using Nitra.Internal;
using Nitra.Model;
using Nitra.Typing;
using Nitra.Compiler.PatternMatching;

using System;
using System.Diagnostics;
using System.Linq;
using SCG = System.Collections.Generic;

namespace Nitra.Compiler
{
  internal abstract partial class RuleParseTreeEmitter
  {
    protected DefineExtensibleRuleGetAstMethod(_baseTb : TypeBuilder) : void
    {
      assert(_baseTb != null);

      unless (this.RuleSymbol.Ast is AstType.Void)
      {
        def astType = GetGetAstMethodReturnType();
        _baseTb.DefineConditional(<[ decl:
          public abstract GetAst() : $astType
        ]>);
      }
    }

    private static MakeParseTreeMemberAccess(path : ParseTreePath) : PExpr
    {
      Util.locate(path.Location.NLocation(),
        match(path)
        {
          | This                       => <[ this ]>
          | Variable(name, _)          => <[ $(name.Value : usesite) ]>
          | Member(qualifier, name, _) => <[ $(MakeParseTreeMemberAccess(qualifier)).$(name.Value : usesite) ]>
        })
    }

    private CompileParseTreeMemberAccess(path : ParseTreePath, tb : TypeBuilder, astType : AstType, compile : PExpr -> PExpr) : PExpr
    {
      def needsBuffer(_ : ParseTreePath) : bool
      {
        | This               => false
        | Variable           => false
        | Member(This, _, _) => false
        | Member(_, _, _)    => true
      }

      def compileAccess(path : ParseTreePath, compile : PExpr -> PExpr) : PExpr
      {
        def loc = path.Location.NLocation();
        match (path)
        {
          | This                       => compile(Util.locate(loc, <[ this ]>))
          | Variable(name, _)          => compile(Util.locate(loc, <[ $(name.Value : usesite) ]>))
          | Member(This, name, _)      => compile(Util.locate(loc, <[ this.$(name.Value : usesite) ]>))
          | Member(qualifier, name, _) =>
            def parseTreeType = Environment.GetParseTreeType(qualifier.Type);
            def methodName    = Util.tmpname("Get_" + name);
            tb.Define(<[ decl:
              private static $(methodName : usesite)(parseTree : $(parseTreeType : typed), buffer : ref Nemerle.Collections.LightList[$(Environment.GetAstType(astType))]) : void
              {
                if (parseTree.IsAmbiguous)
                {
                  foreach (item in (parseTree :> Nitra.IAmbiguousParseTree).Ambiguities)
                    $(methodName : usesite)(item :> $(parseTreeType : typed), ref buffer)
                }
                else unless (parseTree.IsMissing)
                  $(compile(<[ parseTree.$(name.Value : usesite) ]>))
              }
            ]>);
            compileAccess(qualifier, expr => Util.locate(loc, <[ $(methodName : usesite)($expr, ref buffer) ]>))
        }
      }

      if (needsBuffer(path))
      {
        def code = compileAccess(path, expr => <[ buffer.Add($(compile(expr))) ]>);
        <[
          mutable buffer = Nemerle.Collections.LightList();
          $code;
          match (buffer.Count)
          {
            | 0 => $(AstEmitter.GetMissingAstCtor(Environment, astType))(this.File, this.Span)
            | 1 => buffer.FirstItem
            | _ => $(AstEmitter.GetAmbiguousAstCtor(Environment, astType))(buffer.ToArray())
          }
        ]>
      }
      else
        compileAccess(path, compile)
    }

    private CompileSyntaxMapping(expr : SyntaxMappingExpr, tb : TypeBuilder) : PExpr
    {
      def compileConversion(mappingType : SyntaxMappingType, obj : PExpr) : PExpr
      {
        def compileTupleAccess(obj : PExpr, access : list[int]) : PExpr
        {
          mutable acc = obj;
          foreach (x in access)
            acc = <[ $acc.$("Item" + x : usesite) ]>;
          acc
        }
        match (mappingType)
        {
          | CallGetAst => <[ $obj.GetAst() ]>
          | CreateList(symbol, itemAccess) =>
            def astType        = Environment.GetAstType(symbol);
            def parseTreeType  = Environment.GetParseTreeType(mappingType.Source);
            def getAstListName = Util.tmpname("GetAstList");
            tb.Define(<[ decl:
              private static $(getAstListName : usesite)(lst : $(parseTreeType : typed)) : $(astType : typed).IAstList
              {
                unchecked
                {
                  if (lst.IsAmbiguous)
                  {
                    def ambiguities  = Nitra.Internal.AstUtils.GetAstAmbiguities(lst :> Nitra.IAmbiguousParseTree, $(getAstListName : usesite));
                    $(astType : typed).AmbiguousAstList(ambiguities)
                  }
                  else
                  {
                    def items = array(lst.Count);
                    foreach (node in lst with index)
                      items[index] = $(compileTupleAccess(<[ node ]>, itemAccess)).GetAst();
                    $(astType : typed).AstList(lst, items)
                  }
                }
              }
            ]>);
            <[ $(getAstListName : usesite)($(compileTupleAccess(obj, mappingType.TupleAccess))) ]>

          | CreateOption(symbol, valueAccess) =>
            def astType          = Environment.GetAstType(symbol);
            def parseTreeType    = Environment.GetParseTreeType(mappingType.Source);
            def getAstOptionName = Util.tmpname("GetAstOption");
            tb.Define(<[ decl:
              private static $(getAstOptionName : usesite)(opt : $(parseTreeType : typed)) : $(astType : typed).IAstOption
              {
                unchecked
                {
                  if (opt.IsAmbiguous)
                  {
                    def ambiguities  = Nitra.Internal.AstUtils.GetAstAmbiguities(opt :> Nitra.IAmbiguousParseTree, $(getAstOptionName : usesite));
                    $(astType : typed).AmbiguousAstOption(ambiguities)
                  }
                  else if (opt.HasValue)
                    $(astType : typed).AstOption(opt, $(compileTupleAccess(<[ opt.Value ]>, valueAccess)).GetAst())
                  else
                    $(astType : typed).AstOption(opt)
                }
              }
            ]>);
            <[ $(getAstOptionName : usesite)($(compileTupleAccess(obj, mappingType.TupleAccess))) ]>

          | ConcatLists(symbol, itemAccess) =>
            def astType        = Environment.GetAstType(symbol);
            def parseTreeType  = Environment.GetParseTreeType(mappingType.Source);
            def getAstListName = Util.tmpname("GetAstList");
            tb.DefineConditional(<[ decl:
              private static $(getAstListName : usesite)(lst : $(parseTreeType : typed)) : $(astType : typed).IAstList
              {
                unchecked
                {
                  if (lst.IsAmbiguous)
                  {
                    def ambiguities  = Nitra.Internal.AstUtils.GetAstAmbiguities(lst :> Nitra.IAmbiguousParseTree, $(getAstListName : usesite));
                    $(astType : typed).AmbiguousAstList(ambiguities)
                  }
                  else
                  {
                    def items = System.Collections.Generic.List();
                    foreach (node in lst)
                    {
                      def ast = $(compileTupleAccess(<[ node ]>, itemAccess)).GetAst();
                      items.AddRange(ast);
                    }
                    $(astType : typed).AstList(lst, items.ToArray())
                  }
                }
              }
            ]>);
            <[ $(getAstListName : usesite)($(compileTupleAccess(obj, mappingType.TupleAccess))) ]>

          | ConcatOptions(symbol, valueAccess) =>
            def astType        = Environment.GetAstType(symbol);
            def parseTreeType  = Environment.GetParseTreeType(mappingType.Source);
            def getAstListName = Util.tmpname("GetAstList");
            tb.Define(<[ decl:
              private static $(getAstListName : usesite)(lst : $(parseTreeType : typed)) : $(astType : typed).IAstList
              {
                unchecked
                {
                  if (lst.IsAmbiguous)
                  {
                    def ambiguities  = Nitra.Internal.AstUtils.GetAstAmbiguities(lst :> Nitra.IAmbiguousParseTree, $(getAstListName : usesite));
                    $(astType : typed).AmbiguousAstList(ambiguities)
                  }
                  else
                  {
                    def items = System.Collections.Generic.List();
                    foreach (node in lst)
                    {
                      def ast = $(compileTupleAccess(<[ node ]>, valueAccess)).GetAst();
                      when (ast.HasValue)
                        items.Add(ast.Value);
                    }
                    $(astType : typed).AstList(lst, items.ToArray())
                  }
                }
              }
            ]>);
            <[ $(getAstListName : usesite)($(compileTupleAccess(obj, mappingType.TupleAccess))) ]>
        }
      }

      def compileField(field : SyntaxMappingField) : PExpr
      {
        def name  = field.Property.Name;
        def value = CompileSyntaxMapping(field.Expr, tb);
        <[ $(name : usesite) = $value ]>
      }

      def compileMatch(path : ParseTreePath, cases : list[SyntaxMappingCase]) : PExpr
      {
        def compileAccess(_ : Access) : PExpr
        {
          | Obj                            => MakeParseTreeMemberAccess(path) // TODO: rewrite with CompileParseTreeMemberAccess approach
          | Sel(ListCons,   0,     access) => <[ $(compileAccess(access)).Head ]>
          | Sel(ListCons,   1,     access) => <[ $(compileAccess(access)).Tail ]>
          | Sel(OptionSome, 0,     access) => <[ $(compileAccess(access)).Value ]>
          | Sel(Tuple,      index, access) => <[ $(compileAccess(access)).$("Item" + (index + 1) : usesite) ]>
          | Sel(ParseTree,  index, access) => <[ $(compileAccess(access)).$(RuleSymbol.NonVoidSubRules.Nth(index).FieldName : usesite) ]>
          | _ => assert(false, "Invalid access path")
        }

        def compileTest(n : string, ctor : ParseTreeCtor) : PExpr
        {
          match (ctor)
          {
            | ListCons   => <[ $(n : usesite).Count > 0 ]>
            | ListNil    => <[ $(n : usesite).Count == 0 ]>
            | OptionSome => <[ $(n : usesite).HasValue ]>
            | OptionNone => <[ ! $(n : usesite).HasValue ]>
            | Tuple
            | ParseTree  => assert(false, "Check is redundant")
          }
        }

        def     redundantCases : SCG.HashSet[_] = SCG.HashSet(cases);
        mutable canFail        : bool;
        def compileDecision(_ : Decision[SyntaxMappingCase]) : PExpr
        {
          | Failure =>
            canFail = true;
            <[ assert(false, "Match failed") ]>

          | Success(case)                     =>
            _ = redundantCases.Remove(case);
            CompileSyntaxMapping(case.Expr, tb)

          | Variable(name, access, continuation) =>
            <[
              def $(name.Value : global) = $(compileAccess(access));
              $(compileDecision(continuation))
            ]>.FlattenPExpr()

          | IfEq(access, ctor, t, f) =>
            def n = Util.tmpname("parseTree");
            <[
              def $(n : usesite) = $(compileAccess(access));
              if ($(compileTest(n, ctor)))
                $(compileDecision(t))
              else
                $(compileDecision(f))
            ]>
        }

        def rules      = cases.Map(c => (c.Pattern, c));
        def decision   = MatchCompiler.Compile(rules);
        def code       = compileDecision(decision);
        when (canFail)
          Environment.Project.Warning(expr, "Matching is not exhaustive.");
        foreach (case in redundantCases)
          Environment.Project.Warning(case, "Match case is redundant.");
        code
      }

      Util.locate(expr.Location.NLocation(),
      {
        match (expr)
        {
          | Code(code)                         => code
          | AstCtor(astSymbol, args)           => <[ $(Environment.GetAstType(astSymbol) : typed)(File = this.File, Span = this.Span, ..$(args.Map(compileField))) ]>
          | ListCtor(astSymbol, [])            => <[ $(Environment.GetAstType(astSymbol) : typed).AstList(this) ]>
          | ListCtor(astSymbol, items)         => <[ $(Environment.GetAstType(astSymbol) : typed).AstList(this, ..$(items.Map(CompileSyntaxMapping(_, tb)))) ]>
          | OptionCtor(astSymbol, Some(value)) => <[ $(Environment.GetAstType(astSymbol) : typed).AstOption(this, $(CompileSyntaxMapping(value, tb))) ]>
          | OptionCtor(astSymbol, None())      => <[ $(Environment.GetAstType(astSymbol) : typed).AstOption(this) ]>
          | Conversion(path, astType, mapping) => CompileParseTreeMemberAccess(path, tb, astType, compileConversion(mapping, _))
          | Match(path, cases)                 => compileMatch(path, cases)
        }
      });
    }

    private DefineGetAstMethod(tb : TypeBuilder, expr : SyntaxMappingExpr, modifiers : NemerleModifiers) : void
    {
      def astType = GetGetAstMethodReturnType();
      def mods    = AttributesAndModifiers(modifiers, []);
      def code    = CompileSyntaxMapping(expr, tb);
      tb.Define(<[ decl: ..$mods GetAst() : $astType { $code } ]>);
    }

    protected DefineSimpleRuleGetAstMethod(_nodeTb : TypeBuilder) : void
    {
      assert(_nodeTb != null);

      def expr = this.RuleSymbol.GetSyntaxMappingExpr();
      when (expr != null)
        DefineGetAstMethod(_nodeTb, expr, NemerleModifiers.Public %| NemerleModifiers.Virtual)
    }

    protected DefineExtensionRuleGetAstMethod(_nodeTb : TypeBuilder) : void
    {
      assert(_nodeTb != null);

      def expr = this.RuleSymbol.GetSyntaxMappingExpr();
      when (expr != null)
        DefineGetAstMethod(_nodeTb, expr, NemerleModifiers.Public %| NemerleModifiers.Override)
    }

    protected DefineAmbiguousOrMissingGetAstMethod(_ambiguousOrMissingTb : TypeBuilder) : void
    {
      assert(_ambiguousOrMissingTb != null);

      def astType = this.RuleSymbol.Ast;
      unless (astType is AstType.Void)
      {
        _ambiguousOrMissingTb.Define(<[ decl:
          public override GetAst() : $(GetGetAstMethodReturnType())
          {
            if (this.IsAmbiguous)
            {
              def astAmbiguities = Nitra.Internal.AstUtils.GetAstAmbiguities(this.ambiguities);
              $(AstEmitter.GetAmbiguousAstCtor(Environment, astType))(astAmbiguities)
            }
            else
              $(AstEmitter.GetMissingAstCtor(Environment, astType))(this.File, $(Environment.NSpanTypeVar : typed)(this.pos))
          }
        ]>)
      }
    }
  }
}
