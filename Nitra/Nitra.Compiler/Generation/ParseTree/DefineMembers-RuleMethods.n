using Nemerle;
using Nemerle.Collections;
using Nemerle.Imperative;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Compiler.Typedtree;

using Nitra.Internal;
using Nitra.Model;
using Nitra.Typing;

using System;
using System.Diagnostics;
using System.Linq;
using SCG = System.Collections.Generic;

namespace Nitra.Compiler
{
  internal abstract partial class RuleParseTreeEmitter
  {
    protected DefineExtensibleRuleMethods(_baseTb : TypeBuilder) : void
    {
      foreach (method in this.RuleSymbol.RuleMethods)
      {
        Util.locate(method.FirstLocation.NLocation(),
          match (method)
          {
            | RuleMethod.AbstractSymbol(Signature = signature, IsCached = isCached) =>
              when (isCached)
                _baseTb.Define(<[ decl: public virtual $(cachingPropertyName(method.Name) : usesite) : $(MakeReturnType(signature)) { get { throw System.NotImplementedException(); } } ]>);
              _baseTb.Define(<[ decl: public abstract $(method.Name : usesite)(..$(MakeParams(signature))) : $(MakeReturnType(signature)); ]>);

            | RuleMethod.DefSymbol(Signature = signature, IsCached = isCached, Body = body) =>
              def flags = NemerleModifiers.Public %| NemerleModifiers.Virtual;
              def mods  = AttributesAndModifiers(flags, []);
              def body2 = if (isCached) addCaching(_baseTb, method.Name, MakeReturnType(signature), body.Expr, flags) else body.Expr;
              def body3 = addRecursionCheck(_baseTb, body2);
              _baseTb.Define(<[ decl: ..$mods $(method.Name : usesite)(..$(MakeParams(signature))) : $(MakeReturnType(signature)) $body3 ]>);

            | _ => ()
          }
        )
      }
    }

    protected DefineSimpleRuleMethods(_baseTb : TypeBuilder) : void
    {
      foreach (method in this.RuleSymbol.RuleMethods)
      {
        Util.locate(method.FirstLocation.NLocation(),
          match (method)
          {
            | RuleMethod.DefPrivateSymbol(Signature = signature, IsCached = isCached, Body = body)
            | RuleMethod.DefSymbol       (Signature = signature, IsCached = isCached, Body = body) =>
              def flags = NemerleModifiers.Public %| NemerleModifiers.Virtual;
              def mods  = AttributesAndModifiers(flags, []);
              def body2 = if (isCached) addCaching(_baseTb, method.Name, MakeReturnType(signature), body.Expr, flags) else body.Expr;
              def body3 = addRecursionCheck(_baseTb, body2);
              _baseTb.Define(<[ decl: ..$mods $(method.Name : usesite)(..$(MakeParams(signature))) : $(MakeReturnType(signature)) $body3 ]>);

            | _ => ()
          }
        )
      }
    }

    protected DefineExtensionRuleMethods(_nodeTb : TypeBuilder) : void
    {
      foreach (method in this.RuleSymbol.RuleMethods)
      {
        Util.locate(method.FirstLocation.NLocation(),
          match (method)
          {
            | RuleMethod.DefPrivateSymbol(Signature = signature, IsCached = isCached, Body = body) =>
              def flags = NemerleModifiers.Public;
              def mods  = AttributesAndModifiers(flags, []);
              def body2 = if (isCached) addCaching(_nodeTb, method.Name, MakeReturnType(signature), body.Expr, flags) else body.Expr;
              def body3 = addRecursionCheck(_nodeTb, body2);
              _nodeTb.Define(<[  decl: ..$mods $(method.Name : usesite)(..$(MakeParams(signature))) : $(MakeReturnType(signature)) $body3 ]>);

            | RuleMethod.OverrideSymbol(BaseRuleMethod = baseRuleMethodSymbol, Body = body) =>
              def signature  = GetSignature(baseRuleMethodSymbol.GetValue(Environment.Project));
              def isCached   = GetIsCached(baseRuleMethodSymbol.GetValue(Environment.Project));
              def flags      = NemerleModifiers.Public %| NemerleModifiers.Override;
              def mods       = AttributesAndModifiers(flags, []);
              def body2      = if (isCached) addCaching(_nodeTb, method.Name, MakeReturnType(signature), body.Expr, flags) else body.Expr;
              def body3      = addRecursionCheck(_nodeTb, body2);
              _nodeTb.Define(<[ decl: ..$mods $(method.Name : usesite)(..$(MakeParams(signature))) : $(MakeReturnType(signature)) $body3 ]>);

            | _ => ()
          }
        )
      }
    }

    protected DefineMissingRuleMethods(_missingTb : TypeBuilder) : void
    {
      def ruleMethodsWithErrorHandler = SCG.HashSet();
      foreach (method is RuleMethod.RuleMethodMissingValueSymbol in this.RuleSymbol.RuleMethods)
        _ = ruleMethodsWithErrorHandler.Add(method.HandlingRuleMethod.GetValue(Environment.Project));

      foreach (method in this.RuleSymbol.RuleMethods)
      {
        Util.locate(method.FirstLocation.NLocation(),
          match (method)
          {
            | RuleMethod.AbstractSymbol  (Signature = signature, AstRef = astRef, IsCached = isCached) when !ruleMethodsWithErrorHandler.Contains(method)
            | RuleMethod.DefPrivateSymbol(Signature = signature, AstRef = astRef, IsCached = isCached) when !ruleMethodsWithErrorHandler.Contains(method)
            | RuleMethod.DefSymbol       (Signature = signature, AstRef = astRef, IsCached = isCached) when !ruleMethodsWithErrorHandler.Contains(method) =>
              def code =
                if (astRef is SymbolRef.Some(ast))
                {
                  def body = <[ IgnoreParams(); $(GetMissingOrAmbiguousAstCtor(ast, signature.Type))(Nitra.NSpan(this.pos)) ]>;
                  def flags = NemerleModifiers.Public %| NemerleModifiers.Override;
                  def body2 = if (isCached) addCaching(_missingTb, method.Name, MakeReturnType(signature), body, flags) else body;
                  body2 // recursion is impossible
                }
                else
                {
                  def msg = $"An attempt to access '$(method.Name)' rule method of '$(this.RuleSymbol.Name)' rule which contains a parse error. Implement the 'missing' handler for this rule method.";
                  <[ IgnoreParams(); throw System.NotImplementedException($(msg : string)); ]>
                };

              _missingTb.Define(<[ decl:
                public override $(method.Name : usesite)(..$(MakeParams(signature))) : $(MakeReturnType(signature)) $code
              ]>);

            | RuleMethod.RuleMethodMissingValueSymbol(Body = body, HandlingRuleMethod = handlingField) =>
              def signature  = GetSignature(handlingField.GetValue(Environment.Project));
              _missingTb.Define(<[ decl: public override $(method.Name : usesite)(..$(MakeParams(signature))) : $(MakeReturnType(signature)) $(body.Expr) ]>);

            | _ => ()
          }
        )
      }
    }

    protected DefineAmbiguousRuleMethods(_ambiguousTb : TypeBuilder) : void
    {
      foreach (method in this.RuleSymbol.RuleMethods)
      {
        Util.locate(method.FirstLocation.NLocation(),
          match (method)
          {
            | RuleMethod.AbstractSymbol  (Signature = signature, AstRef = astRef, IsCached = isCached)
            | RuleMethod.DefPrivateSymbol(Signature = signature, AstRef = astRef, IsCached = isCached)
            | RuleMethod.DefSymbol       (Signature = signature, AstRef = astRef, IsCached = isCached) =>
              def code =
                if (astRef is SymbolRef.Some(ast))
                {
                  def body =
                    <[
                      def ptAmbiguities  = this.Ambiguities;
                      def astAmbiguities = array(ptAmbiguities.Length);
                      for (mutable i = 0; i < ptAmbiguities.Length; ++i)
                        astAmbiguities[i] = ptAmbiguities[i].$(method.Name : usesite)(..$(signature.Params.Map(p => <[ $(p.Name.Id : usesite) ]>)));
                      $(GetMissingOrAmbiguousAstCtor(ast, signature.Type))(astAmbiguities)
                    ]>;
                  def flags = NemerleModifiers.Public %| NemerleModifiers.Override;
                  def body2 = if (isCached) addCaching(_ambiguousTb, method.Name, MakeReturnType(signature), body, flags) else body;
                  body2 // recursion check is redundant
                }
                else
                {
                  def msg = $"An attempt to access '$(method.Name)' rule method of '$(this.RuleSymbol.Name)' rule which contains ambiguous node.";
                  <[ IgnoreParams(); throw System.NotImplementedException($(msg : string)); ]>
                };

              _ambiguousTb.Define(<[ decl:
                public override $(method.Name : usesite)(..$(MakeParams(signature))) : $(MakeReturnType(signature)) $code
              ]>);

            | _ => ()
          }
        )
      }
    }

    private GetMissingOrAmbiguousAstCtor(ast : AstSymbol, actualType : NType) : PExpr
    {
      match (actualType)
      {
        | Option            => <[ $(GetBaseAstType(ast)).AmbiguousOption ]>
        | OptionList | List => <[ $(GetBaseAstType(ast)).AmbiguousList ]>
        | Qualified         => GetAmbiguousAstType(ast)
        | _                 => assert(false)
      }
    }

    private MakeParams(signature : RuleMethod.RuleMethodSignature) : list[PParameter]
    {
      def result = SCG.List();
      foreach (p in signature.Params)
      {
        Util.locate(p.Location.NLocation(),
        {
          result.Add(<[ parameter: $(p.Name.Id : usesite) : $(TypeCompiler.Compile(p.Type)) ]>);
        });
      }
      result.ToNList()
    }

    private MakeReturnType(signature : RuleMethod.RuleMethodSignature) : PExpr
    {
      TypeCompiler.Compile(signature.Type)
    }

    private static cachingPropertyName(ruleMethodName : string) : string
    {
      regexp match (ruleMethodName)
      {
        | "(Get|Compute|Calculate|Calc|Create|Make|Evaluate|Eval)(?<baseName>.*)" => baseName
        | _ => "Computed" + ruleMethodName
      }
    }

    private static addRecursionCheck(tb : TypeBuilder, body : PExpr) : PExpr.Sequence
    {
      def bitField = tb.GetBitFieldManager().Allocate();
      <[
        when ($(bitField.Read()))
          throw System.InvalidOperationException("Recursion detected (see stack trace for details).");
        $(bitField.Set());
        try $body
        finally $(bitField.Clear());
      ]>
    }

    private static addCaching(tb : TypeBuilder, name : string, type : PExpr, body : PExpr, flags : NemerleModifiers) : PExpr
    {
      def bitField = tb.GetBitFieldManager().Allocate();
      def fieldName = Util.tmpname(name + "_cache");
      tb.Define(<[ decl: private mutable $(fieldName : usesite) : $type ]>);
      def mods = Modifiers(flags, []);
      tb.Define(<[ decl:
        ..$mods $(cachingPropertyName(name) : usesite) : $type
        {
          get
          {
            unless ($(bitField.Read()))
              throw System.InvalidOperationException("Rule method '" + $(name : string) + "' value not computed yet.");
            this.$(fieldName : usesite);
          }
        }
      ]>);

      <[
        unless ($(bitField.Read()))
        {
          this.$(fieldName : usesite) = $body;
          $(bitField.Set());
        }
        this.$(fieldName : usesite);
      ]>
    }

    private static GetSignature(symbol : RuleMethod.RuleMethodSymbol) : RuleMethod.RuleMethodSignature
    {
      | symbol is RuleMethod.ISignature => symbol.Signature
      | _ => assert(false)
    }

    private static GetIsCached(symbol : RuleMethod.RuleMethodSymbol) : bool
    {
      | symbol is RuleMethod.ICached => symbol.IsCached
      | _ => assert(false)
    }
  }
}
