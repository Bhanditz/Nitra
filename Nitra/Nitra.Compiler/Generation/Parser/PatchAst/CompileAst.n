using Nitra.Typing;
using Nemerle;
using Nemerle.Collections;
using Nemerle.Compiler.Parsetree;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Imperative;

using System;
using SCG = System.Collections.Generic;
using System.Linq;

using Nitra.Model;

namespace Nitra.Compiler
{
  internal sealed partial class PatchAstMethodEmitter : MethodEmitter
  {
    public CompileAst(sequence : SequenceCompileInfo.Ast) : PExpr
    {
      def code = SCG.List();
      def createAst(sequence)
      {
        if (sequence is SequenceCompileInfo.Ast(Symbol = Nitra.Typing.ExtensionRuleSymbol))
        {
          <[
            def newAstPtr = parseResult.Allocate($(sequence.Size), $(sequence.AstId : global));
            parseResult.ast[newAstPtr + Nitra.Internal.ExtensibleRuleParser.AstOfs.State] = $(sequence.NonMarkerSubrules[0].State);
            frame.AstHandle.AstPtr = newAstPtr;
            newAstPtr
          ]>
        }
        else
          <[
            def newAstPtr = parseResult.Allocate($(sequence.Size), $(sequence.AstId : global));
            parseResult.ast[newAstPtr + Nitra.Internal.ExtensibleRuleParser.AstOfs.State] = $(sequence.NonMarkerSubrules[0].State);
            frame.AstHandle.AstPtr = newAstPtr;
            parseResult.ast[newAstPtr + $(sequence.HeaderNext.Offset)] = parseResult.memoize[frame.AstHandle.TextPos];
            parseResult.memoize[frame.AstHandle.TextPos] = newAstPtr;
            newAstPtr
          ]>
      }
      code.Add(<[ _ = startPos; ]>);
      code.Add(<[ def failState = frame.FailState; ]>);
      def asts = sequence.AllNonMarkerSubrules.Filter(subrule => !subrule.IsPredicate).Grouping(subrule => (subrule.Owner, subrule));
      def cases = SCG.List();
      foreach ((sequence, subrules) in asts.KeyValuePairs)
      {
        if (sequence.Owner is List as owner when owner.IsSkipAnyPattern)
          foreach (subrule in subrules)
            cases.Add(<[ case: | $(subrule.State) => assert3(false) ]>)
        else
          foreach (subrule in subrules)
          {
            def getSize = match (subrule)
            {
              | Empty                                      => Some(<[ 0 ]>)
              | TokenString    (str)                       => Some(<[ { assert3($(ParseMethodEmitter.CheckStringCode(str, <[ parseResult.Text ]>, <[ startPos ]>))); $(str.Length); } ]>)
              | RegularCall    (ruleSymbol)                => Some(<[ $(MakeRegularRuleCall(ruleSymbol, <[ startPos ]>, <[ parseResult.Text ]>)) - startPos ]>)
              | SimpleCall     (ruleSymbol)                => Some(<[ $(Owner.MakeParserName(ruleSymbol) : global).Parse(startPos, parseResult.Text, parseResult) - startPos ]>)
              | ExtensibleCall (ruleSymbol, bindingPower)  => Some(<[ $(Owner.MakeParserName(ruleSymbol, bindingPower) : global).Parse(startPos, parseResult.Text, parseResult) - startPos ]>)
              | Option | List | ListWithSeparator//TODO: FIXME если у поля есть предикат то восстановление может начатья перед циклом
              | Marker => None()
            }
            def getAst =
              <[
                mutable astPtr = if (frame.AstHandle.AstPtr > 0)
                  frame.AstHandle.AstPtr;
                else
                  $(createAst(sequence));
              ]>;
            def frameType = match (subrule.Owner)
            {
              | Ast | Option                 => <[ Nitra.Internal.Recovery.RecoveryStackFrame.Rule ]>
              | List | ListWithSeparatorRule => <[ Nitra.Internal.Recovery.RecoveryStackFrame.ListBody ]>
              | ListWithSeparatorSeparator   => <[ Nitra.Internal.Recovery.RecoveryStackFrame.ListSeparator ]>
              | Predicate                    => assert3(false);
            }
            def (astPtr, astPtrRef) = if (sequence is SequenceCompileInfo.Ast(Symbol = Nitra.Typing.ExtensionRuleSymbol))
              ([<[ astPtr ]>], [<[ ref astPtr ]>])
            else
              ([], []);
            def frameCounter = match (sequence.Owner)
            {
              | List              as subrule when subrule.UseCounter => [<[ frame.Counter ]>]
              | ListWithSeparator as subrule when subrule.UseCounter => [<[ frame.Counter ]>]
              | _                                                => []
            }
            cases.Add(<[ case:
              | $(subrule.State) =>
                def frame = frame :> $frameType;
                frame.AstHandle.UpdateAstPtr(parseResult);
                $getAst;
                when (startState == $(subrule.State))
                {
                  $(if (getSize is Some(getSize))
                    <[
                      parseResult.ErrorData[errorIndex].Data = $getSize;
                      assert3(parseResult.ErrorData[errorIndex].Data >= 0);
                      startState = GetNextState(startState);
                    ]>
                    else
                    <[
                      assert3(false);
                    ]>
                  )
                }
                parseResult.PatchAst(this, astPtr, errorIndex, frame.FailState2, $(subrule.State), startState);
                def pos = $(sequence.ParseFunctionName : global)(frame.StartPos, parseResult.Text, ..$astPtrRef, parseResult);
                if (pos < 0)
                {
                  def startPos = frame.StartPos;
                  foreach (parent in frame.Parents)
                    $(sequence.FindRecoveryPositionFunctionName : global)(startPos, ..$frameCounter, ..$astPtr, parent, parseResult);
                  false
                }
                else
                  true
              ]>);
          }
      }
      cases.Add(<[ case: | _ => assert(false); ]>);
      code.Add(<[ match (failState) { ..$cases }]>);

      code.FlattenPExpr();
    }
  }
}
