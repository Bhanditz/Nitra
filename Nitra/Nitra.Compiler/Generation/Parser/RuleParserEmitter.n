using Nemerle;
using Nemerle.Collections;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Text;
using Nemerle.Utility;

using Nitra.Model;
using Nitra.Typing;

using System;
using System.Collections.Generic;
using System.Linq;

namespace Nitra.Compiler
{
  internal abstract partial class RuleParserEmitter : IConstantEmitter
  {
    public Owner : SyntaxModuleEmitter { get; }
    public RuleSymbol : RuleDefSymbol { get; }
    public Environment : EmitterEnvironment { get { Owner.Environment } }
    public this(owner : SyntaxModuleEmitter, ruleSymbol : RuleDefSymbol)
    {
      Owner          = owner;
      RuleSymbol     = ruleSymbol;
    }

    private mutable _callCounter : int = 0;
    private _simpleCalls : List[SimpleRuleSymbol * string] = List();

    [Memoize]
    public MakeParserName(ruleSymbol : SimpleRuleSymbol) : string
    {
      Owner.CallRule(ruleSymbol);
      def name = $"_parser_$(_callCounter)_$(ruleSymbol.Name)";
      _simpleCalls.Add((ruleSymbol, name));
      ++_callCounter;
      name
    }

    private _extensibleCalls : List[ExtensibleRuleSymbol * int * string] = List();

    [Memoize]
    public MakeParserName(ruleSymbol : ExtensibleRuleSymbol, bindingPower : int) : string
    {
      Owner.CallRule(ruleSymbol);
      def name = $"_parser_$(_callCounter)_$(ruleSymbol.Name)";
      _extensibleCalls.Add((ruleSymbol, bindingPower, name));
      ++_callCounter;
      name
    }

    public abstract DefineParser() : void;

    public abstract DefineParserMethods() : void;

    public abstract Emit() : void;

    protected DefineImplementation(member : ClassMember) : void
    {
      if (Owner.Environment.IsDebug)
        Owner.GrammarImplTB.DefineConditional(member)
      else
        Owner.GrammarImplTB.Define(member)
    }

    protected DefineReflection(tb : TypeBuilder, sequence : SequenceCompileInfo.Ast) : void
    {
      def reflectionCases = List();
      def reflectionFields = List();
      def structReflect(sequence : SequenceCompileInfo) : PExpr
      {
        def type = match (sequence)
        {
          | SequenceCompileInfo.Ast                        => <[ Nitra.Runtime.Reflection.SequenceInfo.Ast                        ]>
          | SequenceCompileInfo.List                       => <[ Nitra.Runtime.Reflection.SequenceInfo.List                       ]>
          | SequenceCompileInfo.Option                     => <[ Nitra.Runtime.Reflection.SequenceInfo.Option                     ]>
          | SequenceCompileInfo.ListWithSeparatorRule      => <[ Nitra.Runtime.Reflection.SequenceInfo.ListWithSeparatorRule      ]>
          | SequenceCompileInfo.ListWithSeparatorSeparator => <[ Nitra.Runtime.Reflection.SequenceInfo.ListWithSeparatorSeparator ]>
          | SequenceCompileInfo.Predicate                  => assert3(false)
        }
        def subrules = List();
        foreach (subrule in sequence.Fields)
        {
          def (subruleType, args) =
            match (subrule)
            {
              | SubruleCompileInfo.Empty                   => (<[ Nitra.Runtime.Reflection.SubruleInfo.Empty             ]>, [])
              | SubruleCompileInfo.List               as x => (<[ Nitra.Runtime.Reflection.SubruleInfo.List              ]>, [structReflect(x.Rule), <[ $(x.MinCount) ]>, if (x.MaxCount is Some(max)) <[ $(max) ]> else <[ null ]>, <[ $(x.IsSkipAnyPattern) ]>])
              | SubruleCompileInfo.ListWithSeparator  as x => (<[ Nitra.Runtime.Reflection.SubruleInfo.ListWithSeparator ]>, [structReflect(x.Rule), structReflect(x.Separator), <[ $(x.MinCount) ]>, if (x.MaxCount is Some(max)) <[ $(max) ]> else <[ null ]>, <[ $(x.HangingSeparator) ]>])
              | SubruleCompileInfo.Option             as x => (<[ Nitra.Runtime.Reflection.SubruleInfo.Option            ]>, [structReflect(x.Rule)])
              | SubruleCompileInfo.SimpleCall         as x => (<[ Nitra.Runtime.Reflection.SubruleInfo.SimpleCall        ]>, [<[ $(MakeParserName(x.Symbol) : global) ]>])
              | SubruleCompileInfo.ExtensibleCall     as x => (<[ Nitra.Runtime.Reflection.SubruleInfo.ExtensibleCall    ]>, [<[ $(MakeParserName(x.Symbol, x.BindingPower) : global) ]>])
              | SubruleCompileInfo.RegularCall        as x => (<[ Nitra.Runtime.Reflection.SubruleInfo.RegularCall       ]>, [x.Symbol.GetRuleDescriptorRef()])
              | SubruleCompileInfo.TokenString        as x => (<[ Nitra.Runtime.Reflection.SubruleInfo.TokenString       ]>, [<[ $(x.String) ]>, <[ $((x.SrcRule :> Rule.String).IsKeyToken) ]>])
              | SubruleCompileInfo.Marker(sym)             => (<[ Nitra.Runtime.Reflection.SubruleInfo.Marker            ]>, [<[ $(sym.FullName : string) ]>])
            };
          def args = [<[ $(subrule.Offset) ]>, <[ $(subrule.SrcRule.ToString()) ]>, <[ $(subrule.State) ]>, <[ $(subrule.CanParseEmptyString) ]>] + args;
          subrules.Add(<[ $subruleType(..$args) ]>);
        }
        def subrule = $"reflectionField$(reflectionFields.Count)";
        reflectionFields.Add((subrule, type));
        reflectionCases.Add(<[case: | _ when ruleId == $(sequence.AstId : global) => $(subrule : global) ]>);
        <[
          $(subrule : global) = $type($(sequence.AstId : global), $(sequence.SrcRule.ToString()), array[..$(subrules.NToList())]);
          $(subrule : global);
        ]>
      }
      def reflection = structReflect(sequence);
      reflectionCases.Add(<[case: | _ => assert(false) ]>);

      foreach ((subrule, type) in reflectionFields)
        tb.DefineConditional(<[decl: private mutable $(subrule : global) : $type ]>);

      tb.DefineConditional(<[decl:
        public override Reflection(ruleId : int) : Nitra.Runtime.Reflection.SequenceInfo
        {
          when ($(reflectionFields[reflectionFields.Count - 1][0] : global) == null)
            _ = $(reflection);

          match (ruleId)
          {
            ..$(reflectionCases.NToList())
          }
        }]>);
    }

    protected DefineInit(tb : TypeBuilder, sequence : SequenceCompileInfo.Ast) : void
    {
      def inits = List();
      foreach (sequence in sequence.NestedSequencies)
      {
        tb.DefineConditional(<[decl: public mutable $(sequence.AstId : global) : int; ]>);
        inits.Add(<[ $(sequence.AstId : global) = Grammar.NewRuleId(this); ]>);
      }

      foreach ((ruleSymbol, name) in _simpleCalls)
      {
        tb.DefineConditional(<[decl: private mutable $(name : global) : Nitra.Internal.SimpleRuleParser; ]>);
        inits.Add(<[ $(name : global) = Grammar.GetSimpleRuleParser($(ruleSymbol.GetRuleDescriptorRef())); ]>);
      }
      foreach ((ruleSymbol, bp, name) in _extensibleCalls)
      {
        tb.DefineConditional(<[decl: private mutable $(name : global) : Nitra.Internal.ExtensibleRuleParser; ]>);
        inits.Add(<[ $(name : global) = Grammar.GetExtensibleRuleParser($(ruleSymbol.GetRuleDescriptorRef()), $bp); ]>);
      }

      tb.DefineConditional(<[decl:
        public override Init() : void
        {
          ..$(inits.NToList())
        }
      ]>);
    }

    protected DefineParse(tb : TypeBuilder, sequence : SequenceCompileInfo.Ast) : void
    {
      ParseMethodEmitter(this, tb, sequence).Emit();
      TryParseMethodEmitter(this, tb, sequence).Emit();
      FindRecoveryPositionMethodEmitter(this, tb, sequence).Emit();
    }

    protected DefineGetNextState(tb : TypeBuilder, sequence : SequenceCompileInfo.Ast) : void
    {
      def fields = sequence.AllFields
        .Where(subrule => !(subrule is SubruleCompileInfo.Marker))
        .OrderBy(_.State)
        .ToList();
      assert(fields.Select((f, i) => (f.State, i)).All((state, i) => state == i)); // ensure states are sequential starting from 0
      def states = fields.Select(f => if (f.NextSibling != null) <[ $(f.NextSibling.State : int) ]> else  <[ -1 ]>);
      tb.DefineConditional(<[ decl:
        private static _stateMap : array[int] = array[..$states];
      ]>);
      tb.DefineConditional(<[ decl:
        public override GetNextState(state : int) : int
        {
          _stateMap[state]
        }
      ]>);
    }

    protected DefineStartState(tb : TypeBuilder, sequence : SequenceCompileInfo.Ast) : void
    {
      def startState = sequence.NonMarkerFields[0].State;
      tb.DefineConditional(<[ decl:
        public override StartState : int { get $(startState : int) }
      ]>);
    }

    protected DefinePatchAst(tb : TypeBuilder, sequence : SequenceCompileInfo.Ast) : void
    {
      PatchAstMethodEmitter(this, tb, sequence).Emit();
    }

    protected DefineUpdateMandatoryTokens(tb : TypeBuilder, sequence : SequenceCompileInfo.Ast) : void
    {
      UpdateMandatoryTokensMethodEmitter(this, tb, sequence).Emit();
    }

    public abstract CreateConstant(name : string, value : int) : string;
  }
}
