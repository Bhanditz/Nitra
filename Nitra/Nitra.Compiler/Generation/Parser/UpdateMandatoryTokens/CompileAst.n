using Nitra.Typing;
using Nemerle;
using Nemerle.Collections;
using Nemerle.Compiler.Parsetree;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Imperative;

using System;
using SCG = System.Collections.Generic;
using System.Linq;

using Nitra.Model;

namespace Nitra.Compiler
{
  internal sealed partial class UpdateMandatoryTokensMethodEmitter : MethodEmitter
  {
    public CompileAst(sequence : SequenceCompileInfo.Ast) : PExpr
    {
      def code = SCG.List();
      def fields = sequence.AllNonMarkerSubrules;
      code.Add(<[ mutable updated = false; ]>);
      code.Add(<[ mutable count; ]>);
      code.Add(<[
        when (_mandatoryTokensForState == null)//TODO: вынести в метод.
        {
          _mandatoryTokensForState = array($(fields.Length));
          for (mutable i = 0; i < $(fields.Length); ++i)
            _mandatoryTokensForState[i] = ~0;
        }
      ]>);
      def sumFields(fields)
      {
        def make(fields)
        {
          | [] => assert3(false);
          | [subrule] => <[ _mandatoryTokensForState[$(subrule.State)] ]>
          | [field1, field2] => <[ Nitra.Internal.ParseResult.AddMandatoryTokens(_mandatoryTokensForState[$(field1.State)], _mandatoryTokensForState[$(field2.State)]) ]>
          | subrule :: fields => <[ Nitra.Internal.ParseResult.AddMandatoryTokens(_mandatoryTokensForState[$(subrule.State)], $(make(fields))) ]>
        }
        make(fields.NToList())
      }
      for (mutable i = fields.Length - 1; i >= 0; --i)
      {
        def subrule = fields[i];
        def countCode = match (subrule)
        {
          | Empty                                      => <[ 0 ]>
          | TokenString    (str)                       => if (str.Length == 0) <[ 0 ]> else <[ 1 ]>
          | RegularCall    (ruleSymbol)                => if (ruleSymbol.CanParseEmptyString) <[ 0 ]> else <[ 1 ]>
          | SimpleCall     (ruleSymbol)                => <[ $(Owner.MakeParserName(ruleSymbol) : global).MandatoryTokens ]>
          | ExtensibleCall (ruleSymbol, bindingPower)  => <[ $(Owner.MakeParserName(ruleSymbol, bindingPower) : global).MandatoryTokens ]>
          | Option                                     => <[ 0 ]>
          | List              as subrule                 =>
            match (subrule.MinCount)
            {
              | 0 => <[ 0 ]>
              | 1 => <[ $(sumFields(subrule.Rule.NonMarkerSubrules)) ]>
              | c => <[ $c * $(sumFields(subrule.Rule.NonMarkerSubrules)) ]>
            }
          | ListWithSeparator as subrule                 =>
            match (subrule.MinCount)
            {
              | 0 => <[ 0 ]>
              | 1 => <[ $(sumFields(subrule.Rule.NonMarkerSubrules)) ]>
              | c => <[ $c * $(sumFields(subrule.Rule.NonMarkerSubrules)) + $(c - 1) * $(sumFields(subrule.Separator.NonMarkerSubrules)) ]>
            }
          | Marker                                     => assert3(false)
        }
        code.Add(<[
          count = $countCode;
          updated = updated || count != _mandatoryTokensForState[$(subrule.State)];
          _mandatoryTokensForState[$(subrule.State)] = count;
        ]>);
      }
      code.Add(<[ MandatoryTokens = $(sumFields(sequence.NonMarkerSubrules)) ]>);
      code.Add(<[ updated; ]>);
      code.FlattenPExpr();
    }
  }
}
