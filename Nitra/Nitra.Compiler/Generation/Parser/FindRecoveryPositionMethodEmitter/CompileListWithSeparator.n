using Nemerle;
using Nemerle.Imperative;
using Nemerle.Collections;
using Nemerle.Compiler.Parsetree;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using SCG = System.Collections.Generic;
using System.Linq;

using Nitra.Model;

namespace Nitra.Compiler
{
  internal partial class FindRecoveryPositionMethodEmitter : MethodEmitter
  {
    public override CompileListWithSeparator(code : SCG.List[PExpr], subrule : SubruleCompileInfo.ListWithSeparator) : void
    {
      CompileFuntion(subrule.Rule);
      CompileFuntion(subrule.Separator);
      def localVariableEmitter = LocalVariableEmitter();
      def stateData = ListStateData(localVariableEmitter, subrule);
      def itemPtr = AstPointer.New(subrule.Rule, ConstantEmitter, this, "itemPtr");
      def separatorPtr = AstPointer.New(subrule.Separator, ConstantEmitter, this, "separatorPtr");
      def body = <[
        $(stateData.Init());
        $(stateData.ListStartPos) = $CurTextPos;
        mutable lastItemStart = -1;
        mutable itemEndPos = $CurTextPos;
        mutable itemNotEmpty = true;
        mutable separatorNotEmpty = true;
        while (itemNotEmpty || separatorNotEmpty)
        {
          def $(itemPtr.Var) = parseResult.TryGetAst(itemEndPos, $(subrule.Rule.AstId : global));
          if ($(itemPtr.Var) > 0 && $(itemPtr.Get(itemPtr.Structure.HeaderState)) == Nitra.Internal.ParseResult.AstParsedState)
          {
            $(stateData.Inc());
            lastItemStart = itemEndPos;
            itemEndPos += parseResult.AstSize($(itemPtr.Var), $(subrule.Rule.SizesStart), $(subrule.Rule.SizesEnd));
            itemNotEmpty = lastItemStart < itemEndPos;
          }
          else
          {
            when (lastItemStart >= 0 && lastItemStart < itemEndPos)
            {
              $(stateData.ListEndPos) = lastItemStart;
              def stack = $(MakeRecoveryStackFrame(subrule, <[ lastItemStart ]>));
              when (stack != null)
                $(FunctionName(subrule.Separator) : global)(lastItemStart, ..$(stateData.TryGetCounter()), stack, parseResult);
            }
            $(stateData.Inc());
            $(stateData.ListEndPos) = itemEndPos;
            def stack = $(MakeRecoveryStackFrame(subrule, <[ itemEndPos ]>));
            when (stack != null)
              $(FunctionName(subrule.Rule) : global)(itemEndPos, ..$(stateData.TryGetCounter()), stack, parseResult);
            break;
          }
          def $(separatorPtr.Var) = parseResult.TryGetAst(itemEndPos, $(subrule.Separator.AstId : global));
          if ($(separatorPtr.Var) > 0 && $(separatorPtr.Get(separatorPtr.Structure.HeaderState)) == Nitra.Internal.ParseResult.AstParsedState)
          {
            lastItemStart = itemEndPos;
            itemEndPos += parseResult.AstSize($(separatorPtr.Var), $(subrule.Separator.SizesStart), $(subrule.Separator.SizesEnd));
            separatorNotEmpty = lastItemStart < itemEndPos;
          }
          else
          {
            when (lastItemStart >= 0 && lastItemStart < itemEndPos)
            {
              $(stateData.ListEndPos) = lastItemStart;
              def stack = $(MakeRecoveryStackFrame(subrule, <[ lastItemStart ]>));
              when (stack != null)
                $(FunctionName(subrule.Rule) : global)(lastItemStart, ..$(stateData.TryGetCounter()), stack, parseResult);
            }
            $(stateData.ListEndPos) = itemEndPos;
            def stack = $(MakeRecoveryStackFrame(subrule, <[ itemEndPos ]>));
            when (stack != null)
              $(FunctionName(subrule.Separator) : global)(itemEndPos, ..$(stateData.TryGetCounter()), stack, parseResult);
            break;
          }
        }
      ]>;
      code.Add(CheckState(subrule, <[
        ..$(localVariableEmitter.Define());
        $body;
      ]>))
    }
  }
}
