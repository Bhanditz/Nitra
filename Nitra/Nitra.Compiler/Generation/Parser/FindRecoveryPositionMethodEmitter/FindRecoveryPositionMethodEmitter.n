using Nitra.Typing;
using Nemerle;
using Nemerle.Collections;
using Nemerle.Compiler.Parsetree;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Imperative;

using System;
using SCG = System.Collections.Generic;
using System.Linq;

using Nitra.Model;

using Nemerle.Compiler;

namespace Nitra.Compiler
{
  internal partial class FindRecoveryPositionMethodEmitter : MethodEmitter
  {
    private EndLabel : PExprLabel;

    public this(owner : RuleParserEmitter, tb : TypeBuilder, sequence : SequenceCompileInfo.Ast)
    {
      base(owner, sequence, tb);
      _data                       = SequenceDataContainer(sequence, this, SequenceData, SubruleData);
      EndLabel                    = Environment.MakeLabel("EndParse");
    }

    public Emit() : void
    {
      CompileFunction(SequenceCompileInfo)
    }

    public CurTextPos : PExpr { get { <[ curTextPos ]> } }

    public MakeRecoveryStackFrame(subrule : SubruleCompileInfo, textPos : PExpr) : PExpr
    {
      def getCounter()
      {
        match (subrule.Owner.Owner)
        {
          | List              as subrule when subrule.UseCounter => <[ counter ]>
          | ListWithSeparator as subrule when subrule.UseCounter => <[ counter ]>
          | List                                             => <[ 0 ]>
          | ListWithSeparator                                => <[ 0 ]>
          | _                                                => assert(false);
        }
      }
      match (subrule.Owner)
      {
        | SequenceCompileInfo.Ast
        | SequenceCompileInfo.Option                    => <[ parseResult.RecoveryStackFrame_Rule(stack, $textPos, astHandle, $(subrule.State)); ]>
        | SequenceCompileInfo.List
        | SequenceCompileInfo.ListWithSeparatorRule     => <[ parseResult.RecoveryStackFrame_ListBody(stack, $textPos, astHandle, $(subrule.State), $(getCounter())); ]>
        | SequenceCompileInfo.ListWithSeparatorSeparator=> <[ parseResult.RecoveryStackFrame_ListSeparator(stack, $textPos, astHandle, $(subrule.State), $(getCounter())); ]>
        | SequenceCompileInfo.Predicate                 => assert(false);
      }
    }
  }
}
