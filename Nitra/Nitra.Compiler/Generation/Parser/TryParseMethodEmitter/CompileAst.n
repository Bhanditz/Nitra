using Nitra.Typing;
using Nemerle;
using Nemerle.Collections;
using Nemerle.Compiler.Parsetree;
using Nemerle.Imperative;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using SCG = System.Collections.Generic;
using System.Linq;

using Nitra.Model;

namespace Nitra.Compiler
{
  internal sealed partial class TryParseMethodEmitter : MethodEmitter
  {
    public CompileAst(sequence : SequenceCompileInfo.Ast) : PExpr
    {
      def initList(subrule)//TODO: Fix counters
      {
        <[
          $(ListStartPos(subrule.Owner.Owner)) = frame.GetParentTextPos();
          $(ListEndPos(subrule.Owner.Owner))   = $CurTextPos;
        ]>
      }
      def makeContinueStateSelector() : PExpr
      {
        def continueCases = SCG.List();
        foreach (subrule in sequence.AllNonMarkerFields)
        {
          def sourceStateComment = subrule.ToString();
          match (subrule)
          {
            | _ when subrule.IsPredicate =>
              continueCases.Add(<[ case: | $(subrule.State) => assert(false, $($"Cannot continue parse from predicate state: '$sourceStateComment'.")) ]>);
            | SubruleCompileInfo(Owner=SequenceCompileInfo(Owner=SubruleCompileInfo.List as lst)) when lst.IsSkipAnyPattern =>
              continueCases.Add(<[ case: | $(subrule.State) => assert(false, $($"Cannot parse from optimized loop state: '$sourceStateComment'.")) ]>);
            | _ =>
              def code = match (subrule.Owner)
              {
                | List =>
                  <[
                    $(initList(subrule));
                    $(GotoParseLabel((subrule.Owner.Owner :> SubruleCompileInfo.List).Rule.NonMarkerFields[0]));
                  ]>;
                | ListWithSeparatorRule =>
                  <[
                    $(initList(subrule));
                    $(GotoParseLabel((subrule.Owner.Owner :> SubruleCompileInfo.ListWithSeparator).Separator.NonMarkerFields[0]))
                  ]>;
                | ListWithSeparatorSeparator =>
                  <[
                    $(initList(subrule));
                    $(GotoParseLabel((subrule.Owner.Owner :> SubruleCompileInfo.ListWithSeparator).Rule.NonMarkerFields[0]))
                  ]>;
                | _ => <[ $(_endLabel.Goto()) ]>;
              }
              continueCases.Add(<[ case: | $(subrule.State) => _ = $sourceStateComment; startLevel = $(subrule.Level); $code; ]>);
          }
        }
        continueCases.Add(<[ case: | x => assert(false, $"Unknown continue parse state '$x'.") ]>);
        <[ assert(continueList); match (frame.FailState) { ..$continueCases } ]>
      }

      def makeStartStateSelector() : PExpr
      {
        def startCases = SCG.List();
        startCases.Add(<[ case: | -1 => $(makeContinueStateSelector()) ]>);
        foreach (subrule in sequence.AllNonMarkerFields)
        {
          def comment = subrule.ToString();
          match (subrule)
          {
            | _ when subrule.IsPredicate =>
              startCases.Add(<[ case: | $(subrule.State) => assert(false, $($"Cannot parse from predicate state: '$comment'.")) ]>);
            | SubruleCompileInfo(Owner=SequenceCompileInfo(Owner=SubruleCompileInfo.List as lst)) when lst.IsSkipAnyPattern =>
              startCases.Add(<[ case: | $(subrule.State) => assert(false, $($"Cannot parse from optimized loop state: '$comment'.")) ]>);
            | _ =>
              def initList = match (subrule.Owner)
              {
                | List
                | ListWithSeparatorRule
                | ListWithSeparatorSeparator =>
                  <[
                    when (continueList)
                      $(initList(subrule));
                  ]>
                | _ => <[ {} ]>
              }
              startCases.Add(<[ case: | $(subrule.State) => _ = $comment; startLevel = $(subrule.Level); $initList; $(GotoParseLabel(subrule)) ]>);
          }
        }
        startCases.Add(<[ case: | x => assert(false, $"Unknown parse state '$x'.") ]>);
        <[ match (startState) { ..$startCases } ]>
      }

      def code = SCG.List();
      code.Add(<[ ignore(curTextPos, parseResult); ]>);
      code.Add(<[ _ = $(sequence.ToString()) ]>);
      code.Add(makeStartStateSelector());

      //parse ok
      code.Add(OkLabel(sequence));
      code.Add(_endLabel.Goto());

      //parse fail
      code.Add(FailLabel(sequence));
      code.Add(<[ $CurTextPos = -1; ]>);
      code.Add(_endLabel.Goto());

      CompileFields(code, sequence);

      code.Add(_endLabel.Label());
      code.Add(<[ $CurTextPos; ]>);

      def codeWithVariables = SCG.List();
      codeWithVariables.Add(<[
        def     targetState : int = frame.FailState; _ = targetState;
        mutable tmpSize     : int; _ = tmpSize;
        mutable newPos      : int; _ = newPos;

      ]>);
      codeWithVariables.AddRange(LocalVariables.Map(name => <[ mutable $(name : global) ]>));
      codeWithVariables.AddRange(code);

      codeWithVariables.FlattenPExpr();
    }
  }
}
