using Nemerle;
using Nemerle.Collections;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Imperative;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;

namespace Nitra.Compiler
{
  internal sealed class SymbolSerializationExtension : IBinarySerializationEmitterExtension, IBinarySerializationMessageEmitter
  {
    public this(environment : EmitterEnvironment)
    {
      _environment = environment;
    }

    _environment : EmitterEnvironment;

    mutable _metadataWriterParam : string;
    mutable _metadataReaderParam : string;

    public CreateParameters(emitter : BinarySerializationEmitter) : void
    {
      _metadataWriterParam = emitter.CreateSerializationParameter("_metadataWriter", <[ Nitra.Serialization2.MetadataWriter ]>);
      _metadataReaderParam = emitter.CreateDeserializationParameter("_metadataReader", <[ Nitra.Serialization2.MetadataReader ]>);
    }

    private SupportedTypes : array[FixedType * string]
    {
      mutable _supportedTypes : array[FixedType * string];
      get
      {
        when (_supportedTypes : object == null)
        {
          def env = _environment.Manager.CoreEnv;
          _supportedTypes = array
          [
            (env.BindFixedType(<[ Nitra.Runtime.Binding.DeclarationSymbol ]>), "Symbol"),
            (env.BindFixedType(<[ Nitra.Runtime.Binding.Scope ]>),             "Scope"),
            (env.BindFixedType(<[ Nitra.Runtime.Binding.IRef ]>),              "Ref"),
            (env.BindFixedType(<[ Nitra.SpanClass ]>),                         "SpanClass"),
            (env.BindFixedType(<[ Nitra.ProjectSystem.File ]>),                "File"),
            (env.BindFixedType(<[ Nitra.Location ]>),                          "Location"),
            (env.BindFixedType(<[ Nitra.Staging.ICollector ]>),                "Collector"),
          ];
        }
        _supportedTypes
      }
    }

    public IsSupportedType(type : FixedType) : bool
    {
      foreach ((t, _) when type.TryRequire(t) in SupportedTypes)
        return true;
      false
    }

    public MakeWriteCode(type : FixedType, _emitter : BinarySerializationEmitter) : PExpr
    {
      foreach ((t, suffix) when type.TryRequire(t) in SupportedTypes)
        return <[ $(_metadataWriterParam : usesite).$("Write" + suffix : usesite)(obj, writer) ]>;

      assert(false)
    }

    public MakeReadCode(type : FixedType, _emitter : BinarySerializationEmitter) : PExpr
    {
      foreach ((t, suffix) when type.TryRequire(t) in SupportedTypes)
      {
        def expr = <[ _ = typeCode; $(_metadataReaderParam : usesite).$("Read" + suffix : usesite)(reader) ]>;
        return if (type.Equals(t)) expr else <[ $expr :> $(type : typed) ]>;
      }

      assert(false)
    }

    public EmitWarning(message : PExpr) : PExpr
    {
      <[ $(_metadataReaderParam : usesite).Project.Warning($(_metadataReaderParam : usesite).ErrorLocation, $message) ]>
    }

    public EmitFatalError(message : PExpr) : PExpr
    {
      <[ $(_metadataReaderParam : usesite).Project.FatalError($(_metadataReaderParam : usesite).ErrorLocation, $message) ]>
    }
  }
}
