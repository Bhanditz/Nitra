using Nitra.Model;
using Nitra.Typing;

using Nemerle;
using Nemerle.Collections;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using SCG = System.Collections.Generic;

namespace Nitra.Compiler
{
  internal sealed class SimpleDeclarationEmitter : DeclarationEmitter
  {
    private         _symbol      : SimpleDeclarationSymbol;
    private mutable _baseTb      : TypeBuilder;
    private mutable _ambiguousTb : TypeBuilder;
    private mutable _concreteTb  : TypeBuilder;

    public this(environment : EmitterEnvironment, symbol : SimpleDeclarationSymbol)
    {
      base(environment, environment.NamespaceOfSymbol(symbol));
      this._symbol = symbol;
    }

    public override DefineTypes() : void
    {
      assert(_baseTb == null);

      def baseTypes = <[ Nitra.Declarations.Declaration[$(CompileNType(_symbol.ParentType))] ]>
        :: _symbol.BaseDeclarations.Map(s => <[ $(Environment.GetDeclarationType(s) : typed) ]>);

      _baseTb = NemerleEnv.Define(<[ decl:
        public abstract partial class $(_symbol.Name : usesite) : ..$baseTypes
        {
        }
      ]>);

      assert(_concreteTb == null);
      _concreteTb = _baseTb.DefineNestedType(<[ decl:
        public sealed partial class $(ConcreteDeclarationName : usesite) : $(_baseTb.GetMemType() : typed)
        {
          public this(parent : $(CompileNType(_symbol.ParentType)), span : $(Environment.NSpanTypeVar : typed))
          {
            this.Parent = parent;
            this.Span = span;
          }

          public override Parent : $(CompileNType(_symbol.ParentType)) { get; }
          public override Span   : $(Environment.NSpanTypeVar : typed) { get; }
        }
      ]>);

      assert(_ambiguousTb == null);
      _ambiguousTb = DefineAmbiguousDeclaration(_baseTb, _symbol.ParentType);
    }

    public override DefineMembers() : void
    {
      assert(_baseTb != null);

      def initParameters = SCG.List();
      def initStatements = SCG.List();

      def dependentProps = SCG.List();
      def declaredProps = SCG.List();

      def defineSimpleField(fieldSymbol : SimpleDeclarationFieldSymbol) : void
      {
        _baseTb.Define(<[ decl:
          public abstract $(fieldSymbol.Name : usesite) : $(MakeFieldType(fieldSymbol)) { get; }
        ]>);

        _ambiguousTb.Define(<[ decl:
          public override $(fieldSymbol.Name : usesite) : $(MakeFieldType(fieldSymbol))
          {
            get { this.Ambiguities[0].$(fieldSymbol.Name : usesite) }
          }
        ]>);

        def backingFieldName = Util.tmpname(fieldSymbol.Name);
        initParameters.Add(<[ parameter : $(fieldSymbol.Name : usesite) : $(MakeFieldType(fieldSymbol)) ]>);
        initStatements.Add(<[ this.$(backingFieldName : usesite) = $(fieldSymbol.Name : usesite) ]>);
        _concreteTb.Define(<[ decl:
          private mutable $(backingFieldName : usesite) : $(MakeFieldType(fieldSymbol))
        ]>);

        def prop = _concreteTb.DefineAndReturn(<[ decl:
          public override $(fieldSymbol.Name : usesite) : $(MakeFieldType(fieldSymbol))
          {
            get { this.$(backingFieldName : usesite) }
          }
        ]>) :> IProperty;

        declaredProps.Add(prop);
      }

      def defineDependentField(fieldSymbol : DependentDeclarationFieldSymbol) : void
      {
        def index = dependentProps.Count;
        dependentProps.Add(fieldSymbol);

        def prop = _baseTb.DefineAndReturn(<[ decl:
          [Nitra.Internal.DependentPropertyAttribute($(fieldSymbol.FullName : string), $(index : int))]
          public abstract $(fieldSymbol.Name : usesite) : $(MakeFieldType(fieldSymbol))
          {
            get;
            set;
          }
        ]>);
        prop.UserData[typeof(DependentDeclarationPropertyRef)] = DependentDeclarationPropertyRef(fieldSymbol, index);

        def prop = _ambiguousTb.DefineAndReturn(<[ decl:
          [Nitra.Internal.DependentPropertyAttribute($(fieldSymbol.FullName : string), $(index : int))]
          public override $(fieldSymbol.Name : usesite) : $(MakeFieldType(fieldSymbol))
          {
            get { this.Ambiguities[0].$(fieldSymbol.Name : usesite) }
            set
            {
              foreach (ambiguity in this.Ambiguities)
                ambiguity.$(fieldSymbol.Name : usesite) = value;
            }
          }
        ]>);
        prop.UserData[typeof(DependentDeclarationPropertyRef)] = DependentDeclarationPropertyRef(fieldSymbol, index);

        def backingFieldName = Util.tmpname(fieldSymbol.Name);

        _concreteTb.Define(<[ decl:
          private mutable $(backingFieldName : usesite) : $(MakeFieldType(fieldSymbol))
        ]>);
        def prop = _concreteTb.DefineAndReturn(<[ decl:
          [Nitra.Internal.DependentPropertyAttribute($(fieldSymbol.FullName : string), $(index : int))]
          public override $(fieldSymbol.Name : usesite) : $(MakeFieldType(fieldSymbol))
          {
            get { this.$(backingFieldName : usesite) }
            set { this.$(backingFieldName : usesite) = value }
          }
        ]>);
        prop.UserData[typeof(DependentDeclarationPropertyRef)] = DependentDeclarationPropertyRef(fieldSymbol, index);
      }

      foreach (fieldSymbol in _symbol.AllFields)
      {
        | SimpleDeclarationFieldSymbol    as s => defineSimpleField(s)
        | DependentDeclarationFieldSymbol as s => defineDependentField(s)
        | _                                    => assert(false)
      }

      _concreteTb.DefineConditional(<[ decl:
        public Initialize(..$initParameters) : void { ..$initStatements }
      ]>);

      DefineDependentFieldsEvaluation(_concreteTb, dependentProps, declaredProps, <[ () ]>);
    }

    public override Emit() : void
    {
      assert(_baseTb != null);
      _baseTb.Compile();

      assert(_concreteTb != null);
      _concreteTb.Compile();

      assert(_ambiguousTb != null);
      _ambiguousTb.Compile();
    }
  }
}
