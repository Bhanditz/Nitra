using Nitra.Model;
using Nitra.Typing;

using Nemerle;
using Nemerle.Collections;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using SCG = System.Collections.Generic;

namespace Nitra.Compiler
{
  internal sealed class ExtensibleDeclarationEmitter : DeclarationEmitter
  {
    private         _symbol      : ExtensibleDeclarationSymbol;
    private mutable _baseTb      : TypeBuilder;
    private mutable _ambiguousTb : TypeBuilder;

    public this(environment : EmitterEnvironment, symbol : ExtensibleDeclarationSymbol)
    {
      base(environment, environment.NamespaceOfSymbol(symbol));
      this._symbol = symbol;
    }

    public override DefineTypes() : void
    {
      assert(_baseTb == null);

      def baseTypes = <[ Nitra.Declarations.Declaration[$(CompileNType(_symbol.ParentType))] ]>
        :: _symbol.BaseDeclarations.Map(s => <[ $(Environment.GetDeclarationType(s) : typed) ]>);

      _baseTb = NemerleEnv.Define(<[ decl:
        public abstract partial class $(_symbol.Name : usesite) : ..$baseTypes
        {
          protected this() { }
        }
      ]>);

      assert(_ambiguousTb == null);
      _ambiguousTb = DefineAmbiguousDeclaration(_baseTb, _symbol.ParentType);
    }

    public override DefineMembers() : void
    {
      assert(_baseTb != null);

      def defineSimpleField(fieldSymbol : SimpleDeclarationFieldSymbol) : void
      {
        def baseDecl =
          if (fieldSymbol.HasBody)
          {
            if (fieldSymbol.DeclaringDeclaration : object == _symbol)
              <[ decl:
                public $(fieldSymbol.Name : usesite) : $(MakeFieldType(fieldSymbol))
                {
                  get { $(MakeFieldBody(fieldSymbol)) }
                }
              ]>
            else
              <[ decl:
                public $(fieldSymbol.Name : usesite) : $(MakeFieldType(fieldSymbol))
                {
                  get { $(InvokeEvalMethod(fieldSymbol)) }
                }
              ]>
          }
          else
            <[ decl: public abstract $(fieldSymbol.Name : usesite) : $(MakeFieldType(fieldSymbol)) { get; } ]>;
        when (CollectImplementedFields(fieldSymbol) is _ :: _ as implementedFields)
          baseDecl.ParsedImplemented = implementedFields.Map(f => <[ $(Environment.GetDeclarationType(f.DeclaringDeclaration) : typed).$(f.Name : usesite) ]>);
        _baseTb.DefineConditional(baseDecl);
      }

      def evalStatements = SCG.List();

      def defineDependentField(fieldSymbol : DependentDeclarationFieldSymbol) : void
      {
        if (fieldSymbol.DeclaringDeclaration : object == _symbol)
        {
          def backingFieldName = Util.tmpname(fieldSymbol.Name);
          _baseTb.DefineConditional(<[ decl:
            private mutable $(backingFieldName : usesite) : $(MakeFieldType(fieldSymbol));
          ]>);
          def baseDecl = <[ decl:
            public $(fieldSymbol.Name : usesite) : $(MakeFieldType(fieldSymbol))
            {
              get { this.$(backingFieldName : usesite) }
            }
          ]>;
          when (CollectImplementedFields(fieldSymbol) is _ :: _ as implementedFields)
            baseDecl.ParsedImplemented = implementedFields.Map(f => <[ $(Environment.GetDeclarationType(f.DeclaringDeclaration) : typed).$(f.Name : usesite) ]>);
          _baseTb.DefineConditional(baseDecl);

          evalStatements.Add(<[ this.$(backingFieldName : usesite) = $(fieldSymbol.Body.Expr) ]>);
        }
        else
        {
        }
      }

      foreach (fieldSymbol in _symbol.AllFields)
      {
        | SimpleDeclarationFieldSymbol    as s => defineSimpleField(s)
        | DependentDeclarationFieldSymbol as s => defineDependentField(s)
        | _                                    => assert(false)
      }

      when (evalStatements.Count > 0)
      {
        _baseTb.DefineConditional(<[ decl:
          public override EvalFields(context : Nitra.Declarations.EvalDeclarationFieldsContext) : void { ..$evalStatements }
        ]>);
      }
    }

    public override DefineNestedType(td : ClassMember.TypeDeclaration) : TypeBuilder
    {
      assert(_baseTb != null);
      _baseTb.DefineNestedType(td);
    }

    public override Emit() : void
    {
      assert(_baseTb != null);
      _baseTb.Compile();

      assert(_ambiguousTb != null);
      _ambiguousTb.Compile();
    }
  }
}
