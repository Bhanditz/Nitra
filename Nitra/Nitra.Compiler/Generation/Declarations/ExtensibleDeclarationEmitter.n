using Nitra.Model;
using Nitra.Typing;

using Nemerle;
using Nemerle.Collections;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using SCG = System.Collections.Generic;

namespace Nitra.Compiler
{
  internal sealed class ExtensibleDeclarationEmitter : DeclarationEmitter
  {
    private         _symbol      : ExtensibleDeclarationSymbol;
    private mutable _baseTb      : TypeBuilder;
    private mutable _ambiguousTb : TypeBuilder;

    public this(environment : EmitterEnvironment, symbol : ExtensibleDeclarationSymbol)
    {
      base(environment, environment.NamespaceOfSymbol(symbol));
      this._symbol = symbol;
    }

    public override DefineTypes() : void
    {
      assert(_baseTb == null);

      def baseTypes = <[ Nitra.Declarations.Declaration[$(CompileNType(_symbol.ParentType))] ]>
        :: _symbol.BaseDeclarations.Map(s => <[ $(Environment.GetDeclarationType(s) : typed) ]>);

      _baseTb = NemerleEnv.Define(<[ decl:
        public abstract partial class $(_symbol.Name : usesite) : ..$baseTypes
        {
          protected this() { }
        }
      ]>);

      assert(_ambiguousTb == null);
      _ambiguousTb = DefineAmbiguousDeclaration(_baseTb, _symbol.ParentType);
    }

    public override DefineMembers() : void
    {
      assert(_baseTb != null);

      def dependentProps = SCG.List();

      def defineSimpleProperty(propertySymbol : SimpleDeclarationPropertySymbol) : void
      {
        def propertyType     = CompileSimplePropertyType(propertySymbol);
        def backingFieldName = Util.tmpname(propertySymbol.Name);

        _baseTb.Define(<[ decl:
          private mutable $(backingFieldName : usesite) : $(propertyType : typed)
        ]>);
        _baseTb.Define(<[ decl:
          public $(propertySymbol.Name : usesite) : $(propertyType : typed)
          {
            get { this.$(backingFieldName : usesite) }
            protected set { this.$(backingFieldName : usesite) = value }
          }
        ]>);

        _ambiguousTb.Define(<[ decl:
          public override $(propertySymbol.Name : usesite) : $(propertyType : typed)
          {
            get { this.Ambiguities[0].$(propertySymbol.Name : usesite) }
          }
        ]>);
      }

      def defineDependentProperty(propertySymbol : DependentDeclarationPropertySymbol) : void
      {
        def index = dependentProps.Count;
        def bit   = _baseTb.GetBitFieldManager().Allocate();
        assert(bit.Index == index);

        dependentProps.Add(propertySymbol);

        DefineDependentProperty(_baseTb, propertySymbol, index, bit, NemerleModifiers.Public | NemerleModifiers.Virtual);
        DefineAmbiguousDependentProperty(_ambiguousTb, propertySymbol, index);
      }

      foreach (propertySymbol in _symbol.AllProperties)
      {
        | SimpleDeclarationPropertySymbol    as s => defineSimpleProperty(s)
        | DependentDeclarationPropertySymbol as s => defineDependentProperty(s)
        | _                                       => assert(false)
      }

      DefineHasValueMethod(_baseTb, 0);
      DefineDependentPropertiesEvaluation(_baseTb, _symbol);
    }

    public override DefineNestedType(td : ClassMember.TypeDeclaration) : TypeBuilder
    {
      assert(_baseTb != null);
      _baseTb.DefineNestedType(td);
    }

    public override Emit() : void
    {
      assert(_baseTb != null);
      _baseTb.Compile();

      assert(_ambiguousTb != null);
      _ambiguousTb.Compile();
    }
  }
}
