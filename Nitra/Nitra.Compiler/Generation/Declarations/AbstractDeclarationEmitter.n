using Nitra.Model;
using Nitra.Typing;

using Nemerle;
using Nemerle.Collections;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using SCG = System.Collections.Generic;

namespace Nitra.Compiler
{
  internal sealed class AbstractDeclarationEmitter : DeclarationEmitter
  {
    private         _symbol : AbstractDeclarationSymbol;
    private mutable _tb     : TypeBuilder;

    public this(environment : EmitterEnvironment, symbol : AbstractDeclarationSymbol)
    {
      base(environment, environment.NamespaceOfSymbol(symbol));
      this._symbol = symbol;
    }

    public override DefineTypes() : void
    {
      assert(_tb == null);

      def baseTypes = match (_symbol.BaseDeclarations)
      {
        | []   => [<[ $(Environment.DeclarationTypeVar : typed) ]>]
        | many => many.Map(s => <[ $(Environment.GetDeclarationType(s) : typed) ]>)
      };

      _tb = NemerleEnv.Define(<[ decl:
        public partial interface $(_symbol.Name : usesite) : ..$baseTypes
        {
        }
      ]>);
    }

    public override DefineMembers() : void
    {
      assert(_tb != null);

      foreach (fieldSymbol in _symbol.Fields)
      {
        _tb.DefineConditional(<[ decl:
          $(fieldSymbol.Name : usesite) : $(MakeFieldType(fieldSymbol)) { get; }
        ]>);
        when (fieldSymbol.HasBody)
        {
          _tb.DefineConditional(<[ decl:
            public static $("Eval" + fieldSymbol.Name : usesite)(self : this) : $(MakeFieldType(fieldSymbol))
            {
              _ = self;
              $(fieldSymbol.Body.Expr)
            }
          ]>);
        }
      }
    }

    public override Emit() : void
    {
      assert(_tb != null);
      _tb.Compile();
    }
  }
}
