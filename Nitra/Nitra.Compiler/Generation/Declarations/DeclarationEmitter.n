using Nitra.Typing;
using Nitra.Model;

using Nemerle;
using Nemerle.Collections;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Compiler.Typedtree;
using Nemerle.Imperative;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using SCG = System.Collections.Generic;

namespace Nitra.Compiler
{
  [Record]
  internal abstract partial class DeclarationEmitter
  {
    protected static AmbiguousDeclarationName = "Ambiguous";
    protected static ConcreteDeclarationName  = "Concrete";

    public Environment : EmitterEnvironment { get; }
    public NemerleEnv  : GlobalEnv          { get; }

    public abstract DefineTypes() : void;
    public abstract DefineMembers() : void;
    public abstract Emit() : void;

    public virtual DefineNestedType(_ : ClassMember.TypeDeclaration) : TypeBuilder
    {
      throw NotSupportedException();
    }

    protected CompileNType(t : NType) : PExpr
    {
      NTypeCompiler.Compile(t, Environment)
    }

    protected MakeFieldType(fieldSymbol : DeclarationFieldSymbol) : PExpr
    {
      NTypeCompiler.Compile(fieldSymbol.Type, Environment)
    }

    protected DefineAmbiguousDeclaration(baseTb : TypeBuilder, parentType : NType) : TypeBuilder
    {
      baseTb.DefineNestedType(<[ decl:
        public sealed partial class $(AmbiguousDeclarationName : usesite) : $(baseTb.GetMemType() : typed)
        {
          public this(ambiguities : array[$(baseTb.GetMemType() : typed)])
          {
            this.Ambiguities = ambiguities;
          }

          public override IsAmbiguous : bool                                  { get { true } }
          public          Ambiguities : array[$(baseTb.GetMemType() : typed)] { get; }
          public override Span        : $(Environment.NSpanTypeVar : typed)   { get { this.Ambiguities[0].Span   } }
          public override Parent      : $(CompileNType(parentType))           { get { this.Ambiguities[0].Parent } }

          public override EvalFields(context : Nitra.Declarations.EvalDeclarationFieldsContext) : void
          {
            foreach (decl in Ambiguities)
              decl.EvalFields(context)
          }

          public override HasValue(index : int) : bool
          {
            this.Ambiguities[0].HasValue(index)
          }
        }
      ]>)
    }

    protected DefineInitializeMethod(tb : TypeBuilder, parameters : Seq[PParameter], body : Seq[PExpr]) : void
    {
      tb.Define(<[ decl: public Initialize(..$parameters) : void { ..$body } ]>);
    }

    protected DefineHasValueMethod(tb : TypeBuilder, inheritedPropCount : int, instancePropCount : int) : void
    {
      def bitFieldSize = 32;
      def bitFieldCount = instancePropCount / bitFieldSize + if (instancePropCount % bitFieldSize > 0) 1 else 0;
      mutable body = <[ throw System.ArgumentOutOfRangeException("index") ]>;
      for (mutable i = bitFieldCount; i > 0; --i)
      {
        def bitField = Util.tmpname("bitField");
        tb.Define(<[ decl: private mutable $(bitField : usesite) : int ]>);
        
        body = <[
          if (index < $(i * bitFieldSize))
            this.$(bitField : usesite) %&& (1 << (index % $(bitFieldSize)))
          else
            $body
        ]>
      }

      if (inheritedPropCount > 0)
      {
        tb.Define(<[ decl:
          public override HasValue(mutable index : int) : bool
          {
            unchecked
            {
              if (index < $(inheritedPropCount : int))
                base.HasValue(index)
              else
              {
                index = index - $(inheritedPropCount : int);
                $body;
              }
            }
          }
        ]>);
      }
      else
      {
        tb.Define(<[ decl:
          public override HasValue(index : int) : bool
          {
            unchecked ($body)
          }
        ]>);
      }
    }
  }
}
