using Nitra.Typing;
using Nitra.Model;

using Nemerle;
using Nemerle.Collections;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Compiler.Typedtree;
using Nemerle.Imperative;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Linq;
using SCG = System.Collections.Generic;

namespace Nitra.Compiler
{
  [Record]
  internal abstract partial class DeclarationEmitter
  {
    protected static AmbiguousDeclarationName = "Ambiguous";
    protected static ConcreteDeclarationName  = "Concrete";

    public Environment : EmitterEnvironment { get; }
    public NemerleEnv  : GlobalEnv          { get; }

    public abstract DefineTypes() : void;
    public abstract DefineMembers() : void;
    public abstract Emit() : void;

    public virtual DefineNestedType(_ : ClassMember.TypeDeclaration) : TypeBuilder
    {
      throw NotSupportedException();
    }

    protected CompileNType(t : NType) : PExpr
    {
      NTypeCompiler.Compile(t, Environment)
    }

    protected MakePropertyType(propertySymbol : DeclarationPropertySymbol) : PExpr
    {
      NTypeCompiler.Compile(propertySymbol.Type, Environment)
    }

    protected DefineAmbiguousDeclaration(baseTb : TypeBuilder, parentType : NType) : TypeBuilder
    {
      baseTb.DefineNestedType(<[ decl:
        public sealed partial class $(AmbiguousDeclarationName : usesite) : $(baseTb.GetMemType() : typed)
        {
          public this(ambiguities : array[$(baseTb.GetMemType() : typed)])
          {
            this.Ambiguities = ambiguities;
          }

          public override IsAmbiguous : bool                                  { get { true } }
          public          Ambiguities : array[$(baseTb.GetMemType() : typed)] { get; }
          public override Span        : $(Environment.NSpanTypeVar : typed)   { get { this.Ambiguities[0].Span   } }
          public override Parent      : $(CompileNType(parentType))           { get { this.Ambiguities[0].Parent } }

          public override EvalFields(context : Nitra.Declarations.EvalDeclarationFieldsContext) : void
          {
            foreach (decl in Ambiguities)
              decl.EvalFields(context)
          }

          public override HasValue(index : int) : bool
          {
            this.Ambiguities[0].HasValue(index)
          }
        }
      ]>)
    }

    protected DefineInitializeMethod(tb : TypeBuilder, parameters : Seq[PParameter], body : Seq[PExpr]) : void
    {
      tb.Define(<[ decl: public Initialize(..$parameters) : void { ..$body } ]>);
    }

    protected DefineDependentProperty(tb : TypeBuilder, propertySymbol : DependentDeclarationPropertySymbol, index : int, bit : BitField, modifiers : NemerleModifiers) : void
    {
      def backingFieldName = Util.tmpname(propertySymbol.Name);

      Util.locate(propertySymbol.FirstLocation.ToNemerleLocation(),
      {
        tb.Define(<[ decl:
          [RecordIgnore] private mutable $(backingFieldName : usesite) : $(MakePropertyType(propertySymbol))
        ]>);

        def mods          = AttributesAndModifiers(modifiers, [<[ Nitra.Internal.DependentPropertyAttribute($(propertySymbol.FullName : string), $(index : int)) ]>]);
        def assertMessage = $"Property '$(propertySymbol.Name)' is not set";
        tb.Define(<[ decl:
          ..$mods $(propertySymbol.Name : usesite) : $(MakePropertyType(propertySymbol))
          {
            get
            {
              unless($(bit.Read()))
                assert3(false, $assertMessage);
              this.$(backingFieldName : usesite)
            }
            set
            {
              unless ($(bit.Read()))
              {
                this.$(backingFieldName : usesite) = value;
                $(bit.Set());
              }
            }
          }
        ]>);
      });
    }

    protected DefineAmbiguousDependentProperty(tb : TypeBuilder, propertySymbol : DependentDeclarationPropertySymbol, index : int) : void
    {
      tb.Define(<[ decl:
        [Nitra.Internal.DependentPropertyAttribute($(propertySymbol.FullName : string), $(index : int))]
        public override $(propertySymbol.Name : usesite) : $(MakePropertyType(propertySymbol))
        {
          get { this.Ambiguities[0].$(propertySymbol.Name : usesite) }
          set
          {
            foreach (ambiguity in this.Ambiguities)
              ambiguity.$(propertySymbol.Name : usesite) = value
          }
        }
      ]>);
    }

    protected DefineHasValueMethod(tb : TypeBuilder, inheritedBitsCount : int) : void
    {
      def     fields = tb.GetBitFieldManager().GetFields().ToArray();
      mutable body   = <[ throw System.ArgumentOutOfRangeException("index") ]>;
      for (mutable i = fields.Length; i > 0; --i)
      {
        body = <[
          if (index < $(i * BitFieldManager.BitFieldSize))
            this.$(fields[i - 1] : usesite) %&& (1 << (index % $(BitFieldManager.BitFieldSize)))
          else
            $body
        ]>
      }

      if (inheritedBitsCount > 0)
      {
        tb.Define(<[ decl:
          public override HasValue(mutable index : int) : bool
          {
            unchecked
            {
              if (index < $(inheritedBitsCount : int))
                base.HasValue(index)
              else
              {
                index = index - $(inheritedBitsCount : int);
                $body;
              }
            }
          }
        ]>);
      }
      else
      {
        tb.Define(<[ decl:
          public override HasValue(index : int) : bool
          {
            unchecked ($body)
          }
        ]>);
      }
    }
  }
}
