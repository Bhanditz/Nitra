using Nitra.Model;
using Nitra.Typing;

using Nemerle;
using Nemerle.Collections;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using SCG = System.Collections.Generic;

namespace Nitra.Compiler
{
  internal sealed class ExtensionDeclarationEmitter : DeclarationEmitter
  {
    private         _parent : DeclarationEmitter;
    private         _symbol : ExtensionDeclarationSymbol;
    private mutable _tb     : TypeBuilder;

    public this(parent : DeclarationEmitter, symbol : ExtensionDeclarationSymbol)
    {
      base(parent.Environment, parent.NemerleEnv);
      this._parent = parent;
      this._symbol = symbol;
    }

    public override DefineTypes() : void
    {
      assert(_tb == null);
      _tb = _parent.DefineNestedType(<[ decl:
        public sealed partial class $(_symbol.Name : usesite) : $(Environment.GetDeclarationType(_symbol.BaseDeclaration.Value) : typed)
        {
          public this(parent : $(CompileNType(_symbol.ParentType)), span : $(Environment.NSpanTypeVar : typed))
          {
            this.Parent = parent;
            this.Span = span;
          }

          public override Parent : $(CompileNType(_symbol.ParentType)) { get; }
          public override Span   : $(Environment.NSpanTypeVar : typed) { get; }
        }
      ]>);
    }

    public override DefineMembers() : void
    {
      assert(_tb != null);

      def initParameters = SCG.List();
      def initStatements = SCG.List();

      def baseDeclaration = _symbol.BaseDeclaration.Value;

      def defineSimpleField(fieldSymbol : SimpleDeclarationFieldSymbol) : void
      {
        def defineField(fieldSymbol : DeclarationFieldSymbol, modifiers : NemerleModifiers, body : PExpr)
        {
          def mods = AttributesAndModifiers(NemerleModifiers.Public %| modifiers, []);
          _tb.DefineConditional(<[ decl:
            ..$mods $(fieldSymbol.Name : usesite) : $(MakeFieldType(fieldSymbol))
            {
              get { $body }
            }
          ]>);
        }

        def defineFieldWithStore(fieldSymbol : DeclarationFieldSymbol, modifiers : NemerleModifiers)
        {
          def backingFieldName = Util.tmpname(fieldSymbol.Name);
          _tb.DefineConditional(<[ decl:
            private mutable $(backingFieldName : usesite) : $(MakeFieldType(fieldSymbol));
          ]>);
          initParameters.Add(<[ parameter : $(fieldSymbol.Name : usesite) : $(MakeFieldType(fieldSymbol)) ]>);
          initStatements.Add(<[ this.$(backingFieldName : usesite) = $(fieldSymbol.Name : usesite) ]>);
          defineField(fieldSymbol, modifiers, <[ this.$(backingFieldName : usesite) ]>)
        }

        if (fieldSymbol.DeclaringDeclaration == _symbol)
        {
          def modifiers = NemerleModifiers.None;
          if (fieldSymbol.HasBody)
            defineField(fieldSymbol, modifiers, MakeFieldBody(fieldSymbol))
          else
            defineFieldWithStore(fieldSymbol, modifiers)
        }
        else if (fieldSymbol.DeclaringDeclaration == baseDeclaration)
        {
          unless (fieldSymbol.HasBody)
            defineFieldWithStore(fieldSymbol, NemerleModifiers.Override)
        }
        else
        {
          def modifiers = NemerleModifiers.Override;
          if (fieldSymbol.HasBody)
            defineField(fieldSymbol, modifiers, InvokeEvalMethod(fieldSymbol))
          else
            defineFieldWithStore(fieldSymbol, modifiers);
        }
      }

      def evalStatements = SCG.List();
      mutable needBaseEvalFieldsCall;

      def defineDependentField(fieldSymbol : DependentDeclarationFieldSymbol) : void
      {
        if (fieldSymbol.DeclaringDeclaration == _symbol)
        {
          def backingFieldName = Util.tmpname(fieldSymbol.Name);
          _tb.DefineConditional(<[ decl:
            private mutable $(backingFieldName : usesite) : $(MakeFieldType(fieldSymbol));
          ]>);
          _tb.DefineConditional(<[ decl:
            public $(fieldSymbol.Name : usesite) : $(MakeFieldType(fieldSymbol))
            {
              get { this.$(backingFieldName : usesite) }
            }
          ]>);
          evalStatements.Add(<[ this.$(backingFieldName : usesite) = $(fieldSymbol.Body.Expr) ]>);
        }
        else if (fieldSymbol.DeclaringDeclaration == baseDeclaration)
          needBaseEvalFieldsCall = true
        else
        {
        }
      }

      foreach (fieldSymbol in _symbol.AllFields)
      {
        | SimpleDeclarationFieldSymbol    as s => defineSimpleField(s)
        | DependentDeclarationFieldSymbol as s => defineDependentField(s)
        | _                                    => assert(false)
      }

      _tb.DefineConditional(<[ decl:
        public Initialize(..$initParameters) : void { ..$initStatements }
      ]>);

      when (needBaseEvalFieldsCall)
        evalStatements.Insert(0, <[ base.EvalFields(context); ]>);

      _tb.DefineConditional(<[ decl:
        public override EvalFields(context : Nitra.Declarations.EvalDeclarationFieldsContext) : void { ..$evalStatements }
      ]>);
    }

    public override Emit() : void
    {
      assert(_tb != null);
      _tb.Compile();
    }
  }
}
