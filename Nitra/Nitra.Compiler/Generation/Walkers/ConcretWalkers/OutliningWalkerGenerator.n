using Nitra.Runtime;
using Nitra.Model;
using Nitra.Typing;

using Nemerle;
using Nemerle.Collections;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;

namespace Nitra.Compiler
{
  [Record]
  public sealed class OutliningWalkerGenerator : WalkerGenerator
  {
    public Environment : EmitterEnvironment { get; }

    public override Name : string { get StandardWalkerTypes.Outlining }

    public override SupportsVoidRules : bool { get true }

    public override GetSignature(_rule : RuleSymbol) : WalkerSignature
    {
      WalkerSignature(
        [<[ parameter: _context : Nitra.Internal.OutliningWalkerContext ]>],
        <[ void ]>);
    }

    static IsBeginOutlineMarker(subrule : SubruleCompileInfo) : bool
    {
      | SubruleCompileInfo.Marker as m when m.Symbol.FullName == "Outline.outline_impl"
      | SubruleCompileInfo.Marker as m when m.Symbol.FullName == "Outline.outline_begin"
      | SubruleCompileInfo.Marker as m when m.Symbol.FullName == "Outline.outline_begin_before" => true
      | _ => false
    }

    static IsNeedSkipSpaces(subrule : SubruleCompileInfo) : bool
    {
      | SubruleCompileInfo.Marker as m when m.Symbol.FullName == "Outline.outline_begin_before"
      | SubruleCompileInfo.Marker as m when m.Symbol.FullName == "Outline.outline_end_before" => true
      | _ => false
    }

    static IsHideByDefault(subrule : SubruleCompileInfo) : bool
    {
      | SubruleCompileInfo.Marker as m when m.Symbol.FullName == "Outline.outline_hiden" => true
      | _ => false
    }

    static IsImplementationMarker(subrule : SubruleCompileInfo) : bool
    {
      | SubruleCompileInfo.Marker as m when m.Symbol.FullName == "Outline.outline_impl" => true
      | _ => false
    }

    static IsEndOutlineMarker(subrule : SubruleCompileInfo) : bool
    {
      | SubruleCompileInfo.Marker as m when m.Symbol.FullName == "Outline.outline_end"
      | SubruleCompileInfo.Marker as m when m.Symbol.FullName == "Outline.outline_end_before" => true
      | _ => false
    }

    protected override GetSubruleValue(subrule : SubruleCompileInfo, parentAstPointer : AstPointerScope) : PExpr
    {
      match (subrule)
      {
        | SimpleCall as simpleField         with (code = CallSimpleRule(simpleField, parentAstPointer, <[ _context ]>), ruleType = simpleField.Symbol.Type)
        | ExtensibleCall as extensibleField with (code = CallExtensibleRule(extensibleField, parentAstPointer, <[ _context ]>),           ruleType = extensibleField.Symbol.Type) =>
          if (ruleType is RuleType.Void)
            <[ def lastSpaceStartPos = pos;
               $code;
               when (pos > lastSpaceStartPos)
               {
                 _context.LastSpaceStartPos = lastSpaceStartPos;
                 _context.LastSpaceEndPos   = pos;
               }
            ]>
          else
            code

        | Marker =>
          if (IsBeginOutlineMarker(subrule))
            if (IsNeedSkipSpaces(subrule))
              <[
                if (_context.LastSpaceEndPos == pos) // пробельное правило было перед текущим
                  outlineSpanStart = _context.LastSpaceStartPos;
                else
                  outlineSpanStart = pos;
              ]>
            else
              <[ outlineSpanStart = pos; ]>
          else if (IsEndOutlineMarker(subrule))
            if (IsNeedSkipSpaces(subrule))
              <[
                def outlineSpanEnd = if (_context.LastSpaceEndPos == pos) _context.LastSpaceStartPos else pos;
                when (outlineSpanEnd > outlineSpanStart)
                  _context.Result.Add(Nitra.OutliningInfo(Nitra.NSpan(outlineSpanStart, outlineSpanEnd), hideByDefault, isImplementation));
                hideByDefault = false;
              ]>
            else
              <[
                when (pos > outlineSpanStart)
                  _context.Result.Add(Nitra.OutliningInfo(Nitra.NSpan(outlineSpanStart, pos), hideByDefault, isImplementation));
                hideByDefault = false;
              ]>
          else if (IsHideByDefault(subrule))
            <[ hideByDefault = true; ]>
          else
            <[ () ]>

        | List as lst when lst.IsSkipAnyPattern
        | Empty | TokenString | RegularCall => Skip(subrule, parentAstPointer)
        | Option as subrule =>
          GetOptionValue(
            subrule            = subrule,
            parentAstPointer = parentAstPointer,
            hasValue         = <[ _ = $(GetSequenceValue(subrule.Rule, "valuePointer")); ]>,
            noValue          = <[ () ]>)

        | List as lst =>
          GetListValue(subrule            = lst,
            parentAstPointer = parentAstPointer,
            init             = <[ () ]>,
            item             = GetSequenceValue(lst.Rule, "itemPointer"),
            returnCode       = <[ () ]>,
            emptyCode        = <[ () ]>);

        | ListWithSeparator as lst=>
          GetListWithSeparatorValue(
            subrule            = lst,
            parentAstPointer = parentAstPointer,
            init             = <[ () ]>,
            item             = GetSequenceValue(lst.Rule, "itemPointer"),
            separator        = GetSequenceValue(lst.Separator, "separatorPointer"),
            returnCode       = <[ () ]>,
            emptyCode        = <[ () ]>);
      }
    }

    protected override CombineValues(_sequence : SequenceCompileInfo, arguments : list[PExpr]) : PExpr
    {
      <[ ignore(..$arguments) ]>
    }

    protected override GetSyntaxRuleValue(ruleSymbol : SyntaxRuleSymbol, astPointer : AstPointerScope) : PExpr
    {
      def sequence = ruleSymbol.Sequence;
      def outlineCount = sequence.Subrules.Count(IsBeginOutlineMarker);
      def statementsList = List();

      when (outlineCount > 0)
      {
        def isImplementation = sequence.Subrules.Exists(IsImplementationMarker);
        statementsList.Add(<[ mutable outlineSpanStart = -1; mutable hideByDefault = false; def isImplementation = $isImplementation; ]>);
        when (outlineCount > 1)
          Message.Error(ruleSymbol.FirstLocation.ToNemerleLocation(), "Currently not supported more than one outline region on rule.");
      }

      foreach (subrule in sequence.Subrules)
        statementsList.Add(GetSubruleValue(subrule, astPointer));

      def statements = statementsList.NToList();

      <[ { ..$statements } ]>
    }

    public override PrefixAmbiguity(_ruleSymbol : ExtensibleRuleSymbol) : PExpr
    {
      <[ ignore(parseResult, endPos, ambiguities); ]>
    }

    public override PostfixAmbiguity(_ruleSymbol : ExtensibleRuleSymbol) : PExpr
    {
      <[ ignore(parseResult, endPos, ambiguities); ]>
    }

    public override PrefixMissed(_ruleSymbol : ExtensibleRuleSymbol) : PExpr
    {
      <[ ignore(parseResult, pos); ]>
    }

    public override SimpleMissed(_ruleSymbol : SimpleRuleSymbol) : PExpr
    {
      <[ ignore(parseResult, pos); ]>
    }
  }
}
