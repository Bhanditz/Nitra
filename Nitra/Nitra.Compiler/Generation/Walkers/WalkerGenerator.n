using Nitra.Model;
using Nitra.Typing;

using Nemerle;
using Nemerle.Collections;
using Nemerle.Compiler.Parsetree;
using Nemerle.Imperative;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;

namespace Nitra.Compiler
{
  [Record]
  public sealed class WalkerSignature
  {
    public Parameters : list[PParameter];
    public ReturnType : PExpr;
  }

  public abstract class WalkerGenerator
  {
    private _calledWalkers : Hashtable[SyntaxRuleSymbol * int, string] = Hashtable();

    protected          ConstantEmitter                 : IConstantEmitter { get; private set; }
    public    abstract Name                            : string           { get; }
    public    abstract SupportsVoidRules               : bool             { get; }
    public    abstract GetSignature(rule : RuleSymbol) : WalkerSignature;

    protected abstract GetSyntaxRuleValue(ruleSymbol : SyntaxRuleSymbol, astPointer : AstPointerScope) : PExpr;
    protected abstract GetSubruleValue(subrule : SubruleCompileInfo, parentAstPointer : AstPointerScope) : PExpr;
    protected abstract CombineValues(sequence : SequenceCompileInfo, arguments : list[PExpr]) : PExpr;

    public virtual PrefixAmbiguity(ruleSymbol : ExtensibleRuleSymbol) : PExpr
    {
      def message = $"Ambiguity between prefix rules of '$(ruleSymbol.FullName)'.";
      <[
        _ = parseResult;
        _ = endPos;
        throw Nitra.Runtime.PrefixAmbiguityException($message, __startPos, ParseResult, ambiguities);
      ]>
    }

    public virtual PostfixAmbiguity(ruleSymbol : ExtensibleRuleSymbol) : PExpr
    {
      def message = $"Ambiguity between postfix rules of '$(ruleSymbol.FullName)'.";
      <[
        _ = parseResult;
        _ = endPos;
        throw Nitra.Runtime.PostfixAmbiguityException($message, __startPos, ParseResult, ambiguities);
      ]>
    }

    public virtual PrefixMissed(ruleSymbol : ExtensibleRuleSymbol) : PExpr
    {
      def message = $"Expected '$(ruleSymbol.FullName)' rule.";
      <[
        _ = parseResult;
        throw Nitra.Runtime.PrefixMissedException($message, pos, ParseResult);
      ]>
    }

    public virtual SimpleMissed(ruleSymbol : SimpleRuleSymbol) : PExpr
    {
      def message = $"Expected '$(ruleSymbol.FullName)' rule.";
      <[
        _ = parseResult;
        throw Nitra.Runtime.SimpleMissedException($message, pos);
      ]>
    }

    public Init(constantEmitter : IConstantEmitter) : void
    {
      ConstantEmitter = constantEmitter;
      _calledWalkers.Clear();
    }

    private GetFieldNameForWalkerCall(ruleSymbol : SyntaxRuleSymbol, bp : int) : string
    {
      def key = (ruleSymbol, bp);
      mutable value;

      if (_calledWalkers.TryGetValue(key, out value))
        value
      else
      {
        def name = $"_walker_$(_calledWalkers.Count)_$(ruleSymbol.Name)";
        _calledWalkers.Add(key, name);
        name
      }
    }

    protected GetSpanOf(subrule : SubruleCompileInfo, parentAstPointer : AstPointerScope) : PExpr
    {
      def size = parentAstPointer.Access().GetSize(subrule);
      <[ Nitra.NSpan(pos, pos + $size) ]>
    }

    public CallSimpleRule(subrule : SubruleCompileInfo.SimpleCall, parentAstPointer : AstPointerScope, params args : array[PExpr]) : PExpr
    {
      def walkCode = <[
        pos += $(parentAstPointer.Access().GetSkip(subrule));
        this.$(GetFieldNameForWalkerCall(subrule.Symbol, 0) : usesite).Walk(ref pos, parseResult, ..$args);
      ]>;
      if (subrule.CanParseEmptyString)
        walkCode
      else
        <[
          if ($(parentAstPointer.Access().GetSize(subrule)) > 0)
            $walkCode
          else
          {
            pos += $(parentAstPointer.Access().GetSkip(subrule));
            this.$(GetFieldNameForWalkerCall(subrule.Symbol, 0) : usesite).OnSimpleMissed(pos, parseResult, ..$args);
          }
        ]>
    }

    public CallExtensibleRule(subrule : SubruleCompileInfo.ExtensibleCall, parentAstPointer : AstPointerScope, params args : array[PExpr]) : PExpr
    {
      <[
        pos += $(parentAstPointer.Access().GetSkip(subrule));
        if ($(parentAstPointer.Access().GetSize(subrule)) > 0)
          this.$(GetFieldNameForWalkerCall(subrule.Symbol, subrule.BindingPower) : usesite).Walk(ref pos, parseResult, ..$args);
        else
          this.$(GetFieldNameForWalkerCall(subrule.Symbol, subrule.BindingPower) : usesite).OnPrefixMissed(pos, parseResult, ..$args);
      ]>
    }

    public GetCalledWalkers() : IEnumerable[SyntaxRuleSymbol * int * string]
    {
      _calledWalkers.Select(pair => (pair.Key[0], pair.Key[1], pair.Value))
    }

    public WalkerCodeForSimpleRule(ruleSymbol : SimpleRuleSymbol) : PExpr
    {
      def pointerAllocator = AstPointerScope(ruleSymbol.Sequence, "astPtr", ConstantEmitter);
      def code             = GetSyntaxRuleValue(ruleSymbol, pointerAllocator);
      def astMissingCode   = SimpleMissed(ruleSymbol);
      pointerAllocator.Compile(astMissingCode, code).FlattenPExpr();
    }

    public WalkerCodeForExtensionRule(ruleSymbol : ExtensionRuleSymbol) : PExpr
    {
      def astPointer = AstPointer.Existing(ruleSymbol.Sequence, ConstantEmitter, "astPtr");
      <[
        _ = astPtr;
        $(GetSyntaxRuleValue(ruleSymbol, AstPointerScope(astPointer)));
      ]>.FlattenPExpr()
    }

    protected Skip(subrule : SubruleCompileInfo, parentAstPointer : AstPointerScope) : PExpr
    {
      <[ pos += $(parentAstPointer.Access().GetSize(subrule)); ]>
    }

    public GetSequenceValue(sequence : SequenceCompileInfo, name : string) : PExpr
    {
      def astPointer = AstPointerScope(sequence, name, ConstantEmitter);

      def statements = List();
      def arguments = List();

      when (sequence is SequenceCompileInfo.Ast(Symbol = ExtensionRuleSymbol(ExtensionType = Postfix)))
        arguments.Add(<[ prefix ]>);

      statements.Add(<[ def __listStartPos = pos; ]>);

      foreach (subrule in sequence.Subrules)
      {
        | SubruleCompileInfo.Marker => ()
        | SubruleCompileInfo.Empty
        | SubruleCompileInfo.SimpleCall(symbol)        when !SupportsVoidRules && symbol.Type is RuleType.Void
        | SubruleCompileInfo.ExtensibleCall(symbol, _) when !SupportsVoidRules && symbol.Type is RuleType.Void => statements.Add(Skip(subrule, astPointer));
        | _  =>
          def varName = subrule.MakeVariableName("ast");
          statements.Add(<[ def $(varName : usesite) = $(GetSubruleValue(subrule, astPointer)) ]>);
          arguments.Add(<[ $(varName : usesite) ]>);
      }

      statements.Add(CombineValues(sequence, arguments.ToNList()));

      astPointer.Compile(<[ { ..$statements } ]>)
    }

    public GetTokenValue(subrule : SubruleCompileInfo, parentAstPointer : AstPointerScope, code : PExpr) : PExpr
    {
      <[
        def (skip, size) = $(parentAstPointer.Access().GetSkipAndSize(subrule));
        pos += skip;
        def tokenPos = pos;
        pos += size;
        $code;
      ]>
    }

    public GetOptionValue
      ( subrule            : SubruleCompileInfo.Option
      , parentAstPointer : AstPointerScope
      , hasValue         : PExpr
      , noValue          : PExpr
      ) : PExpr
    {
      <[
        if ($(parentAstPointer.Access().GetSize(subrule)) > 0)
          $hasValue;
        else
          $noValue;
      ]>
    }

    public GetListValue
      ( subrule            : SubruleCompileInfo.List
      , parentAstPointer : AstPointerScope
      , init             : PExpr
      , item             : PExpr
      , returnCode       : PExpr
      , emptyCode        : PExpr
      ) : PExpr
    {
      assert3(!subrule.IsSkipAnyPattern);

      def loopCode = <[
        def loop()
        {
          $item;
          if (pos < listEnd)
            loop();
          else
            assert(pos == listEnd);
        }
      ]>;
      GetListValueImpl
        (subrule             = subrule
        , parentAstPointer = parentAstPointer
        , init             = init
        , loopCode         = loopCode
        , returnCode       = returnCode
        , emptyCode        = emptyCode)
    }

    public GetListWithSeparatorValue
      ( subrule            : SubruleCompileInfo.ListWithSeparator
      , parentAstPointer : AstPointerScope
      , init             : PExpr
      , item             : PExpr
      , separator        : PExpr
      , returnCode       : PExpr
      , emptyCode        : PExpr
      ) : PExpr
    {
      def continueLoop =
        if (subrule.HangingSeparator)
          <[
            if (pos < listEnd)
              loop();
            else
              assert(pos == listEnd);
          ]>
        else
          <[ loop(); ]>;
      def loopCode = <[
        def loop()
        {
          $item;
          if (pos < listEnd)
          {
            $separator;
            $continueLoop;
          }
          else
            assert(pos == listEnd);
        }
      ]>;
      GetListValueImpl
        (subrule             = subrule
        , parentAstPointer = parentAstPointer
        , init             = init
        , loopCode         = loopCode
        , returnCode       = returnCode
        , emptyCode        = emptyCode)
    }

    private GetListValueImpl
      (subrule             : SubruleCompileInfo
      , parentAstPointer : AstPointerScope
      , init             : PExpr
      , loopCode         : PExpr
      , returnCode       : PExpr
      , emptyCode        : PExpr
      ) : PExpr
    {
      def nonemptyCode = List();
      if (init is <[ { ..$exprs } ]>)
        nonemptyCode.AddRange(exprs);
      else
        nonemptyCode.Add(init);
      nonemptyCode.Add(loopCode);
      nonemptyCode.Add(<[ loop() ]>);
      nonemptyCode.Add(returnCode);
      <[
        def listEnd = pos + $(parentAstPointer.Access().GetSize(subrule));
        if (listEnd > pos) { ..$nonemptyCode }
        else $emptyCode
      ]>
    }
  }
}
