using Nitra.Model;
using Nitra.Typing;

using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;

using System;
using SCG = System.Collections.Generic;

namespace Nitra.Compiler
{
  public sealed class NTypeCompiler
  {
    public this(environment : EmitterEnvironment)
    {
      Environment = environment;
    }

    public Environment : EmitterEnvironment;

    [Memoize]
    public CompileParentType(symbol : DeclarationSymbol) : FixedType
    {
      def expr = Compile(symbol.ParentType);
      Environment.Manager.CoreEnv.BindFixedType(expr)
    }

    [Memoize]
    public CompileSimplePropertyType(propertySymbol : SimpleDeclarationPropertySymbol) : FixedType
    {
      def expr   = Compile(propertySymbol.Type);
      def result = Environment.Manager.CoreEnv.BindFixedType(expr);
      unless (result.IsPrimitive || result.TryRequire(Environment.DeclarationNodeTypeVar) || result.TryRequire(Environment.NSpanTypeVar) || result.TryRequire(Environment.ReferenceTypeVar))
        Environment.Project.Error(propertySymbol.Type.Location, $"Type '$result' is not supported in Declaration. Use primitive types, subtype of '$(Environment.DeclarationNodeTypeVar)', '$(Environment.ReferenceTypeVar)' or '$(Environment.NSpanTypeVar)'.");
      result
    }

    [Memoize]
    public CompileDependentPropertyType(propertySymbol : DependentDeclarationPropertySymbol) : FixedType
    {
      def expr = Compile(propertySymbol.Type);
      Environment.Manager.CoreEnv.BindFixedType(expr)
    }

    private Compile(t : NType) : PExpr
    {
      Util.locate(t.Location.ToNemerleLocation(),
        match (t)
        {
          | Predefined(t)    => Environment.MakeNemerleType(t)
          | Qualified(parts) =>
            def makeName(part : TypeNamePart) : Name
            {
              Name(part.Name, part.NemerleEnv.Manager.MacroColors.Color, part.NemerleEnv)
            }

            if (parts is first :: other)
            {
              mutable acc = Util.locate(first.Location.ToNemerleLocation(),
              {
                def head = <[ $(makeName(first) : name) ]>;
                if (first.TypeArguments.IsEmpty())
                  head
                else
                  <[ $head[..$(first.TypeArguments.Map(Compile))]]>;
              });
              foreach (t in other)
              {
                Util.locate(t.Location.ToNemerleLocation(),
                {
                  acc = <[ $acc . $(makeName(t) : name) ]>;
                  unless (t.TypeArguments.IsEmpty())
                    acc = <[ $acc[..$(t.TypeArguments.Map(Compile))]]>;
                });
              }
              acc
            }
            else assert3(false)

          | Tuple(members)   => <[ Nitra.Declarations.DeclarationSequence[..$(members.Map(Compile))] ]>
          | Func(from, to)   => <[ $(Compile(from)) -> $(Compile(to)) ]>
          | OptionList(item)
          | List(item)       => <[ $(Compile(item)).ListProxy ]>
          | Option(item)     => <[ Nitra.Declarations.DeclarationOption[$(Compile(item))] ]>
        })
    }

    public TryGetDeclarationSymbol(t : NType) : DeclarationSymbol
    {
      def expr      = Compile(t);
      def fixedType = Environment.Manager.CoreEnv.BindFixedType(expr);
      if (fixedType.TypeInfo != null)
      {
        def symbolPath = NString.SplitToList(fixedType.TypeInfo.FullName, array['.']);
        match (Environment.Root.BindMany.[DeclarationSymbol](symbolPath))
        {
          | [one] => one
          | _     => null
        }
      }
      else null
    }

    public GetListProxy(symbol : DeclarationSymbol) : FixedType
    {
      def name = "_N_<ListProxy>" + symbol.FullName.Replace('.', '_');
      def env  = Environment.Manager.CoreEnv.EnterIntoNamespace(["Nitra", "Declarations", "Internal"]);
      if (env.LookupType([name]) is Some(t))
        FixedType.Class(t, [])
      else
      {
        def declarationType = Environment.GetDeclarationType(symbol);
        def tb = env.Define(<[ decl:
          internal sealed class $(name : usesite) : Nitra.Declarations.DeclarationList[$(declarationType : typed)], $(declarationType : typed).ListProxy
          {
            public this(parent : $(Environment.DeclarationTypeVar : typed), span : $(Environment.NSpanTypeVar : typed), items : array[$(declarationType : typed)])
            {
              base(parent, span, items)
            }
          }
        ]>);


//        def result0 = SCG.List();
//        def result1 = SCG.List();

        def bitFieldManager = tb.GetBitFieldManager();
        foreach (propertySymbol is DependentDeclarationPropertySymbol in symbol.AllProperties with index)
        {
          def propertyType     = CompileDependentPropertyType(propertySymbol);
          def bit              = bitFieldManager.Allocate();
          assert(bit.Index == index);
          def backingFieldName = Util.tmpname(propertySymbol.Name);
          tb.Define(<[ decl:
            [RecordIgnore] private mutable $(backingFieldName : usesite) : $(propertyType : typed)
          ]>);

          def assertMessage = $"Property '$(propertySymbol.Name)' is not set";
          def setterMods    = DeclarationEmitter.GetDependentPropertySetterMods(propertySymbol);
          tb.Define(<[ decl:
            [$(DeclarationEmitter.MakeDependentPropertyAttribute(propertySymbol, index))]
            public $(propertySymbol.Name : usesite) : $(propertyType : typed)
            {
              get
              {
                unless($(bit.Read()))
                  assert3(false, $assertMessage);
                this.$(backingFieldName : usesite)
              }
              ..$setterMods
              set
              {
                unless ($(bit.Read()))
                {
                  this.$(backingFieldName : usesite) = value;
                  $(bit.Set());
                }
              }
            }
          ]>);

          def isEvaluatedName = DeclarationEmitter.GetIsEvaluatedPropertyName(propertySymbol);
          tb.Define(<[ decl:
            $(isEvaluatedName : usesite) : bool implements $(declarationType : typed).ListProxy.$(isEvaluatedName : usesite) { get { $(bit.Read()) } }
          ]>);

//          when (propertySymbol.Direction == DependentPropertyDirection.Out && propertySymbol.LinkedProperty.HasValue)
//          {
//            def input  = propertySymbol.LinkedProperty.Value;
//            def output = propertySymbol;
//            result0.Add(<[ when (hasValue($(input.Name : usesite)) && !hasValue($(output.Name : usesite))) this.$(output.Name : usesite) = this.$(input.Name : usesite); ]>);
//          }
//
//          when (propertySymbol.Direction == DependentPropertyDirection.In)
//          {
//            result1.Add(<[ when (input.HasValue && !_items[0].input.HasValue)  _items input; ]>);
//          }
        }

        DeclarationEmitter.DefineIsPropertyEvaluatedMethod(tb, 0);

        tb.Define(<[ decl:
          public override EvalProperties(context : Nitra.Declarations.EvalDeclarationPropertiesContext) : void
          {
            match (_items.Length)
            {
              | 0 => ()
              | 1 =>
                _items[0].EvalProperties(context);

              | _ =>
                foreach (item in _items)
                {
                  item.EvalProperties(context);
                }
            }
          }
        ]>);

        _types.Add(tb);
        FixedType.Class(tb, [])
      }
    }

    private _types : SCG.List[TypeBuilder] = SCG.List();

    public EmitTypes() : void
    {
      foreach (t in _types)
        t.Compile();
    }
  }
}
