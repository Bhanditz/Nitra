using Nitra.Model;
using Nitra.Typing;

using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;

using System;
using SCG = System.Collections.Generic;

namespace Nitra.Compiler
{
  public sealed class NTypeCompiler
  {
    public this(environment : EmitterEnvironment)
    {
      Environment = environment;
    }

    public Environment : EmitterEnvironment;

    [Memoize]
    public CompileParentType(symbol : AstSymbol) : FixedType
    {
      def parentType =
        match (symbol.ParentProperty)
        {
          | SymbolRef.Some(p)   => p.Type
          | SymbolRef.None as x => Utils.GetDefaultAstParentType(x.Location)
        };
      def expr = Compile(parentType);
      Environment.Manager.CoreEnv.BindFixedType(expr)
    }

    [Memoize]
    public CompileProjectedPropertyType(propertySymbol : ProjectedAstPropertySymbol) : FixedType
    {
      def expr   = Compile(propertySymbol.Type);
      def result = Environment.Manager.CoreEnv.BindFixedType(expr);
      result
    }

    [Memoize]
    public CompileSimplePropertyType(propertySymbol : SimpleAstPropertySymbol) : FixedType
    {
      def isParsedValueType(t : FixedType) : bool
      {
        | Class(x, [_]) => x.Equals(Environment.ParsedValueTypeInfo)
        | _ => false
      }

      def expr   = Compile(propertySymbol.Type);
      def result = Environment.Manager.CoreEnv.BindFixedType(expr);
      if (isParsedValueType(result) || result.TryRequire(Environment.AstTypeVar) || result.TryRequire(Environment.NSpanTypeVar))
        result
      else
        FixedType.Class(Environment.ParsedValueTypeInfo, [result])
    }

    [Memoize]
    public CompileNamePropertyType(propertySymbol : NameAstPropertySymbol) : FixedType
    {
      def expr   = Compile(propertySymbol.Type);
      def result = Environment.Manager.CoreEnv.BindFixedType(expr);
      // TODO: add check
      result
    }

    [Memoize]
    public CompileDependentPropertyType(propertySymbol : DependentAstPropertySymbol) : FixedType
    {
      def expr = Compile(propertySymbol.Type);
      Environment.Manager.CoreEnv.BindFixedType(expr)
    }

    private Compile(t : NType) : PExpr
    {
      Util.locate(t.Location.NLocation(),
        match (t)
        {
          | Predefined(t)    => Environment.MakeNemerleType(t)
          | Qualified(parts) =>
            def makeName(part : TypeNamePart) : Name
            {
              Name(part.Name, part.NemerleEnv.Manager.MacroColors.Color, part.NemerleEnv)
            }

            if (parts is first :: other)
            {
              mutable acc = Util.locate(first.Location.NLocation(),
              {
                def head = <[ $(makeName(first) : name) ]>;
                if (first.TypeArguments.IsEmpty())
                  head
                else
                  <[ $head[..$(first.TypeArguments.Map(Compile))]]>;
              });
              foreach (t in other)
              {
                Util.locate(t.Location.NLocation(),
                {
                  acc = <[ $acc . $(makeName(t) : name) ]>;
                  unless (t.TypeArguments.IsEmpty())
                    acc = <[ $acc[..$(t.TypeArguments.Map(Compile))]]>;
                });
              }
              acc
            }
            else assert3(false)

          | Tuple(members)   => PExpr.Tuple(members.Map(Compile))
          | Func(from, to)   => <[ $(Compile(from)) -> $(Compile(to)) ]>
          | OptionList(item)
          | List(item)       => <[ $(Compile(item)).IAstList ]>
          | Option(item)     => <[ $(Compile(item)).IAstOption ]>
        })
    }

    public TryGetAstSymbol(t : NType) : AstSymbol
    {
      def expr      = Compile(t);
      def fixedType = Environment.Manager.CoreEnv.BindFixedType(expr);
      if (fixedType.TypeInfo != null)
      {
        def symbolPath = NString.SplitToList(fixedType.TypeInfo.FullName, array['.']);
        match (Environment.Root.BindMany.[AstSymbol](symbolPath))
        {
          | [one] => one
          | _     => null
        }
      }
      else null
    }
  }
}
