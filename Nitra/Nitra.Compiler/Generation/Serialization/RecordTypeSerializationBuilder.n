using Nemerle;
using Nemerle.Collections;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Compiler.Typedtree;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Reflection;
using System.Text.RegularExpressions;
using System.Linq;
using SCG = System.Collections.Generic;

namespace Nitra.Serialization
{
  [Record]
  public class RecordTypeSerializationBuilder : ComplexTypeSerializationBuilder
  {
    public override Tag : TypeTag { get { TypeTag.Object } }

    [RecordIgnore] private mutable _members : list[string * string * TypeSerializationBuilder];
    
    protected override CollectTypeData() : void
    {
      assert(_members : object == null);

      def typeInfo  = Type.TypeInfo;
      def members   = typeInfo.GetMembers(BindingFlags.Public | BindingFlags.Instance).Filter(m => m is IField || m is IProperty);
      def memberMap = members.ToDictionary(m => m.Name);
      def ctors     = typeInfo.GetConstructors(BindingFlags.Public | BindingFlags.Instance);

      mutable result;

      foreach (ctor in ctors)
        when (ctor.IsCustomAttributeDefined("Nemerle.Internal.RecordCtorAttribute"))
          when (result == null || ctor.Header.Parameters.Length > result.Header.Parameters.Length)
            result = ctor;

      def makeMember(p : TParameter) : string * string * TypeSerializationBuilder
      {
        match (p.AttributesAndModifiers.FindAttribute(Compiler.MappedMemberAttribute, Compiler.Manager.CoreEnv))
        {
          | Some(<[ $_($(name : string)) ]>) =>
            def member               = memberMap[name];
            def memberType           = Type.TypeOfMember(member).Fix();
            def serializationBuilder = Compiler.EnqueueType(memberType);
            (member.Name, GetMemberName(member), serializationBuilder)

          | _ => assert3(false)
        }
      }

      if (result == null)
        _members = []
      else
        _members = result.Header.Parameters.Map(makeMember)
    }

    protected override GenerateWriteBody(body : SCG.List[PExpr]) : void
    {
      assert(_members : object != null);

      foreach ((originalName, normalizedName, serializationBuilder) in _members)
      {
        body.Add(Formatter.WriteTag(serializationBuilder.Tag));
        body.Add(Formatter.WriteString(normalizedName));
        body.Add(serializationBuilder.Write(<[ obj.$(originalName : usesite) ]>));
      }
      body.Add(Formatter.WriteEnd());
    }

    protected override GenerateReadBody(body : SCG.List[PExpr]) : void
    {
      assert(_members : object != null);

      def ctorArgs       = SCG.List();
      def fieldNameCases = SCG.List();
      foreach ((originalName, normalizedName, serializationBuilder) in _members)
      {
        def varName = "____" + originalName;
        body.Add(<[ mutable $(varName : usesite) : $(serializationBuilder.Type : typed) ]>);
        ctorArgs.Add(<[ $(varName : usesite) ]>);
        fieldNameCases.Add(<[ case: | $(normalizedName : string) => $(varName : usesite) = $(serializationBuilder.Read(<[ fieldName ]>, <[ typeTag ]>)) ]>)
      }
      def unknownFieldCase = Formatter.EmitFatalError(<[ "Unknown member '" + fieldName + "'." ]>);
      if (fieldNameCases.Count > 0)
      {
        fieldNameCases.Add(<[ case: | _ => $unknownFieldCase ]>);

        body.Add(<[
          def loop()
          {
            def typeTag = $(Formatter.ReadTag());
            when (typeTag != Nitra.Serialization.TypeTag.Empty)
            {
              def fieldName = $(Formatter.ReadString());
              match (fieldName)
              {
                ..$fieldNameCases
              }
              loop()
            }
          }
        ]>);
        body.Add(<[ loop() ]>);
      }
      else
      {
        body.Add(<[
          def typeTag = $(Formatter.ReadTag());
          when (typeTag != Nitra.Serialization.TypeTag.Empty)
          {
            def fieldName = $(Formatter.ReadString());
            $unknownFieldCase;
          }
        ]>);
      }
      body.Add(<[ $(Type : typed)(..$ctorArgs) ]>);
    }

    private static _extractNameRx : Regex = Regex(@"_N_((\w|\d|_)+)_\d+", RegexOptions.Compiled);

    private static GetMemberName(member : IMember) : string
    {
      def res = _extractNameRx.Match(member.Name);

      if (res.Success)
        res.Groups[1].Value
      else
        member.Name
    }
  }
}
