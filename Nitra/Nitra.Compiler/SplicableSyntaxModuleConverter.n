using Nitra.Model;
using Nitra.ProjectSystem;
using Nitra.Typing;
using Nitra.Runtime;
using Nitra.Util;

using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using SCG = System.Collections.Generic;
using System.Linq;

namespace Nitra.Compiler
{
  public sealed class SplicableSyntaxModuleConverter
  {
    _rewriteOperations : SCG.Queue[RuleDefSymbol * Rule.Sequence] = SCG.Queue();
    _ruleMapTable      : SCG.Dictionary[RuleDefSymbol, RuleDefSymbol]                  = SCG.Dictionary();

    public CreateSymbols(syntaxModule : ParsedSyntaxModuleSymbol) : void
    {
      def splicableSyntaxModule = ChemicalSyntaxModuleSymbol(syntaxModule.FirstLocation, syntaxModule.Name)
        .SetExternalImports([])
        .SetTokenLiterals([]);
      _ = syntaxModule.Node.Parent.AddAndReport(["Splicable"], splicableSyntaxModule, splicableSyntaxModule.FirstLocation);

      def enumerateRules(sourceNode, targetNode, declarationSite : IRuleDeclarationSite)
      {
        foreach (symbol in sourceNode.GetChildren.[Symbol]())
        {
          match (symbol)
          {
            | ExtensibleRuleSymbol(IsToken = false) as ruleSymbol =>
              def splicableRuleSymbol = ChemicalBaseExtensibleRuleSymbol(ruleSymbol.FirstLocation, ruleSymbol.Name)
                .SetDeclarationSite(declarationSite)
                .SetOptions(RuleDefinitionOptions.Empty);

              _ = targetNode.AddAndReport(splicableRuleSymbol, splicableRuleSymbol.FirstLocation);
              _ruleMapTable.Add(ruleSymbol, splicableRuleSymbol);
              enumerateRules(ruleSymbol.Node, splicableRuleSymbol.Node, splicableRuleSymbol);

            | SimpleRuleSymbol(IsToken = false) as ruleSymbol when !(ruleSymbol.Type is RuleType.Void) =>
              def splicableRuleSymbol = ChemicalBaseSimpleRuleSymbol(ruleSymbol.FirstLocation, ruleSymbol.Name);
              _ = splicableRuleSymbol
                .SetDeclarationSite(declarationSite)
                .SetOptions(RuleDefinitionOptions.Empty)
                .SetKind(SimpleRuleKind.Normal)
                .SetType(RuleType.Ref(splicableRuleSymbol));

              _ = targetNode.AddAndReport(splicableRuleSymbol, splicableRuleSymbol.FirstLocation);
              _ruleMapTable.Add(ruleSymbol, splicableRuleSymbol);
              _rewriteOperations.Enqueue(splicableRuleSymbol, ruleSymbol.Rule);
              enumerateRules(ruleSymbol.Node, splicableRuleSymbol.Node, splicableRuleSymbol);

            | ExtensionRuleSymbol(IsToken = false) as ruleSymbol =>
              ()

            | _ => ()
          }
        }
      }
      enumerateRules(syntaxModule.Node, splicableSyntaxModule.Node, splicableSyntaxModule)
    }

    public ConvertRules() : void
    {
      while (_rewriteOperations.Count > 0)
      {
        def (ruleSymbol, seq) = _rewriteOperations.Dequeue();
        def newSeq = RewriteSequence(ruleSymbol, seq);
        match (ruleSymbol)
        {
          | ChemicalBaseSimpleRuleSymbol as s => _ = s.SetRule(newSeq);
          | _ => assert(false)
        }
      }
    }

    private RewriteSequence(ruleSymbol : RuleDefSymbol, seq : Rule.Sequence) : Rule.Sequence
    {
      def rewrite(_ : Rule) : Rule
      {
        | RepeatWithSeparator(minCount, maxCount, item, separator, hangingSeparator) as rule => Rule.RepeatWithSeparator(rule, minCount, maxCount, rewrite(item), rewrite(separator), hangingSeparator)
        | Repeat(minCount, maxCount, item)     as rule => Rule.Repeat(rule, minCount, maxCount, rewrite(item))
        | Sequence(rules)                      as rule => Rule.Sequence(rule, rules.Map(rewrite))
        | String                               as rule => rule
        | Not(item)                            as rule => Rule.Not(rule, rewrite(item))
        | And(item)                            as rule => Rule.And(rule, rewrite(item))
        | Call(SymbolRef.Some(RuleDefSymbol as ruleSymbol), bp) as rule =>
          mutable splicableRuleSymbol;
          if (_ruleMapTable.TryGetValue(ruleSymbol, out splicableRuleSymbol))
            Rule.Call(Location.Default, splicableRuleSymbol.Type, "", SymbolRef.Some(Location.Default, true, splicableRuleSymbol), bp)
          else
            rule

        | Call                               as rule => rule
      }

      def newRules = SCG.List();

      foreach (rule in seq.Rules)
      {
        if (rule.Type is RuleType.Void
            || rule.Type is RuleType.Chars
            || rule.Type is RuleType.Ref(RuleDefSymbol(IsToken = true)))
          newRules.Add(rule)
        else
        {
          def fieldName = rule.FieldName;
          def syntaxModule = ruleSymbol.DeclaringModule;

          def rootSymbol = ChemicalBaseExtensibleRuleSymbol(Location.Default, Nemerle.Compiler.Util.tmpname(fieldName))
            .SetDeclarationSite(syntaxModule)
            .SetOptions(RuleDefinitionOptions.Empty);
          _ = syntaxModule.Node.AddAndReport(rootSymbol, rootSymbol.FirstLocation);

          def spliceSeqRules = [
            Rule.String(Location.Default, "", "$" + fieldName, null, true),
            //Rule.Call(S),
            Rule.String(Location.Default, "", "("),
            //Rule.Call(s),
            //Rule.Call(expr),
            Rule.String(Location.Default, "", ")"),
            //Rule.Call(s),
          ];
          def spliceRule = Rule.Sequence(Location.Default, Utils.EvaluateSequenceRuleType(spliceSeqRules), "", spliceSeqRules);
          def spliceRuleSymbol = ChemicalBaseExtensionRuleSymbol(Location.Default, "Splice")
            .SetDeclarationSite(rootSymbol)
            .SetBaseRule(SymbolRef.Some(Location.Default, true, rootSymbol))
            .SetOptions(RuleDefinitionOptions.Empty)
            .SetRule(spliceRule);
          _ = rootSymbol.Node.AddAndReport(spliceRuleSymbol, spliceRuleSymbol.FirstLocation);

          def rewrittenRule = rewrite(rule);
          def quoteRule =
            if (rewrittenRule is Rule.Sequence as r)
              r
            else
              Rule.Sequence(Location.Default, Utils.EvaluateSequenceRuleType([rewrittenRule.Type]), "", [rewrittenRule]);
          def quoteRuleSymbol = ChemicalBaseExtensionRuleSymbol(Location.Default, "Quote")
            .SetDeclarationSite(rootSymbol)
            .SetBaseRule(SymbolRef.Some(Location.Default, true, rootSymbol))
            .SetOptions(RuleDefinitionOptions.Empty)
            .SetRule(quoteRule);
          _ = rootSymbol.Node.AddAndReport(quoteRuleSymbol, quoteRuleSymbol.FirstLocation);
        }
      }

      Rule.Sequence(seq.Location, Utils.EvaluateSequenceRuleType(newRules), "", newRules.ToNList())
    }
  }
}
