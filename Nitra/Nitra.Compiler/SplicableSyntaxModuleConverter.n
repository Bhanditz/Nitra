using Nitra.Model;
using Nitra.ProjectSystem;
using Nitra.Typing;
using Nitra.Runtime;
using Nitra.Util;

using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using SCG = System.Collections.Generic;
using System.Linq;

namespace Nitra.Compiler
{
  public module SplicableSyntaxModuleConverter
  {
    public Convert(syntaxModule : ParsedSyntaxModuleSymbol) : void
    {
      def splicableSyntaxModule = ChemicalSyntaxModuleSymbol(syntaxModule.FirstLocation, syntaxModule.Name)
        .SetExternalImports([])
        .SetTokenLiterals([]);
      _ = syntaxModule.Node.Parent.AddAndReport(["Splicable"], splicableSyntaxModule, splicableSyntaxModule.FirstLocation);

      def pairs = SCG.List();

      def enumerateRules(sourceNode, targetNode, declarationSite : IRuleDeclarationSite)
      {
        foreach (symbol in sourceNode.GetChildren.[Symbol]())
        {
          match (symbol)
          {
            | ExtensibleRuleSymbol(IsToken = false) as ruleSymbol =>
              def splicableRuleSymbol = ChemicalExtensibleRuleSymbol(ruleSymbol.FirstLocation, ruleSymbol.Name)
                .SetDeclarationSite(declarationSite)
                .SetIdInGrammar(splicableSyntaxModule.GetNewRuleId())
                .SetOptions(RuleDefinitionOptions.Empty)
                .SetCanParseEmptyString(ruleSymbol.CanParseEmptyString)
                .SetFirstCharLowerBound(char.MinValue)
                .SetFirstCharUpperBound(char.MaxValue);
              _ = targetNode.AddAndReport(splicableRuleSymbol, splicableRuleSymbol.FirstLocation);

              pairs.Add(ruleSymbol, splicableRuleSymbol);

              enumerateRules(ruleSymbol.Node, splicableRuleSymbol.Node, splicableRuleSymbol);

            | _ => ()
          }
        }
      }
      enumerateRules(syntaxModule.Node, splicableSyntaxModule.Node, splicableSyntaxModule)
    }
  }
}
