using Nitra.Model;
using Nitra.ProjectSystem;
using Nitra.Typing;
using Nitra.Runtime;
using Nitra.Util;

using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using SCG = System.Collections.Generic;
using System.Linq;

namespace Nitra.Compiler
{
  public sealed class SplicableSyntaxModuleConverter
  {
    _rewriteOperations : SCG.List[SyntaxRuleSymbol * SyntaxRuleSymbol]      = SCG.List();
    _ruleMapTable      : SCG.Dictionary[SyntaxRuleSymbol, SyntaxRuleSymbol] = SCG.Dictionary();

    public CreateSymbols(syntaxModule : ParsedSyntaxModuleSymbol) : void
    {
      def splicableSyntaxModule = ChemicalSyntaxModuleSymbol(syntaxModule.FirstLocation, syntaxModule.Name)
        .SetExternalImports([])
        .SetTokenLiterals([])
        .SetIsSplicable(true);

      match (syntaxModule.Node.Parent.GetSymbol.[NamespaceSymbol]())
      {
        | syntaxModuleNs :: _ =>
          def nsName = "Splicable";
          def ns = 
            match (syntaxModuleNs.Node.BindMany.[NamespaceSymbol](nsName))
            {
              | ns :: _ =>
                ns.AddDefinition(splicableSyntaxModule.FirstLocation);
                ns

              | [] =>
                def newNs = NamespaceSymbol(nsName);
                syntaxModuleNs.AddChild(newNs, splicableSyntaxModule.FirstLocation);
                newNs.AddDefinition(splicableSyntaxModule.FirstLocation);
                newNs
            };

          _ = ns.Node.AddAndReport(splicableSyntaxModule, splicableSyntaxModule.FirstLocation);

        | [] => assert3(false);
      }


      def enumerateRules(sourceNode, targetNode, declarationSite : IRuleDeclarationSite)
      {
        foreach (symbol in sourceNode.GetChildren.[Symbol]())
        {
          match (symbol)
          {
            | ExtensibleRuleSymbol as ruleSymbol =>
              mutable options = RuleDefinitionOptions.Empty;
              when (ruleSymbol.IsToken)
                options = options.SetTokenRule(true);

              def rewrittenRuleSymbol = ChemicalBaseExtensibleRuleSymbol(ruleSymbol.FirstLocation, ruleSymbol.Name)
                .SetDeclarationSite(declarationSite)
                .SetOptions(options)
                .SetIsSplicable(false);

              _ = targetNode.AddAndReport(rewrittenRuleSymbol, rewrittenRuleSymbol.FirstLocation);
              _ruleMapTable.Add(ruleSymbol, rewrittenRuleSymbol);
              enumerateRules(ruleSymbol.Node, rewrittenRuleSymbol.Node, rewrittenRuleSymbol);

            | SimpleRuleSymbol as ruleSymbol when !(ruleSymbol.Type is RuleType.Void) =>
              mutable options = RuleDefinitionOptions.Empty;
              when (ruleSymbol.IsToken)
                options = options.SetTokenRule(true);

              def rewrittenRuleSymbol = ChemicalBaseSimpleRuleSymbol(ruleSymbol.FirstLocation, ruleSymbol.Name);
              _ = rewrittenRuleSymbol
                .SetDeclarationSite(declarationSite)
                .SetOptions(options)
                .SetKind(SimpleRuleKind.Normal)
                .SetType(RuleType.Ref(rewrittenRuleSymbol));

              _ = targetNode.AddAndReport(rewrittenRuleSymbol, rewrittenRuleSymbol.FirstLocation);
              _ruleMapTable.Add(ruleSymbol, rewrittenRuleSymbol);
              _rewriteOperations.Add(ruleSymbol, rewrittenRuleSymbol);
              enumerateRules(ruleSymbol.Node, rewrittenRuleSymbol.Node, rewrittenRuleSymbol);

            | ExtensionRuleSymbol as ruleSymbol =>
              mutable options = RuleDefinitionOptions.Empty;
              when (ruleSymbol.IsToken)
                options = options.SetTokenRule(true);

              def rewrittenBaseRule = GetRewrittenRuleSymbol(ruleSymbol.BaseRule.Value);

              def rewrittenRuleSymbol = ChemicalBaseExtensionRuleSymbol(ruleSymbol.FirstLocation, ruleSymbol.Name)
                .SetDeclarationSite(declarationSite)
                .SetOptions(options)
                .SetBaseRule(SymbolRef.Some(Location.Default, true, rewrittenBaseRule));

              _ = targetNode.AddAndReport(rewrittenRuleSymbol, rewrittenRuleSymbol.FirstLocation);
              _rewriteOperations.Add(ruleSymbol, rewrittenRuleSymbol);
              enumerateRules(ruleSymbol.Node, rewrittenRuleSymbol.Node, rewrittenRuleSymbol);

            | ExtendSyntaxSymbol(Extend = SymbolRef.Some(extendingRuleSymbol)) as extendSymbol =>
              def rewrittenBaseRule = GetRewrittenRuleSymbol(extendingRuleSymbol);

              def rewrittenExtendSymbol = ChemicalExtendSyntaxSymbol(extendSymbol.FirstLocation, extendSymbol.Name)
                .SetDeclarationSite(declarationSite)
                .SetExtend(SymbolRef.Some(Location.Default, true, rewrittenBaseRule));

              _ = targetNode.AddAndReport(rewrittenExtendSymbol, rewrittenExtendSymbol.FirstLocation);
              enumerateRules(extendSymbol.Node, rewrittenExtendSymbol.Node, rewrittenExtendSymbol);

            | _ => ()
          }
        }
      }
      enumerateRules(syntaxModule.Node, splicableSyntaxModule.Node, splicableSyntaxModule)
    }

    public RewriteRules() : void
    {
      foreach ((sourceRuleSymbol, rewrittenRuleSymbol) in _rewriteOperations)
      {
        def newRules = sourceRuleSymbol.Rule.Rules.Map(rule =>
          match (rule.Type : RuleType)
          {
            | Void | Chars => rule
            | _ =>
              def ruleSymbol = MakeSplicableRuleSymbol(rewrittenRuleSymbol.DeclaringModule, rule, rewrittenRuleSymbol.IsToken);
              Rule.Call(Location.Default, ruleSymbol.Type, rule.FieldName, SymbolRef.Some(Location.Default, true, ruleSymbol), 0)
          });

        def newSeq = Rule.Sequence(Location.Default, Utils.EvaluateSequenceRuleType(newRules), "", newRules);

        match (rewrittenRuleSymbol)
        {
          | ChemicalBaseSimpleRuleSymbol    as s => _ = s.SetRule(newSeq);
          | ChemicalBaseExtensionRuleSymbol as s => _ = s.SetRule(newSeq);
          | _ => assert(false)
        }
      }
    }

    private GetRewrittenRuleSymbol[TSymbol](ruleSymbol : TSymbol) : TSymbol
      where TSymbol : SyntaxRuleSymbol
    {
      mutable rewrittenRuleSymbol;
      if (_ruleMapTable.TryGetValue(ruleSymbol, out rewrittenRuleSymbol))
        rewrittenRuleSymbol :> TSymbol
      else
      {
        def syntaxModule = ruleSymbol.DeclaringModule;
        if (syntaxModule.Node.Parent.BindMany.[TSymbol]("Splicable" :: syntaxModule.Name :: ruleSymbol.ModuleRelativeName) is [r])
          r
        else
          assert3(false, "cant find rewritten rule")
      }
    }

    [Memoize]
    private MakeSplicableRuleSymbol(syntaxModule : SyntaxModuleSymbol, rule : Rule, isToken : bool) : ExtensibleRuleSymbol
    {
      def rewrite(_ : Rule) : Rule
      {
        | RepeatWithSeparator(minCount, maxCount, item, separator, hangingSeparator) as rule => Rule.RepeatWithSeparator(rule, minCount, maxCount, rewrite(item), rewrite(separator), hangingSeparator)
        | Repeat(minCount, maxCount, item)     as rule => Rule.Repeat(rule, minCount, maxCount, rewrite(item))
        | Sequence(rules)                      as rule => Rule.Sequence(rule, rules.Map(rewrite))
        | String                               as rule => rule
        | Not(item)                            as rule => Rule.Not(rule, rewrite(item))
        | And(item)                            as rule => Rule.And(rule, rewrite(item))
        | Call(SymbolRef.Some(SimpleRuleSymbol as ruleSymbol), bp) when !(ruleSymbol.Type is RuleType.Void) =>
          def r = GetRewrittenRuleSymbol(ruleSymbol);
          Rule.Call(Location.Default, r.Type, "", SymbolRef.Some(Location.Default, true, r), bp)

        | Call(SymbolRef.Some(ExtensibleRuleSymbol as ruleSymbol), bp) =>
          def r = GetRewrittenRuleSymbol(ruleSymbol);
          Rule.Call(Location.Default, r.Type, "", SymbolRef.Some(Location.Default, true, r), bp)

        | Call                                 as rule => rule
      }

      mutable options = RuleDefinitionOptions.Empty;
      when (isToken)
        options = options.SetTokenRule(true);

      def rootSymbol = ChemicalBaseExtensibleRuleSymbol(Location.Default, Nemerle.Compiler.Util.tmpname(rule.FieldName))
        .SetDeclarationSite(syntaxModule)
        .SetOptions(options)
        .SetIsSplicable(true);
      _ = syntaxModule.Node.AddAndReport(rootSymbol, rootSymbol.FirstLocation);

      def spliceSeqRules = [
        Rule.String(Location.Default, "", "$" + rule.FieldName, null, true),
        //Rule.Call(S),
        Rule.String(Location.Default, "", "("),
        //Rule.Call(s),
        //Rule.Call(expr),
        Rule.String(Location.Default, "", ")"),
        //Rule.Call(s),
      ];
      def spliceRule = Rule.Sequence(Location.Default, Utils.EvaluateSequenceRuleType(spliceSeqRules), "", spliceSeqRules);
      def spliceRuleSymbol = ChemicalBaseExtensionRuleSymbol(Location.Default, "Splice")
        .SetDeclarationSite(rootSymbol)
        .SetBaseRule(SymbolRef.Some(Location.Default, true, rootSymbol))
        .SetOptions(options)
        .SetRule(spliceRule);
      _ = rootSymbol.Node.AddAndReport(spliceRuleSymbol, spliceRuleSymbol.FirstLocation);

      def rewrittenRule = rewrite(rule);
      def quoteRule =
        if (rewrittenRule is Rule.Sequence as r)
          r
        else
          Rule.Sequence(Location.Default, rewrittenRule.Type, "", [rewrittenRule]);
      def quoteRuleSymbol = ChemicalBaseExtensionRuleSymbol(Location.Default, "Quote")
        .SetDeclarationSite(rootSymbol)
        .SetBaseRule(SymbolRef.Some(Location.Default, true, rootSymbol))
        .SetOptions(options)
        .SetRule(quoteRule);
      _ = rootSymbol.Node.AddAndReport(quoteRuleSymbol, quoteRuleSymbol.FirstLocation);

      rootSymbol
    }
  }
}
