using Nitra;
using Nitra.Utils;
using Nitra.Model;
using Nitra.ProjectSystem;
using Nitra.Runtime;
using Nitra.Typing;
using Nitra.Typing.TypingUtils;

using Nemerle.Collections;
using Nemerle.Imperative;
using Nemerle.Compiler.Parsetree;

using System;
using System.Collections.Generic;
using System.Text;
using System.Linq;

syntax module NitraSyntax
{
  using Outline;
  using PrettyPrint;
  using TokenNames;
  using StandardSpanClasses;
  using Whitespaces;
  using Identifiers;
  using CStyleComments;

  literal Prefix              = "\\u";
  literal DodDot              = "..";
  literal Op                  = ".";
  literal Pipe                = "|";

  braces "(", ")";
  braces "{", "}";
  braces "[", "]";

  keyword regex IdentifierStartCharacter (IdentifierPartCharacters | '-')* rule S;

  alias Name            = Identifier;
  alias QualifiedName   = QualifiedIdentifier;
  alias NamespaceOrType = QualifiedIdentifier;
  alias Char            = Any;
  alias GrammarName     = QualifiedIdentifier;
  alias BaseName        = QualifiedIdentifier;

  regex PredefinedType = "void" | "int" | "string";

  regex Keyword = "as" | "syntax" | "declaration" | "declarations" | "ast" | "asts" | "extend" | "module"
                | "marker" | "map" | "token" | "field" | "span" | "alias" | "regex" | "literal" | "decompose"
                | "multiple" | "optional" | "abstract" | "in" | "out" | "inout" | "class"
                | "rule" | "precedence" | "using" | "namespace" | PredefinedType;

  extend token IgnoreToken
  {
    | [SpanClass(Comment)] SingleLineComment;
    | [SpanClass(Comment)] MultiLineComment;
  }

  regex HexDigit                  = ['0'..'9', 'a'..'f', 'A'..'F'];
  regex ReservedStringChar        = "\"" | "\\";
  regex ReservedCharChar          = "\'" | "\\";

  [SpanClass(String)]
  token StringLiteral                    = "\""  StringPart* "\""
  {
    Value() : string = FoldThrough(StringParts, StringBuilder(), _.Value(_)).ToString();
  }

  token StringPart
  {
    Value(sb : StringBuilder) : StringBuilder;

    | UnicodeEscapeSequence = "\\u" HexDigit HexDigit HexDigit HexDigit
      {
        override Value = sb.Append(HexToChar(this, HexDigit1.StartPos, HexDigit4.EndPos));
      }
    | EscapeSequence        = "\\"  Char
      {
        override Value = sb.Append(UnescapeChar(FirstChar(Char)));
      }
    | Simple                = Chars=(!ReservedStringChar !NewLine Any)+
      {
        override Value = sb.Append(this.GetText());
      }
  }

  [SpanClass(Char)]
  token CharLiteral                      = "\'"  CharPart "\'" { Value() : char = CharPart.Value(); }

  token CharPart
  {
    Value() : char;

    | Simple                = !ReservedCharChar Char
      {
        override Value = FirstChar(this.Char);
      }
    | UnicodeEscapeSequence = "\\u" HexDigit HexDigit HexDigit HexDigit
      {
        override Value = HexToChar(this, HexDigit1.StartPos, HexDigit4.EndPos);
      }
    | EscapeSequence        = "\\" Char
      {
        override Value = UnescapeChar(FirstChar(this.Char));
      }
  }

  regex Digits = ['0'..'9']+;

  [SpanClass(Number)]
  token Number = Digits { Value() : int = DecToInt(this, Digits.StartPos, Digits.EndPos); }

  token Identifier                       = !(Keyword !IdentifierPartCharacters) IdentifierBody
  {
    Value() : string = GetText(IdentifierBody);
    Identifier() : Nitra.Model.Identifier = Nitra.Model.Identifier(this, IdentifierBody);
    LocatedName() : LocatedName = LocatedName(this.Location);
  }

  [ExplicitSpaces]
  syntax QualifiedIdentifier              = Names=(Identifier; s "." s)+
  {
    Identifiers() : list[LocatedName] = Names.Item1.MapToList(_.LocatedName());
    Parts() : list[string] = Names.Item1.MapToList(_.Value());
    CalcLocation() : Nitra.Location
    {
      this.Location // At present QualifiedIdentifier have no 's' at the end of rule. This allows the use rule location.
    }
    CalcLocations() : list[Nitra.Location] = Names.Item1.MapToList(_.Location);
  }

  ///////////////////////////////////////////////////////////////////////////
  //

  [StartRule, ExplicitSpaces]
  syntax Start                = s NamespaceBody !Any
  {
    CollectGlobalSymbols(rootNs : NamespaceSymbol) : void = NamespaceBody.CollectGlobalSymbols(rootNs);
    [Cached] MakeContext(parent : Context) : Context = NamespaceBody.MakeContext(parent);
    CollectSyntaxMappings() : void = NamespaceBody.CollectSyntaxMappings();
    TypeSyntaxMappings() : void = NamespaceBody.TypeSyntaxMappings();
    TypeAst() : void = NamespaceBody.TypeAst();
    Typing() : void = NamespaceBody.Typing();
  }

  syntax Usings = outline_hiden outline_begin Using* outline_end_before
  {
    MakeContext(parent : Context) : Context = FoldThrough(Usings, parent, _.MakeContext(_));
  }

  syntax NamespaceBody = Usings NamespaceMember*
  {
    CollectGlobalSymbols(rootNs : NamespaceSymbol) : void = foreach (topDecl in NamespaceMembers) topDecl.CollectGlobalSymbols(rootNs);
    [Cached] MakeContext(parent : Context) : Context
    {
      def context1 = Usings.MakeContext(parent);
      def context2 = PassThrough(NamespaceMembers, context1, _.MakeContext(_));
      context2
    }
    CollectSyntaxMappings() : void = foreach (topDecl in NamespaceMembers) topDecl.CollectSyntaxMappings();
    TypeSyntaxMappings() : void = foreach (topDecl in NamespaceMembers) topDecl.TypeSyntaxMappings();
    TypeAst() : void = foreach (topDecl in NamespaceMembers) topDecl.TypeAst();
    Typing() : void = foreach (topDecl in NamespaceMembers) topDecl.Typing();
  }

  syntax Using
  {
    [Cached] MakeContext(parent : Context) : Context;

    | UsingOpen  = "using" sm NamespaceOrType ";" nl
      {
        override MakeContext = OpenNamespaceOrTypeContext(parent, NamespaceOrType);
      }
    | UsingAlias = "using" Name sm "=" sm NamespaceOrType ";" nl
      {
        override MakeContext = NamespaceOrTypeAliasContext(parent, Name, NamespaceOrType);
      }
  }

  syntax NitraTypeArguments
  {
    Typing(context : Context) : list[NType];
    | Corners = "<" (NitraType; "," sm; ?)+ ">" { override Typing = this.NitraTypes.Item1.MapToList(t => t.Typing(context)[0]); }
    | Braces  = "[" (NitraType; "," sm; ?)+ "]" { override Typing = this.NitraTypes.Item1.MapToList(t => t.Typing(context)[0]); }
  }

  syntax NitraTypeName = Identifier NitraTypeArguments?
  {
    Typing(context : Context) : TypeNamePart
    {
      def name     = this.Identifier.GetText();
      def typeArgs = if (this.NitraTypeArgumentsOpt.HasValue) this.NitraTypeArgumentsOpt.Value.Typing(context) else [];
      TypeNamePart(this.Location, name, typeArgs, context.GetNemerleEnvironment())
    }
  }

  syntax NitraType
  {
    Typing(context : Context) : NType * bool;

    | PredefinedType
      {
        override Typing
        {
          _ = context;
          def value = match (GetText(this.PredefinedType))
          {
            | "void"   => NPredefinedType.Void
            | "int"    => NPredefinedType.Int
            | "string" => NPredefinedType.String
            | _        => assert3(false)
          };
          (NType.Predefined(this.Location, value), false);
        }
      }
    | QualifiedType  = (NitraTypeName; ".")+
      {
        override Typing
        {
          def parts = LightList();
          foreach (t in this.NitraTypeNames.Item1)
            parts.Add(t.Typing(context));
          (NType.Qualified(this.Location, parts.ToNList()), false);
        }
      }
    | Braces         = "(" NitraType ")"
      {
        override Typing = (this.NitraType.Typing(context)[0], false);
      }
    | Tuple          = NitraType "*" NitraType     precedence 40  right-associative
      {
        override Typing
        {
          def first = this.NitraType1.Typing(context)[0];
          match (this.NitraType2.Typing(context))
          {
            | (NType.Tuple(members), true) => (NType.Tuple(this.Location, first :: members), true)
            | (second, _)                  => (NType.Tuple(this.Location, [first, second]), true)
          }
        }
      }
    | Func           = NitraType "->" NitraType    precedence 30  right-associative
      {
        override Typing = (NType.Func(this.Location, this.NitraType1.Typing(context)[0], this.NitraType2.Typing(context)[0]), false);
      }
    | OptionList     = NitraType "*" precedence 50
      {
        override Typing = (NType.OptionList(this.Location, this.NitraType.Typing(context)[0]), false);
      }
    | List           = NitraType "+" precedence 50
      {
        override Typing = (NType.List(this.Location, this.NitraType.Typing(context)[0]), false);
      }
    | Option         = NitraType "?" precedence 50
      {
        override Typing = (NType.Option(this.Location, this.NitraType.Typing(context)[0]), false);
      }
  }

  syntax AstInheritance = ":" sm BaseAsts=(QualifiedIdentifier; "," sm)+
  {
    Typing(context : Context, isDeclaration : bool) : list[AstSymbol] = TypingUtils.BindAstInheritanceList(this.BaseAsts.Item1, context, isDeclaration);
  }

  syntax AstBody = outline_begin_before nl "{" inl Members=AstMember* d "}" outline_end_before nl
  {
    CollectGlobalSymbols(site : IMemberSite) : void = foreach (member in Members) member.CollectGlobalSymbols(site);
    [Cached] MakeContext(parent : Context) : Context = PassThrough(Members, parent, _.MakeContext(_));
    Typing() : void = foreach (member in Members) member.Typing();
    TypeProperties() : void = foreach (member in Members) member.TypeProperties();
  }

  syntax AstMember
  {
    CollectGlobalSymbols(site : IMemberSite) : void;
    [Cached] MakeContext(parent : Context) : Context = parent;
    Typing() : void;
    TypeProperties() : void {}

    | SimpleProperty = Name sm ":" sm NitraType ";" nl
      {
        private MakeSymbol() : AstPropertySymbol
        {
          match (Name.Value())
          {
            | "Parent" => ParsedParentAstPropertySymbol(this)
            | _        => ParsedSimpleAstPropertySymbol(this)
          }
        }
        override CollectGlobalSymbols
        {
          def symbol = MakeSymbol();
          _ = site.Node.AddAndReport.[AstPropertySymbol](symbol, Name.Location);
        }
        [Cached] private MakeType() : NType = this.NitraType.Typing(this.Context)[0];
        override Typing
        {
          _ = MakeType();
        }
      }
    | InProperty = "in" Name sm ":" sm NitraType ";" nl
      {
        [Cached] private MakeSite(site : IMemberSite) : IMemberSite = site;
        [Cached] private MakeSymbol() : ParsedInAstPropertySymbol = ParsedInAstPropertySymbol(this);
        override CollectGlobalSymbols
        {
          TypingUtils.CheckSpecialPropertyNames(Name, site.Node.Project);
          _ = MakeSite(site);
          _ = site.Node.AddAndReport.[AstPropertySymbol](MakeSymbol(), Name.Location);
        }
        [Cached] private MakeType() : NType = this.NitraType.Typing(this.Context)[0];
        override Typing
        {
          _ = MakeType();
        }
      }
    | OutProperty = "out" Name sm ":" sm NitraType DependentPropertyValue
      {
        [Cached] private MakeSite(site : IMemberSite) : IMemberSite = site;
        [Cached] private MakeSymbol() : ParsedOutAstPropertySymbol = ParsedOutAstPropertySymbol(this);
        override CollectGlobalSymbols
        {
          TypingUtils.CheckSpecialPropertyNames(Name, site.Node.Project);
          _ = MakeSite(site);
          _ = site.Node.AddAndReport.[AstPropertySymbol](MakeSymbol(), Name.Location);
        }
        [Cached] private MakeType() : NType = this.NitraType.Typing(this.Context)[0];
        override Typing
        {
          _ = MakeType();
          when (this.DependentPropertyValue.HasValue())
          {
            def assignment = DependentPropertyAssignment(this.Location, [LocatedName(Name.Location, Symbol.Name)], NemerleParser.Parse(this.DependentPropertyValue, this.Context));
            TypingUtils.RegisterDependentPropertyAssignment(this.Site, assignment, this.Context)
          }
        }
      }
    | InOutProperty = "inout" Name sm ":" sm NitraType DependentPropertyValue
      {
        [Cached] private MakeSite(site : IMemberSite) : IMemberSite = site;
        [Cached] private MakeInSymbol() : ParsedAutoInAstPropertySymbol = ParsedAutoInAstPropertySymbol(this);
        [Cached] private MakeOutSymbol() : ParsedAutoOutAstPropertySymbol = ParsedAutoOutAstPropertySymbol(this);
        override CollectGlobalSymbols
        {
          TypingUtils.CheckSpecialPropertyNames(Name, site.Node.Project);
          _ = MakeSite(site);
          _ = site.Node.AddAndReport.[AstPropertySymbol](MakeInSymbol(), Name.Location);
          _ = site.Node.AddAndReport.[AstPropertySymbol](MakeOutSymbol(), Name.Location);
        }
        [Cached] private MakeType() : NType = this.NitraType.Typing(this.Context)[0];
        override Typing
        {
          _ = MakeType();
          when (this.DependentPropertyValue.HasValue())
          {
            def assignment = DependentPropertyAssignment(this.Location, [LocatedName(Name.Location, OutSymbol.Name)], NemerleParser.Parse(this.DependentPropertyValue, this.Context));
            TypingUtils.RegisterDependentPropertyAssignment(this.Site, assignment, this.Context)
          }
        }
      }
    | PropertyAssignment = QualifiedName sm "=" sm Expression ";"
      {
        [Cached] private MakeSite(site : IMemberSite) : IMemberSite = site;
        override CollectGlobalSymbols { _ = MakeSite(site) }
        override Typing
        {
          def assignment = DependentPropertyAssignment(this.Location, this.QualifiedName.Identifiers(), NemerleParser.Parse(this.Expression, this.Context));
          TypingUtils.RegisterDependentPropertyAssignment(this.Site, assignment, this.Context)
        }
      }
    | Decompose = "decompose" Name outline_begin_before nl "{" inl Properties=ProjectedProperty* d "}" outline_end_before nl
      {
        syntax ProjectedProperty = Name sm ":" NitraType ";" nl
        {
          CollectGlobalSymbols(site : IMemberSite) : void
          {
            TypingUtils.CheckSpecialPropertyNames(Name, site.Node.Project);
            def symbol = ParsedProjectedAstPropertySymbol(this);
            _ = site.Node.AddAndReport.[AstPropertySymbol](symbol, Name.Location);
          }
          [Cached] MakeType() : NType = this.NitraType.Typing(this.Context)[0];
          [Cached] MakeContext(parent : Context) : Context = parent;
          [Cached] MakeProjectionType(t : AstPropertyProjectionType) : AstPropertyProjectionType = t;
          Typing() : void
          {
            _ = MakeType();
          }
          TypeProjection(projectionSource : SimpleAstPropertySymbol, baseType : AstSymbol) : void
          {
            _ = MakeProjectionType(MakeAstPropertyProjectionType(this.Type, projectionSource, baseType, this.Context))
          }
        }

        [Cached] private MakeDeclaringAst(site : IMemberSite) : AstSymbol = site :> AstSymbol;
        override CollectGlobalSymbols
        { 
          _ = MakeDeclaringAst(site);
          foreach (property in Properties) property.CollectGlobalSymbols(site);
        }
        override MakeContext = FoldThrough(Properties, parent, _.MakeContext(_));
        override Typing = foreach (property in Properties) property.Typing();
        override TypeProperties
        {
          def (projectionSource, baseType) = BindAstPropertyProjectionSource(this.DeclaringAst, this.Name, this.Context);
          foreach (property in Properties) property.TypeProjection(projectionSource, baseType)
        }
      }
  }

  syntax DependentPropertyValue
  {
    ValueLocation() : Nitra.Location;
    HasValue() : bool;

    | Expression = sm "=" sm Expression ";" nl
      {
        override ValueLocation = Expression.Location;
        override HasValue = true;
      }
    | Empty = ";" nl
      {
        override ValueLocation = this.Location.FromStart();
        override HasValue = false;
      }
  }

  syntax ExtensionAst = "|" sm AstModifier* Name Body=AstBody?
  {
    [Cached] MakeAstSymbol(isDeclaration : bool, compilerMessages : ICompilerMessages) : ParsedExtensionAstSymbol
    {
      def (_, _, cardinality) = TypingUtils.TypeAstModifiers(this.AstModifiers, true, isDeclaration, compilerMessages);
      ParsedExtensionAstSymbol(this, isDeclaration, cardinality);
    }
    CollectGlobalSymbols(site : IMemberSite, isDeclaration : bool) : void
    {
      def symbol = MakeAstSymbol(isDeclaration, site.Node.Project);
      _ = site.Node.AddAndReport.[AstSymbol](symbol, Name.Location);
      when (Body.HasValue)
        Body.Value.CollectGlobalSymbols(symbol);
    }
    [Cached] MakeContext(parent : Context) : Context
    {
      def  context1 = AstContext(parent, this.AstSymbol);
      when (Body.HasValue)
        _ = Body.Value.MakeContext(context1);
      parent
    }
    Typing(baseAstRef : SymbolRef[ExtensibleAstSymbol]) : void
    {
      _ = MakeBaseAstRef(baseAstRef);
      when (Body.HasValue)
        Body.Value.Typing();
    }
    TypeProperties() : void = when (Body.HasValue) Body.Value.TypeProperties();
    [Cached] MakeBaseAstRef(baseAstRef : SymbolRef[ExtensibleAstSymbol]) : SymbolRef[ExtensibleAstSymbol] = baseAstRef;
  }

  token AstModifier
  {
    IsAbstract(acc : bool, isExtensible : bool, compilerMessages : ICompilerMessages) : bool                                          { IgnoreParams(); acc }
    Cardinality(acc : AstCardinality, isDeclaration : bool, isAbstract : bool, compilerMessages : ICompilerMessages) : AstCardinality { IgnoreParams(); acc }

    | Abstract = "abstract" sm { override IsAbstract  = TypingUtils.TypeAstModifier_IsAbstract(this, acc, isExtensible, compilerMessages); }
    | Optional = "optional" sm { override Cardinality = TypingUtils.TypeAstModifier_Cardinality(this, acc, isDeclaration, isAbstract, compilerMessages, AstCardinality.Optional); }
    | Multiple = "multiple" sm { override Cardinality = TypingUtils.TypeAstModifier_Cardinality(this, acc, isDeclaration, isAbstract, compilerMessages, AstCardinality.Multiple); }
  }

  syntax NamespaceMember
  {
    CollectGlobalSymbols(ns : NamespaceSymbol) : void;
    [Cached] MakeContext(parent : Context) : Context;
    CollectSyntaxMappings() : void {}
    TypeSyntaxMappings() : void {}
    TypeAst() : void {}
    Typing() : void;

    | SimpleAst = Header sm Name AstInheritance? Body=AstBody
      {
        syntax Header
        {
          Modifiers(compilerMessages : ICompilerMessages) : bool * bool * AstCardinality;
          | Ast         = AstModifier* "ast"         { override Modifiers = TypingUtils.TypeAstModifiers(this.AstModifiers, false, false, compilerMessages); }
          | Declaration = AstModifier* "declaration" { override Modifiers = TypingUtils.TypeAstModifiers(this.AstModifiers, false, true,  compilerMessages); }
        }

        [Cached] private MakeAstSymbol(compilerMessages : ICompilerMessages) : AstSymbol
        {
          def (isDeclaration, isAbstract, cardinality) = this.Header.Modifiers(compilerMessages);
          if (isAbstract)
          {
            assert(cardinality == AstCardinality.Single);
            ParsedAbstractAstSymbol(this, isDeclaration)
          }
          else
            ParsedSimpleAstSymbol(this, isDeclaration, cardinality)
        }
        [Cached] private MakeBaseAsts() : list[AstSymbol] = TypingUtils.TypeAstInheritance(this.AstInheritanceOpt, this.Context, this.AstSymbol.IsDeclaration);
        override CollectGlobalSymbols
        {
          def symbol = MakeAstSymbol(ns.Node.Project);
          _ = ns.Node.AddAndReport.[AstSymbol](symbol, Name.Location);
          Body.CollectGlobalSymbols(symbol :> IMemberSite);
        }
        override MakeContext
        {
          def  context1 = AstContext(parent, this.AstSymbol);
          def _context2 = Body.MakeContext(context1);
          parent
        }
        override Typing
        {
          _ = MakeBaseAsts();
          Body.Typing();
        }
        override TypeAst = Body.TypeProperties();
      }

    | ExtensibleAst = Header sm Name AstInheritance? Body
      {
        syntax Header
        {
          IsDeclaration() : bool;
          | Ast         = "asts"         { override IsDeclaration = false; }
          | Declaration = "declarations" { override IsDeclaration = true; }
        }

        syntax Body = outline_begin_before nl "{" inl Members=AstMember* Extensions=ExtensionAst* d "}" outline_end_before nl
        {
          CollectGlobalSymbols(site : IMemberSite, isDeclaration : bool) : void
          {
            foreach (member in Members) member.CollectGlobalSymbols(site);
            foreach (extension in Extensions) extension.CollectGlobalSymbols(site, isDeclaration);
          }
          [Cached] MakeContext(parent : Context) : Context
          {
            def context1 = PassThrough(Members, parent, _.MakeContext(_));
            def context2 = PassThrough(Extensions, context1, _.MakeContext(_));
            context2
          }
          Typing(baseAstRef : SymbolRef[ExtensibleAstSymbol]) : void
          {
            foreach (member in Members) member.Typing();
            foreach (extension in Extensions) extension.Typing(baseAstRef);
          }
          TypeAst() : void
          {
            foreach (member in Members) member.TypeProperties();
            foreach (extension in Extensions) extension.TypeProperties();
          }
        }

        [Cached] private MakeAstSymbol() : ParsedExtensibleAstSymbol = ParsedExtensibleAstSymbol(this, this.Header.IsDeclaration());
        [Cached] private MakeBaseAsts() : list[AstSymbol] = TypingUtils.TypeAstInheritance(this.AstInheritanceOpt, this.Context, this.AstSymbol.IsDeclaration);
        override CollectGlobalSymbols
        {
          def symbol = MakeAstSymbol();
          _ = ns.Node.AddAndReport.[AstSymbol](symbol, Name.Location);
          Body.CollectGlobalSymbols(symbol, symbol.IsDeclaration);
        }
        override MakeContext
        {
          def  context1 = AstContext(parent, this.AstSymbol);
          def _context2 = Body.MakeContext(context1);
          parent
        }
        override Typing
        {
          _ = MakeBaseAsts();
          Body.Typing(SymbolRef.Some(Name.Location, false, AstSymbol));
        }
        override TypeAst = Body.TypeAst();
      }

    | ExtendAst = Header sm (Name sm "=" sm)? BaseName=QualifiedName Body
      {
        syntax Header
        {
          IsDeclaration() : bool;
          | Ast         = "extend" "asts"         { override IsDeclaration = false; }
          | Declaration = "extend" "declarations" { override IsDeclaration = true;  }
        }

        syntax Body = outline_begin_before nl "{" inl Extensions=ExtensionAst* d "}" outline_end_before nl
        {
          CollectGlobalSymbols(site : IMemberSite, isDeclaration : bool) : void
          {
            foreach (extension in Extensions)
              extension.CollectGlobalSymbols(site, isDeclaration);
          }
          [Cached] MakeContext(parent : Context) : Context = PassThrough(Extensions, parent, _.MakeContext(_));
          Typing(baseAstRef : SymbolRef[ExtensibleAstSymbol]) : void
          {
            foreach (extension in Extensions)
              extension.Typing(baseAstRef);
          }
          TypeAst() : void = foreach (extension in Extensions) extension.TypeProperties();
        }

        override CollectGlobalSymbols
        {
          def isDeclaration = Header.IsDeclaration();
          def symbol = ParsedExtendAstSymbol(this, isDeclaration);
          _ = ns.Node.AddAndReport.[ExtendAstSymbol](symbol, Location);
          Body.CollectGlobalSymbols(symbol, isDeclaration);
        }
        override MakeContext = Body.MakeContext(parent);
        override Typing
        {
          def baseAstRef = MakeBaseAstRef();
          when (baseAstRef is SymbolRef.Some(baseAst))
          when (baseAst.IsDeclaration != this.Header.IsDeclaration())
          {
            def baseType = if (baseAst.IsDeclaration) "declaration" else "ast";
            this.Context.Error(this.Header, $"Expected 'extend $baseType'.");
          }
          Body.Typing(baseAstRef);
        }
        override TypeAst = Body.TypeAst();
        [Cached] private MakeBaseAstRef() : SymbolRef[ExtensibleAstSymbol] = SymbolRef[ExtensibleAstSymbol].Create(BaseName, Context.Bind(BaseName));
      }

    | MapSyntax = "map" "syntax" sm RuleName=QualifiedName sm "->" sm AstName=QualifiedName MapSyntaxBody
      {
        override CollectGlobalSymbols { _ = ns; }
        override MakeContext
        {
          def context = MapSyntaxContext(parent);
          _ = MapSyntaxBody.MakeContext(context);
          context
        }
        [Cached] private MakeAstSymbolRef() : SymbolRef[AstSymbol] = this.Context.Bind.[AstSymbol](AstName);
        [Cached] private MakeSyntaxRuleRef()  : SymbolRef[SyntaxRuleSymbol]  = this.Context.Bind.[SyntaxRuleSymbol](RuleName);
        override CollectSyntaxMappings
        {
          def astSymbolRef = MakeAstSymbolRef();
          def ruleSymbolRef  = MakeSyntaxRuleRef();
          when (ruleSymbolRef is SymbolRef.Some(ruleSymbol))
            MapSyntaxBody.CollectSyntaxMappings(astSymbolRef, ruleSymbol);
        }
        override TypeSyntaxMappings
        {
          def astSymbolRef = MakeAstSymbolRef();
          def ruleSymbolRef  = MakeSyntaxRuleRef();
          when (ruleSymbolRef is SymbolRef.Some(ruleSymbol))
            MapSyntaxBody.TypeSyntaxMappings(astSymbolRef, ruleSymbol);
        }
        override Typing { }
      }

    | Namespace   = "namespace"   sm QualifiedName outline_begin_before nl "{" inl NamespaceBody      d "}" outline_end_before nl
      {
        [Cached] private MakeCurrentSymbol(ns : NamespaceSymbol) : NamespaceSymbol = MakeNamespaceSymbol(ns, QualifiedName.CalcLocations());
        override CollectGlobalSymbols = NamespaceBody.CollectGlobalSymbols(MakeCurrentSymbol(ns));
        override MakeContext
        {
          def nsContext = EnteredNamespaceContext(parent, CurrentSymbol);
          _ = NamespaceBody.MakeContext(nsContext);
          parent
        }
        override CollectSyntaxMappings = NamespaceBody.CollectSyntaxMappings();
        override TypeSyntaxMappings = NamespaceBody.TypeSyntaxMappings();
        override Typing = NamespaceBody.Typing();
        override TypeAst = NamespaceBody.TypeAst();
      }

    | SyntaxModule = SyntaxModuleAttributes "syntax" sm "module"sm Name outline_begin_before nl "{" inl Usings SyntaxModuleMember* d "}" outline_end_before nl
      {
        override CollectGlobalSymbols
        {
          def symbol = ParsedSyntaxModuleSymbol(this);
          _ = ns.Node.AddAndReport(symbol, Name.Location);
          foreach (decl in SyntaxModuleMembers)
            decl.CollectGlobalSymbols(symbol);
        }
        [Cached] private MakeInitialContext(contextToSave : SyntaxModuleContext) : SyntaxModuleContext = contextToSave;
        [Cached] private MakeFinalContext(contextToSave : Context) : Context = contextToSave;
        override MakeContext
        {
          def context1 = MakeInitialContext(SyntaxModuleContext(parent, Name));
          def context2 = Usings.MakeContext(context1);
          def context3 = SyntaxModuleBodyContext(context2);
          def finalContext = MakeFinalContext(FoldThrough(SyntaxModuleMembers, context3, _.MakeContext(_)));
          Utils.RegisterGlobalSpanClassSymbols(context1.SyntaxModuleSymbol, finalContext);
          parent
        }
        [Cached] private MakeTokenLiteralNames() : Map[string, Nitra.Model.Identifier] = FoldThrough(SyntaxModuleMembers, Map(), _.GetTokenLiteralNames(_));
        override CollectSyntaxMappings
        {
          foreach (decl in SyntaxModuleMembers)
            decl.CollectSyntaxMappings();
        }
        override TypeSyntaxMappings
        {
          foreach (decl in SyntaxModuleMembers)
            decl.TypeSyntaxMappings();
        }
        override Typing
        {
          _ = MakeTokenLiteralNames();
          foreach (decl in SyntaxModuleMembers)
            decl.Typing();
        }
      }
  }

  syntax SyntaxModuleAttribute
  {
    Options(inOptions : SyntaxModuleOptions) : SyntaxModuleOptions = inOptions;
    [Cached] MakeContext(_parent : Context) : Context = _parent;

    | Splicable = AttributeName="Splicable"
      {
        override Options = inOptions.SetNeedSplicable(this, true);
      }
    | ExplicitSpaces = AttributeName="ExplicitSpaces"
      {
        override Options = inOptions.SetExplicitSpaces(this, true);
      }
    | ImplicitSpaces = AttributeName="ImplicitSpaces"
      {
        override Options = inOptions.SetExplicitSpaces(this, false);
      }
  }

  syntax SyntaxModuleAttributeList = "[" (SyntaxModuleAttribute; ","sm)+ "]" sm
  {
    Options(inOptions : SyntaxModuleOptions) : SyntaxModuleOptions = FoldThrough(SyntaxModuleAttributes.Item1, inOptions, _.Options(_));
    MakeContext(parent : Context) : Context = FoldThrough(SyntaxModuleAttributes.Item1, parent, _.MakeContext(_));
  }

  syntax SyntaxModuleAttributes    = SyntaxModuleAttributeList*
  {
    [Cached] Options(inOptions : SyntaxModuleOptions) : SyntaxModuleOptions = FoldThrough(SyntaxModuleAttributeLists, inOptions, _.Options(_));
    [Cached] MakeContext(parent : Context) : Context = FoldThrough(SyntaxModuleAttributeLists, parent, _.MakeContext(_));
  }

  syntax RuleAttribute
  {
    Options(inOptions : RuleDefinitionOptions) : RuleDefinitionOptions = inOptions;
    [Cached] MakeContext(_parent : Context) : Context = _parent;

    | Start                  = AttributeName="StartRule"
      {
        override Options = inOptions.SetStart(this, true);
      }
    | "Arity" "(" Number ")" { override Options = inOptions.SetArity(this, Number.Value()); }
    | "Prefix"               { override Options = inOptions.SetOperatorInfo(this, OperatorInfo.Prefix); }
    | "Postfix"              { override Options = inOptions.SetOperatorInfo(this, OperatorInfo.Postfix); }
    | "Infix"                { override Options = inOptions.SetOperatorInfo(this, OperatorInfo.Infix); }
    | SpanClass              = AttributeName="SpanClass" "(" Class=Identifier ")"
      {
        override Options = Context.Bind.[SpanClassSymbol](Class).Map(inOptions.SetSpanClass(Class, _)) ?? inOptions;
      }
    | ExplicitSpaces         = AttributeName="ExplicitSpaces"
      {
        override Options = inOptions.SetExplicitSpaces(this, true);
      }
    | ImplicitSpaces         = AttributeName="ImplicitSpaces"
      {
        override Options = inOptions.SetExplicitSpaces(this, false);
      }
    | SuppressTrailingSpaces = AttributeName="SuppressTrailingSpaces"
      {
        override Options = inOptions.SetSuppressTrailingSpaces(this, true);
      }
    | AllowTrailingSpaces    = AttributeName="AllowTrailingSpaces"
      {
        override Options = inOptions.SetSuppressTrailingSpaces(this, false);
      }
    | NoParseTree            = AttributeName="NoParseTree"
      {
        override Options = inOptions.SetNoParseTree(this, true);
      }
    | KeyToken               = AttributeName="Key"
      {
        override Options = inOptions.SetKeyToken(this, true);
      }
    | Keyword               = AttributeName="Keyword"
      {
        override Options = inOptions.SetKeyword(this, true);
      }
    | Identifier            = AttributeName="Identifier"
      {
        override Options = inOptions.SetIdentifier(this, true);
      }
    | DynamicSyntaxExtender = AttributeName="DynamicSyntaxExtender"
      {
        override Options = inOptions.SetDynamicSyntaxExtender(this, true);
      }
    | DynamicSyntaxExtentionPoint = AttributeName="DynamicSyntaxExtentionPoint"
      {
        override Options = inOptions.SetDynamicSyntaxExtentionPoint(this, true);
      }
  }

  syntax RuleAttributeList = "[" (RuleAttribute; ","sm)+ "]" sm
  {
    Options(inOptions : RuleDefinitionOptions) : RuleDefinitionOptions = FoldThrough(RuleAttributes.Item1, inOptions, _.Options(_));
    MakeContext(parent : Context) : Context = FoldThrough(RuleAttributes.Item1, parent, _.MakeContext(_));
  }

  syntax RuleAttributes    = RuleAttributeList*
  {
    [Cached] Options(inOptions : RuleDefinitionOptions) : RuleDefinitionOptions = FoldThrough(RuleAttributeLists, inOptions, _.Options(_));
    [Cached] MakeContext(parent : Context) : Context = FoldThrough(RuleAttributeLists, parent, _.MakeContext(_));
  }

  [StartRule]
  syntax SyntaxModuleMember
  {
    CollectGlobalSymbols(owner : IRuleDeclarationSite) : void = _ = owner;
    [Cached] MakeContext(parent : Context) : Context = parent;
    CollectSyntaxMappings() : void {}
    TypeSyntaxMappings() : void {}
    Typing() : void {}

    GetTokenLiteralNames(result : Map[string, Nitra.Model.Identifier]) : Map[string, Nitra.Model.Identifier] = result;

    | RegexRule
      {
        override CollectGlobalSymbols = RegexRule.CollectGlobalSymbols(owner);
        override MakeContext          = RegexRule.MakeContext(parent);
        override CollectSyntaxMappings = RegexRule.CollectSyntaxMappings();
        override TypeSyntaxMappings   = RegexRule.TypeSyntaxMappings();
        override Typing               = RegexRule.Typing();
      }
    | TokenRule
      {
        override CollectGlobalSymbols = TokenRule.CollectGlobalSymbols(owner);
        override MakeContext          = TokenRule.MakeContext(parent);
        override CollectSyntaxMappings = TokenRule.CollectSyntaxMappings();
        override TypeSyntaxMappings   = TokenRule.TypeSyntaxMappings();
        override Typing               = TokenRule.Typing();
      }
    | SimpleRule
      {
        override CollectGlobalSymbols = SimpleRule.CollectGlobalSymbols(owner);
        override MakeContext          = SimpleRule.MakeContext(parent);
        override CollectSyntaxMappings = SimpleRule.CollectSyntaxMappings();
        override TypeSyntaxMappings   = SimpleRule.TypeSyntaxMappings();
        override Typing               = SimpleRule.Typing();
      }
    | VoidRule
      {
        override CollectGlobalSymbols = VoidRule.CollectGlobalSymbols(owner);
        override MakeContext          = VoidRule.MakeContext(parent);
        override CollectSyntaxMappings = VoidRule.CollectSyntaxMappings();
        override TypeSyntaxMappings   = VoidRule.TypeSyntaxMappings();
        override Typing               = VoidRule.Typing();
      }
    | ExtensibleTokenRule
      {
        override CollectGlobalSymbols = ExtensibleTokenRule.CollectGlobalSymbols(owner);
        override MakeContext          = ExtensibleTokenRule.MakeContext(parent);
        override CollectSyntaxMappings = ExtensibleTokenRule.CollectSyntaxMappings();
        override TypeSyntaxMappings   = ExtensibleTokenRule.TypeSyntaxMappings();
        override Typing               = ExtensibleTokenRule.Typing();
      }
    | ExtensibleRule
      {
        override CollectGlobalSymbols = ExtensibleRule.CollectGlobalSymbols(owner);
        override MakeContext          = ExtensibleRule.MakeContext(parent);
        override CollectSyntaxMappings = ExtensibleRule.CollectSyntaxMappings();
        override TypeSyntaxMappings   = ExtensibleRule.TypeSyntaxMappings();
        override Typing               = ExtensibleRule.Typing();
      }
    | Marker              = "marker"              sm Name                                                   ";"nl
      {
        override CollectGlobalSymbols = _ = owner.Node.AddAndReport(ParsedMarkerSymbol(Name, owner), Location);
      }
    | ExtendRule          = Header sm (Name sm "=" sm)? BaseName outline_begin_before nl "{" inl ExtensionRule* d "}" outline_end_before nl
      {
        syntax Header
        {
          IsToken() : bool;
          | Token  = "extend" sm "token"  { override IsToken = true;  }
          | Syntax = "extend" sm "syntax" { override IsToken = false; }
        }

        [Cached] private MakeSymbol(owner : IRuleDeclarationSite) : ParsedExtendSyntaxSymbol = ParsedExtendSyntaxSymbol(this, owner, this.Header.IsToken());
        override CollectGlobalSymbols
        {
          def symbol = MakeSymbol(owner);
          _ = owner.Node.AddAndReport.[ExtendSyntaxSymbol](symbol, Location);
          foreach (rule in ExtensionRules)
            rule.CollectGlobalSymbols(symbol);
        }
        override MakeContext
        {
          def context = RuleDeclarationSiteContext(parent, Symbol);
          _ = FoldThrough(ExtensionRules, context, _.MakeContext(_));
          parent
        }
        override CollectSyntaxMappings = foreach (m in ExtensionRules) m.CollectSyntaxMappings();
        override TypeSyntaxMappings = foreach (m in ExtensionRules) m.TypeSyntaxMappings();
        [Cached] private MakeBaseRuleRef() : ExtensibleRuleRef = this.Context.Bind(BaseName);
        override Typing
        {
          def baseRule = MakeBaseRuleRef();
          when (baseRule is Some(symbol) when symbol.Options.IsTokenRule != this.Symbol.IsToken)
          {
            def msg = if (symbol.Options.IsTokenRule) "Can't extend token with syntax rule."
                      else "Can't extend syntax rule with token.";
            this.Context.Error(BaseName, msg);
          }
          foreach (m in ExtensionRules)
            m.Typing(baseRule);
        }
      }
    | RuleAlias
      {
        override MakeContext = RuleAlias.MakeContext(parent);
      }
    | TokenLiteral        = "literal"             sm Name  sm "="  sm (StringLiteral; ","sm)+               ";"nl
      {
        override GetTokenLiteralNames
        {
          def name = Name.Identifier();
          FoldThrough(StringLiterals.Item1, result, (strLit, result) => result.Replace(strLit.Value(), name))
        }
        override MakeContext = TokenLiteralContext(parent, Name, StringLiterals.Item1);
      }
    | SpanClass           = "span"    sm "class"  sm Name MatchTokens=("=" RegexExpression)?                ";"nl
      {
        [Cached] private MakeSymbol(context : Context) : SpanClassSymbol
        {
          def symbol = ParsedSpanClassSymbol(this, context);
          context.Project.AddSymbolDef(symbol, Name.Location);
          symbol
        }
        [Cached] private RegularRule() : option[RegularRule] = MatchTokens.Map(t =>
        {
          def rr = t.Item2.Typing();
          rr.ValidateRegularRule(this.Context);
          rr
        });
        override MakeContext
        {
          def context = SpanClassContext(parent, MakeSymbol(parent));
          _ = MatchTokens.Map(t => t.Item2.MakeContext(context));
          context
        }
        override Typing
        {
          _ = RegularRule();
        }
      }
    | BracePair           = "braces"  sm Open=RegexExpression "," sm Close=RegexExpression                  ";"nl
      {
        override MakeContext
        {
          def context = BracePairContext(parent, Open, Close);
          _ = Open.MakeContext(context);
          _ = Close.MakeContext(context);
          context
        }
        override Typing
        {
          Open.Typing().ValidateRegularRule(this.Context);
          Close.Typing().ValidateRegularRule(this.Context);
        }
      }
    | KeywordRegex        = "keyword" sm "regex"  sm MatchTokens=RegexExpression sm "rule" sm QualifiedName ";"nl
      {
        override MakeContext
        {
          def context = KeywordRegexContext(parent, MatchTokens, QualifiedName);
          _ = MatchTokens.MakeContext(context);
          context
        }
      }
  }

  syntax RuleAlias = "alias" sm Name sm "=" sm RuleExpression ";"nl
  {
    [Cached] private MakeSymbol(project : Project) : RuleAliasSymbol
    {
      def symbol = ParsedRuleAliasSymbol(this);
      project.AddSymbolDef(symbol, Name.Location);
      symbol
    }
    MakeContext(parent : Context) : Context
    {
      RuleAliasContext(parent, MakeSymbol(parent.Project));
    }
  }

  syntax MapSyntaxExpression
  {
    | Block
    | Expression = Expression ";"
  }

  syntax ParseTreeFieldAutoMapping = RuleFieldPath=QualifiedName sm "->" sm AstPropertyName=Name ";"
  {
    [Cached] MakeContext(parent : Context) : Context = parent;
    GetSyntaxMappingField(astSymbol : AstSymbol, ruleSymbol : SyntaxRuleSymbol, variables : Dictionary[string, ParseTreePattern.Var]) : SyntaxMappingField
    {
      def astPropertyRef = TypingUtils.BindAstProperty(astSymbol, this.AstPropertyName, this.Context);
      def parseTreePathOpt       = TypingUtils.BindRuleField(ruleSymbol, this.RuleFieldPath, variables, this.Context);
      when (astPropertyRef is SymbolRef.Some(astProperty))
      when (parseTreePathOpt is Some(parseTreePath))
      {
        def syntaxMappingTypeOpt = TypingUtils.MakeSyntaxMappingType(Context, astProperty, parseTreePath, this.Location);
        when (syntaxMappingTypeOpt is Some(syntaxMappingType))
          return SyntaxMappingField.Automatic(this.Location, astPropertyRef, parseTreePath, syntaxMappingType);
      }
      SyntaxMappingField.Error(this.Location, astPropertyRef)
    }
  }

  syntax ParseTreeFieldInlineMapping = FieldName=Name sm "=" sm Code=MapSyntaxExpression
  {
    [Cached] MakeContext(parent : Context) : Context = parent;
    GetSyntaxMappingField(astSymbol : AstSymbol, ruleSymbol : SyntaxRuleSymbol, variables : Dictionary[string, ParseTreePattern.Var]) : SyntaxMappingField
    {
      _ = ruleSymbol;
      _ = variables;
      def fieldRef = TypingUtils.BindAstProperty(astSymbol, this.FieldName, this.Context);
      def code     = NemerleParser.Parse(this.Code, this.Context);
      SyntaxMappingField.Inline(this.Location, fieldRef, code)
    }
  }

  syntax MapSyntaxMatchCaseBodyMember
  {
    MakeContext(parent : Context) : Context;
    GetSyntaxMappingField(astSymbol : AstSymbol, ruleSymbol : SyntaxRuleSymbol, variables : Dictionary[string, ParseTreePattern.Var]) : SyntaxMappingField;

    | ParseTreeFieldAutoMapping
      {
        override MakeContext           = ParseTreeFieldAutoMapping.MakeContext(parent);
        override GetSyntaxMappingField = ParseTreeFieldAutoMapping.GetSyntaxMappingField(astSymbol, ruleSymbol, variables);
      }
    | ParseTreeFieldInlineMapping
      {
        override MakeContext           = ParseTreeFieldInlineMapping.MakeContext(parent);
        override GetSyntaxMappingField = ParseTreeFieldInlineMapping.GetSyntaxMappingField(astSymbol, ruleSymbol, variables);
      }
  }

  syntax MapSyntaxBodyMember
  {
    [Cached] MakeContext(parent : Context) : Context;
    CollectMappingFields(astSymbolRef : SymbolRef[AstSymbol], ruleSymbol : SyntaxRuleSymbol, buffer : List[SyntaxMappingField]) : void { IgnoreParams() }
    CollectExtensionMappings(astSymbolRef : SymbolRef[AstSymbol], baseRuleSymbol : ExtensibleRuleSymbol, simpleMappings : List[ExtensionRuleSymbol * SymbolRef[AstSymbol]], matchingMappings : HashSet[ExtensionRuleSymbol]) : void { IgnoreParams() }
    CollectSimpleMatchCases(astSymbolRef : SymbolRef[AstSymbol], ruleSymbol : SyntaxRuleSymbol, sharedMappingFields : List[SyntaxMappingField], buffer : List[SyntaxMappingCase]) : void { IgnoreParams() }
    CollectExtensionBodies(astSymbolRef : SymbolRef[AstSymbol], baseRuleSymbol : ExtensibleRuleSymbol, mappingCases : List[ExtensionRuleSymbol * SyntaxMappingCase], mappingBodies : List[ExtensionRuleSymbol * SyntaxMappingBody]) : void { IgnoreParams() }

    | ParseTreeFieldAutoMapping
      {
        override MakeContext          = ParseTreeFieldAutoMapping.MakeContext(parent);
        override CollectMappingFields
        {
          when (astSymbolRef is SymbolRef.Some(astSymbol))
            buffer.Add(ParseTreeFieldAutoMapping.GetSyntaxMappingField(astSymbol, ruleSymbol, Dictionary()));
        }
      }
    | ParseTreeFieldInlineMapping
      {
        override MakeContext          = ParseTreeFieldInlineMapping.MakeContext(parent);
        override CollectMappingFields
        {
          when (astSymbolRef is SymbolRef.Some(astSymbol))
            buffer.Add(ParseTreeFieldInlineMapping.GetSyntaxMappingField(astSymbol, ruleSymbol, Dictionary()));
        }
      }
    | MatchCaseEmpty = "|" sm Pattern (sm "->" sm Name)?
      {
        override MakeContext = parent;
        [Cached] private MakeAstSymbolRef(astSymbolRef : SymbolRef[AstSymbol]) : SymbolRef[AstSymbol]
        {
          if (astSymbolRef is SymbolRef.Some(astSymbol))
          {
            if (NameOpt.HasValue)
              TypingUtils.BindAstSymbolFromMappingExtension(astSymbol, NameOpt.Value.Item2, this.Context)
            else
              this.Pattern.BindExtensionAst(astSymbol, this.Context)
          }
          else
            astSymbolRef
        }
        override CollectExtensionMappings
        {
          match (this.Pattern.BindExtensionRule(baseRuleSymbol, this.Context))
          {
            | (SymbolRef.Some(ruleSymbol), false) => simpleMappings.Add((ruleSymbol, MakeAstSymbolRef(astSymbolRef)))
            | (SymbolRef.Some(ruleSymbol), true)  => _ = matchingMappings.Add(ruleSymbol)
            | _ => ()
          }
        }
        override CollectSimpleMatchCases
        {
          def (pattern, _)             = this.Pattern.SimpleTyping(ruleSymbol, this.Context);
          def caseDeclatationSymbolRef = MakeAstSymbolRef(astSymbolRef);
          buffer.Add(SyntaxMappingCase.PerField(this.Location, pattern, caseDeclatationSymbolRef, sharedMappingFields.ToNList()))
        }
        override CollectExtensionBodies
        {
          def (ruleRef, hasPattern) = this.Pattern.BindExtensionRule(baseRuleSymbol, this.Context);
          when (ruleRef is SymbolRef.Some(ruleSymbol))
          {
            def extensionAstSymbolRef = MakeAstSymbolRef(astSymbolRef);
            when (extensionAstSymbolRef is SymbolRef.Some(astSymbol))
            {
              def errorLoc = this.Location.FromEnd();
              TypingUtils.CheckRequiredAstProperties(astSymbol, [], errorLoc, this.Context);
            }
            if (hasPattern)
              mappingCases.Add((ruleSymbol, SyntaxMappingCase.PerField(this.Location, this.Pattern.ExtensionTyping(ruleSymbol, this.Context)[0], extensionAstSymbolRef, [])))
            else
              mappingBodies.Add((ruleSymbol, SyntaxMappingBody.PerField(this.Location, extensionAstSymbolRef, [])))
          }
        }
      }
    | MatchCasePerField = "|" sm Pattern (sm "->" sm Name)? outline_begin_before nl OpenBrace="{" inl Members=MapSyntaxMatchCaseBodyMember* d CloseBrace="}" outline_end_before nl
      {
        override MakeContext = PassThrough(Members, parent, _.MakeContext(_));
        [Cached] private MakeAstSymbolRef(astSymbolRef : SymbolRef[AstSymbol]) : SymbolRef[AstSymbol]
        {
          if (astSymbolRef is SymbolRef.Some(astSymbol))
          {
            if (NameOpt.HasValue)
              TypingUtils.BindAstSymbolFromMappingExtension(astSymbol, NameOpt.Value.Item2, this.Context)
            else
              this.Pattern.BindExtensionAst(astSymbol, this.Context)
          }
          else
            astSymbolRef
        }
        override CollectExtensionMappings
        {
          match (this.Pattern.BindExtensionRule(baseRuleSymbol, this.Context))
          {
            | (SymbolRef.Some(ruleSymbol), false) => simpleMappings.Add((ruleSymbol, MakeAstSymbolRef(astSymbolRef)))
            | (SymbolRef.Some(ruleSymbol), true)  => _ = matchingMappings.Add(ruleSymbol)
            | _ => ()
          }
        }
        override CollectSimpleMatchCases
        {
          def (pattern, variables)     = this.Pattern.SimpleTyping(ruleSymbol, this.Context);
          def mappingFields            = List(sharedMappingFields);
          def caseDeclatationSymbolRef = MakeAstSymbolRef(astSymbolRef);
          when (caseDeclatationSymbolRef is SymbolRef.Some(astSymbol))
            foreach (member in Members)
              mappingFields.Add(member.GetSyntaxMappingField(astSymbol, ruleSymbol, variables));
          buffer.Add(SyntaxMappingCase.PerField(this.Location, pattern, caseDeclatationSymbolRef, mappingFields.ToNList()))
        }
        override CollectExtensionBodies
        {
          def getMappingFields(astSymbolRef, ruleSymbol, variables, mappingFields)
          {
            when (astSymbolRef is SymbolRef.Some(astSymbol))
            {
              foreach (member in Members)
                mappingFields.Add(member.GetSyntaxMappingField(astSymbol, ruleSymbol, variables));

              def errorLoc = Location(this.Location.Source, this.CloseBrace);
              TypingUtils.CheckRequiredAstProperties(astSymbol, mappingFields, errorLoc, this.Context);
            }
          }

          def (ruleRef, hasPattern) = this.Pattern.BindExtensionRule(baseRuleSymbol, this.Context);
          when (ruleRef is SymbolRef.Some(ruleSymbol))
          {
            def extensionAstSymbolRef = MakeAstSymbolRef(astSymbolRef);
            def mappingFields                 = List();
            if (hasPattern)
            {
              def (pattern, variables)          = this.Pattern.ExtensionTyping(ruleSymbol, this.Context);
              getMappingFields(extensionAstSymbolRef, ruleSymbol, variables, mappingFields);
              mappingCases.Add((ruleSymbol, SyntaxMappingCase.PerField(this.Location, pattern, extensionAstSymbolRef, mappingFields.ToNList())))
            }
            else
            {
              getMappingFields(extensionAstSymbolRef, ruleSymbol, Dictionary(), mappingFields);
              mappingBodies.Add((ruleSymbol, SyntaxMappingBody.PerField(this.Location, extensionAstSymbolRef, mappingFields.ToNList())))
            }
          }
        }
      }
    | MatchCaseInline = "|" sm Pattern sm "=" sm Expr=MapSyntaxExpression
      {
        [Cached] override MakeContext = parent;
        override CollectExtensionMappings
        {
          match (this.Pattern.BindExtensionRule(baseRuleSymbol, this.Context))
          {
            | (SymbolRef.Some(ruleSymbol), false) => simpleMappings.Add((ruleSymbol, astSymbolRef))
            | (SymbolRef.Some(ruleSymbol), true)  => _ = matchingMappings.Add(ruleSymbol)
            | _ => ()
          }
        }
        override CollectSimpleMatchCases
        {
          _ = sharedMappingFields;
          _ = astSymbolRef;
          def (pattern, _) = this.Pattern.SimpleTyping(ruleSymbol, this.Context);
          def code         = NemerleParser.Parse(this.Expr, this.Context);
          buffer.Add(SyntaxMappingCase.Inline(this.Location, pattern, code))
        }
        override CollectExtensionBodies
        {
          def code = NemerleParser.Parse(this.Expr, this.Context);
          match (this.Pattern.BindExtensionRule(baseRuleSymbol, this.Context))
          {
            | (SymbolRef.Some(ruleSymbol), true)  => mappingCases.Add((ruleSymbol, SyntaxMappingCase.Inline(this.Location, this.Pattern.ExtensionTyping(ruleSymbol, this.Context)[0], code)))
            | (SymbolRef.Some(ruleSymbol), false) => mappingBodies.Add((ruleSymbol, SyntaxMappingBody.Inline(this.Location, astSymbolRef, code)))
            | _ => ()
          }
        }
      }
  }

  syntax Pattern
  {
    [Cached] BindExtensionRule(baseRuleSymbol : ExtensibleRuleSymbol, context : Context) : SymbolRef[ExtensionRuleSymbol] * bool
    {
      _ = baseRuleSymbol;
      context.Error(this, "Extension rule pattern expected");
      (SymbolRef.None(this.Location, true), false)
    }
    BindExtensionAst(baseAstSymbol : AstSymbol, context : Context) : SymbolRef[AstSymbol]
    {
      _ = baseAstSymbol;
      context.Error(this, "Extension rule pattern expected");
      SymbolRef.None(this.Location, true)
    }
    ExtensionTyping(ruleSymbol : ExtensionRuleSymbol, context : Context) : ParseTreePattern * Dictionary[string, ParseTreePattern.Var]
    {
      IgnoreParams();
      assert(false)
    }
    SimpleTyping(ruleSymbol : SyntaxRuleSymbol, context : Context) : ParseTreePattern * Dictionary[string, ParseTreePattern.Var]
    {
      def pattern   = PatternTyper.TypeParseTreePattern(this.Location, ruleSymbol, ConcreteListParseTree(this.Location, array[this]), context);
      def variables = TypingUtils.CollectPatternVariables(pattern, context);
      (pattern, variables)
    }
    Typing(ruleType : RuleType, context : Context) : ParseTreePattern;

    | Identifier
      {
        override BindExtensionRule        = (Utils.BindByHierarchy.[ExtensionRuleSymbol](baseRuleSymbol, this.Identifier, context), false);
        override BindExtensionAst         = TypingUtils.BindAstSymbolFromMappingExtension(baseAstSymbol, this.Identifier, context);
        override Typing                   = PatternTyper.TypeIdentifier(this.Location, this.Identifier.LocatedName(), ruleType, context);
      }
    | Ctor  = Identifier "(" (Pattern; "," s)* ")"
      {
        override BindExtensionRule        = (Utils.BindByHierarchy.[ExtensionRuleSymbol](baseRuleSymbol, this.Identifier, context), true);
        override BindExtensionAst         = TypingUtils.BindAstSymbolFromMappingExtension(baseAstSymbol, this.Identifier, context);
        override Typing                   = PatternTyper.TypeCtor(this.Location, this.Identifier.LocatedName(), this.Patterns.Item1, ruleType, context);
        override ExtensionTyping
        {
          def pattern = PatternTyper.TypeParseTreePattern(this.Location, ruleSymbol, this.Patterns.Item1, context);
          def variables = TypingUtils.CollectPatternVariables(pattern, context);
          (pattern, variables)
        }
      }
    | Tuple = "(" (Pattern; "," s)* ")"
      {
        override Typing       = PatternTyper.TypeTuple(this.Location, this.Patterns.Item1, ruleType, context);
        override SimpleTyping
        {
          def pattern   = PatternTyper.TypeParseTreePattern(this.Location, ruleSymbol, this.Patterns.Item1, context);
          def variables = TypingUtils.CollectPatternVariables(pattern, context);
          (pattern, variables)
        }
      }
    | List1 = Pattern ^ 10 s "::" s Pattern ^ 11
      {
        override Typing = PatternTyper.TypeList1(this.Location, this.Pattern1, this.Pattern2, ruleType, context);
      }
    | List2 = "[" (Pattern; "," s)* "]"
      {
        override Typing = PatternTyper.TypeList2(this.Location, this.Patterns.Item1, ruleType, context);
      }
  }

  syntax MapSyntaxBody
  {
    [Cached] MakeContext(parent : Context) : Context = parent;
    CollectSyntaxMappings(astSymbolRef : SymbolRef[AstSymbol], ruleSymbol : SyntaxRuleSymbol) : void;
    TypeSyntaxMappings(astSymbolRef : SymbolRef[AstSymbol], ruleSymbol : SyntaxRuleSymbol) : void;

    | Empty = ";"
      {
        override CollectSyntaxMappings = ruleSymbol.SetAst(astSymbolRef);
        override TypeSyntaxMappings
        {
          when (astSymbolRef is SymbolRef.Some(astSymbol))
          unless (ruleSymbol is ExtensibleRuleSymbol)
            TypingUtils.CheckRequiredAstProperties(astSymbol, [], this.Location, this.Context);
          def body = SyntaxMappingBody.PerField(this.Location, astSymbolRef, []);
          ruleSymbol.SetSyntaxMappingBody(body);
        }
      }
    | Inline = sm "=" sm Expr=MapSyntaxExpression
      {
        override CollectSyntaxMappings = ruleSymbol.SetAst(astSymbolRef);
        override TypeSyntaxMappings
        {
          def code = NemerleParser.Parse(this.Expr, this.Context);
          def body = SyntaxMappingBody.Inline(this.Location, astSymbolRef, code);
          ruleSymbol.SetSyntaxMappingBody(body);
        }
      }
    | PerMember = outline_begin_before nl OpenBrace="{" inl Members=MapSyntaxBodyMember* d CloseBrace="}" outline_end_before nl
      {
        override MakeContext = PassThrough(Members, parent, _.MakeContext(_));
        override CollectSyntaxMappings
        {
          ruleSymbol.SetAst(astSymbolRef);
          when (ruleSymbol is ExtensibleRuleSymbol as baseRuleSymbol)
          {
            def simpleMappings   = List();
            def matchingMappings = HashSet();

            foreach (member in Members)
              member.CollectExtensionMappings(astSymbolRef, baseRuleSymbol, simpleMappings, matchingMappings);

            foreach ((extensionRuleSymbol, extensionAstSymbolRef) in simpleMappings)
              extensionRuleSymbol.SetAst(extensionAstSymbolRef);

            foreach (extensionRuleSymbol in matchingMappings)
              extensionRuleSymbol.SetAst(astSymbolRef);
          }
        }
        override TypeSyntaxMappings
        {
          if (ruleSymbol is ExtensibleRuleSymbol as baseRuleSymbol)
          {
            ruleSymbol.SetSyntaxMappingBody(SyntaxMappingBody.PerField(this.Location, astSymbolRef, []));

            def mappingCases  = List();
            def mappingBodies = List();
            foreach (member in Members)
              member.CollectExtensionBodies(astSymbolRef, baseRuleSymbol, mappingCases, mappingBodies);

            foreach ((extensionRuleSymbol, body) in mappingBodies)
              extensionRuleSymbol.SetSyntaxMappingBody(body);

            foreach (item in mappingCases.GroupBy(tup => tup[0], tup => tup[1]))
            {
              def extensionRuleSymbol = item.Key;
              def mappingCases        = NList.ToList(item);
              def body                = SyntaxMappingBody.Match(this.Location, astSymbolRef, mappingCases);
              extensionRuleSymbol.SetSyntaxMappingBody(body)
            }
          }
          else
          {
            def mappingFields = List();
            foreach (member in Members)
              member.CollectMappingFields(astSymbolRef, ruleSymbol, mappingFields);

            def mappingCases = List();
            foreach (member in Members)
              member.CollectSimpleMatchCases(astSymbolRef, ruleSymbol, mappingFields, mappingCases);

            def body =
              if (mappingCases.Count > 0)
                SyntaxMappingBody.Match(this.Location, astSymbolRef, mappingCases.ToNList())
              else
              {
                when (astSymbolRef is SymbolRef.Some(astSymbol))
                {
                  def errorLoc = Location(this.Location.Source, this.CloseBrace);
                  TypingUtils.CheckRequiredAstProperties(astSymbol, mappingFields, errorLoc, this.Context);
                }
                SyntaxMappingBody.PerField(this.Location, astSymbolRef, mappingFields.ToNList());
              }

            ruleSymbol.SetSyntaxMappingBody(body)
          }
        }
      }
  }

  syntax TokenRule = RuleAttributes "token" sm Name sm "=" sm RuleExpression SimpleRuleBody
  {
    [Cached] private MakeSymbol(owner : IRuleDeclarationSite) : ParsedTokenRuleSymbol = ParsedTokenRuleSymbol(this, owner);
    CollectGlobalSymbols(owner : IRuleDeclarationSite) : void
    {
      def symbol = MakeSymbol(owner);
      _ = owner.Node.AddAndReport.[RuleDefSymbol](symbol, Location);
      SimpleRuleBody.CollectGlobalSymbols(symbol);
    }
    MakeContext(parent : Context) : Context
    {
      def context = RuleDeclarationSiteContext(parent, this.Symbol);
      _ = RuleAttributes.MakeContext(context);
      _ = SimpleRuleBody.MakeContext(context);
      parent
    }
    [Cached] private MakeTypedRule()   : Rule.Sequence = TypeRuleExpression(this.Symbol.Options, SimpleRuleBody.Context, RuleExpression.Typing(None(), 0, None(), SimpleRuleBody.Context, this.Symbol.Options));
    CollectSyntaxMappings() : void = SimpleRuleBody.CollectSyntaxMappings(this.Symbol);
    TypeSyntaxMappings() : void = SimpleRuleBody.TypeSyntaxMappings(this.Symbol);
    Typing() : void
    {
      _ = MakeTypedRule();
      SimpleRuleBody.Typing(this.Symbol);
    }
  }

  syntax RegexRule = RuleAttributes "regex" sm Name sm "=" sm RegexExpression RegexRuleBody
  {
    [Cached] private MakeSymbol(owner : IRuleDeclarationSite) : ParsedRegularRuleSymbol = ParsedRegularRuleSymbol(this, owner);
    CollectGlobalSymbols(owner : IRuleDeclarationSite) : void
    {
      def symbol = MakeSymbol(owner);
      _ = owner.Node.AddAndReport.[RuleDefSymbol](symbol, Location);
      RegexRuleBody.CollectGlobalSymbols(symbol);
    }
    MakeContext(parent : Context) : Context
    {
      def context = RuleDeclarationSiteContext(parent, Symbol);
      _ = RuleAttributes.MakeContext(context);
      _ = RegexExpression.MakeContext(context);
      _ = RegexRuleBody.MakeContext(context);
      parent
    }
    [Cached] private Regex() : RegularRule      = RegexExpression.Typing();
    CollectSyntaxMappings() : void = RegexRuleBody.CollectSyntaxMappings();
    TypeSyntaxMappings() : void = RegexRuleBody.TypeSyntaxMappings();
    Typing() : void
    {
      _ = Regex();
      RegexRuleBody.Typing();
    }
  }

  syntax RegexRuleBody
  {
    CollectGlobalSymbols(ruleSymbol : RegularRuleSymbol) : void = _ = ruleSymbol;
    [Cached] MakeContext(parent : Context) : Context = parent;
    GetLastLocation() : Nitra.Location;
    CollectSyntaxMappings() : void { }
    TypeSyntaxMappings() : void { }
    Typing() : void { }

    | Empty = ";"nl
      {
        override GetLastLocation = MakeLastLocation(this, Semicolon);
      }
    | Block = outline_begin_before nl "{" inl RegexRuleBodyMember* d "}" outline_end_before nl
      {
        override CollectGlobalSymbols = foreach (member in RegexRuleBodyMembers) member.CollectGlobalSymbols(ruleSymbol);
        override MakeContext = FoldThrough(RegexRuleBodyMembers, parent, _.MakeContext(_));
        override GetLastLocation = MakeLastLocation(this, OpenBrace);
        override CollectSyntaxMappings = foreach (x in RegexRuleBodyMembers) x.CollectSyntaxMappings();
        override TypeSyntaxMappings = foreach (x in RegexRuleBodyMembers) x.TypeSyntaxMappings();
        override Typing = foreach (x in RegexRuleBodyMembers) x.Typing();
      }
  }

  syntax RegexRuleBodyMember
  {
    CollectGlobalSymbols(ruleSymbol : RegularRuleSymbol) : void = _ = ruleSymbol;
    [Cached] MakeContext(parent : Context) : Context = parent;
    CollectSyntaxMappings() : void { }
    TypeSyntaxMappings() : void { }
    Typing() : void { }

    | RuleAlias
      {
        override MakeContext = RuleAlias.MakeContext(parent);
      }
    | RegexRule
      {
        override CollectGlobalSymbols = RegexRule.CollectGlobalSymbols(ruleSymbol);
        override MakeContext          = RegexRule.MakeContext(parent);
        override CollectSyntaxMappings = RegexRule.CollectSyntaxMappings();
        override TypeSyntaxMappings   = RegexRule.TypeSyntaxMappings();
        override Typing               = RegexRule.Typing();
      }
    | TokenRule
      {
        override CollectGlobalSymbols = TokenRule.CollectGlobalSymbols(ruleSymbol);
        override MakeContext          = TokenRule.MakeContext(parent);
        override CollectSyntaxMappings = TokenRule.CollectSyntaxMappings();
        override TypeSyntaxMappings   = TokenRule.TypeSyntaxMappings();
        override Typing               = TokenRule.Typing();
      }
  }

  syntax SimpleRule = RuleAttributes "syntax" sm Name sm "=" sm RuleExpression SimpleRuleBody
  {
    [Cached] private MakeSymbol(owner : IRuleDeclarationSite) : ParsedSimpleRuleSymbol = ParsedSimpleRuleSymbol(this, owner);
    CollectGlobalSymbols(owner : IRuleDeclarationSite) : void
    {
      def symbol = MakeSymbol(owner);
      _ = owner.Node.AddAndReport.[RuleDefSymbol](symbol, Location);
      SimpleRuleBody.CollectGlobalSymbols(symbol);
    }
    MakeContext(parent : Context) : Context
    {
      def context = RuleDeclarationSiteContext(parent, Symbol);
      _ = RuleAttributes.MakeContext(context);
      _ = SimpleRuleBody.MakeContext(context);
      parent
    }
    [Cached] private MakeTypedRule()   : Rule.Sequence = TypeRuleExpression(this.Symbol.Options, SimpleRuleBody.Context, RuleExpression.Typing(None(), 0, None(), SimpleRuleBody.Context, this.Symbol.Options));
    CollectSyntaxMappings() : void = SimpleRuleBody.CollectSyntaxMappings(this.Symbol);
    TypeSyntaxMappings() : void = SimpleRuleBody.TypeSyntaxMappings(this.Symbol);
    Typing() : void
    {
      _ = MakeTypedRule();
      SimpleRuleBody.Typing(Symbol);
    }
  }

  syntax VoidRule = RuleAttributes "void" sm Name sm "=" sm RuleExpression SimpleRuleBody
  {
    [Cached] private MakeSymbol(owner : IRuleDeclarationSite) : ParsedVoidRuleSymbol = ParsedVoidRuleSymbol(this, owner);
    CollectGlobalSymbols(owner : IRuleDeclarationSite) : void
    {
      def symbol = MakeSymbol(owner);
      _ = owner.Node.AddAndReport.[RuleDefSymbol](symbol, Location);
      SimpleRuleBody.CollectGlobalSymbols(symbol);
    }
    MakeContext(parent : Context) : Context
    {
      def context = RuleDeclarationSiteContext(parent, Symbol);
      _ = RuleAttributes.MakeContext(context);
      _ = SimpleRuleBody.MakeContext(context);
      parent
    }
    [Cached] private MakeTypedRule()   : Rule.Sequence = TypeRuleExpression(this.Symbol.Options, SimpleRuleBody.Context, RuleExpression.Typing(None(), 0, None(), SimpleRuleBody.Context, this.Symbol.Options));
    CollectSyntaxMappings() : void = SimpleRuleBody.CollectSyntaxMappings(this.Symbol);
    TypeSyntaxMappings() : void = SimpleRuleBody.TypeSyntaxMappings(this.Symbol);
    Typing() : void
    {
      _ = MakeTypedRule();
      SimpleRuleBody.Typing(Symbol);
    }
  }

  syntax SimpleRuleBody
  {
    CollectGlobalSymbols(ruleSymbol : SimpleRuleSymbol) : void = _ = ruleSymbol;
    [Cached] MakeContext(parent : Context) : Context = parent;
    GetLastLocation() : Nitra.Location;
    CollectSyntaxMappings(ruleSymbol : SimpleRuleSymbol) : void { _ = ruleSymbol }
    TypeSyntaxMappings(ruleSymbol : SimpleRuleSymbol) : void { _ = ruleSymbol }
    Typing(ruleSymbol : SimpleRuleSymbol) : void { _ = ruleSymbol }

    | Empty = ";"nl
      {
        override GetLastLocation = MakeLastLocation(this, Semicolon);
      }
    | Block = outline_begin_before nl "{" inl SimpleRuleBodyMember* d "}" outline_end_before nl
      {
        override CollectGlobalSymbols = foreach (member in SimpleRuleBodyMembers) member.CollectGlobalSymbols(ruleSymbol);
        override MakeContext = FoldThrough(SimpleRuleBodyMembers, parent, _.MakeContext(_));
        override GetLastLocation = MakeLastLocation(this, OpenBrace);
        override CollectSyntaxMappings = foreach (x in SimpleRuleBodyMembers) x.CollectSyntaxMappings(ruleSymbol);
        override TypeSyntaxMappings = foreach (x in SimpleRuleBodyMembers) x.TypeSyntaxMappings(ruleSymbol);
        override Typing = foreach (x in SimpleRuleBodyMembers) x.Typing(ruleSymbol);
      }
  }

  syntax SimpleRuleBodyMember
  {
    CollectGlobalSymbols(ruleSymbol : SimpleRuleSymbol) : void = _ = ruleSymbol;
    [Cached] MakeContext(parent : Context) : Context = parent;
    CollectSyntaxMappings(_ruleSymbol : SimpleRuleSymbol) : void {}
    TypeSyntaxMappings(_ruleSymbol : SimpleRuleSymbol) : void {}
    Typing(_ruleSymbol : SimpleRuleSymbol) : void { }

    | RuleAlias
      {
        override MakeContext = RuleAlias.MakeContext(parent);
      }
    | RegexRule
      {
        override CollectGlobalSymbols = RegexRule.CollectGlobalSymbols(ruleSymbol);
        override MakeContext          = RegexRule.MakeContext(parent);
        override CollectSyntaxMappings = RegexRule.CollectSyntaxMappings();
        override TypeSyntaxMappings   = RegexRule.TypeSyntaxMappings();
        override Typing               = RegexRule.Typing();
      }
    | TokenRule
      {
        override CollectGlobalSymbols = TokenRule.CollectGlobalSymbols(ruleSymbol);
        override MakeContext          = TokenRule.MakeContext(parent);
        override CollectSyntaxMappings = TokenRule.CollectSyntaxMappings();
        override TypeSyntaxMappings   = TokenRule.TypeSyntaxMappings();
        override Typing               = TokenRule.Typing();
      }
    | VoidRule
      {
        override CollectGlobalSymbols = VoidRule.CollectGlobalSymbols(ruleSymbol);
        override MakeContext          = VoidRule.MakeContext(parent);
        override CollectSyntaxMappings = VoidRule.CollectSyntaxMappings();
        override TypeSyntaxMappings   = VoidRule.TypeSyntaxMappings();
        override Typing               = VoidRule.Typing();
      }
    | SimpleRule
      {
        override CollectGlobalSymbols = SimpleRule.CollectGlobalSymbols(ruleSymbol);
        override MakeContext          = SimpleRule.MakeContext(parent);
        override CollectSyntaxMappings = SimpleRule.CollectSyntaxMappings();
        override TypeSyntaxMappings   = SimpleRule.TypeSyntaxMappings();
        override Typing               = SimpleRule.Typing();
      }
    | ExtensibleTokenRule
      {
        override CollectGlobalSymbols = ExtensibleTokenRule.CollectGlobalSymbols(ruleSymbol);
        override MakeContext          = ExtensibleTokenRule.MakeContext(parent);
        override CollectSyntaxMappings = ExtensibleTokenRule.CollectSyntaxMappings();
        override TypeSyntaxMappings   = ExtensibleTokenRule.TypeSyntaxMappings();
        override Typing               = ExtensibleTokenRule.Typing();
      }
    | ExtensibleRule
      {
        override CollectGlobalSymbols = ExtensibleRule.CollectGlobalSymbols(ruleSymbol);
        override MakeContext          = ExtensibleRule.MakeContext(parent);
        override CollectSyntaxMappings = ExtensibleRule.CollectSyntaxMappings();
        override TypeSyntaxMappings   = ExtensibleRule.TypeSyntaxMappings();
        override Typing               = ExtensibleRule.Typing();
      }
    | RuleMethod
      {
        override CollectGlobalSymbols = RuleMethod.CollectGlobalSymbols(ruleSymbol);
        override MakeContext          = RuleMethod.MakeContext(parent);
        override Typing               = RuleMethod.Typing();
      }
    | RuleMethodOverride
      {
        override CollectGlobalSymbols = RuleMethodOverride.CollectGlobalSymbols(ruleSymbol);
        override MakeContext          = RuleMethodOverride.MakeContext(parent);
        override Typing               = RuleMethodOverride.Typing();
      }
    | RuleMethodMissing
      {
        override CollectGlobalSymbols = RuleMethodMissing.CollectGlobalSymbols(ruleSymbol);
        override MakeContext          = RuleMethodMissing.MakeContext(parent);
        override Typing               = RuleMethodMissing.Typing();
      }
    | MapSyntax = "map" sm AstName=QualifiedName MapSyntaxBody
      {
        override MakeContext
        {
          def context = MapSyntaxContext(parent);
          _ = MapSyntaxBody.MakeContext(context);
          context
        }
        [Cached] private MakeAstSymbolRef() : SymbolRef[AstSymbol] = this.Context.Bind.[AstSymbol](AstName);
        override CollectSyntaxMappings = MapSyntaxBody.CollectSyntaxMappings(MakeAstSymbolRef(), _ruleSymbol);
        override TypeSyntaxMappings    = MapSyntaxBody.TypeSyntaxMappings(MakeAstSymbolRef(), _ruleSymbol);
      }
  }

  syntax ExtensibleRule = RuleAttributes "syntax"  sm Name ExtensibleRuleBody
  {
    [Cached] private MakeSymbol(owner : IRuleDeclarationSite) : ParsedExtensibleRuleSymbol = ParsedExtensibleRuleSymbol(this, owner);
    CollectGlobalSymbols(owner : IRuleDeclarationSite) : void
    {
      def symbol = MakeSymbol(owner);
      _ = owner.Node.AddAndReport.[RuleDefSymbol](symbol, Location);
      ExtensibleRuleBody.CollectGlobalSymbols(symbol);
    }
    MakeContext(parent : Context) : Context
    {
      def context = RuleDeclarationSiteContext(parent, Symbol);
      _ = RuleAttributes.MakeContext(context);
      _ = ExtensibleRuleBody.MakeContext(context);
      parent
    }
    CollectSyntaxMappings() : void = ExtensibleRuleBody.CollectSyntaxMappings(this.Symbol);
    TypeSyntaxMappings() : void = ExtensibleRuleBody.TypeSyntaxMappings(this.Symbol);
    Typing() : void
    {
      _ = ExtensibleRuleBody.Typing(ExtensibleRuleRef.Some(Name.Location, false, Symbol));
    }
  }

  syntax ExtensibleTokenRule = RuleAttributes "token"  sm Name ExtensibleRuleBody
  {
    [Cached] private MakeSymbol(owner : IRuleDeclarationSite) : ParsedExtensibleTokenRuleSymbol = ParsedExtensibleTokenRuleSymbol(this, owner);
    CollectGlobalSymbols(owner : IRuleDeclarationSite) : void
    {
      def symbol = MakeSymbol(owner);
      _ = owner.Node.AddAndReport.[RuleDefSymbol](symbol, Location);
      ExtensibleRuleBody.CollectGlobalSymbols(symbol);
    }
    MakeContext(parent : Context) : Context
    {
      def context = RuleDeclarationSiteContext(parent, Symbol);
      _ = RuleAttributes.MakeContext(context);
      _ = ExtensibleRuleBody.MakeContext(context);
      parent
    }
    CollectSyntaxMappings() : void = ExtensibleRuleBody.CollectSyntaxMappings(this.Symbol);
    TypeSyntaxMappings() : void = ExtensibleRuleBody.TypeSyntaxMappings(this.Symbol);
    Typing() : void
    {
      _ = ExtensibleRuleBody.Typing(ExtensibleRuleRef.Some(Name.Location, false, this.Symbol));
    }
  }

  syntax ExtensibleRuleBody
  {
    CollectGlobalSymbols(ruleSymbol : ExtensibleRuleSymbol) : void = _ = ruleSymbol;
    [Cached] MakeContext(parent : Context) : Context = parent;
    GetLastLocation() : Nitra.Location;
    CollectSyntaxMappings(_ruleSymbol : ExtensibleRuleSymbol) : void { }
    TypeSyntaxMappings(_ruleSymbol : ExtensibleRuleSymbol) : void { }
    Typing(_baseRule : ExtensibleRuleRef) : void { }

    | Empty = ";"nl
      {
        override GetLastLocation = MakeLastLocation(this, Semicolon);
      }
    | Block = outline_begin_before nl "{" inl ExtensibleRuleBodyMember* d "}" outline_end_before nl
      {
        override CollectGlobalSymbols = foreach (member in ExtensibleRuleBodyMembers) member.CollectGlobalSymbols(ruleSymbol);
        override MakeContext = FoldThrough(ExtensibleRuleBodyMembers, parent, _.MakeContext(_));
        override GetLastLocation = MakeLastLocation(this, OpenBrace);
        override CollectSyntaxMappings = foreach (x in ExtensibleRuleBodyMembers) x.CollectSyntaxMappings(_ruleSymbol);
        override TypeSyntaxMappings = foreach (x in ExtensibleRuleBodyMembers) x.TypeSyntaxMappings(_ruleSymbol);
        override Typing = foreach (x in ExtensibleRuleBodyMembers) x.Typing(_baseRule);
      }
  }

  syntax ExtensibleRuleBodyMember
  {
    CollectGlobalSymbols(ruleSymbol : ExtensibleRuleSymbol) : void = _ = ruleSymbol;
    [Cached] MakeContext(parent : Context) : Context = parent;
    CollectSyntaxMappings(_ruleSymbol : ExtensibleRuleSymbol) : void { }
    TypeSyntaxMappings(_ruleSymbol : ExtensibleRuleSymbol) : void { }
    Typing(_baseRule : ExtensibleRuleRef) : void { }

    | RuleAlias
      {
        override MakeContext = RuleAlias.MakeContext(parent);
      }
    | RegexRule
      {
        override CollectGlobalSymbols = RegexRule.CollectGlobalSymbols(ruleSymbol);
        override MakeContext          = RegexRule.MakeContext(parent);
        override CollectSyntaxMappings = RegexRule.CollectSyntaxMappings();
        override TypeSyntaxMappings   = RegexRule.TypeSyntaxMappings();
        override Typing               = RegexRule.Typing();
      }
    | TokenRule
      {
        override CollectGlobalSymbols = TokenRule.CollectGlobalSymbols(ruleSymbol);
        override MakeContext          = TokenRule.MakeContext(parent);
        override CollectSyntaxMappings = TokenRule.CollectSyntaxMappings();
        override TypeSyntaxMappings   = TokenRule.TypeSyntaxMappings();
        override Typing               = TokenRule.Typing();
      }
    | VoidRule
      {
        override CollectGlobalSymbols = VoidRule.CollectGlobalSymbols(ruleSymbol);
        override MakeContext          = VoidRule.MakeContext(parent);
        override CollectSyntaxMappings = VoidRule.CollectSyntaxMappings();
        override TypeSyntaxMappings   = VoidRule.TypeSyntaxMappings();
        override Typing               = VoidRule.Typing();
      }
    | SimpleRule
      {
        override CollectGlobalSymbols = SimpleRule.CollectGlobalSymbols(ruleSymbol);
        override MakeContext          = SimpleRule.MakeContext(parent);
        override CollectSyntaxMappings = SimpleRule.CollectSyntaxMappings();
        override TypeSyntaxMappings   = SimpleRule.TypeSyntaxMappings();
        override Typing               = SimpleRule.Typing();
      }
    | ExtensibleTokenRule
      {
        override CollectGlobalSymbols = ExtensibleTokenRule.CollectGlobalSymbols(ruleSymbol);
        override MakeContext          = ExtensibleTokenRule.MakeContext(parent);
        override CollectSyntaxMappings = ExtensibleTokenRule.CollectSyntaxMappings();
        override TypeSyntaxMappings   = ExtensibleTokenRule.TypeSyntaxMappings();
        override Typing               = ExtensibleTokenRule.Typing();
      }
    | ExtensibleRule
      {
        override CollectGlobalSymbols = ExtensibleRule.CollectGlobalSymbols(ruleSymbol);
        override MakeContext          = ExtensibleRule.MakeContext(parent);
        override CollectSyntaxMappings = ExtensibleRule.CollectSyntaxMappings();
        override TypeSyntaxMappings   = ExtensibleRule.TypeSyntaxMappings();
        override Typing               = ExtensibleRule.Typing();
      }
    | ExtensionRule
      {
        override CollectGlobalSymbols = ExtensionRule.CollectGlobalSymbols(ruleSymbol);
        override MakeContext          = ExtensionRule.MakeContext(parent);
        override CollectSyntaxMappings = ExtensionRule.CollectSyntaxMappings();
        override TypeSyntaxMappings   = ExtensionRule.TypeSyntaxMappings();
        override Typing               = ExtensionRule.Typing(_baseRule);
      }
    | RuleMethod
      {
        override CollectGlobalSymbols = RuleMethod.CollectGlobalSymbols(ruleSymbol);
        override MakeContext          = RuleMethod.MakeContext(parent);
        override Typing               = RuleMethod.Typing();
      }
    | RuleMethodOverride
      {
        override CollectGlobalSymbols = RuleMethodOverride.CollectGlobalSymbols(ruleSymbol);
        override MakeContext          = RuleMethodOverride.MakeContext(parent);
        override Typing               = RuleMethodOverride.Typing();
      }
    | RuleMethodMissing
      {
        override CollectGlobalSymbols = RuleMethodMissing.CollectGlobalSymbols(ruleSymbol);
        override MakeContext          = RuleMethodMissing.MakeContext(parent);
        override Typing               = RuleMethodMissing.Typing();
      }
    | MapSyntax = "map" sm AstName=QualifiedName MapSyntaxBody
      {
        override MakeContext
        {
          def context = MapSyntaxContext(parent);
          _ = MapSyntaxBody.MakeContext(context);
          context
        }
        [Cached] private MakeAstSymbolRef() : SymbolRef[AstSymbol] = this.Context.Bind.[AstSymbol](AstName);
        override CollectSyntaxMappings = MapSyntaxBody.CollectSyntaxMappings(MakeAstSymbolRef(), _ruleSymbol);
        override TypeSyntaxMappings    = MapSyntaxBody.TypeSyntaxMappings(MakeAstSymbolRef(), _ruleSymbol);
      }
  }

  syntax ExtensionRule = "|" sm RuleAttributes (Name "=")? RuleExpression Precedence? ExtensionRuleBody?
  {
    [Cached] private MakeSymbol(owner : IRuleDeclarationSite) : ParsedExtensionRuleSymbol = ParsedExtensionRuleSymbol(this, owner);
    CollectGlobalSymbols(owner : IRuleDeclarationSite) : void
    {
      def symbol = MakeSymbol(owner);
      _ = owner.Node.AddAndReport.[RuleDefSymbol](symbol, Location);
      when (ExtensionRuleBodyOpt.HasValue)
        ExtensionRuleBodyOpt.Value.CollectGlobalSymbols(symbol);
    }
    [Cached] MakeContext(parent : Context) : Context
    {
      def context = RuleDeclarationSiteContext(parent, Symbol);
      _ = RuleAttributes.MakeContext(context);
      _ = MakeRuleTypingContext(context);
      parent
    }
    [Cached] private MakeRuleTypingContext(parent : Context) : Context
    {
      if (ExtensionRuleBodyOpt.HasValue)
        ExtensionRuleBodyOpt.Value.MakeContext(parent)
      else
        parent
    }
    [Cached] private MakeBaseRuleRef(baseRule : ExtensibleRuleRef)  : ExtensibleRuleRef     = baseRule;
    [Cached] private MakeTypedRule()                                : Rule.Sequence         = TypeRuleExpression(this.Symbol.Options, RuleTypingContext, RuleExpression.Typing(BaseRuleRef, PrecedenceOpt.Map(_.Value()) ?? 0, None(), RuleTypingContext, this.Symbol.Options));
    CollectSyntaxMappings() : void
    {
      when (ExtensionRuleBodyOpt.HasValue)
        ExtensionRuleBodyOpt.Value.CollectSyntaxMappings(this.Symbol);
    }
    TypeSyntaxMappings() : void
    {
      TypingUtils.ValidateExtensionRuleAstMapping(this.Symbol, this.Context);
      when (ExtensionRuleBodyOpt.HasValue)
        ExtensionRuleBodyOpt.Value.TypeSyntaxMappings(this.Symbol);
    }
    Typing(baseRule : ExtensibleRuleRef) : void
    {
      _ = MakeBaseRuleRef(baseRule);
      _ = MakeTypedRule();
      when (this.Symbol.Options.OperatorInfo == OperatorInfo.None && baseRule.IsSome)
        TryInferOperatorType(this.Symbol);
      when (ExtensionRuleBodyOpt.HasValue)
        ExtensionRuleBodyOpt.Value.Typing(BaseRuleRef, this.Symbol);
    }
  }

  syntax ExtensionRuleBody
  {
    CollectGlobalSymbols(ruleSymbol : ExtensionRuleSymbol) : void = _ = ruleSymbol;
    [Cached] MakeContext(parent : Context) : Context = parent;
    GetLastLocation() : Nitra.Location;
    CollectSyntaxMappings(_ruleSymbol : ExtensionRuleSymbol) : void { }
    TypeSyntaxMappings(_ruleSymbol : ExtensionRuleSymbol) : void { }
    Typing(_baseRule : ExtensibleRuleRef, _ruleSymbol : ExtensionRuleSymbol) : void { }

    | Empty = ";"nl
      {
        override GetLastLocation = MakeLastLocation(this, Semicolon);
      }
    | Block = outline_hiden outline_begin_before inl "{" inl ExtensionRuleBodyMember* d "}" outline_end_before nl  d
      {
        override CollectGlobalSymbols = foreach (member in ExtensionRuleBodyMembers) member.CollectGlobalSymbols(ruleSymbol);
        override MakeContext          = FoldThrough(ExtensionRuleBodyMembers, parent, _.MakeContext(_));
        override GetLastLocation      = MakeLastLocation(this, OpenBrace);
        override CollectSyntaxMappings = foreach (x in ExtensionRuleBodyMembers) x.CollectSyntaxMappings(_ruleSymbol);
        override TypeSyntaxMappings   = foreach (x in ExtensionRuleBodyMembers) x.TypeSyntaxMappings(_ruleSymbol);
        override Typing               = foreach (x in ExtensionRuleBodyMembers) x.Typing(_baseRule, _ruleSymbol);
      }
  }

  syntax ExtensionRuleBodyMember
  {
    CollectGlobalSymbols(ruleSymbol : ExtensionRuleSymbol) : void = _ = ruleSymbol;
    [Cached] MakeContext(parent : Context) : Context = parent;
    CollectSyntaxMappings(_ruleSymbol : ExtensionRuleSymbol) : void { }
    TypeSyntaxMappings(_ruleSymbol : ExtensionRuleSymbol) : void { }
    Typing(_baseRule : ExtensibleRuleRef, _ruleSymbol : ExtensionRuleSymbol) : void { }

    | RuleAlias
      {
        override MakeContext = RuleAlias.MakeContext(parent);
      }
    | RegexRule
      {
        override CollectGlobalSymbols = RegexRule.CollectGlobalSymbols(ruleSymbol);
        override MakeContext          = RegexRule.MakeContext(parent);
        override CollectSyntaxMappings = RegexRule.CollectSyntaxMappings();
        override TypeSyntaxMappings   = RegexRule.TypeSyntaxMappings();
        override Typing               = RegexRule.Typing();
      }
    | TokenRule
      {
        override CollectGlobalSymbols = TokenRule.CollectGlobalSymbols(ruleSymbol);
        override MakeContext          = TokenRule.MakeContext(parent);
        override CollectSyntaxMappings = TokenRule.CollectSyntaxMappings();
        override TypeSyntaxMappings   = TokenRule.TypeSyntaxMappings();
        override Typing               = TokenRule.Typing();
      }
    | VoidRule
      {
        override CollectGlobalSymbols = VoidRule.CollectGlobalSymbols(ruleSymbol);
        override MakeContext          = VoidRule.MakeContext(parent);
        override CollectSyntaxMappings = VoidRule.CollectSyntaxMappings();
        override TypeSyntaxMappings   = VoidRule.TypeSyntaxMappings();
        override Typing               = VoidRule.Typing();
      }
    | SimpleRule
      {
        override CollectGlobalSymbols = SimpleRule.CollectGlobalSymbols(ruleSymbol);
        override MakeContext          = SimpleRule.MakeContext(parent);
        override CollectSyntaxMappings = SimpleRule.CollectSyntaxMappings();
        override TypeSyntaxMappings   = SimpleRule.TypeSyntaxMappings();
        override Typing               = SimpleRule.Typing();
      }
    | ExtensibleTokenRule
      {
        override CollectGlobalSymbols = ExtensibleTokenRule.CollectGlobalSymbols(ruleSymbol);
        override MakeContext          = ExtensibleTokenRule.MakeContext(parent);
        override CollectSyntaxMappings = ExtensibleTokenRule.CollectSyntaxMappings();
        override TypeSyntaxMappings   = ExtensibleTokenRule.TypeSyntaxMappings();
        override Typing               = ExtensibleTokenRule.Typing();
      }
    | ExtensibleRule
      {
        override CollectGlobalSymbols = ExtensibleRule.CollectGlobalSymbols(ruleSymbol);
        override MakeContext          = ExtensibleRule.MakeContext(parent);
        override CollectSyntaxMappings = ExtensibleRule.CollectSyntaxMappings();
        override TypeSyntaxMappings   = ExtensibleRule.TypeSyntaxMappings();
        override Typing               = ExtensibleRule.Typing();
      }
    | RuleMethod
      {
        override CollectGlobalSymbols = RuleMethod.CollectGlobalSymbols(ruleSymbol);
        override MakeContext          = RuleMethod.MakeContext(parent);
        override Typing               = RuleMethod.Typing();
      }
    | RuleMethodOverride
      {
        override CollectGlobalSymbols = RuleMethodOverride.CollectGlobalSymbols(ruleSymbol);
        override MakeContext          = RuleMethodOverride.MakeContext(parent);
        override Typing               = RuleMethodOverride.Typing();
      }
    | RuleMethodMissing
      {
        override CollectGlobalSymbols = RuleMethodMissing.CollectGlobalSymbols(ruleSymbol);
        override MakeContext          = RuleMethodMissing.MakeContext(parent);
        override Typing               = RuleMethodMissing.Typing();
      }
    | MapSyntax = "map" sm AstName=QualifiedName MapSyntaxBody
      {
        [Cached] private MakeAstSymbolRef() : SymbolRef[AstSymbol] = this.Context.Bind.[AstSymbol](AstName);
        override MakeContext
        {
          def context = MapSyntaxContext(parent);
          _ = MapSyntaxBody.MakeContext(context);
          context
        }
        override CollectSyntaxMappings = MapSyntaxBody.CollectSyntaxMappings(MakeAstSymbolRef(), _ruleSymbol);
        override TypeSyntaxMappings    = MapSyntaxBody.TypeSyntaxMappings(MakeAstSymbolRef(), _ruleSymbol);
      }
  }

  syntax RuleMethodsParam = Name sm ":" sm Type=NitraType
  {
    Typing(context : Context) : RuleMethod.RuleMethodParameter = RuleMethod.RuleMethodParameter(this.Location, this.Name.LocatedName(), this.Type.Typing(context)[0]);
  }

  token RuleMethodPrivate = "private" sm;

  syntax RuleMethodAttribute
  {
    IsCached() : bool;

    | Cached = AttributeName="Cached"
      {
        override IsCached = true;
      }
  }
  syntax RuleMethodAttributeList = "[" (RuleMethodAttribute; ",")+ "]" nl
  {
    IsCached() : bool
    {
      foreach(x when x.IsCached() in RuleMethodAttributes.Item1)
        return true;
      false
    }
  }
  syntax RuleMethodAttributes = RuleMethodAttributeList*
  {
    IsCached() : bool
    {
      foreach(x when x.IsCached() in RuleMethodAttributeLists)
        return true;
      false
    }
  }

  syntax RuleMethod = RuleMethodAttributes RuleMethodPrivate? Name sm "(" (RuleMethodsParam; "," sm)* ")" sm ":" sm Type=NitraType RuleMethodBody
  {
    [Cached] MakeContext(parent : Context) : Context = parent;
    [Cached] private MakeSymbol(ruleSymbol : SyntaxRuleSymbol, compilerMessages : ICompilerMessages) : RuleMethod.DefinitionSymbol
    {
      if (RuleMethodPrivateOpt.HasValue)
      {
        when (RuleMethodBody.IsEmpty())
          compilerMessages.Error(this, "A private rule method must have a body.");
        unless (ruleSymbol is SimpleRuleSymbol || ruleSymbol is ExtensionRuleSymbol)
          compilerMessages.Error(this, "A private rule method can be declared only in simple rules and extension rules.");
        RuleMethod.ParsedDefPrivateSymbol(this)
      }
      else if (RuleMethodBody.IsEmpty())
      {
        unless (ruleSymbol is ExtensibleRuleSymbol)
          compilerMessages.Error(this, "An abstract rule method must be defined in an extension point rule only.");
        RuleMethod.ParsedAbstractSymbol(this)
      }
      else
      {
        unless (ruleSymbol is SimpleRuleSymbol || ruleSymbol is ExtensibleRuleSymbol)
          compilerMessages.Error(this, "A public rule method must be defined in an extension point rule or a simple rule only.");
        RuleMethod.ParsedDefSymbol(this)
      }
    }
    CollectGlobalSymbols(ruleSymbol : SyntaxRuleSymbol) : void
    {
      def compilerMessages = ruleSymbol.Node.Project;
      _ = ruleSymbol.Node.AddAndReport(MakeSymbol(ruleSymbol, compilerMessages), this.Location);
    }
    [Cached] private MakeSignature() : RuleMethod.RuleMethodSignature
    {
      def context    = this.Context;
      def parameters = this.RuleMethodsParams.Item1.MapToList(_.Typing(context));
      def (type, _)  = this.Type.Typing(context);
      RuleMethod.RuleMethodSignature(this.Location, parameters, type);
    }
    [Cached] private MakeBody()      : RuleMethod.RuleMethodBody      = RuleMethod.RuleMethodBody(this.RuleMethodBody.BodyLocation(), NemerleParser.Parse(this.RuleMethodBody, Context));
    [Cached] private MakeIsCached()  : bool                           = RuleMethodAttributes.IsCached();
    Typing() : void
    {
      _ = MakeSignature();
      _ = MakeBody();
      _ = MakeIsCached();
    }
  }

  syntax RuleMethodOverride = RuleMethodAttributes "override"     sm  Name RuleMethodBody
  {
    [Cached] MakeContext(parent : Context) : Context = parent;
    [Cached] private MakeSymbol(compilerMessages : ICompilerMessages) : RuleMethod.DefinitionSymbol
    {
      when (RuleMethodBody.IsEmpty())
        compilerMessages.Error(this, "An overriding rule method must have a body.");
      RuleMethod.ParsedOverrideSymbol(this);
    }
    CollectGlobalSymbols(ruleSymbol : SyntaxRuleSymbol) : void
    {
      _ = ruleSymbol.Node.AddAndReport(MakeSymbol(ruleSymbol.Node.Project), this.Location);
    }
    [Cached] private MakeBaseRuleMethod(compilerMessages : ICompilerMessages) : SymbolRef[RuleMethod.RuleMethodSymbol]
    {
      match (this.Symbol.DeclaringRule)
      {
        | ExtensionRuleSymbol(BaseRule = SymbolRef.Some(baseRuleSymbol)) =>
          match (baseRuleSymbol.Node.BindMany.[RuleMethod.DefinitionSymbol](Name.Location))
          {
            | [RuleMethod.DefSymbol      as baseRuleMethodSymbol]
            | [RuleMethod.AbstractSymbol as baseRuleMethodSymbol] =>
              SymbolRef.Some(Name.Location, false, baseRuleMethodSymbol)

            | [_] =>
              def name = Name.Value();
              compilerMessages.Error(this, $"Cannot override '$name' rule method."); //TODO: rewrite error message!
              SymbolRef.None(Name.Location, false)

            | _ =>
              def name = Name.Value();
              compilerMessages.Error(this, $"No '$name' rule method to override.");
              SymbolRef.None(Name.Location, false)
          }

        | _ =>
          compilerMessages.Error(this, "An rule method can be overridden only in extending rules.");
          SymbolRef.None(Name.Location, false)
      }
    }
    [Cached] private MakeBody() : RuleMethod.RuleMethodBody = RuleMethod.RuleMethodBody(this.RuleMethodBody.BodyLocation(), NemerleParser.Parse(this.RuleMethodBody, Context));
    Typing() : void
    {
      _ = MakeBaseRuleMethod(this.Context);
      _ = MakeBody();
    }
  }

  syntax RuleMethodMissing = RuleMethodAttributes "missing"        sm  Name RuleMethodBody
  {
    [Cached] MakeContext(parent : Context) : Context = parent;
    [Cached] private MakeSymbol(compilerMessages : ICompilerMessages) : RuleMethod.RuleMethodMissingValueSymbol
    {
      when (RuleMethodBody.IsEmpty())
        compilerMessages.Error(this, "A 'missing' handler must have a body.");
      RuleMethod.ParsedRuleMethodMissingValueSymbol(this);
    }
    CollectGlobalSymbols(ruleSymbol : SyntaxRuleSymbol) : void
    {
      def compilerMessages = ruleSymbol.Node.Project;
      _ = ruleSymbol.Node.AddAndReport(MakeSymbol(compilerMessages), this.Location);
    }
    [Cached] private MakeHandlingRuleMethod(compilerMessages : ICompilerMessages) : SymbolRef[RuleMethod.RuleMethodSymbol]
    {
      match (this.Symbol.DeclaringRule)
      {
        | ExtensibleRuleSymbol as targetRuleSymbol
        | SimpleRuleSymbol     as targetRuleSymbol =>
          match (targetRuleSymbol.Node.BindMany.[RuleMethod.DefinitionSymbol](Name.Location))
          {
            | [ruleMethodSymbol] => SymbolRef.Some(Name.Location, false, ruleMethodSymbol)
            | _ =>
              def name = Name.Value();
              compilerMessages.Error(this, $"No '$name' rule method to handle 'missing'.");
              SymbolRef.None(Name.Location, false)
          }

        | _ =>
          compilerMessages.Error(this, "A 'missing' handler for a rule method can be defined in simple and extensible rules.");
          SymbolRef.None(Name.Location, false)
      }
    }
    [Cached] private MakeBody() : RuleMethod.RuleMethodBody = RuleMethod.RuleMethodBody(this.RuleMethodBody.BodyLocation(), NemerleParser.Parse(this.RuleMethodBody, Context));
    Typing() : void
    {
      _ = MakeHandlingRuleMethod(this.Context);
      _ = MakeBody();
    }
  }

  syntax Precedence = "precedence" sm Number RightAssociative=("right-associative")?
  {
    Value() : int = if (RightAssociative.HasValue) -Number.Value() else Number.Value();
  }

  syntax RuleMethodBody
  {
    BodyLocation() : Nitra.Location;
    IsEmpty() : bool;

    | Block
      {
        override BodyLocation = Block.Location;
        override IsEmpty = false;
      }
    | Expression = sm "=" sm Expression ";" nl
      {
        override BodyLocation = Expression.Location;
        override IsEmpty = false;
      }
    | Empty = ";" nl
      {
        override BodyLocation = this.Location.FromStart();
        override IsEmpty = true;
      }
  }

  syntax Block = outline_hiden outline_begin_before nl "{" inl (Expression; ";" nl)* ";"* nl d "}" outline_end_before nl;
  syntax Parentheses = "(" Expression? ")";

  syntax Content
  {
    | Block;
    | IgnoreToken+;
    | CharLiteral;
    | StringLiteral;
    | Parentheses;
    | "fold" sm Identifier "(" Expression ";" (Expression; ";"sm)+ ")";
  }

  syntax ExpressionContent
  {
    | Content1 = Content;
    | Content2 = (!";" !")" !"}" !Content Any)+;
  }

  syntax Expression = ExpressionContent+;

  syntax Range
  {
    RangeSet(inCharSet : RangeSet, _compilationMessages : ICompilerMessages) : RangeSet;

    | SingleChar = CharLiteral
      {
        override RangeSet = inCharSet.AddSingleCharRange(CharLiteral.Value());
      }
    | CharRange       = CharLiteral ".." CharLiteral
      {
        override RangeSet = inCharSet.AddRange(CharLiteral1.Value(), CharLiteral2.Value());
      }
    | UnicodeRange    = Name
      {
        override RangeSet
        {
          def nameText = Name.Value();
          if (UnicodeCategoryTable.StrToUnicodeCategory(nameText) is Some(cat))
            inCharSet.AddRange(cat)
          else
          {
            _compilationMessages.Error(this, $"Invalid unicode category '$nameText'.");
            inCharSet
          }
        }
      }
  }

  syntax RepeatQuantifier
  {
    Bounds() : RepeatBounds;

    | ZeroOrMany = "*"                                { override Bounds = (0,               None());                }
    | OneOrMany  = "+"                                { override Bounds = (1,               None());                }
    | UpperBound = "{" sm        "," sm Number sm "}" { override Bounds = (0,               Some(Number.Value()));  }
    | LowerBound = "{" sm Number ","           sm "}" { override Bounds = (Number.Value(),  None());                }
    | FullBounds = "{" sm Number "," sm Number sm "}" { override Bounds = (Number1.Value(), Some(Number2.Value())); }
    | Exact      = "{" sm Number               sm "}" { override Bounds { def x = Number.Value(); (x, Some(x)); }   }
  }

  alias Separator  = RegexExpression;

  syntax RegexExpression
  {
    [Cached] MakeContext(parent : Context) : Context = parent;
    [Cached] Typing() : RegularRule;

    | Choice                  = LeftRule=RegexExpression ^ 10 sm RightRules=("|" RegexExpression ^ 10)+
      {
        override MakeContext
        {
          def context1 = LeftRule.MakeContext(parent);
          def context2 = FoldThrough(RightRules, context1, (t, c) => t.Item2.MakeContext(c));
          context2
        }
        override Typing = RegularRule.Choice(Location, LeftRule.Typing() :: RightRules.Map(r => r.Item2.Typing()));
      }
    | Sequence                = LeftRule=RegexExpression ^ 20 sm RightRules=(RegexExpression ^ 20)+
      {
        override MakeContext
        {
          def context1 = LeftRule.MakeContext(parent);
          def context2 = FoldThrough(RightRules, context1, _.MakeContext(_));
          context2
        }
        override Typing = RegularRule.Sequence(Location, LeftRule.Typing() :: RightRules.Map(_.Typing()));
      }
    | Optional                = RegexExpression "?" precedence 30
      {
        override MakeContext = RegexExpression.MakeContext(parent);
        override Typing = RegularRule.Repeat(Location, 0, Some(1), this.RegexExpression.Typing());
      }
    | Repeat              = RegexExpression RepeatQuantifier precedence 30
      {
        override MakeContext = RegexExpression.MakeContext(parent);
        override Typing
        {
          def (lower, upper) = RepeatQuantifier.Bounds();
          RegularRule.Repeat(Location, lower, upper, this.RegexExpression.Typing());
        }
      }
    | Invert                  = "~" RegexExpression precedence 25
      {
        override MakeContext = RegexExpression.MakeContext(parent);
        override Typing = RegularRule.Invert(Location, this.RegexExpression.Typing());
      }
    | Subtract                = Rule1 = RegexExpression "-" Rule2 = RegexExpression precedence 22
      {
        override MakeContext = Rule2.MakeContext(Rule1.MakeContext(parent));
        override Typing = RegularRule.Subtract(Location, this.Rule1.Typing(), this.Rule2.Typing());
      }
    | Char                    = CharLiteral
      {
        override Typing = RegularRule.Chars(Location, [RangeSet().AddSingleCharRange(CharLiteral.Value())]);
      }
    | String                  = StringLiteral
      {
        override Typing = RegularRule.Chars(Location, RangeSet.MakeString(StringLiteral.Value()));
      }
    | Call                    = QualifiedName
      {
        override Typing
        {
          def ruleRef = SymbolRef.Create(QualifiedName, Context.Bind(QualifiedName));
          RegularRule.Call(Location, ruleRef)
        }
      }
    | Rounds                  = "(" RegexExpression ")"
      {
        override MakeContext = RegexExpression.MakeContext(parent);
        override Typing = RegexExpression.Typing();
      }
    | Range                   = "[" (Range; ","sm)+ "]"
      {
        override Typing
        {
          def compilerMessages = this.Context;
          RegularRule.Chars(Location, [FoldThrough(Ranges.Item1, RangeSet(), _.RangeSet(_, compilerMessages))]);
        }
      }
    | InvertedRange           = "[" "^" (Range; ","sm)+ "]"
      {
        override Typing
        {
          def compilerMessages = this.Context;
          RegularRule.Chars(Location, InvertRange(FoldThrough(Ranges.Item1, RangeSet(), _.RangeSet(_, compilerMessages))));
        }
      }
    | RepeatWithSeparator = "(" RegexExpression ";"sm Separator ")" RepeatQuantifier
      {
        override MakeContext  = parent |> RegexExpression.MakeContext |> Separator.MakeContext;
        override Typing
        {
          def (lower, upper) = RepeatQuantifier.Bounds();
          RegularRule.RepeatWithSeparator(Location, lower, upper, RegexExpression.Typing(), Separator.Typing());
        }
      }
  }

  alias Separator   = RuleExpression;

  syntax RuleExpression
  {
    /// precedence < 0 if it is right-associative
    Typing(_baseRule : option[ExtensibleRuleSymbol], _precedence : int, _fieldName : option[string], context : Context, _options : RuleDefinitionOptions) : Nitra.Model.Rule;
    InferName() : string = "";

    | Sequence                        = LeftRule=RuleExpression ^ 10 RightRules=(sm RuleExpression ^ 10)+
      {
        override Typing = TypeSequence(_baseRule, _precedence, _fieldName, context, _options, LeftRule, RightRules, this);
        override InferName = LeftRule.InferName();
      }
    | Not                             = "!" RuleExpression ^ 20
      {
        override Typing
        {
          def rule = this.RuleExpression.Typing(None(), 0, None(), context, _options);
          Rule.Not(this.Location, RuleType.Void(), "", rule);
        }
      }
    | And                             = "&" RuleExpression ^ 20
      {
        override Typing = Rule.And(this.Location, RuleType.Void(), "", RuleExpression.Typing(None(), 0, None(), context, _options));
      }
    | Optional                        = RuleExpression "?" precedence 30
      {
        override Typing
        {
          def rule  = RuleExpression.Typing(None(), 0, None(), context, _options);
          def type  = EvaluateOptionRuleType(rule);
          Rule.Repeat(this.Location, type, _fieldName ?? (rule.FieldName + "Opt"), 0, Some(1), rule);
        }
        override InferName = RuleExpression.InferName() + "Opt";
      }
    | Repeat                      = RuleExpression RepeatQuantifier precedence 30
      {
        override Typing
        {
          def rule           = RuleExpression.Typing(None(), 0, None(), context, _options);
          def type           = EvaluateListRuleType(rule);
          def (lower, upper) = RepeatQuantifier.Bounds();
          Rule.Repeat(this.Location, type, MakePlural(_fieldName, rule, context), lower, upper, rule);
        }
        override InferName = MakePlural(RuleExpression.InferName());
      }
    | FieldName1                      = RuleExpression ^ 12 sm "as" sm Name
      {
        override Typing = RuleExpression.Typing(_baseRule, _precedence, Some(Name.Value()), context, _options);
        override InferName = Name.GetText();
      }
    | FieldName2                      = Name sm "=" sm RuleExpression ^ 11
      {
        override Typing = RuleExpression.Typing(_baseRule, _precedence, Some(Name.Value()), context, _options);
        override InferName = Name.GetText();
      }
    | Char                            = CharLiteral
      {
        override Typing = StringRuleTyping(CharLiteral.Location, CharLiteral.Value().ToString(), _fieldName, context);
        override InferName = CharLiteral.Value().ToString();
      }
    | String                          = StringLiteral
      {
        override Typing = StringRuleTyping(StringLiteral.Location, StringLiteral.Value().ToString(), _fieldName, context);
        override InferName = StringLiteral.Value().ToString();
      }
    | Rounds                          = "(" RuleExpression ")"
      {
        override Typing = RuleExpression.Typing(_baseRule, _precedence, _fieldName, context, _options);
        override InferName = RuleExpression.InferName();
      }
    | Call                            = QualifiedName BindingPower=(sm "^" sm Number)?
      {
        override Typing = TypeCall(_baseRule, _precedence, _fieldName, context, _options, QualifiedName, BindingPower);
        override InferName = QualifiedName.Parts().LastOrDefault("");
      }
    | RepeatWithSeparator         = "(" RuleExpression ";"sm Separator HangingOpt=(";"sm "?")? ")" RepeatQuantifier
      {
        override Typing
        {
          def rule           = RuleExpression.Typing(None(), 0, None(), context, _options);
          def sepRule        = Separator.Typing(None(), 0, None(), context, _options);
          def type           = EvaluateListWithSeparatorRuleType(rule, sepRule);
          def (lower, upper) = RepeatQuantifier.Bounds();
          def isHanging      = HangingOpt.HasValue;
          Rule.RepeatWithSeparator(this.Location, type, MakePlural(_fieldName, rule, sepRule, context), lower, upper, rule, sepRule, isHanging);
        }
        override InferName = MakePlural(RuleExpression.InferName());
      }
  } // extend syntax RuleExpression
} // syntax module
