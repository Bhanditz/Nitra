using DotNet;

using Nitra.AstUtils;
using Nitra.Declarations;

using System.Collections.Generic;

namespace Nitra.Ast
{
  abstract declaration RuleType : Type
  {
    symbol
    {
      Kind = "rule type";
    }
  }

  abstract declaration RuleVoidType : RuleType { }

  declaration RuleVoidTypeImpl : RuleVoidType
  {
    symbol
    {
      ToString = "Void";
      ToXaml = ToString();
    }
  }
  declaration RuleListType    : RuleType
  {
    symbol
    {
      in ElemType  : RuleTypeSymbol;
      ToString = "List[" + ElemType + "]";
      ToXaml = ToString();

      DecomposeType =
        if (IsElemTypeEvaluated)
        {
          typeInfo = WellKnownSymbols.ListRuleType;
          arguments.Add(ElemType);
          true
        }
        else
          false;
    }
  }
  declaration RuleTupleType   : RuleType
  {
    symbol
    {
      in ElemTypes : IList[RuleTypeSymbol];
      ToString = string.Join(" * ", ElemTypes);
      ToXaml = ToString();

      DecomposeType =
        if (IsElemTypesEvaluated)
        {
          typeInfo = WellKnownSymbols.TupleRuleType;
          arguments.AddRange(ElemTypes);
          true
        }
        else
          false;
    }
  }
  declaration RuleOptionType  : RuleType
  {
    symbol
    {
      in ValueType : RuleTypeSymbol;
      ToString = "option(" + ValueType + ")";
      ToXaml = ToString();

      DecomposeType =
        if (IsValueTypeEvaluated)
        {
          typeInfo = WellKnownSymbols.OptionRuleType;
          arguments.Add(ValueType);
          true
        }
        else
          false;
    }
  }
  abstract declaration RuleCharsType : RuleType { }
  declaration RuleLiteralType : RuleCharsType
  {
    symbol
    {
      ToString = "Literal";
      ToXaml = ToString();
    }
  }
}
