using DotNet;

using Nitra.Runtime.Binding;
using Nemerle.Collections;

namespace Nitra.Ast
{
  using R = Nitra.Ast.RuleExpressions;
  using RX = Nitra.Ast.RegexExpressions;
  using AM = Nitra.Ast.AstMembers;

  map syntax NitraSyntax.Start -> CompilationUnit
  {
    NamespaceMembers -> Members;
  }

  map syntax NitraSyntax.NamespaceMember -> NamespaceMember
  {
    | Namespace -> ExplicitNamespace
      {
        NamespaceName.Name          -> Name;
        NamespaceName.Path(ImplicitNamespaceTag{}) -> Path;
        //ExternAliasDirectives       -> ExternAlias;
        //UsingDirectives             -> UsingDirectives;
        NamespaceBody.NamespaceMembers -> Members;
      }

    | Ast -> Nitra.Ast.TopAst          // Header Name AstInheritanceOpt Body
      {
        Name -> Name;
        match(AstInheritanceOpt) { Some(value) -> value | None() -> [] } -> TypeAst;
        Body.Members -> Members;
      }

    | MapSyntax  // RuleName ParametersOpt AstName MapSyntaxBody
      {
      }

    | SyntaxModule  // SyntaxModuleAttributes Name LanguageOpt SyntaxModuleMembers 
      {
        Name -> Name;
        Usings.Usings -> Usings;
        SyntaxModuleMembers -> Members;
      }

    | Language -> Nitra.Ast.Language   // Name ParentOpt Members
      {
        Name -> Name;
        Members -> Members;
      }

    //| Type -> TypeDeclaration
    //| ExternAliasDirective -> ExternAliasDirective
    //  {
    //    Name -> Name;
    //  }

    | UsingAlias -> UsingAliasDirective
      {
        Name          -> Name;
        NamespaceOrType -> NamespaceOrTypeName;
      }

    | UsingOpen -> UsingOpenDirective
      {
        NamespaceOrType -> NamespaceOrTypeName;
      }
  }

  map syntax NitraSyntax.AstInheritance -> QualifiedReference*
  {
    BaseAsts.Item1
  }

  map syntax NitraSyntax.Using -> SyntaxModuleUsingDirective
  {
    | UsingAlias -> SyntaxModuleUsingAliasDirective
      {
        Name -> Name;
        NamespaceOrType -> NamespaceOrTypeName;
      }

    | UsingOpen -> SyntaxModuleUsingOpenDirective
      {
        NamespaceOrType -> NamespaceOrTypeName;
      }
  }

  ast ImplicitNamespaceTag { }

  map syntax NitraSyntax.Name(_tag : ImplicitNamespaceTag) -> ImplicitNamespace
  {
    this -> Name;
  }

  map syntax NitraSyntax.QualifiedReference -> QualifiedReference
  {
    | ((first :: other, _)) -> fold (item in other; acc = Simple { first() -> Name; }; acc = Qualified { item() -> Name; Qualifier = acc;  })
    | (([],             _)) = AstUtils.CreateMissingQualifiedReference(Names.File, Names.Span);
  }

  map syntax NitraSyntax.StyleProperty -> StyleProperty
  {
    | ForegroundColor { Color = ParsedValue(Color.Span, Color.Value(Nitra.Declarations.AstContext.CompilerMessages)); }
  }

  map syntax NitraSyntax.LanguageMember -> LanguageMember
  {
    | Style -> Style // "style" sm Name sm StyleBody
      {
        Name -> Name;
      }

    | SpanClass -> StyleReference(Name) // "span" sm "class" sm Name sm MatchTokensOpt=("regex" sm RegexExpression sm)? StyleReference

    // "syntax" sm "module" sm Module=QualifiedReference RuleOpt=(sm "start" sm "rule" sm QualifiedReference)? ";"
    | SyntaxModule(_, _, m, Some((_, _, r)), _) -> StartSyntaxModuleReference
      {
        m -> Module;
        r -> Rule;
      }

    // "syntax" sm "module" sm Module=QualifiedReference RuleOpt=(sm "start" sm "rule" sm QualifiedReference)? ";"
    | SyntaxModule(_, _, m, None, _) -> AdditionSyntaxModuleReference
      {
        m -> Module;
      }

    | FileExtension { Extension = ParsedValue(Ext, GetText(Ext)); }
    | Company     { Name = ParsedValue(Name, GetText(Name)); }
    | Description { Text = ParsedValue(Text, GetText(Text)); }
    | Authors     { Text = ParsedValue(Text, GetText(Text)); }
    | Copyright   { Text = ParsedValue(Text, GetText(Text)); }
    | LicenseUrl  { Text = ParsedValue(Text, GetText(Text)); }
    | RequireLicenseAcceptance { }
  }

  map syntax NitraSyntax.LanguageMember.SpanClass.StyleReference(name : Name) -> SpanClass
  {
    | Reference -> StyledSpanClass { name -> Name; QualifiedReference -> StyleReference; } //= "=" sm QualifiedReference ";"
    | StyleBody -> InlineSpanClass { name -> Name; StyleBody.Properties -> Properties; } 
  }

  map syntax NitraSyntax.SyntaxModuleMember -> Nitra.Ast.SyntaxModuleMember
  {
    | RegexRule       -> this.RegexRule
    | SimpleRule      -> this.SimpleRule
    | ExtensibleRule  -> this.ExtensibleRule
    | Marker          -> Marker { Name -> Name; }
    | RuleAlias       -> this.RuleAlias
    | ExtendRule -> TopExtendRule  {}
    | TokenLiteral     //    = "literal"             sm Name  sm "="  sm (StringLiteral; ","sm)+               ";"nl
      {
        Name = ParsedValue(Name.Span, Name.GetText());
        StringLiterals.Item1 -> Literals;
      }

    | KeywordRegex    {} //    = "keyword" sm "regex"  sm MatchTokens=RegexExpression sm "rule" sm QualifiedReference ";"nl
  }

  map syntax NitraLiterals.StringLiteral -> StringLiteral
  {
    Value = ParsedValue(this.Span, this.Value());
  }

  map syntax NitraLiterals.CharLiteral -> CharLiteral
  {
    Value = ParsedValue(this.Span, this.Value());
  }

  ast NestedTag {}

  map syntax NitraSyntax.RuleAlias -> TopRuleAlias
  {
  }

  map syntax NitraSyntax.RuleAlias(_ : NestedTag) -> NestedRuleAlias
  {
  }

  map syntax NitraSyntax.RegexRule -> TopRegexRule
  {
    Name -> Name;
    RegexExpression -> Expression;
  }

  map syntax NitraSyntax.RegexRule(_ : NestedTag) -> NestedRegexRule
  {
    Name -> Name;
    RegexExpression -> Expression;
  }

  map syntax NitraSyntax.SimpleRule -> TopSimpleRule
  {
    Name -> Name;
    Expression -> Expression;
  }

  map syntax NitraSyntax.SimpleRule(_ : NestedTag) -> NestedSimpleRule
  {
    Name -> Name;
    Expression -> Expression;
  }

  map syntax NitraSyntax.ExtensibleRule -> TopExtensibleRule
  {
    Name -> Name;
    RuleBody -> Members;
  }

  map syntax NitraSyntax.ExtensibleRule(_ : NestedTag) -> NestedExtensibleRule
  {
    Name -> Name;
    RuleBody -> Members;
  }

  map syntax NitraSyntax.RuleBody -> RuleBodyMember*
  {
    | Empty -> []
    | Block -> RuleBodyMembers
  }

  map syntax NitraSyntax.RuleBodyMember -> RuleBodyMember
  {
    | RuleAlias      -> this.RuleAlias(NestedTag {})
    | RegexRule      -> this.RegexRule(NestedTag {})
    | SimpleRule     -> this.SimpleRule(NestedTag {})
    | ExtensibleRule -> this.ExtensibleRule(NestedTag {})
    | ExtensionRule(_, _, Some((name, _)), ruleExpression, rightAssociativeOpt, ruleBodyOpt) -> ExtensionRuleWithExplicitName
      {
        name -> Name;
        ruleExpression -> Expression;
      }

    | ExtensionRule(_, _, None, ruleExpression, rightAssociativeOpt, ruleBodyOpt) -> ExtensionRuleWithInferredName
      {
        Name = Name(File, NSpan(Span.StartPos), "");
        ruleExpression -> Expression;
      }
      
    | Precedence         -> Precedence { PrecedenceName -> Name; }  // "precedence" sm PrecedenceName Order=(sm "order" sm (Reference; sm "<" sm){2,})? ":"
    | MapSyntax          -> InlineMapSyntax {  }                    // "map" ParametersOpt=MapSyntaxParameters? sm AstName=NitraType MapSyntaxBody
    | RuleMethod         -> RuleMethod          { Name -> Name; }            // RuleMethodAttributes RuleMethodPrivate? Name sm "(" (RuleMethodParam; "," sm)* ")" sm ":" sm Type=NitraType RuleMethodBody
    | RuleMethodOverride -> RuleMethodOverride  { Name -> Name; } // RuleMethodAttributes "override"     sm  Name RuleMethodBody
    | RuleMethodMissing  -> RuleMethodMissing   { Name -> Name; } // RuleMethodAttributes "missing"        sm  Name RuleMethodBody
  }

  map syntax NitraSyntax.PrecedenceName -> Name
  {
    | Zero = Name(File, Span, "0");
    | Identifier -> Name
  }

  map syntax NitraSyntax.RuleExpression -> R.Expression
  {
    | Sequence(leftRule, rightRules) -> R.Sequence // LeftRule=RuleExpression ^ Sequence RightRules=(sm RuleExpression ^ Sequence)+
      {
        leftRule   -> Expression;
        rightRules -> Expressions;
      }

    | FieldName2 -> R.FieldName // Name sm "=" sm RuleExpression ^ FieldName2
      {
        Name = ParsedValue(Name.Span, Name.GetText());
        RuleExpression -> Expression;
      }

    | FieldName1 -> R.FieldName // RuleExpression ^ FieldName1 sm "as" sm Name
      {
        Name = ParsedValue(Name.Span, Name.GetText());
        RuleExpression -> Expression;
      }

    | Not -> R.Not                // "!" RuleExpression ^ Predicate
      {
        RuleExpression -> Expression;
      }

    | And -> R.And                 // "&" RuleExpression ^ Predicate
      {
        RuleExpression -> Expression;
      }

    | Optional -> R.Optional            // RuleExpression "?"
      {
        RuleExpression -> Expression;
      }

    | Repeat -> R.Repeat              // RuleExpression RepeatQuantifier
      {
        RuleExpression -> Expression;
      }

    | RepeatWithSeparator -> R.RepeatWithSeparator // "(" RuleExpression ";"sm Separator HangingOpt=(";"sm "?")? ")" RepeatQuantifier
      {
        RuleExpression -> Expression;
        Separator      -> Separator;
      }

    | Char   -> R.String { Str = ParsedValue(CharLiteral.Span, CharLiteral.Value().ToString()); }  // CharLiteral
    | String -> R.String { Str = ParsedValue(StringLiteral.Span, StringLiteral.Value()); }  // StringLiteral
    | Rounds -> RuleExpression             // "(" RuleExpression ")"
    | Call   -> R.Call  // QualifiedReference BindingPower=(sm "^" sm "+"? PrecedenceReference2)?
      {
        QualifiedReference -> RuleReference;
      }
  }

  map syntax NitraSyntax.RegexExpression -> RX.Expression
  {
    | Choice(leftRule, rightRules) -> RX.Sequence
      {
        leftRule   -> Expression;
        rightRules -> Expressions;
      }

    | Sequence(leftRule, rightRules) -> RX.Sequence
      {
        leftRule   -> Expression;
        rightRules -> Expressions;
      }

    | Optional -> RX.Optional            // RuleExpression "?"
      {
        RegexExpression -> Expression;
      }

    | Repeat -> RX.Repeat
      {
        RegexExpression -> Expression;
      }

    | Invert -> RX.Invert
      {
        RegexExpression -> Expression;
      }

    | Range -> RX.Range
      {
      }

    | InvertedRange -> RX.InvertedRange
      {
      }

    | Subtract -> RX.Subtract
      {
        Rule1 -> Expression1;
        Rule2 -> Expression2;
      }

    | RepeatWithSeparator -> RX.RepeatWithSeparator
      {
        RegexExpression -> Expression;
        Separator       -> Separator;
      }

    | Char   -> RX.Char   { CharLiteral   -> Literal; }
    | String -> RX.String { StringLiteral -> Literal; }
    | Rounds -> RegexExpression
    | Call   -> RX.Call
      {
        QualifiedReference -> RuleReference;
      }
  }

  map syntax NitraSyntax.AstMember -> AM.AstMember
  {
    | StructuralProperty       -> AM.StructuralProperty { Name -> Name; NitraType -> Type; }
    | DependentProperty        -> this.DependentProperty
    | DependentAssignStatement -> this.DependentAssignStatement
    | DependentCallStatement   -> this.DependentCallStatement
    | DependentAddStatement    -> this.DependentAddStatement
    | Decompose                -> AM.Decompose {}
    | StageScope               -> this.StageScope
    | ChildAst                 -> AM.NestedAst
      {
        Name -> Name;
        match(AstInheritanceOpt) { Some(value) -> value | None() -> [] } -> TypeAst;
        match(Body) { Some(value) -> value.Members | None() -> [] } -> Members;
      }
  }

  map syntax NitraSyntax.DependentProperty -> AM.AstDependentProperty
  {
    Name -> Name;
    NitraType -> Type;
  }

  map syntax NitraSyntax.DependentAssignStatement -> AM.DependentAssignStatement
  {
    Path -> Path;
  }

  map syntax NitraSyntax.DependentCallStatement -> AM.DependentCallStatement
  {
    //Path -> Path;
    Name -> Name;
  }

  map syntax NitraSyntax.DependentAddStatement -> AM.DependentAddStatement
  {
    Path -> Path;
  }

  map syntax NitraSyntax.StageScope -> AM.StageScope
  {
    Stage = ParsedValue(Number.Span, Number.Value());
  }

  map syntax NitraSyntax.NitraType -> QualifiedReference
  {
    | PredefinedType -> QualifiedReference.Simple
      {
        Name = Reference(File, PredefinedType, GetText(PredefinedType));
      }

    | QualifiedType((first :: tail, _)) -> fold (item in tail; acc = first(); acc = item(acc))
    | QualifiedType(([], _)) = AstUtils.CreateMissingQualifiedReference(File, Span);

    | Braces -> NitraType
    | Tuple = AstUtils.CreateTupleQualifiedReference(File, Span, NitraType2.GetAst(QualifiedReference.AstList(File, Span, NitraType1.GetAst())));
    | Func  = AstUtils.CreateFuncQualifiedReference(File, Span, NitraType1.GetAst(), NitraType2.GetAst()); 
    | OptionList     -> QualifiedReference.Generic
      {
        QualifiedName = AstUtils.CreateBuiltinName(File, Span, "#OptionList");
        [NitraType] -> Arguments;
      }
    | List           -> QualifiedReference.Generic
      {
        QualifiedName = AstUtils.CreateBuiltinName(File, Span, "#List");
        [NitraType] -> Arguments;
      }
    | Option         -> QualifiedReference.Generic
      {
        QualifiedName = AstUtils.CreateBuiltinName(File, Span, "#Option");
        [NitraType] -> Arguments;
      }
  }

  map syntax NitraSyntax.NitraType(tupleArgs : QualifiedReference*) -> QualifiedReference*
  {
    | PredefinedType = tupleArgs.Append(GetAst());
    | QualifiedType  = tupleArgs.Append(GetAst());
    | Braces         = tupleArgs.Append(GetAst());
    | Func           = tupleArgs.Append(GetAst());
    | Tuple          = NitraType2.GetAst(tupleArgs.Append(NitraType1.GetAst()));
    | OptionList     = tupleArgs.Append(GetAst());
    | List           = tupleArgs.Append(GetAst());
    | Option         = tupleArgs.Append(GetAst());
  }

  map syntax NitraSyntax.NitraTypeName -> QualifiedReference
  {
    | (r, None) -> Simple { r -> Name; }
    | (r, Some(args)) -> Generic
      {
        Simple { r -> Name; } -> QualifiedName;
        args -> Arguments;
      }
  }

  map syntax NitraSyntax.NitraTypeName(qualifier : QualifiedReference) -> QualifiedReference
  {
    | (r, None) -> Qualified { r -> Name; qualifier -> Qualifier; }
    | (r, Some(args)) -> Generic
      {
        Qualified { r -> Name; qualifier -> Qualifier; } -> QualifiedName;
        args -> Arguments;
      }
  }

  map syntax NitraSyntax.NitraTypeArguments -> QualifiedReference*
  {
    | Corners -> NitraTypes.Item1
    | Braces  -> NitraTypes.Item1
  }
}
