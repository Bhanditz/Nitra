using DotNet;

using Nitra.Runtime.Binding;
using Nemerle.Collections;

namespace Nitra.Ast
{
  using R = Nitra.Ast.RuleExpressions;
  using RX = Nitra.Ast.RegexExpressions;
  using AM = Nitra.Ast.AstMembers;

  map syntax NitraSyntax.Start -> CompilationUnit
  {
    NamespaceMembers -> Members;
  }

  map syntax NitraSyntax.NamespaceMember -> NamespaceMember
  {
    | Namespace -> ExplicitNamespace
      {
        NamespaceName.Name          -> Name;
        NamespaceName.Path(ImplicitNamespaceTag{}) -> Path;
        //ExternAliasDirectives       -> ExternAlias;
        //UsingDirectives             -> UsingDirectives;
        NamespaceBody.NamespaceMembers -> Members;
      }

    | Ast -> Nitra.Ast.TopAst          // Header Name AstInheritanceOpt Body
      {
        Name -> Name;
        match(AstInheritanceOpt) { Some(value) -> value | None() -> [] } -> TypeAst;
        Body.Members -> Members;
      }

    | MapSyntax -> TopMapSyntax // "map" "syntax" RuleName=QualifiedReference ParametersOpt=MapSyntaxParameters? "->" AstName=NitraType /*AstType*/ MapSyntaxBody
      {
        RuleName -> Rule;
        AstName  -> Ast;
        match (ParametersOpt) { Some(p) -> p | None() -> [] } -> Parameters;
        MapSyntaxBody -> Body;
      }

    | SyntaxModule  // SyntaxModuleAttributes Name LanguageOpt SyntaxModuleMembers 
      {
        Name -> Name;
        Usings.Usings -> Usings;
        SyntaxModuleMembers -> Members;
      }

    | Language -> Nitra.Ast.Language   // Name ParentOpt Members
      {
        Name -> Name;
        Members -> Members;
      }

    //| Type -> TypeDeclaration

    | UsingAlias -> UsingAliasDirective
      {
        Name          -> Name;
        NamespaceOrType -> NamespaceOrTypeName;
      }

    | UsingOpen -> UsingOpenDirective
      {
        NamespaceOrType -> NamespaceOrTypeName;
      }
  }

  map syntax NitraSyntax.AstInheritance -> QualifiedReference*
  {
    BaseAsts.Item1
  }

  map syntax NitraSyntax.Using -> SyntaxModuleUsingDirective
  {
    | UsingAlias -> SyntaxModuleUsingAliasDirective
      {
        Name -> Name;
        NamespaceOrType -> NamespaceOrTypeName;
      }

    | UsingOpen -> SyntaxModuleUsingOpenDirective
      {
        NamespaceOrType -> NamespaceOrTypeName;
      }
  }

  ast ImplicitNamespaceTag { }

  map syntax NitraSyntax.Name(_tag : ImplicitNamespaceTag) -> ImplicitNamespace
  {
    this -> Name;
  }

  map syntax NitraSyntax.QualifiedReference -> QualifiedReference
  {
    | ((first :: other, _)) -> fold (item in other; acc = Simple { first() -> Name; }; acc = Qualified { item() -> Name; Qualifier = acc;  })
    | (([],             _)) = AstUtils.CreateMissingQualifiedReference(Names.File, Names.Span);
  }

  map syntax NitraSyntax.StyleProperty -> StyleProperty
  {
    | ForegroundColor { Color = ParsedValue(Color.Span, Color.Value(Nitra.Declarations.AstContext.CompilerMessages)); }
  }

  map syntax NitraSyntax.LanguageMember -> LanguageMember
  {
    | Style -> Style // "style" sm Name sm StyleBody
      {
        Name -> Name;
        StyleBody.Properties -> Properties;
      }

    | SpanClass -> StyleReference(Name) // "span" sm "class" sm Name sm MatchTokensOpt=("regex" sm RegexExpression sm)? StyleReference

    // "syntax" sm "module" sm Module=QualifiedReference RuleOpt=(sm "start" sm "rule" sm QualifiedReference)? ";"
    | SyntaxModule(_, _, m, Some((_, _, r)), _) -> StartSyntaxModuleReference
      {
        m -> Module;
        r -> Rule;
      }

    // "syntax" sm "module" sm Module=QualifiedReference RuleOpt=(sm "start" sm "rule" sm QualifiedReference)? ";"
    | SyntaxModule(_, _, m, None, _) -> AdditionSyntaxModuleReference
      {
        m -> Module;
      }

    | FileExtension { Extension = ParsedValue(Ext, GetText(Ext)); }
    | Company     { Name = ParsedValue(Name, GetText(Name)); }
    | Description { Text = ParsedValue(Text, GetText(Text)); }
    | Authors     { Text = ParsedValue(Text, GetText(Text)); }
    | Copyright   { Text = ParsedValue(Text, GetText(Text)); }
    | LicenseUrl  { Text = ParsedValue(Text, GetText(Text)); }
    | RequireLicenseAcceptance { }
  }

  map syntax NitraSyntax.LanguageMember.SpanClass.StyleReference(name : Name) -> SpanClass
  {
    | Reference -> StyledSpanClass { name -> Name; QualifiedReference -> StyleReference; } //= "=" sm QualifiedReference ";"
    | StyleBody -> InlineSpanClass { name -> Name; StyleBody.Properties -> Properties; } 
  }

  map syntax NitraSyntax.SyntaxModuleMember -> Nitra.Ast.SyntaxModuleMember
  {
    | RegexRule       -> this.RegexRule
    | SimpleRule      -> this.SimpleRule
    | ExtensibleRule  -> this.ExtensibleRule
    | Marker          -> Marker { Name -> Name; }
    | RuleAlias       -> this.RuleAlias
    | ExtendRule -> TopExtendRule  {}
    | TokenLiteral     //    = "literal"             sm Name  sm "="  sm (StringLiteral; ","sm)+               ";"nl
      {
        Name = ParsedValue(Name.Span, Name.GetText());
        StringLiterals.Item1 -> Literals;
      }

    | KeywordRegex    {} //    = "keyword" sm "regex"  sm MatchTokens=RegexExpression sm "rule" sm QualifiedReference ";"nl
  }

  map syntax NitraLiterals.StringLiteral -> StringLiteral
  {
    Value = ParsedValue(this.Span, this.Value());
  }

  map syntax NitraLiterals.CharLiteral -> CharLiteral
  {
    Value = ParsedValue(this.Span, this.Value());
  }

  ast NestedTag {}

  map syntax NitraSyntax.RuleAlias -> TopRuleAlias
  {
  }

  map syntax NitraSyntax.RuleAlias(_ : NestedTag) -> NestedRuleAlias
  {
  }

  map syntax NitraSyntax.RegexRule -> TopRegexRule
  {
    Name -> Name;
    RegexExpression -> Expression;
  }

  map syntax NitraSyntax.RegexRule(_ : NestedTag) -> NestedRegexRule
  {
    Name -> Name;
    RegexExpression -> Expression;
  }

  map syntax NitraSyntax.SimpleRule -> SyntaxModuleMember
  {
    Header(Name, Expression)
  }

  map syntax NitraSyntax.SimpleRule.Header(name : Name, expression : R.Expression) -> SyntaxModuleMember
  {
    | Syntax -> TopSimpleRule { name -> Name; expression -> Expression; }
    | Token  -> TopTokenRule  { name -> Name; expression -> Expression; }
    | Void   -> TopVoidRule   { name -> Name; expression -> Expression; }
  }

  map syntax NitraSyntax.SimpleRule.Header(_ : NestedTag, name : Name, expression : R.Expression) -> RuleBodyMemberDeclaration
  {
    | Syntax -> NestedSimpleRule { name -> Name; expression -> Expression; }
    | Token  -> NestedTokenRule  { name -> Name; expression -> Expression; }
    | Void   -> NestedVoidRule   { name -> Name; expression -> Expression; }
  }

  map syntax NitraSyntax.SimpleRule(tag : NestedTag) -> RuleBodyMemberDeclaration
  {
    Header(tag, Name, Expression)
  }

  map syntax NitraSyntax.ExtensibleRule -> TopExtensibleRule
  {
    Name -> Name;
    RuleBody -> Members;
  }

  map syntax NitraSyntax.ExtensibleRule(_ : NestedTag) -> NestedExtensibleRule
  {
    Name -> Name;
    RuleBody -> Members;
  }

  map syntax NitraSyntax.RuleBody -> RuleBodyMember*
  {
    | Empty -> []
    | Block -> RuleBodyMembers
  }

  map syntax NitraSyntax.RuleBodyMember -> RuleBodyMember
  {
    | RuleAlias      -> this.RuleAlias(NestedTag {})
    | RegexRule      -> this.RegexRule(NestedTag {})
    | SimpleRule     -> this.SimpleRule(NestedTag {})
    | ExtensibleRule -> this.ExtensibleRule(NestedTag {})
    | ExtensionRule(_, _, Some((name, _)), ruleExpression, rightAssociativeOpt, ruleBodyOpt) -> ExtensionRuleWithExplicitName
      {
        name -> Name;
        ruleExpression -> Expression;
      }

    | ExtensionRule(_, _, None, ruleExpression, rightAssociativeOpt, ruleBodyOpt) -> ExtensionRuleWithInferredName
      {
        Name = Name(File, NSpan(Span.StartPos), "");
        ruleExpression -> Expression;
      }

    | Precedence         -> Precedence { PrecedenceName -> Name; }  // "precedence" sm PrecedenceName Order=(sm "order" sm (Reference; sm "<" sm){2,})? ":"
    | MapSyntax          -> InlineMapSyntax // "map" ParametersOpt=MapSyntaxParameters? sm AstName=NitraType /*AstType*/ MapSyntaxBody
      {
        AstName  -> Ast;
        match (ParametersOpt) { Some(p) -> p | None() -> [] } -> Parameters;
        MapSyntaxBody -> Body;
      }
    | RuleMethod         -> RuleMethod          { Name -> Name; }            // RuleMethodAttributes RuleMethodPrivate? Name sm "(" (RuleMethodParam; "," sm)* ")" sm ":" sm Type=NitraType /*Type*/ RuleMethodBody
    | RuleMethodOverride -> RuleMethodOverride  { Name -> Name; } // RuleMethodAttributes "override"     sm  Name RuleMethodBody
    | RuleMethodMissing  -> RuleMethodMissing   { Name -> Name; } // RuleMethodAttributes "missing"        sm  Name RuleMethodBody
  }

  map syntax NitraSyntax.PrecedenceName -> Name
  {
    | Zero = Name(File, Span, "0");
    | Identifier -> Name
  }

  map syntax NitraSyntax.RuleExpression -> R.Expression
  {
    | Sequence(leftRule, rightRules) -> R.Sequence // LeftRule=RuleExpression ^ Sequence RightRules=(sm RuleExpression ^ Sequence)+
      {
        leftRule   -> Expression;
        rightRules -> Expressions;
      }

    | FieldName2 -> R.FieldName // Name sm "=" sm RuleExpression ^ FieldName2
      {
        Name = ParsedValue(Name.Span, Name.GetText());
        RuleExpression -> Expression;
      }

    | FieldName1 -> R.FieldName // RuleExpression ^ FieldName1 sm "as" sm Name
      {
        Name = ParsedValue(Name.Span, Name.GetText());
        RuleExpression -> Expression;
      }

    | Not -> R.Not                // "!" RuleExpression ^ Predicate
      {
        RuleExpression -> Expression;
      }

    | And -> R.And                 // "&" RuleExpression ^ Predicate
      {
        RuleExpression -> Expression;
      }

    | Optional -> R.Optional            // RuleExpression "?"
      {
        RuleExpression -> Expression;
      }

    | Repeat -> R.Repeat              // RuleExpression RepeatQuantifier
      {
        RuleExpression -> Expression;
      }

    | RepeatWithSeparator -> R.RepeatWithSeparator // "(" RuleExpression ";"sm Separator HangingOpt=(";"sm "?")? ")" RepeatQuantifier
      {
        RuleExpression -> Expression;
        Separator      -> Separator;
      }

    | Char   -> R.String { Str = ParsedValue(CharLiteral.Span, CharLiteral.Value().ToString()); }  // CharLiteral
    | String -> R.String { Str = ParsedValue(StringLiteral.Span, StringLiteral.Value()); }  // StringLiteral
    | Rounds -> RuleExpression             // "(" RuleExpression ")"
    | Call   -> R.Call  // QualifiedReference BindingPower=(sm "^" sm "+"? PrecedenceReference2)?
      {
        QualifiedReference -> RuleReference;
      }
  }

  map syntax NitraSyntax.RegexExpression -> RX.Expression
  {
    | Choice(leftRule, rightRules) -> RX.Sequence
      {
        leftRule   -> Expression;
        rightRules -> Expressions;
      }

    | Sequence(leftRule, rightRules) -> RX.Sequence
      {
        leftRule   -> Expression;
        rightRules -> Expressions;
      }

    | Optional -> RX.Optional            // RuleExpression "?"
      {
        RegexExpression -> Expression;
      }

    | Repeat -> RX.Repeat
      {
        RegexExpression -> Expression;
      }

    | Invert -> RX.Invert
      {
        RegexExpression -> Expression;
      }

    | Range -> RX.Range
      {
      }

    | InvertedRange -> RX.InvertedRange
      {
      }

    | Subtract -> RX.Subtract
      {
        Rule1 -> Expression1;
        Rule2 -> Expression2;
      }

    | RepeatWithSeparator -> RX.RepeatWithSeparator
      {
        RegexExpression -> Expression;
        Separator       -> Separator;
      }

    | Char   -> RX.Char   { CharLiteral   -> Literal; }
    | String -> RX.String { StringLiteral -> Literal; }
    | Rounds -> RegexExpression
    | Call   -> RX.Call
      {
        QualifiedReference -> RuleReference;
      }
  }

  map syntax NitraSyntax.AstMember -> AM.AstMember
  {
    | StructuralProperty       -> AM.StructuralProperty { Name -> Name; NitraType /*AstType*/ -> Type; }
    | DependentProperty        -> this.DependentProperty
    | DependentAssignStatement -> this.DependentAssignStatement
    | DependentCallStatement   -> this.DependentCallStatement
    | DependentAddStatement    -> this.DependentAddStatement
    | Decompose                -> AM.Decompose {}
    | StageScope               -> this.StageScope
    | ChildAst                 -> AM.NestedAst
      {
        Name -> Name;
        match(AstInheritanceOpt) { Some(value) -> value | None() -> [] } -> TypeAst;
        match(Body) { Some(value) -> value.Members | None() -> [] } -> Members;
      }
  }

  map syntax NitraSyntax.DependentProperty -> AM.AstDependentProperty
  {
    Name -> Name;
    NitraType /*Type or AstType ???*/ -> Type;
  }

  map syntax NitraSyntax.DependentAssignStatement -> AM.DependentAssignStatement
  {
    Path -> Path;
  }

  map syntax NitraSyntax.DependentCallStatement -> AM.DependentCallStatement
  {
    //Path -> Path;
    Name -> Name;
  }

  map syntax NitraSyntax.DependentAddStatement -> AM.DependentAddStatement
  {
    Path -> Path;
  }

  map syntax NitraSyntax.StageScope -> AM.StageScope
  {
    Stage = ParsedValue(Number.Span, Number.Value());
  }

  map syntax NitraSyntax.NitraType -> QualifiedReference
  {
    | PredefinedType -> QualifiedReference.Simple
      {
        Name = Reference(File, PredefinedType, GetText(PredefinedType));
      }

    | QualifiedType((first :: tail, _)) -> fold (item in tail; acc = first(); acc = item(acc))
    | QualifiedType(([], _)) = AstUtils.CreateMissingQualifiedReference(File, Span);

    | Braces -> NitraType
    | Tuple = AstUtils.CreateTupleQualifiedReference(File, Span, NitraType2.GetAst(QualifiedReference.AstList(File, Span, NitraType1.GetAst())));
    | Func  = AstUtils.CreateFuncQualifiedReference(File, Span, NitraType1.GetAst(), NitraType2.GetAst()); 
    | OptionList     -> QualifiedReference.Generic
      {
        QualifiedName = AstUtils.CreateBuiltinName(File, Span, "#OptionList");
        [NitraType] -> Arguments;
      }
    | List           -> QualifiedReference.Generic
      {
        QualifiedName = AstUtils.CreateBuiltinName(File, Span, "#List");
        [NitraType] -> Arguments;
      }
    | Option         -> QualifiedReference.Generic
      {
        QualifiedName = AstUtils.CreateBuiltinName(File, Span, "#Option");
        [NitraType] -> Arguments;
      }
  }

  map syntax NitraSyntax.NitraType(tupleArgs : QualifiedReference*) -> QualifiedReference*
  {
    | PredefinedType = tupleArgs.Append(GetAst());
    | QualifiedType  = tupleArgs.Append(GetAst());
    | Braces         = tupleArgs.Append(GetAst());
    | Func           = tupleArgs.Append(GetAst());
    | Tuple          = NitraType2.GetAst(tupleArgs.Append(NitraType1.GetAst()));
    | OptionList     = tupleArgs.Append(GetAst());
    | List           = tupleArgs.Append(GetAst());
    | Option         = tupleArgs.Append(GetAst());
  }

  map syntax NitraSyntax.NitraTypeName -> QualifiedReference
  {
    | (r, None) -> Simple { r -> Name; }
    | (r, Some(args)) -> Generic
      {
        Simple { r -> Name; } -> QualifiedName;
        args -> Arguments;
      }
  }

  map syntax NitraSyntax.NitraTypeName(qualifier : QualifiedReference) -> QualifiedReference
  {
    | (r, None) -> Qualified { r -> Name; qualifier -> Qualifier; }
    | (r, Some(args)) -> Generic
      {
        Qualified { r -> Name; qualifier -> Qualifier; } -> QualifiedName;
        args -> Arguments;
      }
  }

  map syntax NitraSyntax.NitraTypeArguments -> QualifiedReference*
  {
    | Corners -> NitraTypes.Item1
    | Braces  -> NitraTypes.Item1
  }

  map syntax NitraSyntax.MapSyntaxParameters -> MapSyntaxParameter*
  {
    RuleMethodParams.Item1
  }

  map syntax NitraSyntax.RuleMethodParam -> MapSyntaxParameter
  {
    Name -> Name;
    Type -> Ast;
  }

  map syntax NitraSyntax.MapSyntaxBody -> MapSyntaxBody
  {
    | Empty {}
    | Inline
      {
        Code = ParsedValue(Code.Span, Code.GetText());
      }

    | Expression -> this.Expr
    | PerMember
      {
        Members -> Members;
      }
  }

  map syntax NitraSyntax.MapSyntaxExpression -> MapSyntaxExpression
  {
    | Braces -> this.Expr
    | This {}
    | Identifier
      {
        Reference -> Reference;
      }

    | Ast
      {
        QualifiedReference -> Ast;
        Members -> Members;
      }

    | List
      {
        ItemExprs.Item1 -> Items;
      }

    | OptionSome
      {
        ValueExpr -> Value;
      }

    | OptionNone {}
    | Match
      {
        Expr             -> Expression;
        MatchCases.Item1 -> Cases;
      }

    | Fold
      {
        ItemName -> ItemName;
        ItemExpr -> ItemExpression;
        AccumulatorName1 -> AccumulatorName1;
        InitExpr -> InitExpression;
        AccumulatorName2 -> AccumulatorName2;
        EachExpr -> EachExpression;
      }

    | DefineVariable
      {
        Name      -> VariableName;
        NitraType -> VariableType;
        Expr      -> Expression;
        Body      -> Body;
      }

    | TypeHint
      {
        Expr      -> Expression;
        NitraType -> Ast;
      }

    | Call
      {
        Expr                -> Expression;
        ArgumentExprs.Item1 -> Arguments;
      }

    | MemberAccess
      {
        Expr      -> Expression;
        Reference -> Reference;
      }
  }

  map syntax NitraSyntax.MapSyntaxBodyMember -> MapSyntaxBodyMember
  {
    | ParseTreeFieldExpressionMapping -> this.ParseTreeFieldExpressionMapping
    | ParseTreeFieldCodeMapping       -> this.ParseTreeFieldCodeMapping
    | MatchCase -> MapSyntaxMatchCase
      {
        Pattern -> Pattern;
        Body    -> Body;
      }
  }

  map syntax NitraSyntax.ParseTreeFieldExpressionMapping -> ParseTreeFieldExpressionMapping
  {
    AstPropertyName -> AstProperty;
    Expr            -> Expression;
  }

  map syntax NitraSyntax.ParseTreeFieldCodeMapping -> ParseTreeFieldCodeMapping
  {
    FieldName -> AstProperty;
    Code = ParsedValue(Code.Span, Code.GetText());
  }

  map syntax NitraSyntax.MatchCaseBody -> MapSyntaxMatchCaseBody
  {
    | Expression -> this.Expr
    | Inline
      {
        Code = ParsedValue(Code.Span, Code.GetText());
      }
    | PerField
      {
        Members -> Members;
      }
  }

  map syntax NitraSyntax.MapSyntaxExpressionAstMember -> MapSyntaxExpressionAstMember
  {
    | ParseTreeFieldExpressionMapping -> this.ParseTreeFieldExpressionMapping
    | ParseTreeFieldCodeMapping       -> this.ParseTreeFieldCodeMapping
  }

  map syntax NitraSyntax.Pattern -> ParseTreePattern
  {
    | Identifier
      {
        Reference -> Reference;
      }

    | Ctor
      {
        Identifier     -> Reference;
        Patterns.Item1 -> Arguments;
      }

    | Tuple
      {
        Patterns.Item1 -> Members;
      }

    | List1
      {
        Pattern1 -> Head;
        Pattern2 -> Tail;
      }

    | List2
      {
        Patterns.Item1 -> Items;
      }
  }

  map syntax NitraSyntax.MapSyntaxExpression.Match.MatchCase -> MapSyntaxMatchCase
  {
    Pattern -> Pattern;
    Expr -> Body;
  }
}
