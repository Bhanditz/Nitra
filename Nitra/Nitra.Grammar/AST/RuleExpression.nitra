using Nitra.AstUtils;
using Nitra.Runtime.Binding;

using System.Drawing;

namespace Nitra.Ast.RuleExpressions
{
  abstract ast Expression : BindableAst
  {
    in FieldName : string;
  }

  ast Sequence            // LeftRule=RuleExpression ^ Sequence RightRules=(sm RuleExpression ^ Sequence)+
  {
    //Expressions.Scope = Scope;
    //Expressions : Expression*;

    Expression.Scope  = Scope;
    Expressions.Scope = Scope;

    Expression : Expression;
    Expressions : Expression*;
  }

  abstract ast Unary : Expression
  {
    Expression.Scope = Scope;
    Expression : Expression;
  }

  ast FieldName : Unary // "!" RuleExpression ^ Predicate
  {
    Name : string;
  }

  ast Not : Unary { } // "!" RuleExpression ^ Predicate
  ast And : Unary { } // "&" RuleExpression ^ Predicate
  ast Optional : Unary { } // RuleExpression "?"

  ast Repeat : Expression // RuleExpression RepeatQuantifier
  {
    Expression.Scope = Scope;
    Expression : Expression;
  }

  ast RepeatWithSeparator : Expression // "(" RuleExpression ";"sm Separator HangingOpt=(";"sm "?")? ")" RepeatQuantifier
  {
    Expression.Scope = Scope;
    Separator.Scope = Scope;

    Expression : Expression;
    Separator : Expression;
  }

  ast String : Expression // CharLiteral
  {
    Str : string;
  }

  ast Call : Expression   // QualifiedReference BindingPower=(sm "^" sm "+"? PrecedenceReference2)?
  {
    RuleReference.Scope = Scope;
    RuleReference : QualifiedReference;
  }
}
