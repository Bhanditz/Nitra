using Nitra.AstUtils;
using Nitra.Runtime.Binding;

using System.Drawing;

using R = Nitra.Ast.RuleExpressions;

namespace Nitra.Ast.RuleExpressions
{
  abstract ast Expression : BindableAst
  {
    in FieldName : string;
  }

  ast Sequence : R.Expression  // LeftRule=RuleExpression ^ Sequence RightRules=(sm RuleExpression ^ Sequence)+
  {
    //Expressions.Scope = Scope;
    //Expressions : R.Expression*;

    Expression.Scope  = Scope;
    Expressions.Scope = Scope;

    Expression : R.Expression;
    Expressions : R.Expression*;
  }

  abstract ast Unary : R.Expression
  {
    Expression.Scope = Scope;
    Expression : R.Expression;
  }

  ast FieldName : Unary // "!" RuleExpression ^ Predicate
  {
    Name : string;
  }

  ast Not : Unary { } // "!" RuleExpression ^ Predicate
  ast And : Unary { } // "&" RuleExpression ^ Predicate
  ast Optional : Unary { } // RuleExpression "?"

  ast Repeat : R.Expression // RuleExpression RepeatQuantifier
  {
    Expression.Scope = Scope;
    Expression : R.Expression;
  }

  ast RepeatWithSeparator : R.Expression // "(" RuleExpression ";"sm Separator HangingOpt=(";"sm "?")? ")" RepeatQuantifier
  {
    Expression.Scope = Scope;
    Separator.Scope = Scope;

    Expression : R.Expression;
    Separator : R.Expression;
  }

  ast String : R.Expression // CharLiteral
  {
    Str : string;
  }

  ast Call : R.Expression   // QualifiedReference BindingPower=(sm "^" sm "+"? PrecedenceReference2)?
  {
    RuleReference.Scope = Scope;
    RuleReference : QualifiedReference;
  }
}
