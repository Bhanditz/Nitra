using DotNet;

using Nitra.Runtime.Binding;

namespace Nitra.Ast
{
  abstract ast MapSyntax : BindableAst
  {
    AstName.Scope = Scope;

    out ParameterScope : TableScope = TableScope("parameters", null);

  stage 1:
    out Rule    : RuleSymbol;
    out AstType : AstTypeSymbol;
    out AstRef  : Ref[AstTypeSymbol] = this.AstName.Ref.Resolve();
    Body.This.Symbol.Type = Rule;

    AstType       = AstRef.Symbol;
    Body.AstScope = Scope.HideWith(AstRef.Scope);
    Body.Scope    = Scope.HideWith(ParameterScope).HideWith(Rule.Scope);
    Body.AstType  = AstType;

    Parameters.ContainingTable = ParameterScope;
    Parameters.Scope = Body.AstScope;

    Parameters : MapSyntaxParameter*;
    AstName    : QualifiedReference;
    Body       : MapSyntaxBody;
  }

  declaration MapSyntaxParameter : BindableAst, TypedDeclaration
  {
    symbol
    {
      Kind      = "parameter";
      SpanClass = DotNetLangLanguage.ParameterSpanClass;
    }

  stage 1:
    out AstTypeRef : Ref[AstTypeSymbol] = AstName.Ref.Resolve();

    AstName.Scope = Scope;
    Symbol.Type   = AstTypeRef.Symbol;

    AstName : QualifiedReference;
  }

  ast TopMapSyntax : MapSyntax, NamespaceMember
  {
    RuleName.Scope = Scope;

  stage 1:
    out RuleRef : Ref[RuleSymbol] = this.RuleName.Ref.Resolve();

    Rule = RuleRef.Symbol;

    RuleName : QualifiedReference;
  }

  ast InlineMapSyntax : MapSyntax, RuleBodyMember
  {
    Rule = Parent;
  }

  ast ExtensionMapSyntax : BindableAst
  {
    RuleName.Scope = Scope;

  stage 1:
    in  AstScope       : Scope;
    in  DefaultAstType : AstTypeSymbol;
    out RuleRef        : Ref[ExtensionRuleSymbol] = this.RuleName.Ref.Resolve();
    out AstTypeRef     : Ref[AstTypeSymbol]       = AstUtils.BindAstExtension(this.RuleName, DefaultAstType.Scope, DefaultAstType);

    Body.AstScope = AstScope.HideWith(AstTypeRef.Scope);
    Body.Scope    = Scope.HideWith(RuleRef.Scope);
    Body.AstType  = AstTypeRef.Symbol;
    Body.This.Symbol.Type = RuleRef.Symbol;

    RuleName : Reference;
    Body     : MapSyntaxBody;
  }

  abstract ast MapSyntaxBody : BindableAst
  {
    This : ThisDeclaration;

    out BodyScope : TableScope = TableScope("body", null);
    This.ContainingTable       = BodyScope;

  stage 1:
    in AstScope : Scope;
    in AstType  : AstTypeSymbol;

    | Empty
      {
      }

    | Inline
      {
        Code : string;
      }

    | PerMember
      {
        Members.AstScope = AstScope;
        Members.Scope    = Scope.HideWith(BodyScope);
        Members.AstType  = AstType;

        Members : MapSyntaxExpressionAstMember*;
      }

    | Expression
      {
        Expression.AstScope = AstScope;
        Expression.Scope    = Scope.HideWith(BodyScope);

        Expression : MapSyntaxExpression;
      }

    | Extensions
      {
        Members.AstScope       = AstScope;
        Members.Scope          = Scope;    // don't pass 'this' variable
        Members.DefaultAstType = AstType;

        Members : ExtensionMapSyntax*;
      }
  }

  abstract ast MapSyntaxExpressionAstMember : BindableAst
  {
  stage 1:
    in AstScope : Scope;
    in AstType  : AstTypeSymbol;

    AstProperty.Scope  = AstType.Scope;
    AstProperty : Reference;

    | Inline
      {
        Code : string;
      }

    | Expression
      {
        Expression.AstScope = AstScope;
        Expression.Scope    = Scope;

        Expression  : MapSyntaxExpression;
      }
  }

  declaration ThisDeclaration : TypedDeclaration
  {
    symbol
    {
      Kind      = "this";
      SpanClass = Language.KeywordSpanClass;
    }
  }
}
