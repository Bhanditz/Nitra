using DotNet;

using Nitra.Runtime.Binding;

namespace Nitra.Ast
{
  abstract ast MapSyntax : BindableAst
  {
    Ast.Scope = Scope;
    Body.Scope = Scope;
  stage 1:
    out RuleSymbol : SyntaxRuleSymbol;
    out AstType    : AstTypeSymbol;
    out AstRef     : Ref[AstTypeSymbol] = this.Ast.Ref.Resolve();

    AstType = AstRef.Symbol;

    Parameters : MapSyntaxParameter*;
    Ast        : QualifiedReference;
    Body       : MapSyntaxBody;
  }

  declaration MapSyntaxParameter
  {
    Ast : QualifiedReference;
  }

  ast TopMapSyntax : MapSyntax, NamespaceMember
  {
    Rule.Scope = Scope;
  stage 1:
    out RuleRef : Ref[SyntaxRuleSymbol] = this.Rule.Ref.Resolve();

    RuleSymbol = RuleRef.Symbol;

    Rule : QualifiedReference;
  }

  ast InlineMapSyntax : MapSyntax, RuleBodyMember
  {
    out RuleRef : Ref[SyntaxRuleSymbol] = Ref.Some(File, Span, Parent).Resolve();

    RuleSymbol = RuleRef.Symbol;
  }

  abstract ast MapSyntaxBody : BindableAst
  {
    | Empty
      {
      }

    | Inline
      {
        Code : string;
      }

    | PerMember
      {
        Members : MapSyntaxBodyMember*;
      }
  }

  abstract ast MapSyntaxBodyMember : BindableAst
  {
  }

  abstract ast MapSyntaxExpressionAstMember
  {
  }

  abstract ast MapSyntaxMatchCaseBody
  {
    | PerField
      {
        Members : MapSyntaxExpressionAstMember*;
      }
    | Inline
      {
        Code : string;
      }
  }

  ast ParseTreeFieldExpressionMapping : MapSyntaxBodyMember, MapSyntaxExpressionAstMember
  {
    AstProperty : Reference;
    Expression  : MapSyntaxExpression;
  }

  ast ParseTreeFieldCodeMapping : MapSyntaxBodyMember, MapSyntaxExpressionAstMember
  {
    AstProperty : Reference;
    Code        : string;
  }

  ast MapSyntaxMatchCase : MapSyntaxBodyMember
  {
    Pattern : ParseTreePattern;
    Body    : MapSyntaxMatchCaseBody;
  }

  abstract ast ParseTreePattern
  {
    | Identifier
      {
        Reference : Reference;
      }

    | Ctor
      {
        Reference : Reference;
        Arguments : ParseTreePattern*;
      }

    | Tuple
      {
        Members : ParseTreePattern*;
      }

    | List1
      {
        Head : ParseTreePattern;
        Tail : ParseTreePattern;
      }

    | List2
      {
        Items : ParseTreePattern*;
      }
  }
}
