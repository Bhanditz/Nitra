using DotNet;

using Nitra.Runtime.Binding;

namespace Nitra.Ast
{
  abstract ast MapSyntax : BindableAst
  {
    AstName.Scope = Scope;

    out ParameterScope : TableScope = TableScope("parameters", null);

  stage 1:
    out Rule    : RuleSymbol;
    out AstType : AstTypeSymbol;
    out AstRef  : Ref[AstTypeSymbol] = this.AstName.Ref.Resolve();

    AstType       = AstRef.Symbol;
    Body.AstScope = Scope.HideWith(AstRef.Scope);
    Body.Scope    = Scope.HideWith(ParameterScope).HideWith(Rule.Scope);
    Body.Rule     = Rule;
    Body.AstType  = AstType;

    Parameters.ContainingTable = ParameterScope;
    Parameters.Scope = Body.AstScope;

    Parameters : MapSyntaxParameter*;
    AstName    : QualifiedReference;
    Body       : MapSyntaxBody;
  }

  declaration MapSyntaxParameter : BindableAst
  {
    symbol
    {
      Kind      = "parameter";
      SpanClass = DotNetLangLanguage.ParameterSpanClass;

    stage 1:
      in Type : AstTypeSymbol;
    }

  stage 1:
    out AstTypeRef : Ref[AstTypeSymbol] = AstName.Ref.Resolve();

    AstName.Scope = Scope;
    Symbol.Type   = AstTypeRef.Symbol;

    AstName : QualifiedReference;
  }

  ast TopMapSyntax : MapSyntax, NamespaceMember
  {
    RuleName.Scope = Scope;

  stage 1:
    out RuleRef : Ref[RuleSymbol] = this.RuleName.Ref.Resolve();

    Rule = RuleRef.Symbol;

    RuleName : QualifiedReference;
  }

  ast InlineMapSyntax : MapSyntax, RuleBodyMember
  {
    Rule = Parent;
  }

  ast ExtensionMapSyntax : BindableAst
  {
    RuleName.Scope = Scope;

  stage 1:
    in  AstScope       : Scope;
    in  DefaultAstType : AstTypeSymbol;
    out RuleRef        : Ref[ExtensionRuleSymbol] = this.RuleName.Ref.Resolve();
    out AstTypeRef     : Ref[AstTypeSymbol]       = AstUtils.BindAstExtension(this.RuleName, DefaultAstType.Scope, DefaultAstType);

    Body.AstScope = AstScope.HideWith(AstTypeRef.Scope);
    Body.Scope    = Scope.HideWith(RuleRef.Scope);
    Body.Rule     = RuleRef.Symbol;
    Body.AstType  = AstTypeRef.Symbol;

    RuleName : Reference;
    Body     : MapSyntaxBody;
  }

  abstract ast MapSyntaxBody : BindableAst
  {
  stage 1:
    in AstScope : Scope;
    in Rule     : RuleSymbol;
    in AstType  : AstTypeSymbol;

    | Empty
      {
      }

    | Inline
      {
        Code : string;
      }

    | PerMember
      {
        Members.AstScope = AstScope;
        Members.Scope    = Scope;
        Members.Rule     = Rule;
        Members.AstType  = AstType;

        Members : MapSyntaxExpressionAstMember*;
      }

    | Expression
      {
        Expression.AstScope = AstScope;
        Expression.Scope    = Scope;

        Expression : MapSyntaxExpression;
      }

    | Extensions
      {
        Members.AstScope       = AstScope;
        Members.Scope          = Scope;
        Members.DefaultAstType = AstType;

        Members : ExtensionMapSyntax*;
      }
  }

  abstract ast MapSyntaxExpressionAstMember : BindableAst
  {
  stage 1:
    in AstScope : Scope;
    in Rule     : RuleSymbol;
    in AstType  : AstTypeSymbol;

    AstProperty.Scope  = AstType.Scope;
    AstProperty : Reference;

    | Inline
      {
        Code : string;
      }

    | Expression
      {
        Expression.AstScope = AstScope;
        Expression.Scope    = Scope;

        Expression  : MapSyntaxExpression;
      }
  }

  abstract ast ParseTreePattern
  {
    in VariableScope : TableScope;

    | Identifier
      {
        Reference : Reference;
      }

    | Ctor
      {
        Reference : Reference;
        Arguments : ParseTreePattern*;
      }

    | Tuple
      {
        Members : ParseTreePattern*;
      }

    | List1
      {
        Head : ParseTreePattern;
        Tail : ParseTreePattern;
      }

    | List2
      {
        Items : ParseTreePattern*;
      }
  }
}
