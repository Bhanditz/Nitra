using DotNet;

using Nitra.Runtime.Binding;

namespace Nitra.Ast
{
  abstract ast MapSyntax : BindableAst
  {
    AstName.Scope = Scope;

    out ParameterScope : TableScope = TableScope("parameters", null);

  stage 1:
    out Rule    : RuleSymbol;
    out AstType : AstTypeSymbol;
    out AstRef  : Ref[AstTypeSymbol] = this.AstName.Ref.Resolve();

    Parameters.ContainingTable = ParameterScope;
    AstType       = AstRef.Symbol;
    Body.Scope    = Scope.HideWith(ParameterScope).HideWith(Rule.Scope);
    Body.Rule     = Rule;
    Body.AstType  = AstType;

    Parameters : MapSyntaxParameter*;
    AstName    : QualifiedReference;
    Body       : MapSyntaxBody;
  }

  declaration MapSyntaxParameter
  {
    symbol
    {
      Kind      = "parameter";
      SpanClass = DotNetLangLanguage.ParameterSpanClass;
    }

    AstName : QualifiedReference;
  }

  ast TopMapSyntax : MapSyntax, NamespaceMember
  {
    RuleName.Scope = Scope;

  stage 1:
    out RuleRef : Ref[RuleSymbol] = this.RuleName.Ref.Resolve();

    Rule = RuleRef.Symbol;

    RuleName : QualifiedReference;
  }

  ast InlineMapSyntax : MapSyntax, RuleBodyMember
  {
    Rule = Parent;
  }

  ast ExtensionMapSyntax : BindableAst
  {
    RuleName.Scope = Scope;

  stage 1:
    in  DefaultAstType : AstTypeSymbol;
    out RuleRef        : Ref[ExtensionRuleSymbol] = this.RuleName.Ref.Resolve();
    out AstTypeRef     : Ref[AstTypeSymbol]       = AstUtils.BindAstExtension(this.RuleName, DefaultAstType.Scope, DefaultAstType);

    Body.Scope   = Scope.HideWith(RuleRef.Scope);
    Body.Rule    = RuleRef.Symbol;
    Body.AstType = AstTypeRef.Symbol;

    RuleName : Reference;
    Body     : MapSyntaxBody;
  }

  abstract ast MapSyntaxBody : BindableAst
  {
  stage 1:
    in Rule    : RuleSymbol;
    in AstType : AstTypeSymbol;

    | Empty
      {
      }

    | Inline
      {
        Code : string;
      }

    | PerMember
      {
        Members.Scope   = Scope;
        Members.Rule    = Rule;
        Members.AstType = AstType;

        Members : MapSyntaxExpressionAstMember*;
      }

    | Expression
      {
        Expression.Scope = Scope;

        Expression : MapSyntaxExpression;
      }

    | Extensions
      {
        Members.Scope          = Scope;
        Members.DefaultAstType = AstType;

        Members : ExtensionMapSyntax*;
      }
  }

  abstract ast MapSyntaxExpressionAstMember : BindableAst
  {
  stage 1:
    in Rule    : RuleSymbol;
    in AstType : AstTypeSymbol;

    AstProperty.Scope  = AstType.Scope;
    AstProperty : Reference;

    | Inline
      {
        Code : string;
      }

    | Expression
      {
        Expression.Scope = Scope;

        Expression  : MapSyntaxExpression;
      }
  }


  abstract ast ParseTreePattern
  {
    in VariableScope : TableScope;

    | Identifier
      {
        Reference : Reference;
      }

    | Ctor
      {
        Reference : Reference;
        Arguments : ParseTreePattern*;
      }

    | Tuple
      {
        Members : ParseTreePattern*;
      }

    | List1
      {
        Head : ParseTreePattern;
        Tail : ParseTreePattern;
      }

    | List2
      {
        Items : ParseTreePattern*;
      }
  }
}
