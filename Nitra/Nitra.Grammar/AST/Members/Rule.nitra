using DotNet;

using Nitra.AstUtils;
using Nitra.Runtime.Binding;

using System.Collections.Generic;

using R  = Nitra.Ast.RuleExpressions;
using RX = Nitra.Ast.RegexExpressions;

namespace Nitra.Ast
{
  abstract declaration RuleType : Type
  {
    symbol
    {
      Kind = "rule type";
    }
  }

  abstract declaration RuleVoidType : RuleType { }

  declaration RuleVoidTypeImpl : RuleVoidType
  {
    symbol
    {
      ToString = "Void";
      ToXaml = ToString();
    }
  }
  declaration RuleListType    : RuleType
  {
    symbol
    {
      in ElemType  : RuleTypeSymbol;
      ToString = "List[" + ElemType + "]";
      ToXaml = ToString();
    }
  }
  declaration RuleTupleType   : RuleType
  {
    symbol
    {
      in ElemTypes : IList[RuleTypeSymbol];
      ToString = string.Join(" * ", ElemTypes);
      ToXaml = ToString();
    }
  }
  declaration RuleOptionType  : RuleType
  {
    symbol
    {
      in ValueType : RuleTypeSymbol;
      ToString = "option(" + ValueType + ")";
      ToXaml = ToString();
    }
  }
  abstract declaration RuleCharsType : RuleType { }
  declaration RuleLiteralType : RuleCharsType
  {
    symbol
    {
      ToString = "Literal";
      ToXaml = ToString();
    }
  }
}

namespace Nitra.Ast
{
  abstract declaration Rule : RuleType, SyntaxElementContainer
  {
    symbol
    {
      out MemberTable : TableScope = TableScope(this.ToString(), this);

      SpanClass = NitraLangLanguage.RuleSpanClass;
      Kind      = "syntax";
    }
  }

  abstract declaration RegexRule : RuleCharsType, Rule
  {
    symbol
    {
      Kind = "regex";
      SpanClass = NitraLangLanguage.RegexRuleSpanClass;
    }

    Expression.Scope = Scope;

    Expression : RX.Expression;
  }

  abstract declaration SyntaxRule : Rule
  {
    symbol
    {
      Kind      = "syntax";
      SpanClass = NitraLangLanguage.RuleSpanClass;
    }

    Expression.Literals = LiteralsIn;
    Expression.Scope = Scope;

    Expression : R.Expression;
  }

  abstract declaration SimpleRuleBase : SyntaxRule { }
  abstract declaration SimpleRule : SimpleRuleBase { }
  abstract declaration VoidRule   : SimpleRuleBase, RuleVoidType
  {
    symbol
    {
      Kind      = "void rule";
      SpanClass = NitraLangLanguage.RuleSpanClass;
    }
  }
  abstract declaration TokenRule  : SimpleRuleBase
  {
    symbol
    {
      Kind      = "token";
      SpanClass = NitraLangLanguage.RuleSpanClass;
    }
  }

  abstract declaration ExtensibleRule : Rule
  {
    Members.LiteralsIn = LiteralsIn;
    Members.ContainingTable = Symbol.MemberTable;
    Members.Scope = Scope;

    Members : RuleBodyMember*;
  }
}
