using DotNet;

using Nitra.Runtime.Binding;

namespace Nitra.Ast
{
  abstract ast ParseTreePattern : ScopedAst, BindableAst
  {
  stage 1:
    in ExpectedType : TypeSymbol;

    | Wildcard
      {
      }

    | Ctor
      {
        Reference.Scope           = Scope;
        Arguments.Scope           = Scope;
        Arguments.ContainingTable = ContainingTable;

        Reference : Reference;
        Arguments : ParseTreePattern*;
      }

    | Tuple
      {
        Members.Scope           = Scope;
        Members.ContainingTable = ContainingTable;

        Members : ParseTreePattern*;
      }

    | List1
      {
      stage 1:
        out ListTypeRef : Ref[RuleListTypeSymbol] = ExpectedType.TryCast(File, Span);

        Head.Scope           = Scope;
        Head.ContainingTable = ContainingTable;
        Head.ExpectedType    = ListTypeRef.Symbol.ElemType;
        Tail.Scope           = Scope;
        Tail.ContainingTable = ContainingTable;
        Tail.ExpectedType    = ListTypeRef.Symbol;

        unless (ListTypeRef.IsSymbolEvaluated)
          Error($"List patten is not valid for type '$(ExpectedType)'.");

        Head : ParseTreePattern;
        Tail : ParseTreePattern;
      }

    | List2
      {
      stage 1:
        out ListTypeRef : Ref[RuleListTypeSymbol] = ExpectedType.TryCast(File, Span);

        Items.Scope           = Scope;
        Items.ContainingTable = ContainingTable;
        Items.ExpectedType    = ListTypeRef.Symbol.ElemType;

        unless (ListTypeRef.IsSymbolEvaluated)
          Error($"List patten is not valid for type '$(ExpectedType)'.");

        Items : ParseTreePattern*;
      }
  }

  declaration ParseTreePatternVariable : ParseTreePattern, TypedDeclaration
  {
    symbol
    {
      Kind = "pattern variable";
    }

    Symbol.Type = ExpectedType;
  }
}
