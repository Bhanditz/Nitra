using Nemerle;
using Nemerle.Collections;
using Nemerle.Imperative;
using Nemerle.Text;
using Nemerle.Utility;

using Nitra;
using Nitra.Ast;
using Nitra.Declarations;
using Nitra.ProjectSystem;
using Nitra.Runtime.Binding;

using System;
using System.Collections.Generic;
using System.Linq;

namespace DotNet
{
  module SymbolUtils
  {
    public TryGetLiterals(reference : Ref[ISymbol2], literals : Map[string, string]) : Map[string, string]
    {
      when (reference.IsSymbolEvaluated)
      when (reference.Symbol is SyntaxModuleSymbol as m)
        return literals.ReplaceRange(m.Literals);
        
      literals
    }
    
    public PrependScopeIfResolved(reference : Ref[ISymbol2], scopes : list[Scope]) : list[Scope]
    {
      if (reference.IsSymbolEvaluated)
        reference.Symbol.Scope :: scopes
      else
        scopes
    }

    public MakeNamespaceFullName(parentFullName : string, name : string) : string
    {
      if (string.IsNullOrEmpty(parentFullName))
        name
      else
        parentFullName + "." + name
    }

    public IsSameIdentity(typeParametersCount : int, candidate : Declaration) : bool
    {
      match (candidate)
      {
        | DotNet.GenericType as t => t.TypeParameterAliases.Count == typeParametersCount
        | Namespace
        | DotNet.Type             => typeParametersCount == 0
        | _                       => false
      }
    }

    public CanMerge[T](typeParametersCount : int, candidate : Declaration) : bool
      where T : GenericType
    {
      match (candidate)
      {
        | genericType is T => genericType.TypeParameterAliases.Count == typeParametersCount
        | _ => false
      }
    }

     public CanMerge[T](symbol : GenericEntitySymbol, candidate : Declaration) : bool
      where T : GenericEntity
    {
      match (candidate)
      {
        | genericType is T => genericType.TypeParameterAliases.Count == symbol.TypeParametersCount
        | _ => false
      }
    }

    public CanMerge[T](symbol : GenericContainerTypeSymbol, candidate : Declaration) : bool
      where T : GenericContainerType
    {
      match (candidate)
      {
        | genericType is T => genericType.TypeParameterAliases.Count == symbol.TypeParametersCount && symbol.IsPartial && genericType.IsPartial.ValueOrDefault
        | _ => false
      }
    }
    
    public FilterResolved(refs : array[Ref[DeclarationSymbol]]) : array[TypeSymbol]
    {
      def lst = List(refs.Length);

      foreach (r in refs)
      {
        def r2 = r.Resolve.[TypeSymbol]();
        when (r2.IsScopeEvaluated)
          lst.Add(r2.Symbol);
      }

      lst.ToArray()
    }

    public CreateNestedConstructedTypeSymbol(t : NestedGenericTypeSymbol, parentTypeSubst : TypeSymbol) : ConstructedTypeSymbol
    {
      def resultSymbol      = NestedConstructedTypeSymbol();
      resultSymbol.Parent   = parentTypeSubst;
      resultSymbol.TypeSubst = resultSymbol;
      foreach (decl in t.Declarations)
        resultSymbol.AddDeclaration(decl);
      resultSymbol
    }

    public CreateNestedConstructedTypeSymbol(file : File, span : NSpan, parentTypeSubst : TypeSymbol) : ConstructedTypeSymbol
    {
      def span2             = NSpan(span.StartPos);
      def name              = Name(file, span, "#ConstructedType");
      def decl              = NestedConstructedType(file, span, name, Attribute.AstList(file, span2), Modifier.AstList(file, span2));
      def resultSymbol      = NestedConstructedTypeSymbol();
      resultSymbol.Parent   = parentTypeSubst;
      resultSymbol.TypeSubst = resultSymbol;
      name.Symbol = resultSymbol;
      resultSymbol.AddDeclaration(decl);
      resultSymbol
    }

    public CreateConstructedTypeSymbol(file : File, span : NSpan) : ConstructedTypeSymbol
    {
      def span2             = NSpan(span.StartPos);
      def name              = Name(file, span, "#ConstructedType");
      def decl              = TopConstructedType(file, span, name, Attribute.AstList(file, span2), Modifier.AstList(file, span2));
      def resultSymbol      = TopConstructedTypeSymbol();
      name.Symbol = resultSymbol;
      resultSymbol.AddDeclaration(decl);
      resultSymbol
    }

    public MakeConstructedType(ast : ILocated, args : array[Ref[DeclarationSymbol]]) : ResolutionAlgorithm[DeclarationSymbol, DeclarationSymbol]
    {
      mutable allArgumentsResolved = true;
      def resolvedArgs = array(args.Length);
      foreach (arg in args with index)
      {
        def resolvedArg = arg.Resolve.[TypeSymbol]();
        if (resolvedArg.IsSymbolEvaluated)
          resolvedArgs[index] = resolvedArg.Symbol
        else
        {
          allArgumentsResolved = false; 
          resolvedArgs[index]  = null;
        }
      }

      fun (symbol)
      {
        | symbol is GenericTypeSymbol =>
          mutable argsWithTemplates = resolvedArgs;
          unless (allArgumentsResolved)
          {
            def typeParameters = symbol.TypeParameters;
            argsWithTemplates  = array(resolvedArgs.Length);
            foreach (arg in resolvedArgs with index)
              argsWithTemplates[index] = arg ?? typeParameters[index];
          }

          def resultSymbol      = CreateConstructedTypeSymbol(ast.File, ast.Span);
          resultSymbol.TypeInfo = symbol;
          resultSymbol.Args     = argsWithTemplates;
          VSome(resultSymbol)

        | _ => VNone()
      }
    }
  } // module
} // NS
