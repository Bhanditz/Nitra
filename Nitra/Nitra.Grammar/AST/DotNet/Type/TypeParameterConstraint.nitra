using Nitra;
using Nitra.Ast;
using Nitra.Runtime.Binding;

using Nemerle.Collections;

namespace DotNet
{
  abstract ast TypeParameterConstraint
  {
  stage 1:
    in    Scope                    : Scope;
    in    TypeConstraints          : TypeConstraintSet;
    inout ConstraintIndex          : int;
    in    ConstraintCount          : int;

    ConstraintIndexOut = ConstraintIndexIn + 1;

    | Ctor
      {
        TypeConstraints |= TypeConstraint.Ctor;

        when (ConstraintIndexOut != ConstraintCount)
          Error("The 'new()' constraint must be the last constraint specified.");
      }
    | Class
      {
        TypeConstraints |= TypeConstraint.Class;

        when (ConstraintIndexIn != 0)
          Error("The 'class' constraint must come before any other constraints.");
      }
    | Struct
      {
        TypeConstraints |= TypeConstraint.Struct;

        when (ConstraintIndexIn != 0)
          Error("The 'struct' constraint must come before any other constraints.");
      }
    | Base
      {
        Type.Scope = Scope;
        TypeConstraints |= Type.Type;

        // TODO: add non-sealed check
        out IsValid                  : bool = Type.Type.IsClass || Type.Type.IsInterface || Type.Type.IsTypeParameter;

      stage 1:
        out IsClassOrStructSpecified : bool = TypeConstraints.Contains(TypeConstraint.Class) || TypeConstraints.Contains(TypeConstraint.Struct);

        Type : QualifiedReference;

        when (Type.Type.IsClass)
        when (IsClassOrStructSpecified)
          Error($"'$(Type.Type)': cannot specify both a constraint class and the 'class' or 'struct' constraint.");

        when (Type.Type.IsClass)
        when (ConstraintIndexIn != 0)
        unless (IsClassOrStructSpecified)
          Error($"The class type constraint '$(Type.Type)' must come before any other constraints.");

        unless (IsValid)
          Error($"'$(Type.Type)' is not a valid constraint. A type used as a constraint must be an interface, a non-sealed class or a type parameter.");
      }
  }
}
