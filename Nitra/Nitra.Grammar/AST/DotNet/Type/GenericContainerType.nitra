using DotNet;

using Nemerle.Collections;

using Nitra;
using Nitra.Ast;
using Nitra.Declarations;
using Nitra.Runtime.Binding;
using Nitra.Internal;

using System.Linq;
using SCG = System.Collections.Generic;

namespace DotNet
{
  // class, struct or interface
  abstract declaration GenericContainerType : GenericType
  {
    symbol
    {
      SpanClass = DotNetLangLanguage.TypeSpanClass;
      Scope     = MemberTable;

      out MemberTable     : TableScope       = TableScope(this.ToString(), this);
      out IsPartial       : bool             = Utils.IsPartial(this.Declarations);
      in  BaseTypeSet     : BaseTypeReferenceSet;

      when (BaseTypeSet.IsCycled)
        Error($"'$(self.Name)' is cycled.");
    }

    TypeBase.Scope   = TypeParameterConstraints.Scope;
    Members.Parent   = Symbol;
    Members.Scope    = Scope.HideWith(Symbol.BaseTypeSet.ParentScope)
                            .HideWith(TypeParameterAliasesScope)
                            .HideWith(Symbol.MemberTable);

    Symbol.BaseTypeSet |= TypeBase.Type;

    TypeBase                 : QualifiedReference*;
    Members                  : TypeMember*;
    IsPartial                : bool;
  }

  abstract declaration TopGenericEntity    : GenericEntity, NamespaceMemberDeclaration { }
  abstract declaration NestedGenericEntity : GenericEntity, TypeMember                 { }

  declaration TopClass        : GenericContainerType, TopGenericEntity    { symbol { Kind = "class";     IsSameIdentity = SymbolUtils.IsSameIdentity(TypeParametersCount, candidate); CanMerge = SymbolUtils.CanMerge.[TopClass       ](this, candidate); } }
  declaration NestedClass     : GenericContainerType, NestedGenericEntity { symbol { Kind = "class";     IsSameIdentity = SymbolUtils.IsSameIdentity(TypeParametersCount, candidate); CanMerge = SymbolUtils.CanMerge.[NestedClass    ](this, candidate); } }
  declaration TopStruct       : GenericContainerType, TopGenericEntity    { symbol { Kind = "struct";    IsSameIdentity = SymbolUtils.IsSameIdentity(TypeParametersCount, candidate); CanMerge = SymbolUtils.CanMerge.[TopStruct      ](this, candidate); } }
  declaration NestedStruct    : GenericContainerType, NestedGenericEntity { symbol { Kind = "struct";    IsSameIdentity = SymbolUtils.IsSameIdentity(TypeParametersCount, candidate); CanMerge = SymbolUtils.CanMerge.[NestedStruct   ](this, candidate); } }
  declaration TopInterface    : GenericContainerType, TopGenericEntity    { symbol { Kind = "interface"; IsSameIdentity = SymbolUtils.IsSameIdentity(TypeParametersCount, candidate); CanMerge = SymbolUtils.CanMerge.[TopInterface   ](this, candidate); } }
  declaration NestedInterface : GenericContainerType, NestedGenericEntity { symbol { Kind = "interface"; IsSameIdentity = SymbolUtils.IsSameIdentity(TypeParametersCount, candidate); CanMerge = SymbolUtils.CanMerge.[NestedInterface](this, candidate); } }
}
