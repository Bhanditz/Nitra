using Nitra;
using Nitra.Runtime.Binding;

using Nemerle;
using Nemerle.Collections;
using Nemerle.Imperative;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;

namespace DotNet
{
  public partial interface TypeSymbol : DeclarationSymbol
  {
  }
  
  public partial class ConstractedTypeSymbol : SymbolBase, TypeSymbol, IEquatable[ConstractedTypeSymbol]
  {
    public Equals(other : ConstractedTypeSymbol) : bool
      implements IEquatable[ConstractedTypeSymbol].Equals
    {
      | null => false
      | _ => this.TypeInfo.Equals(other.TypeInfo) && this.Args.Equals(other.Args)
    }

    public override Equals(other : object) : bool
    {
      | ConstractedTypeSymbol as other => Equals(other)
      | _ => false
    }

    public override GetHashCode() : int
    {
      unchecked
      {
        mutable i = TypeInfo.GetHashCode();
        foreach (arg in Args with index)
          i ^= arg.GetHashCode() << index;
        i
      }
    }
  }
  
  public partial class TypeParameterSymbol : SymbolBase, TypeSymbol
  {
    private mutable _aliases : list[TypeParameterAlias] = [];

    public Aliases : list[TypeParameterAlias] { get { _aliases } }

    internal AddAliasSymbol(alias : TypeParameterAlias) : void
    {
      _aliases ::= alias;
      def decl = TypeParameter(alias.File, alias.Span, alias.Name, alias.Attributes, alias.Modifiers, false);
      AddDeclaration(decl);
    }
  }

  public partial class TypeParameterAliasSymbol : SymbolBase, TypeSymbol
  {
  }
}
