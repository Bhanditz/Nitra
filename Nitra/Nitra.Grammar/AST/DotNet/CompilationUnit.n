using Nemerle;
using Nemerle.Collections;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Imperative;
using Nemerle.Text;
using Nemerle.Utility;

using Nitra;
using Nitra.Declarations;
using Nitra.Internal;
using Nitra.ProjectSystem;
using Nitra.Runtime.Binding;

using System;
using System.Collections.Generic;
using System.Linq;

using NRB = Nitra.Runtime.Binding;

namespace Nitra.Runtime.Binding
{
  public partial interface BindableAst : IDependentPropertyContainer, IAst { }
}

namespace DotNet
{
  public partial interface NamespaceBody : IDependentPropertyContainer, IAst, BindableAst {}
  
  public partial class CompilationUnit : AstBase, IProjectSupport, NamespaceBody
  {
    public RefreshProject(files : Seq[File]) : void
    {
      def files         = files.ToArray();
      def context       = DependentPropertyEvalContext();
      def rootNamespace = NamespaceSymbol();
      rootNamespace.MemberTable = TableScope("<root namespace>");
      rootNamespace.Parent = null;
      rootNamespace.FullName = "";

      CreateNemerleSymbols(rootNamespace, context);

      foreach (file in files)
        when (file.Ast is CompilationUnit as cu)
          cu.RootNamespace = rootNamespace;
      AstUtils.EvalProperties(context, files, "SymbolHierarchy", 0, rootNamespace);

      def rootScope = rootNamespace.Scope;
      foreach (file in files)
        when (file.Ast is CompilationUnit as cu)
          cu.Scope = rootScope;
      AstUtils.EvalProperties(context, files, "Scopes", 1, rootNamespace);

      AstUtils.EvalProperties(context, files, "Type bodies binding", 2, rootNamespace);
    } 

    class Compiler : ManagerClass
    {
      public this ()
      {
        base (CompilationOptions());
        def localPath = IO.Path.GetFullPath(Uri(typeof(ManagerClass).Assembly.CodeBase).LocalPath);
        def macroLibPath = localPath;
        def compilerDir = IO.Path.GetDirectoryName(localPath);
        this.Options.DoNotLoadMacros = true;
        this.Options.MacrosToLoad ::= macroLibPath;
        this.Options.LibraryPaths ::= compilerDir;
        InitCompiler ();
        LoadExternalLibraries ();
      }
    }
    
    private static CreateNemerleSymbols(rootNamespace : NamespaceSymbol, context : DependentPropertyEvalContext) : void
    {
      when (ManagerClass.Instance == null)
      {
        ManagerClass.Instance = Compiler();
      }
        
      def manager       = ManagerClass.Instance;
      def nemerleNsRoot = manager.NameTree.NamespaceTree;
      def fakeSnapshot  = SourceSnapshot("");
      def file          = fakeSnapshot.File;
      def span          = NSpan(0);
      
      def loadNsMemebers(node : NamespaceTree.Node, parent : DotNet.NamespaceSymbol) : void
      {
        def addTopType(node : NamespaceTree.Node, tycon : TypeInfo) : void
        {
          def name = NRB.Name(file, span, node.PartName);
          def kind = tycon.GetTydecl();
          match (kind)
          {
            | Interface
            | Class =>
              def symbol : TopGenericEntitySymbol = 
                           if (tycon.IsDelegate) TopDelegateSymbol() 
                      else if (tycon.IsInterface) TopInterfaceSymbol()
                      else if (tycon.IsValueType) TopStructSymbol()
                      else TopClassSymbol();
              symbol.TypeParametersCount = tycon.TyparmsCount;
              symbol.TypeParameters = Utils.CreateTypeParameters(tycon.TyparmsCount);
              def decl   = ExternalDeclaration(name, symbol, node);
              _ = parent.MemberTable.Define(decl, context, null);
              symbol.Parent = parent;
                
            | Alias         =>
              def symbol = TypeAliasSymbol();
              def decl   = ExternalDeclaration(name, symbol, node);
              _ = parent.MemberTable.Define(decl, context, null);
              symbol.Parent = parent;

            | Variant       => ()
            | VariantOption => ()
            | Enum          =>
              def symbol = TopEnumSymbol();
              def decl   = ExternalDeclaration(name, symbol, node);
              _ = parent.MemberTable.Define(decl, context, null);
              symbol.Parent = parent;
          }
        }
        node.EnsureCached();
   
        match (node.Value)
        {
          | No                               => ()
          | MacroCall                        => ()
          | null                             => ()
          | NamespaceReference               => 
            def symbol = NamespaceSymbol();
            def decl   = ExternalDeclaration(NRB.Name(file, span, node.PartName), symbol, node);
            _ = parent.MemberTable.Define(decl, context, null);
            symbol.Parent = parent;
            foreach (subNode in node.Children.Values.ToArray())
              loadNsMemebers(subNode, symbol);
            
          | Cached(tycon) =>  addTopType(node, tycon);
          | CachedAmbiguous(elems)       => foreach (e in elems) addTopType(node, e);
          | NotLoaded(_externalType)     => assert2(false)
          | NotLoadedList(_externalType) => assert2(false)
        }
      }
      
      rootNamespace.EvalProperties(context);
      
      foreach (node in nemerleNsRoot.Children.Values)
        loadNsMemebers(node, rootNamespace);
    }
  }
  
  class ExternalDeclaration : Nitra.Declarations.DeclarationBase, Declaration
  {
    mutable _symbol : DeclarationSymbol;
    _nemerleTrypeTreeNode : NamespaceTree.Node;
    
    public this(name : NRB.Name, symbol : DeclarationSymbol, nemerleTrypeTreeNode : NamespaceTree.Node)
    {
      this.File = name.File;
      this.Span = name.Span;
      __NameImpl = name;
      _symbol = symbol;
      _nemerleTrypeTreeNode = nemerleTrypeTreeNode;
    }

    public CreateSymbol() : DeclarationSymbol { _symbol }
    
    public IsSymbolEvaluated : bool { get; private set; }
    
    public Name : NRB.Name { get { __NameImpl } }
    
    public Symbol : DeclarationSymbol
    {
      get { _symbol }
      set { IsSymbolEvaluated = true; _symbol = value; }
    }
    
    public ContainingTable : TableScope { get; set; }
    public IsContainingTableEvaluated : bool { get { ContainingTable != null } }
  }
}
