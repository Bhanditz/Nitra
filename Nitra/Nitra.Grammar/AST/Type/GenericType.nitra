using DotNet.Utils;

using Nemerle.Collections;

using Nitra;
using Nitra.Ast;
using Nitra.Declarations;
using Nitra.Runtime.Binding;
using Nitra.Internal;

using System.Linq;
using SCG = System.Collections.Generic;

namespace DotNet
{

  abstract declaration GenericEntity : BindableAst
  {
    symbol
    {
      out TypeParametersCount : int = GetTypeParametersCount(this.Declarations);
      out TypeParameters      : SCG.IList[TypeParameterSymbol] = CreateTypeParameters(TypeParametersCount);
    }

    // Local scope. Type parameters can have different names. We should use alias to reflect it.
    out TypeParameterAliasesScope : TableScope = TableScope("type parameters");

    TypeParameterAliases.TypeParameterSymbols  = Symbol.TypeParameters;
    TypeParameterAliases.IndexIn               = 0;
    TypeParameterAliases.ContainingTable       = TypeParameterAliasesScope;
    TypeParameterAliases.Scope                 = Scope;
    TypeParameterConstraints.Scope             = Scope.HideWith(TypeParameterAliasesScope);
    TypeParameterConstraints.ConstraintedParameters = SCG.HashSet();
    TypeParameterAliases.DeclaringMember       = Symbol;

    TypeParameterAliases     : TypeParameterAlias*;
    TypeParameterConstraints : TypeParameterConstraintsClause*;
  }

  // delegate, class, struct or interface
  abstract declaration GenericType : Type, GenericEntity
  {
    symbol
    {
    }
  }
}
