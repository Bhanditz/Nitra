using DotNet;

using Nemerle;
using Nemerle.Imperative;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using Nitra.Ast;
using Nitra.Declarations;
using Nitra.ProjectSystem;
using Nitra.Runtime.Binding;

using System;
using System.Collections.Generic;
using System.Linq;

namespace Nitra
{
  module AstUtils
  {
    public UpdateLiterals(inMap : Map[string, string], literals : StringLiteral.IAstList, name : string) : Map[string, string]
    {
      when (string.IsNullOrEmpty(name))
        return inMap;

      def xs = literals.Select(x => x.Value.ValueOrDefault).Where(x => !string.IsNullOrEmpty(x)).Select(x => (x, name));
      inMap.ReplaceRange(xs)
    }

    public MakePlural(parsedValue : ParsedValue[string]) : ParsedValue[string]
    {
      if (parsedValue.HasValue)
        ParsedValue(parsedValue.Span, JetBrains.Util.NounUtil.GetPlural(parsedValue.Value))
      else
        parsedValue
    }

    public NMakeLiteralName(parsedValue : ParsedValue[string], literals : Map[string, string]) : ParsedValue[string]
    {
      unless (parsedValue.HasValue)
        return parsedValue;
        
      def value = parsedValue.ValueOrDefault;
      
      if (literals.Find(value) is Some(name))
        ParsedValue(parsedValue.Span, name)
      else if (Utils.IsIdentifier(value))
        ParsedValue(parsedValue.Span, Utils.ToPascalCase(value, "Kw"))
      else
        ParsedValue(parsedValue.Span, "Literal")
    }

    public TryGetLiterals(reference : Ref[DeclarationSymbol], literals : Map[string, string]) : Map[string, string]
    {
      when (reference.IsSymbolEvaluated)
      when (reference.Symbol is SyntaxModuleSymbol as m)
        return literals.ReplaceRange(m.Literals);
        
      literals
    }
    
    public static Init[T](this context : DependentPropertyEvalContext, symbol : T) : T
      where T: DeclarationSymbol
    {
      symbol.EvalProperties(context);
      symbol
    }

    public CanBeTupleElem(x : RuleTypeSymbol) : bool
    {
      !(x is RuleVoidTypeSymbol)
    }

    public InitTuple(context : DependentPropertyEvalContext, arg1 : RuleTypeSymbol, restArgs : array[RuleTypeSymbol]) : RuleTypeSymbol
    {
      when (restArgs.Length == 0)
      {
        if (CanBeTupleElem(arg1))
          return arg1;
        else
          return context.GetRuleVoidType();
      }
        
      def args = List();
      
      when (CanBeTupleElem(arg1))
        args.Add(arg1);
        
      foreach (arg when CanBeTupleElem(arg) in restArgs)
        args.Add(arg);

      match (args.Count)
      {
        | 0 => context.GetRuleVoidType()
        | 1 => args[0]
        | _ => 
          def symbol = RuleTupleTypeSymbol();
          symbol.ElemTypes = args;
          context.Init(symbol)
      }
    }

    public InitTuple(context : DependentPropertyEvalContext, arg1 : RuleTypeSymbol, arg2 : RuleTypeSymbol) : RuleTypeSymbol
    {
      match (CanBeTupleElem(arg1), CanBeTupleElem(arg2))
      {
        | (false,  true) => arg2
        | (true,  false) => arg1
        | (false, false) => context.GetRuleVoidType()
        | (true,   true) => 
            def symbol = RuleTupleTypeSymbol();
            symbol.ElemTypes = array[arg1, arg2];
            context.Init(symbol)
      }
    }

    public GetRuleVoidType(this context : DependentPropertyEvalContext) : RuleVoidTypeSymbol
    {
      def context = context :> NitraDependentPropertyEvalContext;
      context.RuleVoidType
    }
    
    public InitList(context : DependentPropertyEvalContext, elemType : RuleTypeSymbol) : RuleTypeSymbol
    {
      unless (CanBeTupleElem(elemType))
        return context.GetRuleVoidType();

      def symbol = RuleListTypeSymbol();
      symbol.ElemType = elemType;
      context.Init(symbol)
    }

    public InitOption(context : DependentPropertyEvalContext, valueType : RuleTypeSymbol) : RuleTypeSymbol
    {
      unless (CanBeTupleElem(valueType))
        return context.GetRuleVoidType();

      def symbol = RuleOptionTypeSymbol();
      symbol.ValueType = valueType;
      context.Init(symbol)
    }

    public CreateListAstType(loc : ILocated, item : Ref[DeclarationSymbol], context : DependentPropertyEvalContext) : Ref[DeclarationSymbol]
    {
      // TODO: handle unresolved Ref
      item.Resolve(fun (_)
      {
        | symbol is AstSymbol =>
          def name       = Name(loc.File, loc.Span, "#List");
          def decl       = ListAstType(loc.File, loc.Span, name);
          def listSymbol = ListAstTypeSymbol();
          listSymbol.AddDeclaration(decl);
          name.Symbol    = listSymbol;
          listSymbol.ElemType = symbol;
          listSymbol.EvalProperties(context);
          VSome(listSymbol)

        | _ => VNone()
      })
    }

    public CreateOptionAstType(loc : ILocated, item : Ref[DeclarationSymbol], context : DependentPropertyEvalContext) : Ref[DeclarationSymbol]
    {
      // TODO: handle unresolved Ref
      item.Resolve(fun (_)
      {
        | symbol is AstSymbol =>
          def name         = Name(loc.File, loc.Span, "#Option");
          def decl         = OptionAstType(loc.File, loc.Span, name);
          def optionSymbol = OptionAstTypeSymbol();
          optionSymbol.AddDeclaration(decl);
          name.Symbol      = optionSymbol;
          optionSymbol.ValueType = symbol;
          optionSymbol.EvalProperties(context);
          VSome(optionSymbol)

        | _ => VNone()
      })
    }

    public BindAstExtension(name : Reference, scope : Scope, defaultReturnType : AstTypeSymbol) : Ref[AstTypeSymbol]
    {
      mutable candidates = LightList();
      scope.BindMany(name, ref candidates);
      match (candidates.Count)
      {
        | 0 => Ref.Some(name.File, name.Span, defaultReturnType)
        | 1 => Ref.Some(name.File, name.Span, candidates.FirstItem)
        | _ => Ref.Ambiguous(name.File, name.Span, candidates.ToNList(), ResolutionSource.Bind(scope))
      }
    }

    public CreateRuleField(parseTree : NitraSyntaxParseTree.RuleExpression) : RuleField
    {
      def name = Name(parseTree.File, NSpan(parseTree.Span.StartPos), "<none>");
      def expr = parseTree.GetAst();
      RuleField(parseTree.File, parseTree.Span, name, expr)
    }

    public CreateRuleFieldList(parseTree : NitraSyntaxParseTree.RuleExpression) : RuleField.IAstList
    {
      RuleField.AstList(parseTree.File, parseTree.Span, AstUtils.CreateRuleField(parseTree));
    }

    public CreateName(file : File, desiredName : ParsedValue[string]) : Name
    {
      Name(file, desiredName.Span, desiredName.ValueOrDefault ?? "")
    }

    public IsLooksLikeVariableName(text : string) : bool
    {
      text.Length > 0 && (text[0] == '_' || char.IsLower(text[0]))
    }
  } // module
} // namespace
