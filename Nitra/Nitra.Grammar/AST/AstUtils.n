using DotNet;

using Nemerle;
using Nemerle.Imperative;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using Nitra.Ast;
using Nitra.Declarations;
using Nitra.ProjectSystem;
using Nitra.Runtime.Binding;

using System;
using System.Collections.Generic;
using System.Linq;

namespace Nitra
{
  module AstUtils
  {
    public UpdateLiterals(inMap : Map[string, string], literals : StringLiteral.IAstList, name : string) : Map[string, string]
    {
      when (string.IsNullOrEmpty(name))
        return inMap;

      def xs = literals.Select(x => x.Value.ValueOrDefault).Where(x => !string.IsNullOrEmpty(x)).Select(x => (x, name));
      inMap.ReplaceRange(xs)
    }

    public MakePlural(parsedValue : ParsedValue[string]) : ParsedValue[string]
    {
      if (parsedValue.HasValue)
        ParsedValue(parsedValue.Span, JetBrains.Util.NounUtil.GetPlural(parsedValue.Value))
      else
        parsedValue
    }

    public NMakeLiteralName(parsedValue : ParsedValue[string], literals : Map[string, string]) : ParsedValue[string]
    {
      unless (parsedValue.HasValue)
        return parsedValue;
        
      def value = parsedValue.ValueOrDefault;
      
      if (literals.Find(value) is Some(name))
        ParsedValue(parsedValue.Span, name)
      else if (Utils.IsIdentifier(value))
        ParsedValue(parsedValue.Span, Utils.ToPascalCase(value, "Kw"))
      else
        ParsedValue(parsedValue.Span, "Literal")
    }

    public TryGetLiterals(reference : Ref[ISymbol2], literals : Map[string, string]) : Map[string, string]
    {
      when (reference.IsSymbolEvaluated)
      when (reference.Symbol is SyntaxModuleSymbol as m)
        return literals.ReplaceRange(m.Literals);
        
      literals
    }
    
    public Init[T](context : DependentPropertyEvalContext, symbol : T) : T
      where T: DeclarationSymbol
    {
      symbol.EvalProperties(context);
      symbol
    }

    public InitTuple(context : DependentPropertyEvalContext, arg1 : RuleTypeSymbol, restArgs : array[RuleTypeSymbol]) : RuleTupleTypeSymbol
    {
      def symbol = RuleTupleTypeSymbol();
      def args = array(restArgs.Length + 1);
      restArgs.CopyTo(args, 1);
      args[0] = arg1;
      symbol.ElemTypes = args;
      Init(context, symbol)
    }

    public InitTuple(context : DependentPropertyEvalContext, arg1 : RuleTypeSymbol, arg2 : RuleTypeSymbol) : RuleTupleTypeSymbol
    {
      def symbol = RuleTupleTypeSymbol();
      symbol.ElemTypes = array[arg1, arg2];
      Init(context, symbol)
    }

    public InitList(context : DependentPropertyEvalContext, elemType : RuleTypeSymbol) : RuleListTypeSymbol
    {
      def symbol = RuleListTypeSymbol();
      symbol.ElemType = elemType;
      Init(context, symbol)
    }

    public InitOption(context : DependentPropertyEvalContext, valueType : RuleTypeSymbol) : RuleOptionTypeSymbol
    {
      def symbol = RuleOptionTypeSymbol();
      symbol.ValueType = valueType;
      Init(context, symbol)
    }
  } // module
} // namespace
