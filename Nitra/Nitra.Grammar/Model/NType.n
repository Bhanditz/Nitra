using Nemerle;
using Nemerle.Extensions;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using SCG = System.Collections.Generic;

using G = NitraSyntaxAst;

namespace Nitra.Model
{
  [Record, StructuralEquality]
  public variant NType
  {
    | Predefined { value : NPredefinedType }
    | Qualified  { parts : list[TypeNamePart] }
    | Tuple      { members : list[NType] }
    | Func       { from : NType; to : NType }
    | OptionList { item : NType }
    | List       { item : NType }
    | Option     { item : NType }

    public override ToString() : string
    {
      match (this)
      {
        | Predefined(t)    => t.ToString().ToLowerInvariant()
        | Qualified(parts) => $<#..$(parts; ".")#>
        | Tuple(members)   => $<#..$(members; " * ")#>
        | Func(from, to)   => $"$from -> $to"
        | OptionList(item) => item.ToString() + "+"
        | List(item)       => item.ToString() + "*"
        | Option(item)     => item.ToString() + "?"
      }
    }
  }

  [Record]
  public struct TypeNamePart
  {
    public Name          : string;
    public TypeArguments : list[NType];

    public override ToString() : string
    {
      if (this.TypeArguments is [])
        Name
      else
        $<#$Name<..$(TypeArguments; ", ")>#>
    }
  }

  public enum NPredefinedType
  {
    | Void = 0
    | Int
    | String
  }
}
