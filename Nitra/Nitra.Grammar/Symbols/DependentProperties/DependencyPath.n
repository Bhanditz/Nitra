using Nemerle;
using Nemerle.Internal;
using Nemerle.Collections;
using Nemerle.Extensions;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Text;
using System.Collections.Generic;
using System.Linq;

namespace Nitra.Typing
{
  [StructuralEquality]
  public variant DependencyPath
  {
    | This
    | Context
    | DeclaredProperty
      {
        Path   : DependencyPath;
        Symbol : PropertySymbol;
        [EqualsIgnore] Mask : int;

        [RecordCtor]
        public new this([MappedMember("Path")] path : DependencyPath, [MappedMember("Symbol")] symbol : PropertySymbol, [MappedMember("Mask")] mask : int)
        {
          Path   = path;
          Symbol = if (symbol.OverrideProperty is SymbolRef.Some(originalSymbol)) originalSymbol else symbol;
          Mask   = mask;
        }
      }
    | CustomProperty
      {
        Path : DependencyPath;
        Name : string;
      }

    public IsSinglePropertyPath : bool
    {
      get
      {
        match (this)
        {
          | DeclaredProperty(This, _, _)
          | CustomProperty(This, _) => true
          | _ => false
        }
      }
    }

    public override ToString() : string
    {
      ToString(StringBuilder()).ToString()
    }

    public ToString(buffer : StringBuilder) : StringBuilder
    {
      match (this)
      {
        | Context => buffer.Append("context")
        | This => buffer
        | DeclaredProperty(This, symbol, _) with name = symbol.Name
        | CustomProperty(This, name) => buffer.Append(name)
        | DeclaredProperty(path, symbol, _) with name = symbol.Name
        | CustomProperty(path, name) => path.ToString(buffer).Append('.').Append(name)
      }
    }
  }
}
