using Nitra.Model;
using Nitra.Serialization;

using Nemerle;
using Nemerle.Collections;
using Nemerle.Extensions;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;

namespace Nitra.Typing
{
  [Record]
  public abstract class AstSymbol : SingleDefSymbol
  {
    public abstract BaseAsts                 : list[AstSymbol]                  { get; }
    public abstract InitializedOutProperties : list[DependentAstPropertySymbol] { get; }
    public abstract IsDeclaration            : bool                             { get; }
    public abstract Cardinality              : AstCardinality                   { get; }
    public abstract Symbol                   : SymbolRef[SymbolSymbol]          { get; }

    public Properties : Seq[AstPropertySymbol]
    {
      get { this.Node.GetChildren.[AstPropertySymbol]() }
    }

    public AllBaseAsts : Seq[AstSymbol]
    {
      get { TypeInheritance(); _allBaseAsts }
    }

    public AllProperties : Seq[AstPropertySymbol]
    {
      get { TypeInheritance(); _allProperties.Values }
    }

    public IsSubtypeOf(other : AstSymbol) : bool
    {
      TypeInheritance();

      this == other || _allBaseAsts.Contains(other)
    }

    [RecordIgnore] private mutable _allBaseAsts         : HashSet[AstSymbol];
    [RecordIgnore] private mutable _allProperties       : Dictionary[string, AstPropertySymbol];
    [RecordIgnore] private mutable _isTypingInheritance : bool;
    [RecordIgnore] private mutable _isCyclic            : bool;

    public TypeInheritance() : void
    {
      if (_isTypingInheritance)
      {
        unless (_isCyclic)
        {
          Node.Project.Error(this.FirstLocation, $"Declaration '$(FullName)' is cyclic.");
          _isCyclic = true;
        }
      }
      else when (_allBaseAsts : object == null)
      {
        _isTypingInheritance = true;
        try
        {
          _allBaseAsts   = HashSet();
          _allProperties = Dictionary(StringComparer.Ordinal);

          foreach (a in BaseAsts)
          {
            _ = _allBaseAsts.Add(a);
            _allBaseAsts.UnionWith(a.AllBaseAsts);
          }

          unless (_isCyclic)
          {
            foreach (ast1 in _allBaseAsts)
            {
              foreach (p1 when p1.OverrideProperty.IsNone in ast1.Properties)
              {
                mutable p2;
                if (_allProperties.TryGetValue(p1.Name, out p2))
                {
                  def ast2 = p2.DeclaringAst;
                  using (root = Node.Project.RootError(this.FirstLocation, $"Declaration '$(FullName)' inherits declaration '$(ast1.FullName)' and declaration '$(ast2.FullName)' which both have property '$(p1.Name)'."))
                  {
                    root.Hint(p1.FirstLocation, "Property declaration.");
                    root.Hint(p2.FirstLocation, "Property declaration.");
                  }
                }
                else
                  _allProperties.Add(p1.Name, p1)
              }
            }
          }

          when (CreateSymbolSymbol(_allBaseAsts) is SymbolRef.Some(symbolSymbol))
            TryOverrideSymbolProperty(symbolSymbol);

          foreach (p in Properties)
          {
            if (p.OverrideProperty is SymbolRef.Some(originalProperty))
            {
              mutable existingProperty;
              if (_allProperties.TryGetValue(p.Name, out existingProperty) && originalProperty : object == existingProperty)
                _allProperties[p.Name] = p;
              else
                Node.Project.Error(p.FirstLocation, $"Invalid property '$(p.Name)'override.");
            }
            else
            {
              mutable existingProperty;
              if (_allProperties.TryGetValue(p.Name, out existingProperty))
              {
                using (root = Node.Project.RootError(p.FirstLocation, $"Redefinition of property '$(p.Name)', property inherited from declaration '$(existingProperty.DeclaringAst.FullName)'."))
                  root.Hint(existingProperty.FirstLocation, "Property declaration.");
              }
              else
                _allProperties.Add(p.Name, p);
            }
          }
        }
        finally _isTypingInheritance = false;
      }
    }

    public LookupProperty(name : string) : ValueOption[AstPropertySymbol]
    {
      assert(_allProperties != null);

      mutable symbol;
      if (_allProperties.TryGetValue(name, out symbol))
        VSome(symbol)
      else
        VNone()
    }

    protected virtual CreateSymbolSymbol(allBaseAsts : HashSet[AstSymbol]) : SymbolRef[SymbolSymbol]
    {
      _ = allBaseAsts;
      Symbol
    }

    protected AddAssignmentImpl(assignment : DependentPropertyAssignment, assignments : List[DependentPropertyAssignment], initializedOutProperties : ref list[DependentAstPropertySymbol]) : void
    {
      assignments.Add(assignment);
      when (assignment.Path is [Identifier(Value = propertyName)])
      {
        when (LookupProperty(propertyName) is VSome(DependentAstPropertySymbol(Direction = Out) as propertySymbol))
        {
          initializedOutProperties ::= propertySymbol;
        }
      }
    }

    private TryOverrideSymbolProperty(symbol : SymbolSymbol) : void
    {
      when (symbol.Declaration : object == this)
      when (LookupProperty("Symbol") is VSome(OutAstPropertySymbol as symbolProperty))
      {
        def newSymbolProperty = ChemicalOutAstPropertySymbol(FirstLocation, "Symbol")
          .SetAssemblyId(AssemblyIds.CurrentAssembly)
          .SetAstType(symbolProperty.AstType)
          .SetLinkedProperty(SymbolRef.None(Location.Default, true))
          .SetOverrideProperty(SymbolRef.Some(Location.Default, true, symbolProperty))
          .SetStage(symbolProperty.Stage)
          .SetType(Utils.MakeNTypeQualified(FirstLocation, symbol.Node.FullNameParts));

        _ = Node.AddAndReport(newSymbolProperty, FirstLocation)
      }
    }
  }
}
