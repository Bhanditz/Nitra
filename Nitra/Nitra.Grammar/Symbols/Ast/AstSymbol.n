using Nitra.Model;
using Nitra.Serialization;

using Nemerle;
using Nemerle.Collections;
using Nemerle.Extensions;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;

namespace Nitra.Typing
{
  [Record]
  public abstract class AstSymbol : SingleDefSymbol
  {
    public abstract BaseAsts                 : list[AstSymbol]                  { get; }
    public abstract InitializedOutProperties : list[DependentAstPropertySymbol] { get; }
    public abstract IsDeclaration            : bool                             { get; }
    public abstract Cardinality              : AstCardinality                   { get; }

    public Properties : Seq[AstPropertySymbol]
    {
      get { this.Node.GetChildren.[AstPropertySymbol]() }
    }

    public AllBaseAsts : HashSet[AstSymbol]
    {
      get { TypeInheritance(); _allBaseAsts }
    }

    public AllProperties : Dictionary[string, AstPropertySymbol]
    {
      get { TypeInheritance(); _allProperties }
    }

    public IsSubtypeOf(other : AstSymbol) : bool
    {
      this == other || this.AllBaseAsts.Contains(other)
    }

    [RecordIgnore] private mutable _allBaseAsts         : HashSet[AstSymbol];
    [RecordIgnore] private mutable _allProperties       : Dictionary[string, AstPropertySymbol];
    [RecordIgnore] private mutable _isTypingInheritance : bool;
    [RecordIgnore] private mutable _isCyclic            : bool;

    public TypeInheritance() : void
    {
      if (_isTypingInheritance)
      {
        unless (_isCyclic)
        {
          Node.Project.Error(this.FirstLocation, $"Declaration '$(FullName)' is cyclic.");
          _isCyclic = true;
        }
      }
      else when (_allBaseAsts : object == null)
      {
        _isTypingInheritance = true;
        try
        {
          _allBaseAsts   = HashSet();
          _allProperties = Dictionary(StringComparer.Ordinal);

          foreach (a in BaseAsts)
          {
            _ = _allBaseAsts.Add(a);
            _allBaseAsts.UnionWith(a.AllBaseAsts);
          }

          unless (_isCyclic)
          {
            foreach (ast1 in _allBaseAsts)
            {
              foreach (p1 in ast1.Properties)
              {
                mutable p2;
                if (_allProperties.TryGetValue(p1.Name, out p2))
                {
                  def ast2 = p2.DeclaringAst;
                  using (root = Node.Project.RootError(this.FirstLocation, $"Declaration '$(FullName)' inherits declaration '$(ast1.FullName)' and declaration '$(ast2.FullName)' which both have property '$(p1.Name)'."))
                  {
                    root.Hint(p1.FirstLocation, "Property declaration.");
                    root.Hint(p2.FirstLocation, "Property declaration.");
                  }
                }
                else
                  _allProperties.Add(p1.Name, p1)
              }
            }
          }

          foreach (p in Properties)
          {
            mutable existingProperty;
            if (_allProperties.TryGetValue(p.Name, out existingProperty))
            {
              using (root = Node.Project.RootError(p.FirstLocation, $"Redefinition of property '$(p.Name)', property inherited from declaration '$(existingProperty.DeclaringAst.FullName)'."))
                root.Hint(existingProperty.FirstLocation, "Property declaration.");
            }
            else
              _allProperties.Add(p.Name, p);
          }
        }
        finally _isTypingInheritance = false;
      }
    }

    public LookupProperty(name : string) : ValueOption[AstPropertySymbol]
    {
      mutable symbol;
      if (_allProperties.TryGetValue(name, out symbol))
        VSome(symbol)
      else
        VNone()
    }

    protected AddAssignmentImpl(assignment : DependentPropertyAssignment, assignments : List[DependentPropertyAssignment], initializedOutProperties : ref list[DependentAstPropertySymbol]) : void
    {
      assignments.Add(assignment);
      when (assignment.Path is [Identifier(Value = propertyName)])
      {
        when (LookupProperty(propertyName) is VSome(DependentAstPropertySymbol(Direction = Out) as propertySymbol))
        {
          initializedOutProperties ::= propertySymbol;
        }
      }
    }
  }
}
