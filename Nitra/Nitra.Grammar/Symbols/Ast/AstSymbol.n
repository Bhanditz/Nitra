using Nitra.Model;
using Nitra.Serialization;

using Nemerle;
using Nemerle.Imperative;
using Nemerle.Collections;
using Nemerle.Extensions;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;

namespace Nitra.Typing
{
  [Record]
  public abstract class AstSymbol : PropertyHostSymbol
  {
    public abstract BaseAsts                 : list[AstSymbol]               { get; }
    public abstract InitializedOutProperties : list[DependentPropertySymbol] { get; }
    public abstract IsDeclaration            : bool                          { get; }
    public abstract Cardinality              : AstCardinality                { get; }
    public abstract Symbol                   : SymbolRef[SymbolSymbol]       { get; }

    public AllBaseAsts : Seq[AstSymbol]
    {
      get { TypeInheritance(); _allBaseAsts }
    }

    public AllProperties : Seq[PropertySymbol]
    {
      get { TypeInheritance(); _allProperties.Values }
    }

    public IsSubtypeOf(other : AstSymbol) : bool
    {
      TypeInheritance();

      this == other || _allBaseAsts.Contains(other)
    }

    [RecordIgnore] private mutable _allBaseAsts         : HashSet[AstSymbol];
    [RecordIgnore] private mutable _allProperties       : Dictionary[string, PropertySymbol];
    [RecordIgnore] private mutable _isTypingInheritance : bool;
    [RecordIgnore] private mutable _isCyclic            : bool;

    public TypeInheritance() : void
    {
      if (_isTypingInheritance)
      {
        unless (_isCyclic)
        {
          Node.Project.Error(this.FirstLocation, $"Declaration '$(FullName)' is cyclic.");
          _isCyclic = true;
        }
      }
      else when (_allBaseAsts : object == null)
      {
        _isTypingInheritance = true;
        try
        {
          _allBaseAsts   = HashSet();
          _allProperties = Dictionary(StringComparer.Ordinal);

          foreach (a in BaseAsts)
          {
            _ = _allBaseAsts.Add(a);
            _allBaseAsts.UnionWith(a.AllBaseAsts);
          }

          unless (_isCyclic)
          {
            foreach (ast1 in _allBaseAsts)
            {
              foreach (p1 when p1.OverrideProperty.IsNone in ast1.Properties)
              {
                mutable p2;
                if (_allProperties.TryGetValue(p1.Name, out p2))
                {
                  def ast2 = p2.PropertyHost;
                  using (root = Node.Project.RootError(this.FirstLocation, $"Declaration '$(FullName)' inherits declaration '$(ast1.FullName)' and declaration '$(ast2.FullName)' which both have property '$(p1.Name)'."))
                  {
                    root.Hint(p1.FirstLocation, "Property declaration.");
                    root.Hint(p2.FirstLocation, "Property declaration.");
                  }
                }
                else
                  _allProperties.Add(p1.Name, p1)
              }
            }
          }

          when (CreateSymbolSymbol() is SymbolRef.Some(symbolSymbol))
            TryOverrideSymbolProperty(symbolSymbol);

          foreach (p in Properties)
          {
            if (p.OverrideProperty is SymbolRef.Some(originalProperty))
            {
              mutable existingProperty;
              if (_allProperties.TryGetValue(p.Name, out existingProperty) && originalProperty : object == existingProperty)
                _allProperties[p.Name] = p;
              else
                Node.Project.Error(p.FirstLocation, $"Invalid property '$(p.Name)'override.");
            }
            else
            {
              mutable existingProperty;
              if (_allProperties.TryGetValue(p.Name, out existingProperty))
              {
                using (root = Node.Project.RootError(p.FirstLocation, $"Redefinition of property '$(p.Name)', property inherited from declaration '$(existingProperty.PropertyHost.FullName)'."))
                  root.Hint(existingProperty.FirstLocation, "Property declaration.");
              }
              else
                _allProperties.Add(p.Name, p);
            }
          }
        }
        finally _isTypingInheritance = false;
      }
    }

    public override LookupProperty(name : string) : ValueOption[PropertySymbol]
    {
      assert(_allProperties != null);

      mutable symbol;
      if (_allProperties.TryGetValue(name, out symbol))
        VSome(symbol)
      else
        VNone()
    }

    protected virtual CreateSymbolSymbol() : SymbolRef[SymbolSymbol]
    {
      Symbol
    }

    protected AddAssignmentImpl(assignment : DependentPropertyAssignment, assignments : List[DependentPropertyAssignment], initializedOutProperties : ref list[DependentPropertySymbol]) : void
    {
      assignments.Add(assignment);
      when (assignment.Path is [Identifier(Value = propertyName)])
      {
        when (LookupProperty(propertyName) is VSome(DependentPropertySymbol(Direction = Out) as propertySymbol))
        {
          initializedOutProperties ::= propertySymbol;
        }
      }
    }

    private TryOverrideSymbolProperty(symbol : SymbolSymbol) : void
    {
      when (symbol.Declaration : object == this || !(this is ExtensionAstSymbol))
      when (LookupProperty("Symbol") is VSome(OutPropertySymbol as symbolProperty))
      {
        def newSymbolProperty = ChemicalOutPropertySymbol(FirstLocation, "Symbol")
          .SetAssemblyId(AssemblyIds.CurrentAssembly)
          .SetLinkedProperty(SymbolRef.None(Location.Default, true))
          .SetOverrideProperty(SymbolRef.Some(Location.Default, true, symbolProperty))
          .SetStage(symbolProperty.Stage)
          .SetType(Utils.MakeNTypeQualified(FirstLocation, symbol.Node.FullNameParts));

        _ = Node.AddAndReport(newSymbolProperty, FirstLocation)
      }
    }

    protected CreateSymbolSymbolImpl(makeSymbol : list[SymbolSymbol] -> SymbolSymbol) : SymbolRef[SymbolSymbol]
    {
      if (IsDeclaration)
      {
        mutable baseSymbols = [];
        mutable sealedSymbolFromBase;
        foreach (baseAst in BaseAsts)
        {
          when (baseAst.Symbol is SymbolRef.Some(s))
          {
            when (s.IsSealed)
            {
              sealedSymbolFromBase = s;
              break;
            }
            baseSymbols ::= s;
          }
        }

        if (sealedSymbolFromBase : object == null)
          SymbolRef.Some(FirstLocation, true, makeSymbol(baseSymbols));
        else
        {
          foreach (baseAst in BaseAsts)
          {
            when (baseAst.Symbol is SymbolRef.Some(s))
            unless (s : object == sealedSymbolFromBase) //TODO: check symbol subtyping: sealedSymbolFromBase.IsSubtypeOf(s)
              using (root = Node.Project.RootError(FirstLocation, $"Symbol inheritance is not available from sealed symbol '$(sealedSymbolFromBase.FullName)'."))
              {
                root.Hint(sealedSymbolFromBase.FirstLocation, "Sealed symbol.");
                break;
              }
          }

          SymbolRef.Some(FirstLocation, true, sealedSymbolFromBase);
        }
      }
      else
        SymbolRef.None(FirstLocation, true);
    }
  }
}
