using Nitra.Model;
using Nitra.ProjectSystem;
using Nitra.Serialization;

using Nemerle;
using Nemerle.Imperative;
using Nemerle.Collections;
using Nemerle.Compiler.Parsetree;
using Nemerle.Text;
using Nemerle.Utility;

using System;

using G = NitraSyntaxParseTree;
using SCG = System.Collections.Generic;

namespace Nitra.Typing
{
  [Record, ExportableSymbol]
  public abstract class SymbolSymbol : PropertyContainerSymbol, INamespaceMember
  {
    public override Description  : string             { get { "symbol" } }
    public abstract Declaration  : AstSymbol          { get; }
    public abstract BaseSymbols  : list[SymbolSymbol] { get; }

    public AllBaseSymbols : Seq[SymbolSymbol]
    {
      get { TypeInheritance(); _allBaseSymbols }
    }

    public override AllProperties : Seq[PropertySymbol]
    {
      get { TypeInheritance(); _allProperties.Values }
    }

    public IsSubtypeOf(other : SymbolSymbol) : bool
    {
      TypeInheritance();

      this == other || _allBaseSymbols.Contains(other)
    }

    [RecordIgnore] private mutable _allBaseSymbols : SCG.HashSet[SymbolSymbol];
    [RecordIgnore] private mutable _allProperties  : SCG.Dictionary[string, PropertySymbol];

    public TypeInheritance() : void
    {
      when (_allBaseSymbols : object == null)
      {
        _allBaseSymbols = SCG.HashSet();
        _allProperties  = SCG.Dictionary(StringComparer.Ordinal);

        foreach (s when _allBaseSymbols.Add(s) in BaseSymbols)
          _allBaseSymbols.UnionWith(s.AllBaseSymbols);

        CollectInheritedProperties(_allBaseSymbols, _allProperties);
        CollectDeclaredProperties(_allProperties);
      }
    }

    public override GetAncestors() : Seq[PropertyContainerSymbol]
    {
      AllBaseSymbols
    }

    public override LookupProperty(name : string) : ValueOption[PropertySymbol]
    {
      assert(_allProperties : object != null);
      mutable p;
      if (_allProperties.TryGetValue(name, out p))
        VSome(p)
      else
        VNone()
    }
  }

  public sealed class ParsedAbstractSymbolSymbol : SymbolSymbol, IDependentPropertyAssignmentContainer
  {
    public this(astSymbol : AstSymbol, baseSymbols : list[SymbolSymbol])
    {
      base (astSymbol.FirstLocation, astSymbol.Name + "Symbol");
      Declaration = astSymbol;
      BaseSymbols = baseSymbols;
      _assignments = SCG.List();
      _initializedOutProperties = [];
    }

    private         _assignments              : SCG.List[DependentPropertyAssignment];
    private mutable _initializedOutProperties : list[DependentPropertySymbol];
    private mutable _propertyDependency       : list[PropertyDependencyNodeData];

    public override Declaration              : AstSymbol                     { get; }
    public override BaseSymbols              : list[SymbolSymbol]            { get; }
    public override InitializedOutProperties : list[DependentPropertySymbol] { get { _initializedOutProperties } }
    public override IsAbstract               : bool                          { get { true } }
    public override HasEvaluations           : bool                          { get { _assignments.Count > 0 } }
    public override PropertyDependency       : list[PropertyDependencyNodeData] { get { assert(_propertyDependency != null); _propertyDependency } }

    public AddAssignment(assignment : DependentPropertyAssignment) : void { AddAssignmentImpl(assignment, _assignments, ref _initializedOutProperties); }
    public GetAssignments() : Seq[DependentPropertyAssignment] { _assignments }
    public override SetPropertyDependency(graph : list[PropertyDependencyNodeData]) : void { assert(graph != null); _propertyDependency = graph; }
  }

  public sealed class ParsedSimpleSymbolSymbol : SymbolSymbol, IDependentPropertyAssignmentContainer
  {
    public this(astSymbol : AstSymbol, baseSymbols : list[SymbolSymbol])
    {
      base (astSymbol.FirstLocation, astSymbol.Name + "Symbol");
      Declaration = astSymbol;
      BaseSymbols = baseSymbols;
      _assignments = SCG.List();
      _initializedOutProperties = [];
    }

    private         _assignments              : SCG.List[DependentPropertyAssignment];
    private mutable _initializedOutProperties : list[DependentPropertySymbol];

    public override Declaration              : AstSymbol                     { get; }
    public override BaseSymbols              : list[SymbolSymbol]            { get; }
    public override InitializedOutProperties : list[DependentPropertySymbol] { get { _initializedOutProperties } }
    public override IsAbstract               : bool                          { get { false } }
    public override HasEvaluations           : bool                          { get { _assignments.Count > 0 } }
    public override PropertyDependency       : list[PropertyDependencyNodeData] { get { [] } }
    public          KindExpr                 : option[PExpr]                 { get; private set; default None(); }
    public          SpanClassExpr            : option[PExpr]                 { get; private set; default None(); }
    public          FullNameExpr             : option[PExpr]                 { get; private set; default None(); }

    public AddAssignment(assignment : DependentPropertyAssignment) : void
    {
      | DependentPropertyAssignment(Path = [Identifier(Value = "Kind")],      Expression = expr) =>
        if (KindExpr.IsNone)
          KindExpr = Some(expr)
        else
          Node.Project.Error(assignment, "Duplicate assignment of property 'Kind'.")

      | DependentPropertyAssignment(Path = [Identifier(Value = "SpanClass")], Expression = expr) =>
        if (SpanClassExpr.IsNone)
          SpanClassExpr = Some(expr)
        else
          Node.Project.Error(assignment, "Duplicate assignment of property 'SpanClass'.")

      | DependentPropertyAssignment(Path = [Identifier(Value = "FullName")],  Expression = expr) =>
        if (FullNameExpr.IsNone)
          FullNameExpr = Some(expr)
        else
          Node.Project.Error(assignment, "Duplicate assignment of property 'FullName'.")

      | _ => AddAssignmentImpl(assignment, _assignments, ref _initializedOutProperties);
    }

    public GetAssignments() : Seq[DependentPropertyAssignment] { _assignments }
  }
}
