using Nitra.Model;

using Nemerle;
using Nemerle.Extensions;
using Nemerle.Collections;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using SCG = System.Collections.Generic;

using G = NitraSyntaxParseTree;

namespace Nitra.Typing
{
  [Record]
  public variant SyntaxMappingBody : Located
  {
    | CallMember { Path   : ParseTreePath }
    | Inline     { Code   : PExpr }
    | PerField   { Fields : list[SyntaxMappingField] }
    | Match      { Cases  : list[SyntaxMappingCase] }
    | Error

    public override Location    : Location                     { get; }
    public          Declaration : SymbolRef[DeclarationSymbol] { get; }
  }

  [Record]
  public sealed class SyntaxMappingCase : Located
  {
    public override Location    : Location                     { get; }
    public          Declaration : SymbolRef[DeclarationSymbol] { get; }
    public          Patterns    : list[ParseTreePattern]       { get; }
    public          Fields      : list[SyntaxMappingField]     { get; }
  }

  [Record]
  public variant ParseTreePattern : Located
  {
    | Var  { Name  : LocatedName; }
    | Ctor { Value : ParseTreeCtor; Args : list[ParseTreePattern] }

    public override Location : Location { get; }
    public          Type     : RuleType { get; }

    public static Wildcard(location : Location, ruleType : RuleType) : ParseTreePattern
    {
      def name = LocatedName(location, "_");
      ParseTreePattern.Var(location, ruleType, name)
    }
  }

  [Record, StructuralEquality]
  public sealed class ParseTreeCtor
  {
    public Name  : string { get; }
    public Arity : int    { get; }
    public Span  : int    { get; }

    public override ToString() : string
    {
      Name
    }

    [Memoize]
    public static Tuple(arity : int) : ParseTreeCtor
    {
      ParseTreeCtor("Tuple", arity, span = 1);
    }

    public static ListCons   : ParseTreeCtor = ParseTreeCtor("Cons", arity = 2, span = 2);
    public static ListNil    : ParseTreeCtor = ParseTreeCtor("Nil",  arity = 0, span = 2);
    public static OptionSome : ParseTreeCtor = ParseTreeCtor("Some", arity = 1, span = 2);
    public static OptionNone : ParseTreeCtor = ParseTreeCtor("None", arity = 0, span = 2);
  }

  internal module PatternTyper
  {
    public TypeCaseSection(rules : list[Rule], patterns : ListParseTree[G.MapSyntaxMember.MatchCase.Nested.Pattern], context : Context) : list[ParseTreePattern]
    {
      using (ruleSeq = rules.GetEnumerator(), patternSeq = patterns.GetEnumerator())
      {
        def loop(errorReported)
        {
          match (ruleSeq.MoveNext(), patternSeq.MoveNext())
          {
            | (false, false) => []
            | (true, true) =>
              def pattern = patternSeq.Current.Typing(ruleSeq.Current.Type, context);
              pattern :: loop(errorReported)

            | (false, true) =>
              unless (errorReported)
                context.Error(patterns.Location, $"Too many patterns specified, needed $(rules.Length), got $(patterns.Count).", -1);
              []

            | (true, false) =>
              unless (errorReported)
                context.Error(patterns.Location, $"Too few patterns specified, needed $(rules.Length), got $(patterns.Count).", -1);
              def source  = patterns.Location.Source;
              def pos     = patterns.Location.EndPos;
              def pattern = ParseTreePattern.Wildcard(Location(source, pos, pos), ruleSeq.Current.Type);
              pattern :: loop(true)
          }
        }
        loop(false)
      }
    }

    private TryBindCtor(identifier : LocatedName) : ParseTreeCtor
    {
      match (identifier.Id)
      {
        | "Some" => ParseTreeCtor.OptionSome
        | "None" => ParseTreeCtor.OptionNone
        | "Cons" => ParseTreeCtor.ListCons
        | "Nil"  => ParseTreeCtor.ListNil
        | _      => null
      }
    }

    private ValidateCtor(location : Location, ctor : ParseTreeCtor, ruleType : RuleType, context : Context) : bool
    {
      match (ruleType)
      {
        | Option => ctor == ParseTreeCtor.OptionSome || ctor == ParseTreeCtor.OptionNone
        | List   => ctor == ParseTreeCtor.ListCons || ctor == ParseTreeCtor.ListNil
        | _      => false
      }
    }

    public TypeIdentifier(identifier : LocatedName, ruleType : RuleType, context : Context) : ParseTreePattern
    {
      match (TryBindCtor(identifier))
      {
        | null => ParseTreePattern.Var(identifier.Location, ruleType, identifier)
        | ctor => ParseTreePattern.Ctor(identifier.Location, ruleType, ctor, [])
      }
    }
  }
}
