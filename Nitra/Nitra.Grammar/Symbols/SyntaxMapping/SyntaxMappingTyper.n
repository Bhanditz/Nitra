using Nitra.ProjectSystem;
using Nitra.Model;

using Nemerle;
using Nemerle.Imperative;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using SCG = System.Collections.Generic;

using G = NitraSyntaxParseTree;

namespace Nitra.Typing
{
  internal module SyntaxMappingTyper
  {
    public MakeExpression(type : SyntaxMappingType, astType : AstType, compilerMessages : ICompilerMessages) : SyntaxMappingExpr
    {
      match (type)
      {
        | Undefined           => SyntaxMappingExpr.Error(type)
        | Ast(exprType, expr) =>
          if (exprType.IsSubtypeOf(astType))
            expr
          else
          {
            compilerMessages.Error(type, $"Expected AST type '$astType' got '$exprType'.");
            SyntaxMappingExpr.Error(type)
          }

        | Option(valueType) =>
          if (astType is AstType.Option(astSymbol))
          {
            def valueExpr =
              if (valueType is Some(expr))
                Some(MakeExpression(expr, AstType.Ast(astType, astSymbol), compilerMessages))
              else
                None();

            SyntaxMappingExpr.OptionCtor(type, astSymbol, valueExpr)
          }
          else
          {
            compilerMessages.Error(type, $"Expected AST type '$astType' got option.");
            SyntaxMappingExpr.Error(type)
          }

        | List(itemTypes) =>
          match (astType)
          {
            | List(astSymbol) | OptionList(astSymbol) =>
              def itemAstType = AstType.Ast(astType, astSymbol);
              def itemExprs   = itemTypes.Map(MakeExpression(_, itemAstType, compilerMessages));
              SyntaxMappingExpr.ListCtor(type, astSymbol, itemExprs)

            | _ =>
              compilerMessages.Error(type, $"Expected AST type '$astType' got list.");
              SyntaxMappingExpr.Error(type)
          }

        | ParseTree(path) with arguments = []
        | Call(path, arguments) =>
          def callType = ResolveCall(type, path, arguments, VSome(astType), compilerMessages);
          MakeExpression(callType, astType, compilerMessages)
      }
    }

    public TypeTypeHint(node : G.MapSyntaxExpression.TypeHint, ruleSymbol : SyntaxRuleSymbol) : SyntaxMappingType
    {
      def astType = TypingUtils.NTypeToAstTypeWithMessage(node.NitraType, node.Context);
      if (astType.IsVoid)
        SyntaxMappingType.Undefined(node)
      else
      {
        def exprType = node.Expr.MakeType(ruleSymbol);
        def expr     = MakeExpression(exprType, astType, node.Context);
        SyntaxMappingType.Ast(node, astType, expr);
      }
    }

    public TypeIdentifier(node : G.MapSyntaxExpression.Identifier, ruleSymbol : SyntaxRuleSymbol) : SyntaxMappingType
    {
      def name = node.Identifier.Identifier();
      def result1 = node.Context.BindMany.[ParseTreePatternVariableSymbol](name.Location);
      match (result1.Candidates)
      {
        | [variable] =>
          def path = ParseTreePath.Variable(node, name, variable.Type);
          SyntaxMappingType.ParseTree(node, path)

        | _ :: _ =>
          result1.Messages.TranslateTo(node.Context);
          SyntaxMappingType.Undefined(node)

        | [] =>
          def mappingContext = node.Context.GetContext.[MapSyntaxContext]();
          if (mappingContext.BindParameter(name) is VSome(parameter))
          {
            def expr = SyntaxMappingExpr.ParameterRef(name, parameter);
            SyntaxMappingType.Ast(node, parameter.Type, expr)
          }
          else if (LookupRuleField(RuleType.Ref(ruleSymbol), name) is VSome(ruleType))
          {
            def path = ParseTreePath.Member(name, ParseTreePath.This(name.Location.FromStart(), ruleSymbol), name, ruleType);
            SyntaxMappingType.ParseTree(node, path)
          }
          else
          {
            node.Context.Error(name, $"Unbound name $(name.Value).");
            SyntaxMappingType.Undefined(node)
          }
      }
    }

    public TypeMemberAccess(node : G.MapSyntaxExpression.MemberAccess, ruleSymbol : SyntaxRuleSymbol) : SyntaxMappingType
    {
      def error(errorLoc : Located, message : string)
      {
        node.Context.Error(errorLoc, message);
        SyntaxMappingType.Undefined(node)
      }
      def unboundName(name : Identifier)
      {
        error(name, $"Unbound name '$name'.")
      }

      def makeAccess(exprType : SyntaxMappingType)
      {
        def loc = node.Location;
        match (exprType)
        {
          | Ast(Void, _) | Undefined => SyntaxMappingType.Undefined(loc)
          | Ast(Option, _) | Option => error(exprType, "Member access expression is not supported on option.")
          | Ast(List, _) | Ast(OptionList, _) | List => error(exprType, "Member access expression is not supported on list.")
          | Ast(Ast(symbol), expr) =>
            def name = node.Identifier.Identifier();
            match (symbol.LookupProperty(name.Value))
            {
              | VSome(SimpleAstPropertySymbol as property) =>
                if (property.AstType.IsVoid)
                  error(name, $"Property type '$(property.Type)' is not valid AST type.")
                else
                  SyntaxMappingType.Ast(loc, property.AstType, SyntaxMappingExpr.PropertyRef(loc, expr, property))

              | VSome(property) => error(name, $"Property '$(property.FullName)' is not simple AST property.")
              | VNone()         => unboundName(name)
            }

          | ParseTree(path) =>
            def name = node.Identifier.Identifier();
            if (LookupRuleField(path.Type, name) is VSome(ruleType))
              SyntaxMappingType.ParseTree(loc, ParseTreePath.Member(loc, path, name, ruleType))
            else
              unboundName(name)

          | Call(path, arguments) => makeAccess(ResolveCall(exprType, path, arguments, VNone(), node.Context))
        }
      }

      makeAccess(node.Expr.MakeType(ruleSymbol))
    }

    public TypeCall(node : G.MapSyntaxExpression.Call, ruleSymbol : SyntaxRuleSymbol) : SyntaxMappingType
    {
      def exprType      = node.Expr.MakeType(ruleSymbol);
      def argumentTypes = node.ArgumentExprs.Item1.MapToList(_.MakeType(ruleSymbol));
      match (exprType)
      {
        | Undefined       => SyntaxMappingType.Undefined(node)
        | ParseTree(path) => SyntaxMappingType.Call(node, path, argumentTypes)
        | _               =>
          node.Context.Error(node, "Syntax mapping invokation is not allowed here");
          SyntaxMappingType.Undefined(node)
      }
    }

    public TypeAst(node : G.MapSyntaxExpression.Ast, ruleSymbol : SyntaxRuleSymbol) : SyntaxMappingType
    {
      def result = TypingUtils.BindAstSymbolFromMappingExtension(node.QualifiedName, node.Context);
      if (result is SymbolRef.Some(astSymbol))
      {
        def mappingFields = SCG.List();
        foreach (member in node.Members)
          when (member.GetSyntaxMappingField(astSymbol, ruleSymbol) is VSome(mappingField))
            mappingFields.Add(mappingField);

        TypingUtils.CheckRequiredAstProperties(astSymbol, mappingFields, Location(node.Location.Source, node.CloseBrace), node.Context);
        def type = AstType.Ast(node.QualifiedName, astSymbol);
        def expr = SyntaxMappingExpr.AstCtor(node, astSymbol, mappingFields.ToNList());
        SyntaxMappingType.Ast(node, type, expr)
      }
      else
        SyntaxMappingType.Undefined(node)
    }

    private LookupRuleField(type : RuleType, name : Identifier) : ValueOption[RuleType]
    {
      match (type)
      {
        | Ref(symbol) =>
          def loop(rules : list[Rule])
          {
            | [] => VNone()
            | rule :: _ when StringComparer.Ordinal.Equals(name.Value, rule.FieldName) => VSome(rule.Type)
            | _ :: otherRules => loop(otherRules)
          }
          loop(symbol.NonVoidSubRules)

        | Tuple(members) =>
          def loop(members, index)
          {
            match (members)
            {
              | [] => VNone()
              | member :: _ when StringComparer.Ordinal.Equals(name.Value, $"Item$index") => VSome(member)
              | _ :: otherMembers => loop(otherMembers, index + 1)
            }
          }
          loop(members, 1)

        | _ => VNone()
      }
    }

    private ResolveCall(loc : Located, originalPath : ParseTreePath, arguments : list[SyntaxMappingType], returnTypeOpt : ValueOption[AstType], compilerMessages : ICompilerMessages) : SyntaxMappingType
    {
      def formatAstType(t : ValueOption[AstType]) : string
      {
        | VSome(astType) => $"AST of type '$astType'"
        | VNone          => "AST"
      }
      def error(message : string) : SyntaxMappingType
      {
        compilerMessages.Error(loc, message);
        SyntaxMappingType.Undefined(loc)
      }
      def selectOverload(targetRuleSymbol : SyntaxRuleSymbol, returnTypePred : AstType -> bool, resultBuilder : AstType * list[SyntaxMappingExpr] -> SyntaxMappingType) : SyntaxMappingType
      {
        def applyArguments(parms, args) : ValueOption[list[SyntaxMappingExpr]]
        {
          | ([], []) => VSome([])
          | (p :: otherParms, a :: otherArgs) =>
            def expr = MakeExpression(a, p.Type, NullCompilerMessages.Instance);
            if (expr is SyntaxMappingExpr.Error)
              VNone()
            else if (applyArguments(otherParms, otherArgs) is VSome(otherExprs))
              VSome(expr :: otherExprs)
            else
              VNone()

          | _ => VNone()
        }

        def buffer = LightList();
        foreach (syntaxMapping in targetRuleSymbol.SyntaxMappings)
        {
          when (returnTypePred(syntaxMapping.ReturnType))
          when (syntaxMapping.Parameters.Length == arguments.Length)
          when (applyArguments(syntaxMapping.Parameters, arguments) is VSome(exprs))
            buffer.Add(syntaxMapping, exprs)
        }

        match (buffer.Count)
        {
          | 1 =>
            def (syntaxMapping, args) = buffer.FirstItem;
            resultBuilder(syntaxMapping.ReturnType, args)

          | 0 =>
            if (targetRuleSymbol.SyntaxMappings.IsEmpty)
              error($"Rule '$(targetRuleSymbol.FullName)' has no AST mapping.")
            else
              error($"Rule '$(targetRuleSymbol.FullName)' has no compatible AST mapping.")

          | _ =>
            using (root = compilerMessages.RootError(loc, $"Ambiguous '$(targetRuleSymbol.FullName)' AST mapping."))
              foreach ((syntaxMapping, _) in buffer.ToArray())
                root.Hint(syntaxMapping.FirstLocation, "AST mapping ambiguity.");
            SyntaxMappingType.Undefined(loc)
        }
      }
      def mapListBottomUpPred(_ : AstType) : bool
      {
        | Ast | List | OptionList | Option => true
        | Void => false
      }
      def mapListTopDownPred(astSymbol : AstSymbol) : AstType -> bool
      {
        fun (returnType : AstType)
        {
          | Ast(returnSymbol) | List(returnSymbol) | OptionList(returnSymbol) | Option(returnSymbol) => returnSymbol.IsSubtypeOf(astSymbol)
          | Void => false
        }
      }
      def mapOptionBottomUpPred(_ : AstType) : bool
      {
        | Ast => true
        | _   => false
      }
      def mapOptionTopDownPred(astSymbol : AstSymbol) : AstType -> bool
      {
        fun (returnType : AstType)
        {
          | Ast(returnSymbol) => returnSymbol.IsSubtypeOf(astSymbol)
          | _                 => false
        }
      }

      def path = FilterTuples(originalPath);
      match (path.Type)
      {
        | Ref(targetRuleSymbol) =>
          selectOverload(targetRuleSymbol,
            if (returnTypeOpt is VSome(astType)) fun (t) { t.IsSubtypeOf(astType) } else fun (_) { true },
            (returnType, args) => SyntaxMappingType.Ast(loc, returnType, SyntaxMappingExpr.Call(loc, path, args, returnType)))

        | List(item) =>
          def itemPath = FilterTuples(ParseTreePath.Variable(path.Location.FromEnd(), Nitra.Model.Identifier(path.Location.FromEnd(), "node"), item));
          match (itemPath.Type, returnTypeOpt)
          {
            | (Ref(targetRuleSymbol), VNone)                        with pred = mapListBottomUpPred
            | (Ref(targetRuleSymbol), VSome(List(astSymbol)))       with pred = mapListTopDownPred(astSymbol)
            | (Ref(targetRuleSymbol), VSome(OptionList(astSymbol))) with pred = mapListTopDownPred(astSymbol) =>
              selectOverload(targetRuleSymbol, pred, fun (returnType : AstType, args : list[SyntaxMappingExpr])
              {
                match (returnType)
                {
                  | Ast(astSymbol)                          => SyntaxMappingType.Ast(loc, AstType.OptionList(Location.Default, astSymbol), SyntaxMappingExpr.ConvertList(loc, path, args, astSymbol, itemPath))
                  | List(astSymbol) | OptionList(astSymbol) => SyntaxMappingType.Ast(loc, AstType.OptionList(Location.Default, astSymbol), SyntaxMappingExpr.ConcatLists(loc, path, args, astSymbol, itemPath))
                  | Option(astSymbol)                       => SyntaxMappingType.Ast(loc, AstType.OptionList(Location.Default, astSymbol), SyntaxMappingExpr.ConcatOptions(loc, path, args, astSymbol, itemPath))
                  | Void                                    => assert(false)
                }
              })

            | (Ref,                   VSome(astType))               => error($"Expected AST type '$astType' got list.")
            | (_,                     x)                            => error($"Cannot map list rule '$(originalPath.Type)' to $(formatAstType(x)): rule '$item' does not refer syntax rule symbol.")
          }

        | Option(value) =>
          def valuePath = FilterTuples(ParseTreePath.Variable(path.Location.FromEnd(), Nitra.Model.Identifier(path.Location.FromEnd(), "node"), value));
          match (valuePath.Type, returnTypeOpt)
          {
            | (Ref(targetRuleSymbol), VNone)                    with pred = mapOptionBottomUpPred
            | (Ref(targetRuleSymbol), VSome(Option(astSymbol))) with pred = mapOptionTopDownPred(astSymbol) =>
              selectOverload(targetRuleSymbol, pred, fun (returnType : AstType, args : list[SyntaxMappingExpr])
              {
                if (returnType is Ast(astSymbol))
                  SyntaxMappingType.Ast(loc, AstType.Option(Location.Default, astSymbol), SyntaxMappingExpr.ConvertOption(loc, path, args, astSymbol, valuePath))
                else
                  assert(false)
              })

            | (Ref,                   VSome(astType))           => error($"Expected AST type '$astType' got option.")
            | (_,                     x)                        => error($"Cannot map option rule '$(originalPath.Type)' to $(formatAstType(x)): rule '$value' does not refer syntax rule symbol.")
          }

        | _ => error($"Cannot map rule '$(originalPath.Type)' to $(formatAstType(returnTypeOpt)).")
      }
    }

    private FilterTuples(path : ParseTreePath) : ParseTreePath
    {
      def filterNonKeywords(members : list[RuleType], index : int) : list[int * RuleType]
      {
        match (members)
        {
          | [] => []
          | RuleType.Chars(Keyword = Some) :: rest => filterNonKeywords(rest, index + 1)
          | x :: rest => (index, x) :: filterNonKeywords(rest, index + 1)
        }
      }

      if (path.Type is Tuple(members))
        if (filterNonKeywords(members, 1) is [(index, nonKeyword)])
          FilterTuples(ParseTreePath.Member(path, path, Identifier(path.Location.FromEnd(), "Item" + index), nonKeyword))
        else path
      else path
    }
  }
}
