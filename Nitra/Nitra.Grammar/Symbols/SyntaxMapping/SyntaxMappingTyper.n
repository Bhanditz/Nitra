using Nitra.ProjectSystem;
using Nitra.Model;

using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using SCG = System.Collections.Generic;

using G = NitraSyntaxParseTree;

namespace Nitra.Typing
{
  internal abstract class SyntaxMappingTyper[TExpr]
  {
    protected abstract GetCompilerMessages(node : G.MapSyntaxExpression) : ICompilerMessages;
    protected abstract TypeNode(node : G.MapSyntaxExpression, ruleSymbol : SyntaxRuleSymbol, astType : AstType) : TExpr;
    protected abstract CreateError(loc : Location) : TExpr;
    protected abstract CreateCall(loc : Location, path : ParseTreePath, syntaxMapping : SyntaxMappingSymbol, arguments : SCG.IList[G.MapSyntaxExpression], ruleSymbol : SyntaxRuleSymbol) : TExpr;
    protected abstract CreateConvertList(loc : Location, astSymbol : AstSymbol, path : ParseTreePath, syntaxMapping : SyntaxMappingSymbol, arguments : SCG.IList[G.MapSyntaxExpression], itemPath : ParseTreePath, ruleSymbol : SyntaxRuleSymbol) : TExpr;
    protected abstract CreateConcatLists(loc : Location, astSymbol : AstSymbol, path : ParseTreePath, syntaxMapping : SyntaxMappingSymbol, arguments : SCG.IList[G.MapSyntaxExpression], itemPath : ParseTreePath, ruleSymbol : SyntaxRuleSymbol) : TExpr;
    protected abstract CreateConcatOptions(loc : Location, astSymbol : AstSymbol, path : ParseTreePath, syntaxMapping : SyntaxMappingSymbol, arguments : SCG.IList[G.MapSyntaxExpression], itemPath : ParseTreePath, ruleSymbol : SyntaxRuleSymbol) : TExpr;
    protected abstract CreateConvertOption(loc : Location, astSymbol : AstSymbol, path : ParseTreePath, syntaxMapping : SyntaxMappingSymbol, arguments : SCG.IList[G.MapSyntaxExpression], valuePath : ParseTreePath, ruleSymbol : SyntaxRuleSymbol) : TExpr;
    protected abstract CreateAstCtor(loc : Location, astSymbol : AstSymbol, members : ListParseTree[G.MapSyntaxExpressionAstMember], closeBrace : NSpan, ruleSymbol : SyntaxRuleSymbol, compilerMessages : ICompilerMessages) : TExpr;
    protected abstract CreateListCtor(loc : Location, astSymbol : AstSymbol, items : array[TExpr]) : TExpr;
    protected abstract CreateOptionCtor(loc : Location, astSymbol : AstSymbol, value : ValueOption[TExpr]) : TExpr;

    public TypeConversion(node : G.MapSyntaxExpression.Conversion, ruleSymbol : SyntaxRuleSymbol, astType : AstType) : TExpr
    {
      def compilerMessages = GetCompilerMessages(node);
      def loc = node.Location;
      def genericError()
      {
        compilerMessages.Error(loc, $"Cannot map rule to AST of type '$astType'.");
        CreateError(loc)
      }
      def pathOpt = BindRuleField(ruleSymbol, node.QualifiedName, node.Context, compilerMessages);
      if (pathOpt is VSome(originalPath))
      {
        def path = FilterTuples(originalPath);
        def arguments = if (node.ArgumentsOpt.HasValue) node.ArgumentsOpt.Value.ArgumentExprs.Item1 else array[];
        match (path.Type)
        {
          | Ref(SyntaxRuleSymbol(SyntaxMappings = syntaxMappings)) =>
            if (SelectSyntaxMappingOverload(ruleSymbol, syntaxMappings, arguments, astType) is VSome(syntaxMapping))
              CreateCall(loc, path, syntaxMapping, arguments, ruleSymbol)
            else
              genericError()

          | List(item) =>
            def itemPath = FilterTuples(ParseTreePath.Variable(path.Location.FromEnd(), Nitra.Model.Identifier(path.Location.FromEnd(), "node"), item));
            if (itemPath.Type is Ref(SyntaxRuleSymbol(SyntaxMappings = syntaxMappings)))
              match(astType)
              {
                | List(astSymbol) | OptionList(astSymbol) =>
                  if (SelectSyntaxMappingOverload(ruleSymbol, syntaxMappings, arguments, AstType.Ast(astType.Location, astSymbol)) is VSome(syntaxMapping))
                    CreateConvertList(loc, astSymbol, path, syntaxMapping, arguments, itemPath, ruleSymbol)
                  else if (SelectSyntaxMappingOverload(ruleSymbol, syntaxMappings, arguments, astType) is VSome(syntaxMapping))
                    CreateConcatLists(loc, astSymbol, path, syntaxMapping, arguments, itemPath, ruleSymbol)
                  else if (SelectSyntaxMappingOverload(ruleSymbol, syntaxMappings, arguments, AstType.Option(astType.Location, astSymbol)) is VSome(syntaxMapping))
                    CreateConcatOptions(loc, astSymbol, path, syntaxMapping, arguments, itemPath, ruleSymbol)
                  else
                    genericError()

                | _ => genericError()
              }
            else
              genericError()

          | Option(value) =>
            def valuePath = FilterTuples(ParseTreePath.Variable(path.Location.FromEnd(), Nitra.Model.Identifier(path.Location.FromEnd(), "node"), value));
            if (valuePath.Type is Ref(SyntaxRuleSymbol(SyntaxMappings = syntaxMappings)))
              match(astType)
              {
                | Option(astSymbol) =>
                  if (SelectSyntaxMappingOverload(ruleSymbol, syntaxMappings, arguments, AstType.Ast(astType.Location, astSymbol)) is VSome(syntaxMapping))
                    CreateConvertOption(loc, astSymbol, path, syntaxMapping, arguments, valuePath, ruleSymbol)
                  else
                    genericError()

                | _ => genericError()
              }
            else
              genericError()

          | _ => genericError()
        }
      }
      else
        genericError()
    }

    public TypeAst(node : G.MapSyntaxExpression.Ast, ruleSymbol : SyntaxRuleSymbol, astType : AstType) : TExpr
    {
      def compilerMessages = GetCompilerMessages(node);
      def loc = node.Location;
      if (astType is AstType.Ast(targetSymbol))
      {
        def astSymbolRef = TypingUtils.BindAstSymbolFromMappingExtension(node.QualifiedName, targetSymbol, node.Context, compilerMessages);
        if (astSymbolRef is SymbolRef.Some(astSymbol))
        {
          if (astSymbol.IsSubtypeOf(targetSymbol))
            CreateAstCtor(loc, astSymbol, node.Members, node.CloseBrace, ruleSymbol, compilerMessages)
          else
          {
            def sourceName = astSymbol.FullName;
            def targetName = targetSymbol.FullName;
            compilerMessages.Error(astSymbolRef, $"Declaration '$sourceName' is not subtype of declaration '$targetName'");
            CreateError(loc)
          }
        }
        else
          CreateError(loc)
      }
      else
      {
        compilerMessages.Error(loc, $"Expected ast type '$astType'");
        CreateError(loc)
      }
    }

    public TypeList(node : G.MapSyntaxExpression.List, ruleSymbol : SyntaxRuleSymbol, astType : AstType) : TExpr
    {
      def compilerMessages = GetCompilerMessages(node);
      def loc = node.Location;
      match (astType)
      {
        | AstType.List(astSymbol) | AstType.OptionList(astSymbol) =>
          def itemType  = AstType.Ast(astType.Location, astSymbol);
          def itemExprs = node.ItemExprs.Item1;
          def items     = array(itemExprs.Count);
          foreach (itemExpr in itemExprs with index)
            items[index] = TypeNode(itemExpr, ruleSymbol, itemType);
          CreateListCtor(loc, astSymbol, items)

        | _ =>
          compilerMessages.Error(loc, $"Expected ast type '$astType' got list");
          CreateError(loc)
      }
    }

    public TypeOptionSome(node : G.MapSyntaxExpression.OptionSome, ruleSymbol : SyntaxRuleSymbol, astType : AstType) : TExpr
    {
      def compilerMessages = GetCompilerMessages(node);
      def loc = node.Location;
      if (astType is AstType.Option(astSymbol))
      {
        def valueType = AstType.Ast(astType.Location, astSymbol);
        def value     = TypeNode(node.ValueExpr, ruleSymbol, valueType);
        CreateOptionCtor(loc, astSymbol, VSome(value))
      }
      else
      {
        compilerMessages.Error(loc, $"Expected ast type '$astType' got option.Some");
        CreateError(loc)
      }
    }

    public TypeOptionNone(node : G.MapSyntaxExpression.OptionNone, _ruleSymbol : SyntaxRuleSymbol, astType : AstType) : TExpr
    {
      def compilerMessages = GetCompilerMessages(node);
      def loc = node.Location;
      if (astType is AstType.Option(astSymbol))
        CreateOptionCtor(loc, astSymbol, VNone())
      else
      {
        compilerMessages.Error(node, $"Expected ast type '$astType' got option.None");
        CreateError(loc)
      }
    }

    private static BindRuleField(ruleSymbol : SyntaxRuleSymbol, qid : G.QualifiedIdentifier, context : Context, compilerMessages : ICompilerMessages) : ValueOption[ParseTreePath]
    {
      def eq(a : string, b : string)
      {
        String.Equals(a, b, StringComparison.InvariantCulture)
      }

      def bind(qualifier : ParseTreePath, name : Identifier, tail : list[Identifier]) : ValueOption[ParseTreePath]
      {
        def failure() : ValueOption[ParseTreePath]
        {
          compilerMessages.Error(name.Location, $"Unbound name '$(name.Value)'");
          VNone()
        }

        def success(ruleType : RuleType) : ValueOption[ParseTreePath]
        {
          def path = ParseTreePath.Member(qualifier.Location + name.Location, qualifier, name, ruleType);
          bindTail(path, tail)
        }

        match (qualifier.Type)
        {
          | Ref(symbol) =>
            def loop(rules : list[Rule])
            {
              | [] => failure()
              | rule :: _ when eq(name.Value, rule.FieldName) => success(rule.Type)
              | _ :: otherRules => loop(otherRules)
            }
            loop(symbol.NonVoidSubRules)

          | Tuple(members) =>
            def loop(members, index)
            {
              match (members)
              {
                | [] => failure()
                | member :: _ when eq(name.Value, "Item" + index.ToString()) => success(member)
                | _ :: otherMembers => loop(otherMembers, index + 1)
              }
            }
            loop(members, 1)

          | _ => failure()
        }
      }
      and bindTail(path : ParseTreePath, tail : list[Identifier]) : ValueOption[ParseTreePath]
      {
        match (tail)
        {
          | [] => VSome(path)
          | nextName :: nextTail => bind(path, nextName, nextTail)
        }
      }

      match (qid.Identifiers())
      {
        | [] =>
          compilerMessages.Error(qid, "No rule field name speciefied");
          VNone()

        | name :: tail =>
          if (context.BindMany.[ParseTreePatternVariableSymbol](name.Location).Candidates is [variable])
          {
            def path = ParseTreePath.Variable(name.Location, name, variable.Type);
            bindTail(path, tail);
          }
          else
          {
            def thisLoc = qid.Location.FromStart();
            def path    = ParseTreePath.This(thisLoc, ruleSymbol);
            bind(path, name, tail)
          }
      }
    }

    private static FilterTuples(path : ParseTreePath) : ParseTreePath
    {
      def filterNonKeywords(members : list[RuleType], index : int) : list[int * RuleType]
      {
        match (members)
        {
          | [] => []
          | RuleType.Chars(Keyword = Some) :: rest => filterNonKeywords(rest, index + 1)
          | x :: rest => (index, x) :: filterNonKeywords(rest, index + 1)
        }
      }

      if (path.Type is Tuple(members))
        if (filterNonKeywords(members, 1) is [(index, nonKeyword)])
          FilterTuples(ParseTreePath.Member(path.Location, path, Identifier(path.Location.FromEnd(), "Item" + index), nonKeyword))
        else path
      else path
    }

    private static SelectSyntaxMappingOverload(contextRuleSymbol : SyntaxRuleSymbol, syntaxMappings : list[SyntaxMappingSymbol], arguments : SCG.IList[G.MapSyntaxExpression], returnType : AstType) : ValueOption[SyntaxMappingSymbol]
    {
      def checkArgumentTypes(index, parms)
      {
        if (parms is current :: other)
          arguments[index].ReturnsType(contextRuleSymbol, current.Type) && checkArgumentTypes(index + 1, other)
        else
          true
      }

      def candidates = LightList();
      foreach (syntaxMapping in syntaxMappings)
      {
        when (syntaxMapping.ReturnType.IsSubtypeOf(returnType))
        when (syntaxMapping.Parameters.Length == arguments.Count)
        when (checkArgumentTypes(0, syntaxMapping.Parameters))
          candidates.Add(syntaxMapping)
      }

      match (candidates.Count)
      {
        | 0 => VNone()
        | 1 => VSome(candidates.FirstItem)
        | _ => VNone()
      }
    }
  }
}
