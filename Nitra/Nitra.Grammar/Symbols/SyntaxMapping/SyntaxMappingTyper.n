using Nitra.ProjectSystem;
using Nitra.Model;

using Nemerle;
using Nemerle.Imperative;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using SCG = System.Collections.Generic;

using G = NitraSyntaxParseTree;

namespace Nitra.Typing
{
  internal module SyntaxMappingTyper
  {
    public MakeExpression(type : SyntaxMappingType, astType : AstType, compilerMessages : ICompilerMessages) : SyntaxMappingExpr
    {
      def makeExpression(type : SyntaxMappingType)
      {
        | Undefined           => SyntaxMappingExpr.Error(type)
        | Ast(exprType, expr) =>
          if (exprType.IsSubtypeOf(astType))
            expr
          else
          {
            compilerMessages.Error(type, $"Expected AST type '$astType' got '$exprType'.");
            SyntaxMappingExpr.Error(type)
          }

        | Option(valueType) =>
          if (astType is AstType.Option(astSymbol))
          {
            def valueExpr =
              if (valueType is Some(expr))
                Some(MakeExpression(expr, AstType.Ast(astType.Location, astSymbol), compilerMessages))
              else
                None();

            SyntaxMappingExpr.OptionCtor(type.Location, astSymbol, valueExpr)
          }
          else
          {
            compilerMessages.Error(type, $"Expected AST type '$astType' got option.");
            SyntaxMappingExpr.Error(type)
          }

        | List(itemTypes) =>
          match (astType)
          {
            | List(astSymbol) | OptionList(astSymbol) =>
              def itemAstType = AstType.Ast(astType.Location, astSymbol);
              def itemExprs   = itemTypes.Map(MakeExpression(_, itemAstType, compilerMessages));
              SyntaxMappingExpr.ListCtor(type.Location, astSymbol, itemExprs)

            | _ =>
              compilerMessages.Error(type, $"Expected AST type '$astType' got list.");
              SyntaxMappingExpr.Error(type)
          }

        | ParseTree(path) with arguments = []
        | Call(path, arguments) => makeExpression(ResolveCall(type, path, arguments, VSome(astType), compilerMessages))
      }
      makeExpression(type)
    }

    public TypeTypeHint(node : G.MapSyntaxExpression.TypeHint, ruleSymbol : SyntaxRuleSymbol) : SyntaxMappingType
    {
      def loc = node.Location;
      def astType = TypingUtils.NTypeToAstTypeWithMessage(node.NitraType, node.Context);
      if (astType.IsVoid)
        SyntaxMappingType.Undefined(loc)
      else
      {
        def exprType = node.Expr.MakeType(ruleSymbol);
        def expr     = MakeExpression(exprType, astType, node.Context);
        SyntaxMappingType.Ast(loc, astType, expr);
      }
    }

    public TypeIdentifier(node : G.MapSyntaxExpression.Identifier, ruleSymbol : SyntaxRuleSymbol) : SyntaxMappingType
    {
      def loc  = node.Location;
      def name = node.Identifier.Identifier();
      def result1 = node.Context.BindMany.[ParseTreePatternVariableSymbol](name.Location);
      match (result1.Candidates)
      {
        | [variable] =>
          def path = ParseTreePath.Variable(loc, name, variable.Type);
          SyntaxMappingType.ParseTree(loc, path)

        | _ :: _ =>
          result1.Messages.TranslateTo(node.Context);
          SyntaxMappingType.Undefined(loc)

        | [] =>
          def mappingContext = node.Context.GetContext.[MapSyntaxContext]();
          if (mappingContext.BindParameter(name) is VSome(parameter))
          {
            def expr = SyntaxMappingExpr.ParameterRef(name.Location, parameter);
            SyntaxMappingType.Ast(loc, parameter.Type, expr)
          }
          else if (LookupRuleField(RuleType.Ref(ruleSymbol), name) is VSome(ruleType))
          {
            def path = ParseTreePath.Member(name.Location, ParseTreePath.This(name.Location.FromStart(), ruleSymbol), name, ruleType);
            SyntaxMappingType.ParseTree(loc, path)
          }
          else
          {
            node.Context.Error(name, $"Unbound name $(name.Value).");
            SyntaxMappingType.Undefined(loc)
          }
      }
    }

    public TypeMemberAccess(node : G.MapSyntaxExpression.MemberAccess, ruleSymbol : SyntaxRuleSymbol) : SyntaxMappingType
    {
      def error(errorLoc : Located, message : string)
      {
        node.Context.Error(errorLoc, message);
        SyntaxMappingType.Undefined(node.Location)
      }
      def unboundName(name : Identifier)
      {
        error(name, $"Unbound name '$name'.")
      }

      def makeAccess(exprType : SyntaxMappingType)
      {
        def loc = node.Location;
        match (exprType)
        {
          | Ast(Void, _) | Undefined => SyntaxMappingType.Undefined(loc)
          | Ast(Option, _) | Option => error(exprType, "Member access expression is not supported on option.")
          | Ast(List, _) | Ast(OptionList, _) | List => error(exprType, "Member access expression is not supported on list.")
          | Ast(Ast(symbol), expr) =>
            def name = node.Identifier.Identifier();
            match (symbol.LookupProperty(name.Value))
            {
              | VSome(SimpleAstPropertySymbol as property) =>
                if (property.AstType.IsVoid)
                  error(name, $"Property type '$(property.Type)' is not valid AST type.")
                else
                  SyntaxMappingType.Ast(loc, property.AstType, SyntaxMappingExpr.PropertyRef(loc, expr, property))

              | VSome(property) => error(name, $"Property '$(property.FullName)' is not simple AST property.")
              | VNone()         => unboundName(name)
            }

          | ParseTree(path) =>
            def name = node.Identifier.Identifier();
            if (LookupRuleField(path.Type, name) is VSome(ruleType))
              SyntaxMappingType.ParseTree(loc, ParseTreePath.Member(loc, path, name, ruleType))
            else
              unboundName(name)

          | Call(path, arguments) => makeAccess(ResolveCall(exprType, path, arguments, VNone(), node.Context))
        }
      }

      makeAccess(node.Expr.MakeType(ruleSymbol))
    }

    public TypeCall(node : G.MapSyntaxExpression.Call, ruleSymbol : SyntaxRuleSymbol) : SyntaxMappingType
    {
      def loc           = node.Location;
      def exprType      = node.Expr.MakeType(ruleSymbol);
      def argumentTypes = node.ArgumentExprs.Item1.MapToList(_.MakeType(ruleSymbol));
      match (exprType)
      {
        | Undefined       => SyntaxMappingType.Undefined(loc)
        | ParseTree(path) => SyntaxMappingType.Call(loc, path, argumentTypes)
        | _               =>
          node.Context.Error(loc, "Syntax mapping invokation is not allowed here");
          SyntaxMappingType.Undefined(loc)
      }
    }

    public TypeAst(node : G.MapSyntaxExpression.Ast, ruleSymbol : SyntaxRuleSymbol) : SyntaxMappingType
    {
      def loc    = node.Location;
      def result = TypingUtils.BindAstSymbolFromMappingExtension(node.QualifiedName, node.Context);
      if (result is SymbolRef.Some(astSymbol))
      {
        def mappingFields = SCG.List();
        foreach (member in node.Members)
          when (member.GetSyntaxMappingField(astSymbol, ruleSymbol) is VSome(mappingField))
            mappingFields.Add(mappingField);

        TypingUtils.CheckRequiredAstProperties(astSymbol, mappingFields, Location(loc.Source, node.CloseBrace), node.Context);
        def type = AstType.Ast(node.QualifiedName.Location, astSymbol);
        def expr = SyntaxMappingExpr.AstCtor(loc, astSymbol, mappingFields.ToNList());
        SyntaxMappingType.Ast(loc, type, expr)
      }
      else
        SyntaxMappingType.Undefined(loc)
    }

    private LookupRuleField(type : RuleType, name : Identifier) : ValueOption[RuleType]
    {
      match (type)
      {
        | Ref(symbol) =>
          def loop(rules : list[Rule])
          {
            | [] => VNone()
            | rule :: _ when StringComparer.Ordinal.Equals(name.Value, rule.FieldName) => VSome(rule.Type)
            | _ :: otherRules => loop(otherRules)
          }
          loop(symbol.NonVoidSubRules)

        | Tuple(members) =>
          def loop(members, index)
          {
            match (members)
            {
              | [] => VNone()
              | member :: _ when StringComparer.Ordinal.Equals(name.Value, $"Item$index") => VSome(member)
              | _ :: otherMembers => loop(otherMembers, index + 1)
            }
          }
          loop(members, 1)

        | _ => VNone()
      }
    }

    private ResolveCall(loc : Located, originalPath : ParseTreePath, arguments : list[SyntaxMappingType], returnType : ValueOption[AstType], compilerMessages : ICompilerMessages) : SyntaxMappingType
    {
      def path = FilterTuples(originalPath);
      match (path.Type)
      {
        | Ref(targetRuleSymbol) =>
          def result = SelectSyntaxMappingOverload(loc, targetRuleSymbol, arguments, returnType);
          if (result.Candidates is [syntaxMapping])
            CreateCall(node, path, syntaxMapping, arguments, ruleSymbol)
          else
            CreateError(node, result.Messages, compilerMessages)

        | List(item) =>
          def itemPath = FilterTuples(ParseTreePath.Variable(path.Location.FromEnd(), Nitra.Model.Identifier(path.Location.FromEnd(), "node"), item));
          if (itemPath.Type is Ref(targetRuleSymbol))
            match(astType)
            {
              | List(astSymbol) | OptionList(astSymbol) =>
                def result1 = SelectSyntaxMappingOverload(loc, targetRuleSymbol, arguments, VSome(AstType.Ast(astType.Location, astSymbol)));
                match (result1.Candidates)
                {
                  | [syntaxMapping] => CreateConvertList(node, astSymbol, path, syntaxMapping, arguments, itemPath, ruleSymbol)
                  | _ :: _          => CreateError(node, result1.Messages, compilerMessages)
                  | [] =>
                    def result2 = SelectSyntaxMappingOverload(loc, targetRuleSymbol, arguments, VSome(astType));
                    match (result2.Candidates)
                    {
                      | [syntaxMapping] => CreateConcatLists(node, astSymbol, path, syntaxMapping, arguments, itemPath, ruleSymbol)
                      | _ :: _          => CreateError(node, result2.Messages, compilerMessages)
                      | [] =>
                        def result3 = SelectSyntaxMappingOverload(node, ruleSymbol, targetRuleSymbol, arguments, AstType.Option(astType.Location, astSymbol));
                        match (result3.Candidates)
                        {
                          | [syntaxMapping] => CreateConcatOptions(node, astSymbol, path, syntaxMapping, arguments, itemPath, ruleSymbol)
                          | _ :: _          => CreateError(node, result3.Messages, compilerMessages)
                          | []              => CreateError(node, result1.Messages, compilerMessages)
                        }
                    }
                }

              | _ => CreateError(node, compilerMessages, $"Expected AST type '$astType' got list.")
            }
          else
            CreateError(node, compilerMessages, $"Cannot map rule '$(originalPath.Type)' to AST of type '$astType': rule '$item' does not refer syntax rule symbol.")

        | Option(value) =>
          def valuePath = FilterTuples(ParseTreePath.Variable(path.Location.FromEnd(), Nitra.Model.Identifier(path.Location.FromEnd(), "node"), value));
          if (valuePath.Type is Ref(targetRuleSymbol))
            match(astType)
            {
              | Option(astSymbol) =>
                def result = SelectSyntaxMappingOverload(node, ruleSymbol, targetRuleSymbol, arguments, AstType.Ast(astType.Location, astSymbol));
                if (result.Candidates is [syntaxMapping])
                  CreateConvertOption(node, astSymbol, path, syntaxMapping, arguments, valuePath, ruleSymbol)
                else
                  CreateError(node, result.Messages, compilerMessages)

              | _ => CreateError(node, compilerMessages, $"Expected AST type '$astType' got option.")
            }
          else
            CreateError(node, compilerMessages, $"Cannot map rule '$(originalPath.Type)' to AST of type '$astType': rule '$value' does not refer syntax rule symbol.")

        | _ => CreateError(node, compilerMessages, $"Cannot map rule '$(originalPath.Type)' to AST of type '$astType'.")
      }
    }

    private static FilterTuples(path : ParseTreePath) : ParseTreePath
    {
      def filterNonKeywords(members : list[RuleType], index : int) : list[int * RuleType]
      {
        match (members)
        {
          | [] => []
          | RuleType.Chars(Keyword = Some) :: rest => filterNonKeywords(rest, index + 1)
          | x :: rest => (index, x) :: filterNonKeywords(rest, index + 1)
        }
      }

      if (path.Type is Tuple(members))
        if (filterNonKeywords(members, 1) is [(index, nonKeyword)])
          FilterTuples(ParseTreePath.Member(path.Location, path, Identifier(path.Location.FromEnd(), "Item" + index), nonKeyword))
        else path
      else path
    }

    private static SelectSyntaxMappingOverload(loc : Located, targetRuleSymbol : SyntaxRuleSymbol, arguments : list[SyntaxMappingType], returnTypeOpt : ValueOption[AstType]) : BindingResult[SyntaxMappingSymbol]
    {
      def checkTypes(parms, args) : bool
      {
        | ([], []) => true
        | (p :: otherParms, a :: otherArgs) => !(MakeExpression(a, p.Type, NullCompilerMessages.Instance) is SyntaxMappingExpr.Error) && checkTypes(otherParms, otherArgs)
        | _ => false
      }

      def buffer = LightList();
      if (returnTypeOpt is VSome(returnType))
      {
        foreach (syntaxMapping in targetRuleSymbol.SyntaxMappings)
        {
          when (syntaxMapping.ReturnType.IsSubtypeOf(returnType))
          when (syntaxMapping.Parameters.Length == arguments.Length)
          when (checkTypes(syntaxMapping.Parameters, arguments))
            buffer.Add(syntaxMapping)
        }
      }
      else
      {
        foreach (syntaxMapping in targetRuleSymbol.SyntaxMappings)
        {
          when (syntaxMapping.Parameters.Length == arguments.Length)
          when (checkTypes(syntaxMapping.Parameters, arguments))
            buffer.Add(syntaxMapping)
        }
      }

      def result   = buffer.ToNList();
      def messages =
        match (result)
        {
          | [_] => []
          | [] =>
            using (msgs = CompilerMessageList())
            {
              if (targetRuleSymbol.SyntaxMappings.IsEmpty)
                msgs.Error(loc, $"Rule '$(targetRuleSymbol.FullName)' has no AST mapping");
              else
                msgs.Error(loc, $"Rule '$(targetRuleSymbol.FullName)' has no compatible AST mapping.");
              msgs.GetMessages()
            }

          | _ =>
            using (msgs = CompilerMessageList())
            {
              using (root = msgs.RootError(loc, $"Ambiguous '$(targetRuleSymbol.FullName)' AST mapping."))
                foreach (syntaxMapping in result)
                  root.Hint(syntaxMapping.FirstLocation, "AST mapping ambiguity.");
              msgs.GetMessages()
            }
        };

      BindingResult(loc, result, messages);
    }

    private sealed class NullCompilerMessages : IRootCompilerMessages
    {
      public static Instance : this = NullCompilerMessages();

      private this() {}

      public Remove(predicate : Func[Guid, Location, bool]) : void
      {
        IgnoreParams();
      }

      public ReportMessage(messageType : CompilerMessageType, loc : Location, msg : string, num : int) : void
      {
        IgnoreParams();
      }

      public ReportRootMessage(messageType : CompilerMessageType, loc : Location, msg : string, num : int) : IRootCompilerMessages
      {
        IgnoreParams();
        this
      }

      public SetFutureMessagesKind(kind : Guid) : void
      {
        IgnoreParams();
      }

      public Dispose() : void {  }
    }
  }
}
