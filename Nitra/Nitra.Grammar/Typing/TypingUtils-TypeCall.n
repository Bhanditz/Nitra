using Nitra.Model;
using Nitra.ProjectSystem;
using Nitra.Runtime;

using Nemerle;
using Nemerle.Imperative;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;

using G = NitraSyntaxParseTree;
using L = NitraLiteralsParseTree;

namespace Nitra.Typing
{
  public partial module TypingUtils
  {
    internal TypeCall(baseRule : option[ExtensibleRuleSymbol], _precedence : int, _fieldName : option[string], context : Context, options : RuleDefinitionOptions,
      QualifiedName : G.QualifiedIdentifier, BindingPower : OptionParseTree[SequenceParseTree[NSpan, L.Number]]) : Rule
    {
      def newFieldName : string = _fieldName ?? QualifiedName.LastIdentifier().Value;

      when (context.TryBind.[RuleAliasSymbol](QualifiedName) is SymbolRef.Some(alias))
        return alias.Rule.Typing(baseRule, _precedence, Some(newFieldName), context, options);

      def ruleRef = context.Bind.[RuleSymbol](QualifiedName);
      def (type, spanClass) =
        if (ruleRef is SymbolRef.Some(RuleDefSymbol as ruleSymbol))
        {
          when (ruleSymbol is ExtensionRuleSymbol)
            context.Error(QualifiedName,
              "You can't use directly reference an extension rule. Use reference to extensible rule instead or make a separate rule.");

          def declarationSiteContext = context.GetContext.[RuleDeclarationSiteContext]();
          match (declarationSiteContext.DeclarationSite)
          {
            | declarationSite is ExtendSyntaxSymbol =>
              when (declarationSite.Extend is Some(declaration) when declaration.IsToken)
                context.Error(ruleRef, "Can't refer to a syntax rule from token.");

            | declarationSite is RuleDefSymbol =>
              when (declarationSite.IsToken && !ruleSymbol.IsToken)
                context.Error(ruleRef, "Can't refer to a syntax rule from token.");

            | _                  => ()
          }

          (ruleSymbol.Type, ruleSymbol.Options.SpanClassSymbol)
        }
        else (RuleType.Void(), null);


      def getPrecedence()
      {
        match (baseRule, ruleRef)
        {
          | (Some(baseRuleSymbol), SymbolRef.Some(ruleRefSymbol)) when baseRuleSymbol == ruleRefSymbol => _precedence
          | _ => 0
        }
      }

      def bp =
        if (BindingPower.HasValue)
        {
          def value = BindingPower.Value.Item2.Value();
          if (value == 0)
            getPrecedence()
          else
          {
            when (_precedence != 0)
              context.Error(BindingPower.Value.Item2, "You can't set a binding power if you set a precedence.");
            value
          }
        }
        else
          getPrecedence();

      Rule.Call(QualifiedName.Location, type, newFieldName, ruleRef, bp, spanClass);
    }
  }
}
