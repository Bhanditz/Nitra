using Nitra.ProjectSystem;
using Nitra.Typing;

using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;

namespace Nitra.Typing
{
  public partial module TypingUtils
  {
    public ValidateDeclarationField(project : NitraProject, field : DeclarationFieldSymbol) : void
    {
      def declarationSymbol = field.DeclaringDeclaration;
      if (field.ImplementedField is SymbolRef.Some(implementedField))
      {
        def otherDeclaration = implementedField.DeclaringDeclaration;

        if (declarationSymbol : object == otherDeclaration)
          project.Error(field.ImplementedField.Location, "Only inherited fields can be implemented.", -1);
        else if (!declarationSymbol.AllBaseDeclarations.Contains(otherDeclaration))
        {
          def thisName  = declarationSymbol.FullName;
          def otherName = otherDeclaration.FullName;
          project.Error(field.ImplementedField.Location, $"Declaration '$thisName' is not subtype of declaration '$otherName'.", -1);
        }
        else unless (otherDeclaration is AbstractDeclarationSymbol)
          Project.CurrentProject.Error(field.ImplementedField.Location, "Only fields from abstract delarations can be implemented.", -1);
      }
      else
      {
        def hiddenFields = declarationSymbol.InheritedFields.Filter(s => StringComparer.InvariantCulture.Equals(s.Name, field.Name));
        unless (hiddenFields.IsEmpty)
        {
          using (messages = Project.CurrentProject.RootError(field.FirstLocation, $"Field '$(field.FullName)' hides inherited field.", -1))
            foreach (hiddenField in hiddenFields)
            {
              def hiddenName = hiddenField.FullName;
              messages.Hint(hiddenField.FirstLocation, $"Hidden field '$hiddenName'.", -1);
            }
        }
      }
    }
  }
}
