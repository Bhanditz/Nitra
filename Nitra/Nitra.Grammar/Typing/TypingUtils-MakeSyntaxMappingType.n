using Nitra.Model;
using Nitra.ProjectSystem;

using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using SCG = System.Collections.Generic;
using G = NitraSyntaxParseTree;

namespace Nitra.Typing
{
  public partial module TypingUtils
  {
    internal SelectSyntaxMappingOverload(contextRuleSymbol : SyntaxRuleSymbol, syntaxMappings : list[SyntaxMappingSymbol], arguments : SCG.IList[G.MapSyntaxExpression], returnType : AstType) : ValueOption[SyntaxMappingSymbol]
    {
      def checkArgumentTypes(index, parms)
      {
        if (parms is current :: other)
          arguments[index].ReturnsType(contextRuleSymbol, current.Type) && checkArgumentTypes(index + 1, other)
        else
          true
      }

      def candidates = LightList();
      foreach (syntaxMapping in syntaxMappings)
      {
        when (syntaxMapping.ReturnType.IsSubtypeOf(returnType))
        when (syntaxMapping.Parameters.Length == arguments.Count)
        when (checkArgumentTypes(0, syntaxMapping.Parameters))
          candidates.Add(syntaxMapping)
      }

      match (candidates.Count)
      {
        | 0 => VNone()
        | 1 => VSome(candidates.FirstItem)
        | _ => VNone()
      }
    }

    internal MakeSyntaxMappingType(context : Context, sourceRuleType : RuleType, targetAstType : AstType, errorLoc : Location) : ValueOption[SyntaxMappingType]
    {
      def filterNonKeywords(members : list[RuleType], index : int) : list[int * RuleType]
      {
        match (members)
        {
          | [] => []
          | RuleType.Chars(Keyword = Some) :: rest => filterNonKeywords(rest, index + 1)
          | x :: rest => (index, x) :: filterNonKeywords(rest, index + 1)
        }
      }

      def genericError() : ValueOption[SyntaxMappingType]
      {
        context.Error(errorLoc, $"Cannot map '$(sourceRuleType)' to '$(targetAstType)'");
        VNone()
      }

      def makeTupleAccess(ruleType : RuleType) : RuleType * list[int]
      {
        if (ruleType is Tuple(members))
          if (filterNonKeywords(members, 1) is [(index, nonKeyword)])
          {
            def (result, access) = makeTupleAccess(nonKeyword);
            (result, index :: access)
          }
          else (ruleType, [])
        else (ruleType, [])
      }

      def selectMapping(ruleSymbol : SyntaxRuleSymbol, pred : AstType -> ValueOption[SyntaxMappingType]) : ValueOption[SyntaxMappingType]
      {
        if (ruleSymbol.SyntaxMappings is _ :: _)
        {
          mutable candidates : list[SyntaxMappingSymbol * SyntaxMappingType] = [];
          foreach (syntaxMapping in ruleSymbol.SyntaxMappings)
            when (syntaxMapping.Parameters.IsEmpty)
            when (pred(syntaxMapping.ReturnType) is VSome(mapping))
              candidates ::= (syntaxMapping, mapping);

          match (candidates)
          {
            | [(_, one)] => VSome(one)
            | [] =>
              context.Error(errorLoc, $"Rule '$(ruleSymbol.FullName)' has no compatible AST mapping.");
              VNone()

            | (_, first) :: _ =>
              using (root = context.RootError(errorLoc, $"Ambiguous '$(ruleSymbol.FullName)' AST mapping."))
                foreach ((syntaxMapping, _) in candidates)
                  root.Hint(syntaxMapping.FirstLocation, "AST mapping ambiguity.");

              VSome(first)
          }
        }
        else
        {
          context.Error(errorLoc, $"Rule '$(ruleSymbol.FullName)' has no AST mapping");
          VNone()
        }
      }

      def (ruleType, tupleAccess) = makeTupleAccess(sourceRuleType);
      match (ruleType, targetAstType)
      {
        | (List(itemType),       List(targetAstSymbol))
        | (List(itemType), OptionList(targetAstSymbol)) =>
          if (makeTupleAccess(itemType) is (Ref(SyntaxRuleSymbol as ruleSymbol), itemTupleAccess))
            selectMapping(ruleSymbol, fun(_ : AstType)
            {
              | Ast(sourceAstSymbol) when (sourceAstSymbol.IsSubtypeOf(targetAstSymbol)) =>
                VSome(SyntaxMappingType.CreateList(ruleType, tupleAccess, targetAstSymbol, itemTupleAccess))

              | List(sourceAstSymbol)
              | OptionList(sourceAstSymbol) when (sourceAstSymbol.IsSubtypeOf(targetAstSymbol)) =>
                VSome(SyntaxMappingType.ConcatLists(ruleType, tupleAccess, targetAstSymbol, itemTupleAccess))

              | Option(sourceAstSymbol) when (sourceAstSymbol.IsSubtypeOf(targetAstSymbol)) =>
                VSome(SyntaxMappingType.ConcatOptions(ruleType, tupleAccess, targetAstSymbol, itemTupleAccess))

              | _ => VNone()
            })
          else
            genericError()

        | (Option(valueType), Option(targetAstSymbol)) =>
          if (makeTupleAccess(valueType) is (Ref(SyntaxRuleSymbol as ruleSymbol), valueTupleAccess))
            selectMapping(ruleSymbol, fun(_ : AstType)
            {
              | Ast(sourceAstSymbol) when (sourceAstSymbol.IsSubtypeOf(targetAstSymbol)) =>
                VSome(SyntaxMappingType.CreateOption(ruleType, tupleAccess, targetAstSymbol, valueTupleAccess))

              | _ => VNone()
            })
          else
            genericError()

        | (Ref(SyntaxRuleSymbol as ruleSymbol), _) =>
          selectMapping(ruleSymbol, sourceAstType =>
            if (sourceAstType.IsSubtypeOf(targetAstType))
              VSome(SyntaxMappingType.CallGetAst(ruleType, tupleAccess, sourceAstType))
            else
              VNone())

        | _ => genericError()
      }
    }
  }
}
