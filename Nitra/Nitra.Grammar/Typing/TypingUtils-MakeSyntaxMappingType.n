using Nitra.Model;
using Nitra.ProjectSystem;

using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;

namespace Nitra.Typing
{
  public partial module TypingUtils
  {
    internal MakeSyntaxMappingType(context : Context, astProperty : AstPropertySymbol, path : ParseTreePath, errorLoc : Location) : ValueOption[SyntaxMappingType]
    {
      mutable errorReported;

      def filterNonKeywords(members : list[RuleType], index : int) : list[int * RuleType]
      {
        match (members)
        {
          | [] => []
          | RuleType.Chars(Keyword = Some) :: rest => filterNonKeywords(rest, index + 1)
          | x :: rest => (index, x) :: filterNonKeywords(rest, index + 1)
        }
      }

      def buildType(ruleType : RuleType, astType : NType) : ValueOption[SyntaxMappingType]
      {
        match (ruleType, astType)
        {
          | (List(ruleItemType), List(astItemType))
          | (List(ruleItemType), OptionList(astItemType)) =>
            if (buildType(ruleItemType, astItemType) is VSome(t))
              VSome(SyntaxMappingType.List(t, ruleType))
            else
              VNone()

          | (Option(ruleItemType), Option(astItemType)) =>
            if (buildType(ruleItemType, astItemType) is VSome(t))
              VSome(SyntaxMappingType.Option(t, ruleType))
            else
              VNone()

          | (Ref(SyntaxRuleSymbol(Ast = AstType.Ast(sourceAstSymbol))), Qualified as targetName) =>
            def targetAstSymbolRef = context.Bind.[AstSymbol](targetName);
            if (targetAstSymbolRef is SymbolRef.Some(targetAstSymbol))
            {
              if (sourceAstSymbol.IsSubtypeOf(targetAstSymbol))
                VSome(SyntaxMappingType.Ref(targetAstSymbol))
              else
              {
                context.Error(errorLoc, $"Declaration '$(sourceAstSymbol.FullName)' is not subtype of declaration '$(targetAstSymbol.FullName)'");
                errorReported = true;
                VNone()
              }
            }
            else
            {
              errorReported = true;
              VNone()
            }

          | (Tuple(members), _) =>
            if (filterNonKeywords(members, 1) is [(index, nonKeyword)])
              if (buildType(nonKeyword, astType) is VSome(t))
                VSome(SyntaxMappingType.Tuple(index, t))
              else
                VNone()
            else
              VNone()

          | _ => VNone()
        }
      }

      def astType = astProperty.Type;
      def result  = buildType(path.Type, astType);
      when (result.IsNone && !errorReported)
        context.Error(errorLoc, $"Cannot map '$(path.Type)' to '$(astType)'");
      result
    }
  }
}
