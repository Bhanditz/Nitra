using Nitra.Model;
using Nitra.ProjectSystem;

using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;

namespace Nitra.Typing
{
  public partial module TypingUtils
  {
    internal MakeSyntaxMappingType(context : Context, sourceRuleType : RuleType, targetAstType : AstType, errorLoc : Location) : ValueOption[SyntaxMappingType]
    {
      def filterNonKeywords(members : list[RuleType], index : int) : list[int * RuleType]
      {
        match (members)
        {
          | [] => []
          | RuleType.Chars(Keyword = Some) :: rest => filterNonKeywords(rest, index + 1)
          | x :: rest => (index, x) :: filterNonKeywords(rest, index + 1)
        }
      }

      def incompartibleTypesError(sourceAstSymbol : AstSymbol, targetAstSymbol : AstSymbol) : ValueOption[SyntaxMappingType]
      {
        context.Error(errorLoc, $"Declaration '$(sourceAstSymbol.FullName)' is not subtype of declaration '$(targetAstSymbol.FullName)'");
        VNone()
      }

      def genericError() : ValueOption[SyntaxMappingType]
      {
        context.Error(errorLoc, $"Cannot map '$(sourceRuleType)' to '$(targetAstType)'");
        VNone()
      }

      def ruleHasNoMapping(ruleSymbol : SyntaxRuleSymbol) : ValueOption[SyntaxMappingType]
      {
        context.Error(errorLoc, $"Rule '$(ruleSymbol.FullName)' has no AST mapping");
        VNone()
      }

      def makeTupleAccess(ruleType : RuleType) : RuleType * list[int]
      {
        if (ruleType is Tuple(members))
          if (filterNonKeywords(members, 1) is [(index, nonKeyword)])
          {
            def (result, access) = makeTupleAccess(nonKeyword);
            (result, index :: access)
          }
          else (ruleType, [])
        else (ruleType, [])
      }

      def (ruleType, tupleAccess) = makeTupleAccess(sourceRuleType);
      match (ruleType, targetAstType)
      {
        | (List(itemType),       List(targetAstSymbol))
        | (List(itemType), OptionList(targetAstSymbol)) =>
          match (makeTupleAccess(itemType))
          {
            | (Ref(SyntaxRuleSymbol(SyntaxMappings = []) as ruleSymbol), _)               => ruleHasNoMapping(ruleSymbol)
            | (Ref(SyntaxRuleSymbol(SyntaxMappings = syntaxMappings)),   itemTupleAccess) =>
              mutable candidates : list[SyntaxMappingType] = [];
              foreach (syntaxMapping in syntaxMappings)
              {
                match (syntaxMapping.ReturnType)
                {
                  | Void => ()
                  | Ast(sourceAstSymbol) =>
                    when (sourceAstSymbol.IsSubtypeOf(targetAstSymbol))
                      candidates ::= SyntaxMappingType.CreateList(ruleType, tupleAccess, targetAstSymbol, itemTupleAccess)

                  | List(sourceAstSymbol)
                  | OptionList(sourceAstSymbol) =>
                    when (sourceAstSymbol.IsSubtypeOf(targetAstSymbol))
                      candidates ::= SyntaxMappingType.ConcatLists(ruleType, tupleAccess, targetAstSymbol, itemTupleAccess)

                  | Option(sourceAstSymbol) =>
                    when (sourceAstSymbol.IsSubtypeOf(targetAstSymbol))
                      candidates ::= SyntaxMappingType.ConcatOptions(ruleType, tupleAccess, targetAstSymbol, itemTupleAccess)
                }
              }
              match (candidates)
              {
                | []    => genericError()
                | [one] => VSome(one)
                | many  => genericError()
              }

            | _ => genericError()
          }

        | (Option(valueType), Option(targetAstSymbol)) => 
          match (makeTupleAccess(valueType))
          {
            | (Ref(SyntaxRuleSymbol(SyntaxMappings = []) as ruleSymbol), _) => ruleHasNoMapping(ruleSymbol)
            | (Ref(SyntaxRuleSymbol(SyntaxMappings = syntaxMappings)), valueTupleAccess) =>
              mutable candidates : list[SyntaxMappingType] = [];
              foreach (syntaxMapping in syntaxMappings)
              {
                match (syntaxMapping.ReturnType)
                {
                  | Ast(sourceAstSymbol) =>
                    when (sourceAstSymbol.IsSubtypeOf(targetAstSymbol))
                      candidates ::= SyntaxMappingType.CreateOption(ruleType, tupleAccess, targetAstSymbol, valueTupleAccess)

                  | _ => ()
                }
              }
              match (candidates)
              {
                | []    => genericError()
                | [one] => VSome(one)
                | many  => genericError()
              }

            | _ => genericError()
          }

        | (Ref(SyntaxRuleSymbol(SyntaxMappings = []) as ruleSymbol), _) => ruleHasNoMapping(ruleSymbol)
        | (Ref(SyntaxRuleSymbol(SyntaxMappings = syntaxMappings)), _) =>
          mutable candidates : list[SyntaxMappingType] = [];
          foreach (syntaxMapping in syntaxMappings)
          {
            def sourceAstType = syntaxMapping.ReturnType;
            when (sourceAstType.IsSubtypeOf(targetAstType))
              candidates ::= SyntaxMappingType.CallGetAst(ruleType, tupleAccess, sourceAstType);
          }
          match (candidates)
          {
            | []    => genericError()
            | [one] => VSome(one)
            | many  => genericError()
          }


        | _ => genericError()
      }
    }
  }
}
