using Nitra.Model;
using Nitra.ProjectSystem;

using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;

namespace Nitra.Typing
{
  public partial module TypingUtils
  {
    internal MakeSyntaxMappingType(context : Context, sourceRuleType : RuleType, targetAstType : AstType, errorLoc : Location) : ValueOption[SyntaxMappingType]
    {
      def filterNonKeywords(members : list[RuleType], index : int) : list[int * RuleType]
      {
        match (members)
        {
          | [] => []
          | RuleType.Chars(Keyword = Some) :: rest => filterNonKeywords(rest, index + 1)
          | x :: rest => (index, x) :: filterNonKeywords(rest, index + 1)
        }
      }

      def incompartibleTypesError(sourceAstSymbol : AstSymbol, targetAstSymbol : AstSymbol) : ValueOption[SyntaxMappingType]
      {
        context.Error(errorLoc, $"Declaration '$(sourceAstSymbol.FullName)' is not subtype of declaration '$(targetAstSymbol.FullName)'");
        VNone()
      }

      def genericError() : ValueOption[SyntaxMappingType]
      {
        context.Error(errorLoc, $"Cannot map '$(sourceRuleType)' to '$(targetAstType)'");
        VNone()
      }

      def buildType(ruleType : RuleType, astType : AstType) : ValueOption[SyntaxMappingType]
      {
        | (List(Ref(SyntaxRuleSymbol(Ast = AstType.Ast(sourceAstSymbol)))), List(targetAstSymbol))
        | (List(Ref(SyntaxRuleSymbol(Ast = AstType.Ast(sourceAstSymbol)))), OptionList(targetAstSymbol)) =>
          if (sourceAstSymbol.IsSubtypeOf(targetAstSymbol))
            VSome(SyntaxMappingType.List(SyntaxMappingType.Ref(sourceAstSymbol), ruleType))
          else
            incompartibleTypesError(sourceAstSymbol, targetAstSymbol)

        | (Option(Ref(SyntaxRuleSymbol(Ast = AstType.Ast(sourceAstSymbol)))), Option(targetAstSymbol)) =>
          if (sourceAstSymbol.IsSubtypeOf(targetAstSymbol))
            VSome(SyntaxMappingType.Option(SyntaxMappingType.Ref(sourceAstSymbol), ruleType))
          else
            incompartibleTypesError(sourceAstSymbol, targetAstSymbol)

        | (Ref(SyntaxRuleSymbol(Ast = AstType.Ast(sourceAstSymbol))), Ast(targetAstSymbol)) =>
          if (sourceAstSymbol.IsSubtypeOf(targetAstSymbol))
            VSome(SyntaxMappingType.Ref(sourceAstSymbol))
          else
            incompartibleTypesError(sourceAstSymbol, targetAstSymbol)

        | (Tuple(members), _) =>
          if (filterNonKeywords(members, 1) is [(index, nonKeyword)])
            if (buildType(nonKeyword, astType) is VSome(t))
              VSome(SyntaxMappingType.Tuple(index, t))
            else
              genericError()
          else
            genericError()

        | _ => genericError()
      }

      buildType(sourceRuleType, targetAstType)
    }
  }
}
