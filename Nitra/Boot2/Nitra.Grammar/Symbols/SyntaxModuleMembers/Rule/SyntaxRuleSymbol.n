using Nitra.ProjectSystem;
using Nitra.Model;
using Nitra.Typing.RuleMethod;

using Nemerle;
using System;

namespace Nitra.Typing
{
  [Record]
  public abstract class SyntaxRuleSymbol : RuleDefSymbol
  {
    public abstract Rule             : Rule.Sequence                {           get; }
    public abstract Ast              : AstType                      {           get; }
    public          NonVoidSubRules  : list[Rule]                   { [Memoize] get { Rule.Rules.Filter(rule => !(rule.Type is RuleType.Void)) } }
    public          SubRules         : list[Rule]                   {           get { Rule.Rules } }
    public          Sequence         : SequenceCompileInfo.Root     { [Memoize] get { SequenceCompileInfo.MakeSequenceCompileInfo(this) } }
    public override IsToken          : bool                         {           get { Options.IsTokenRule } }

    internal virtual SetAst(astType : AstType) : void
    {
      assert(Node != null);
      Node.Project.Error(astType, "Declaration mapping is not allowed here")
    }

    internal virtual SetSyntaxMappingExpr(expr : SyntaxMappingExpr) : void
    {
      _ = expr
    }

    public virtual GetSyntaxMappingExpr() : SyntaxMappingExpr
    {
      null
    }

    protected TrySetAst(ast : ref AstType, newValue : AstType) : void
    {
      assert(Node != null);
      assert(newValue != null);
      if (ast == null)
        ast = newValue
      else using (messages = Node.Project.RootError(newValue, "Only single declaration mapping is allowed"))
        messages.Hint(ast, "Fist declaration mapping")
    }

    protected TrySetSyntaxMappingExpr(expr : ref SyntaxMappingExpr, newValue : SyntaxMappingExpr) : void
    {
      assert(newValue != null);
      when (expr == null)
        expr = newValue;
    }
  }
}
