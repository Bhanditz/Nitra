using Nitra.Model;

using Nemerle;
using Nemerle.Collections;
using Nemerle.Compiler.Parsetree;
using Nemerle.Text;
using Nemerle.Utility;

using System;

namespace Nitra.Typing
{
  [Record]
  public variant SyntaxMappingExpr : Located
  {
    | Code          { Expr   : PExpr }
    | Match         { Path   : ParseTreePath; Cases : list[SyntaxMappingCase] }
    | AstCtor       { Symbol : AstSymbol; Fields : list[SyntaxMappingField]  }
    | ListCtor      { Symbol : AstSymbol; Items  : list[SyntaxMappingExpr]   }
    | OptionCtor    { Symbol : AstSymbol; Value  : option[SyntaxMappingExpr] }
    | Call          { Path : ParseTreePath; Arguments : list[SyntaxMappingExpr]; ReturnType : AstType; }
    | ConvertList   { Path : ParseTreePath; Arguments : list[SyntaxMappingExpr]; Symbol : AstSymbol; ItemPath  : ParseTreePath }
    | ConvertOption { Path : ParseTreePath; Arguments : list[SyntaxMappingExpr]; Symbol : AstSymbol; ValuePath : ParseTreePath }
    | ConcatLists   { Path : ParseTreePath; Arguments : list[SyntaxMappingExpr]; Symbol : AstSymbol; ItemPath  : ParseTreePath }
    | ConcatOptions { Path : ParseTreePath; Arguments : list[SyntaxMappingExpr]; Symbol : AstSymbol; ItemPath  : ParseTreePath }

    public override Location : Location { get; }

    public static Error(loc : Located) : SyntaxMappingExpr
    {
      Error(loc.Location)
    }

    public static Error(loc : Location) : SyntaxMappingExpr
    {
      SyntaxMappingExpr.Code(loc, PExpr.Error(loc.NLocation(), "Typing failed on syntax mapping expression"))
    }
  }
}
