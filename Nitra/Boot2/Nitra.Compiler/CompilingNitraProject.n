using Nemerle;
using Nemerle.Collections;
using Nemerle.Compiler;
using Nemerle.Text;
using Nemerle.Utility;

using Nitra.Runtime;
using Nitra.Typing;
using Nitra.ProjectSystem;

using System;
using System.Reflection;
using SCG = System.Collections.Generic;

namespace Nitra.Compiler
{
  public sealed class CompilingNitraProject : NitraProject
  {
    public this()
    {
      base(NemerleCompilerMessages())
    }

    public ErrorCount : int { get { (CompilerMessages :> NemerleCompilerMessages).ErrorCount } }

    public Environment : EmitterEnvironment { get; private set; }

    public override Files : Seq[File] { get { throw NotImplementedException() } }

    public override Init(referencedAssemblies : Seq[AssemblyName]) : void
    {
      base.Init(referencedAssemblies);
      Environment = EmitterEnvironment(ManagerClass.Instance, this);
      _fakeSourceSnapshots.Clear();
    }

    public override GetNemerleType(symbol : Symbol) : FixedType
    {
      | ruleSymbol        is RuleSymbol        => Environment.GetParseTreeType(ruleSymbol)
      | declarationSymbol is DeclarationSymbol => Environment.GetDeclarationType(declarationSymbol)
      | _ => assert(false, $"Cannot get Nemerle type for symbol '$symbol'")
    }

    private _fakeSourceSnapshots : SCG.Dictionary[int, SourceSnapshot] = SCG.Dictionary();

    public override MakeFakeNitraLocation(location : Nemerle.Compiler.Location) : Nitra.Location
    {
      mutable sourceSnapshot;
      unless (_fakeSourceSnapshots.TryGetValue(location.FileIndex, out sourceSnapshot))
      {
        sourceSnapshot = SingleLineSourceSnapshot(string.Empty, location.FileIndex, location.File);
        _fakeSourceSnapshots.Add(location.FileIndex, sourceSnapshot);
      }
      Nitra.Location(sourceSnapshot, NSpan(0, 0))
    }
  }
}
