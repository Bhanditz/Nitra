using Nemerle;
using Nemerle.Collections;
using Nemerle.Imperative;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Compiler.Typedtree;

using Nitra.Internal;
using Nitra.Model;
using Nitra.Typing;

using System;
using System.Diagnostics;
using System.Linq;
using SCG = System.Collections.Generic;

namespace Nitra.Compiler
{
  internal partial class RuleAstEmitter
  {
    public DefineMembers() : void
    {
      when (_baseTb != null)
        DefineBaseAstRuleMethods();
      when (_astTb != null)
      {
        DefineAstCtorAndFields();
        DefineAstPrettyPrint();
        DefineAstRuleMethods();
      }
      when (_spliceTb != null)
      {
        DefineSpliceRuleMethods();
      }
      when (_missingTb != null)
      {
        DefineMissingPrettyPrint();
        DefineMissingRuleMethods();
      }
      when (_ambiguousTb != null)
      {
        DefineAmbiguousPrettyPrint();
        DefineAmbiguousRuleMethods();
      }
    }

    private DefineAstCtorAndFields() : void
    {
      def args = SCG.List();
      args.Add(<[ parameter: location : Nitra.Location ]>);
      def init = SCG.List();
      init.Add(<[ base(location) ]>);
      foreach (rule in this.RuleSymbol.NonVoidSubRules)
      {
        def fieldType = Environment.GetAstType(rule.Type);
        _astTb.DefineConditional(<[decl: public new $(rule.FieldName : usesite) : $(fieldType : typed) ]>);
        args.Add(<[ parameter: $(rule.FieldName : usesite) : $(fieldType : typed)  ]>);
        init.Add(<[ this.$(rule.FieldName : usesite) = $(rule.FieldName : usesite) ]>);
      }
      _astTb.DefineConditional(<[decl: public this(..$(args.ToNList())) { ..$(init.ToNList()) } ]>);
    }
  }
}
