using Nitra.Model;
using Nitra.Typing;

using Nemerle;
using Nemerle.Collections;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using SCG = System.Collections.Generic;

namespace Nitra.Compiler
{
  internal sealed class SimpleDeclarationEmitter : DeclarationEmitter
  {
    private         _symbol            : SimpleDeclarationSymbol;
    private mutable _baseTb            : TypeBuilder;
    private mutable _ambiguousTb       : TypeBuilder;
    private mutable _concreteTb        : TypeBuilder;
    private         _collectionEmitter : CollectionEmitter;

    public this(environment : EmitterEnvironment, symbol : SimpleDeclarationSymbol)
    {
      base(environment, environment.NamespaceOfSymbol(symbol));
      this._symbol = symbol;
      this._collectionEmitter = CollectionEmitter(this, symbol);
    }

    public override DefineTypes() : void
    {
      Util.locate(_symbol.FirstLocation.ToNemerleLocation(),
      {
        assert(_baseTb == null);

        def parentType = Environment.TypeCompiler.CompileParentType(_symbol);

        def baseTypes = SCG.List();
        baseTypes.Add(<[ Nitra.Declarations.AstBase[$(parentType : typed)] ]>);
        foreach (baseDeclaration in _symbol.BaseDeclarations)
          baseTypes.Add(<[ $(Environment.GetDeclarationType(baseDeclaration) : typed) ]>);
        when (_symbol.NameProperty.HasValue)
          baseTypes.Add(<[ $(Environment.DeclarationTypeVar : typed) ]>);

        _baseTb = NemerleEnv.Define(<[ decl:
          public abstract partial class $(_symbol.Name : usesite) : ..$baseTypes
          {
          }
        ]>);

        assert(_concreteTb == null);
        _concreteTb = _baseTb.DefineNestedType(<[ decl:
          public sealed partial class $(ConcreteDeclarationName : usesite) : $(_baseTb.GetMemType() : typed)
          {
            public override Parent : $(parentType : typed)                   { get; protected set; }
            public override Span   : $(Environment.NSpanTypeVar : typed)     { get; }
          }
        ]>);

        assert(_ambiguousTb == null);
        _ambiguousTb = DefineAmbiguousDeclaration(_baseTb, parentType);

        _collectionEmitter.DefineTypes(_baseTb);
      });
    }

    public override DefineMembers() : void
    {
      assert(_baseTb != null);

      def initParameters = SCG.List();
      initParameters.Add(<[ parameter: Span : $(Environment.NSpanTypeVar : typed) ]>);

      def initStatements = SCG.List();
      initStatements.Add(<[ this.Span = Span ]>);

      def initStatementsTail = SCG.List();

      def implementSimpleProperty(propertySymbol : DeclarationPropertySymbol, propertyType : FixedType)
      {
        def backingFieldName = Util.tmpname(propertySymbol.Name);
        initParameters.Add(<[ parameter : $(propertySymbol.Name : usesite) : $(propertyType : typed) ]>);
        initStatements.Add(<[ this.$(backingFieldName : usesite) = $(propertySymbol.Name : usesite) ]>);
        _concreteTb.Define(<[ decl:
          private mutable $(backingFieldName : usesite) : $(propertyType : typed)
        ]>);

        _concreteTb.Define(<[ decl:
          public override $(propertySymbol.Name : usesite) : $(propertyType : typed)
          {
            get { this.$(backingFieldName : usesite) }
          }
        ]>);

        _ambiguousTb.Define(<[ decl:
          public override $(propertySymbol.Name : usesite) : $(propertyType : typed)
          {
            get { this.Ambiguities[0].$(propertySymbol.Name : usesite) }
          }
        ]>);

        when (propertyType.TryRequire(Environment.AstTypeVar))
          initStatementsTail.Add(<[ this.$(backingFieldName : usesite).SetParent(this) ]>);
      }

      when (_symbol.NameProperty is SymbolRef.Some(propertySymbol))
      {
        def propertyType = Environment.TypeCompiler.CompileNamePropertyType(propertySymbol);
        _baseTb.Define(<[ decl: public abstract $(propertySymbol.Name : usesite) : $(propertyType : typed) implements $(Environment.DeclarationTypeVar : typed).Name { get; } ]>);
        implementSimpleProperty(propertySymbol, propertyType)
      }

      def dependentProps = SCG.Dictionary();

      def defineSimpleProperty(propertySymbol : SimpleDeclarationPropertySymbol) : void
      {
        def propertyType = Environment.TypeCompiler.CompileSimplePropertyType(propertySymbol);
        _baseTb.Define(<[ decl: public abstract $(propertySymbol.Name : usesite) : $(propertyType : typed) { get; } ]>);
        implementSimpleProperty(propertySymbol, propertyType)
      }

      def defineDependentProperty(propertySymbol : DependentDeclarationPropertySymbol) : void
      {
        def index = dependentProps.Count;
        def bit   = _baseTb.GetBitFieldManager().Allocate();
        assert(bit.Index == index);

        def propertyRef = DependentDeclarationPropertyRef.Compiling(propertySymbol, index, bit);
        dependentProps.Add(propertySymbol, propertyRef);

        DefineDependentProperty(_baseTb, propertyRef, NemerleModifiers.Public | NemerleModifiers.Virtual);
        DefineAmbiguousDependentProperty(_ambiguousTb, propertyRef, NemerleModifiers.Public | NemerleModifiers.Override);
      }

      foreach (propertySymbol in _symbol.AllProperties)
      {
        | SimpleDeclarationPropertySymbol    as s => defineSimpleProperty(s)
        | DependentDeclarationPropertySymbol as s => defineDependentProperty(s)
        | _                                       => ()
      }

      initStatements.AddRange(initStatementsTail);

      _concreteTb.Define(<[ decl:
        public this(..$initParameters) { ..$initStatements }
      ]>);

      DefineIsPropertyEvaluatedMethod(_baseTb, NemerleModifiers.Override);
      DefineDependentPropertiesEvaluation(_baseTb, _symbol);

      _collectionEmitter.DefineMembers(dependentProps);
    }

    public override Emit() : void
    {
      assert(_baseTb != null);
      _baseTb.Compile();

      assert(_concreteTb != null);
      _concreteTb.Compile();

      assert(_ambiguousTb != null);
      _ambiguousTb.Compile();

      _collectionEmitter.Emit();
    }
  }
}
