using Nitra.Runtime;
using Nitra.Model;
using Nitra.Typing;

using Nemerle;
using Nemerle.Collections;
using Nemerle.Compiler.Parsetree;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;

namespace Nitra.Compiler
{
  [Record]
  public class AstWalkerGenerator : WalkerGenerator
  {
    public Environment : EmitterEnvironment { get; }

    public override Name : string { get StandardWalkerTypes.Ast }

    public override SupportsVoidRules : bool { get false }

    public override GetSignature(rule : RuleSymbol) : WalkerSignature
    {
      WalkerSignature([], <[ $(Environment.GetAstType(rule) : typed) ]>);
    }

    protected override GetSubruleValue(subrule : SubruleCompileInfo, parentAstPointer : AstPointerScope) : PExpr
    {
      match (subrule)
      {
        | Empty      as subrule => Skip(subrule, parentAstPointer)
        | SimpleCall as subrule =>
          if (subrule.Symbol.Type is RuleType.Void)
            Skip(subrule, parentAstPointer)
          else
            CallSimpleRule(subrule, parentAstPointer)

        | ExtensibleCall as subrule =>
          if (subrule.Symbol.Type is RuleType.Void)
            Skip(subrule, parentAstPointer)
          else
            CallExtensibleRule(subrule, parentAstPointer)

        | RegularCall
        | List as lst when lst.IsSkipAnyPattern
        | TokenString => GetTokenValue(subrule, parentAstPointer, <[ Nitra.NSpan(tokenPos, pos) ]>)
        | Option as subrule =>
          if (subrule.SrcRule.Type is RuleType.Void)
            Skip(subrule, parentAstPointer)
          else
            GetOptionValue(
              subrule          = subrule,
              parentAstPointer = parentAstPointer,
              hasValue         = <[ Some($(GetSequenceValue(subrule.Rule, "valuePointer"))) ]>,
              noValue          = <[ None() ]>)

        | List as lst =>
          if (subrule.SrcRule.Type is RuleType.Void)
            Skip(subrule, parentAstPointer)
          else
            GetListValue(
              subrule          = lst,
              parentAstPointer = parentAstPointer,
              init             = <[ def itemBuffer = System.Collections.Generic.List(16) ]>,
              item             = <[ itemBuffer.Add($(GetSequenceValue(lst.Rule, "itemPointer"))) ]>,
              returnCode       = <[ Nemerle.Collections.NList.ToList(itemBuffer) ]>,
              emptyCode        = <[ [] ]>);

        | ListWithSeparator as lst=>
          match (lst.Rule.SrcRule.Type, lst.Separator.SrcRule.Type)
          {
            | (Void, Void) => Skip(subrule, parentAstPointer)
            | (_, Void) =>
                GetListWithSeparatorValue(
                  subrule          = lst,
                  parentAstPointer = parentAstPointer,
                  init             = <[ def itemBuffer = System.Collections.Generic.List(16) ]>,
                  item             = <[ itemBuffer.Add($(GetSequenceValue(lst.Rule, "itemPointer"))) ]>,
                  separator        = <[ _ = $(GetSequenceValue(lst.Separator, "separatorPointer")) ]>,
                  returnCode       = <[ Nemerle.Collections.NList.ToList(itemBuffer) ]>,
                  emptyCode        = <[ [] ]>);

            | (Void, _) =>
                GetListWithSeparatorValue(
                  subrule          = lst,
                  parentAstPointer = parentAstPointer,
                  init             = <[ def separatorBuffer = System.Collections.Generic.List(16) ]>,
                  item             = <[ _ = $(GetSequenceValue(lst.Rule, "itemPointer")) ]>,
                  separator        = <[ separatorBuffer.Add($(GetSequenceValue(lst.Separator, "separatorPointer"))) ]>,
                  returnCode       = <[ Nemerle.Collections.NList.ToList(separatorBuffer) ]>,
                  emptyCode        = <[ [] ]>);

            | _ =>
              GetListWithSeparatorValue(
                subrule          = lst,
                parentAstPointer = parentAstPointer,
                init             = <[ def itemBuffer = System.Collections.Generic.List(16); def separatorBuffer = System.Collections.Generic.List(16); ]>,
                item             = <[ itemBuffer.Add($(GetSequenceValue(lst.Rule, "itemPointer"))) ]>,
                separator        = <[ separatorBuffer.Add($(GetSequenceValue(lst.Separator, "separatorPointer"))) ]>,
                returnCode       = <[ (Nemerle.Collections.NList.ToList(itemBuffer), Nemerle.Collections.NList.ToList(separatorBuffer)) ]>,
                emptyCode        = <[ ([], []) ]>);
          }

        | Marker => <[ () ]>
      }
    }

    protected override CombineValues(_sequence : SequenceCompileInfo, arguments : list[PExpr]) : PExpr
    {
      match (arguments)
      {
        | []   => <[ () ]> //assert3(false, "Void values not allowed for AST")
        | [x]  => x
        | many => <[ (..$many) ]>
      }
    }

    protected override GetSyntaxRuleValue(ruleSymbol : SyntaxRuleSymbol, astPointer : AstPointerScope) : PExpr
    {
      def sequence = ruleSymbol.Sequence;
      def statements = List();
      def arguments  = List();

      arguments.Add(<[ Nitra.Location(parseResult, __startPos, pos) ]>);
      when (sequence is SequenceCompileInfo.Ast(Symbol = ExtensionRuleSymbol(ExtensionType=Postfix)))
        arguments.Add(<[ prefix ]>);

      foreach (subrule in sequence.NonMarkerSubrules)
      {
        if (RuleAstEmitter.IsSubruleAcceptedForAst(subrule))
        {
          def varName = subrule.MakeVariableName("ast");
          statements.Add(<[ def $(varName : usesite) = $(GetSubruleValue(subrule, astPointer)) ]>);
          arguments.Add(<[ $(varName : usesite) ]>);
        }
        else
          statements.Add(GetSubruleValue(subrule, astPointer));
      }

      def ctor =
        if (ruleSymbol is ExtensionRuleSymbol)
          <[ $(Environment.GetAstType(ruleSymbol) : typed) ]>
        else
          <[ $(Environment.GetAstType(ruleSymbol) : typed).Ast ]>;
      statements.Add(<[ $ctor(..$(arguments.NToList())) ]>);
      <[ { ..$(statements.NToList()); } ]>
    }

    public override PrefixAmbiguity(ruleSymbol : ExtensibleRuleSymbol) : PExpr
    {
      <[
        def asts = array(ambiguities.Count);
        foreach( (ast, _) in ambiguities with index)
          asts[index] = ast;
        $(Environment.GetAstType(ruleSymbol) : typed).AmbiguousAst(Nitra.Location(parseResult, __startPos, endPos), asts)
      ]>
    }

    public override PostfixAmbiguity(ruleSymbol : ExtensibleRuleSymbol) : PExpr
    {
      <[
        def asts = array(ambiguities.Count);
        foreach( (ast, _) in ambiguities with index)
          asts[index] = ast;
        $(Environment.GetAstType(ruleSymbol) : typed).AmbiguousAst(Nitra.Location(parseResult, __startPos, endPos), asts)
      ]>
    }

    public override PrefixMissed(ruleSymbol : ExtensibleRuleSymbol) : PExpr
    {
      <[ $(Environment.GetAstType(ruleSymbol) : typed).MissingAst(Nitra.Location(parseResult, pos, pos)) ]>
    }

    public override SimpleMissed(ruleSymbol : SimpleRuleSymbol) : PExpr
    {
      <[ $(Environment.GetAstType(ruleSymbol) : typed).MissingAst(Nitra.Location(parseResult, pos, pos)) ]>
    }
  }
}
