using Nemerle;
using Nemerle.Collections;
using Nemerle.Compiler.Parsetree;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using SCG = System.Collections.Generic;
using System.Linq;

using Nitra.Model;

using N = Nemerle.Compiler;

namespace Nitra.Compiler
{
  internal sealed partial class TryParseMethodEmitter : MethodEmitter
  {
    public override CompileTokenString(code : SCG.List[PExpr], subrule : SubruleCompileInfo.TokenString) : void
    {
      def astSize = subrule.String.Length;
      def makeStringCheckCode(str : string) : PExpr
      {
        if (str == "")
          <[ true ]>
        else
        {
          def check = if (astSize > 1) <[$CurTextPos + $((astSize - 1) : int)]> else <[ $CurTextPos ]>;

          def makeCharCheckCode(ch : char, i : int) : PExpr
          {
            def index = if (i <= 0) <[ $CurTextPos ]> else <[ $CurTextPos + $(i : int) ]>;
            <[ text[$index] == $(ch : char) ]>
          }
          def exprs = str.Select(makeCharCheckCode);
          def condExpr = exprs.Aggregate((e1, e2) => <[ $e1 && $e2 ]>);
          <[ $check < text.Length && $condExpr ]>
        }
      }

      def checkCode = makeStringCheckCode(subrule.String);
      def predicateCode = CompilePredicate(subrule.HeadPredicates, GotoFailParseLabel(subrule));
      code.Add(<[
        $(ParseLabel(subrule));
          _ = $(subrule.ToString());
          $predicateCode;
          if ($checkCode)
          {
            $(AddParsedStateInfo(subrule, <[ $astSize ]>));
            $CurTextPos += $astSize;
            $(GotoContinueParseLabel(subrule));
          }
          else
          {
            $(RecoveryCode());
            $(GotoFailParseLabel(subrule));
          }
      ]>);
    }
  }
}
