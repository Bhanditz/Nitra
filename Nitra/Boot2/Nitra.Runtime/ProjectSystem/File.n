using Nitra.Runtime;
using Nitra.Declarations;

using Nemerle;
using Nemerle.Assertions;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;

namespace Nitra.ProjectSystem
{
  public class FileStatistics
  {
    public this([NotNull] parse : StatisticsTask.Single, [NotNull] parseTree : StatisticsTask.Single, [NotNull] ast : StatisticsTask.Single)
    {
      Parse     = parse;
      ParseTree = parseTree;
      Ast       = ast;
    }

    public Parse     : StatisticsTask.Single { get; }
    public ParseTree : StatisticsTask.Single { get; }
    public Ast       : StatisticsTask.Single { get; }
  }

  [Record]
  public abstract class File : ISourceSnapshotProvider
  {
    public abstract Project     : Project { get; }
    public abstract Length      : int     { get; }
    public abstract FullName    : string  { get; }
    public Statistics           : FileStatistics { get; }

    public abstract GetSource() : SourceSnapshot;

    public virtual EvalProperties(context : DependentPropertyEvalContext, compilerMessages : ICompilerMessages) : void
    {
      IgnoreParams();
    }

    public override ToString() : string { FullName }
  }

  public abstract class ConcreteFile[TAst] : File
    where TAst: IAst
  {
            _ruleDescriptor   : StartRuleDescriptor;
            _compositeGrammar : CompositeGrammar;
    mutable _parseResult      : IParseResult;
    mutable _astRoot          : AstRoot[TAst];
    mutable _parseTree        : IMappedParseTree[TAst];
    
    public ParseResult : IParseResult { get { _parseResult }}

    protected this(ruleDescriptor : StartRuleDescriptor, compositeGrammar : CompositeGrammar = null, statistics : FileStatistics = null)
    {
      base(statistics);
      _ruleDescriptor   = ruleDescriptor;
      _compositeGrammar = compositeGrammar;
    }

    public virtual Ast        : TAst
    {
      get
      {
        when (_astRoot == null)
          UpdateAst();
        _astRoot.Content
      }
    }

    public virtual ParseTree : IMappedParseTree[TAst]
    {
      get
      {
        when (_parseTree == null)
          UpdateParseTree();
        _parseTree
      }
    }

    public virtual ResetCache() : void
    {
      _astRoot     = null;
      _parseTree   = null;
      _parseResult = null;
    }

    public virtual ResetAst() : void
    {
      _astRoot     = null;
    }
    
    public virtual ResetParseTree() : void
    {
      _astRoot     = null;
      _parseTree   = null;
    }
    
    public override EvalProperties(context : DependentPropertyEvalContext, compilerMessages : ICompilerMessages) : void
    {
      when (_astRoot == null)
        UpdateAst();
      _astRoot.EvalProperties(context, compilerMessages);
    }

    protected virtual GetParseSession() : ParseSession
    {
      ParseSession(_ruleDescriptor, _compositeGrammar);
    }

    public virtual ReParse() : void
    {
      assert3(Project != null);

      def stat = Statistics;
      stat?.Parse.Restart();
      
      def parseSession = GetParseSession();
      def parseResult  = parseSession.Parse(GetSource());
      _parseResult     = parseResult;
      
      def project      = Project;
      foreach(error in parseResult.GetErrors())
        project.Error(error.Location, error.Message);
      
      stat?.Parse.Stop();
    }

    public virtual UpdateParseTree() : void
    {
      when (_parseResult == null)
        ReParse();
        
      def stat = Statistics;
      // TODO: The parse tree does not materialize here. So the measurements are incorrect.
      stat?.ParseTree.Restart();

      _parseTree = _parseResult.CreateParseTree() :> IMappedParseTree[TAst];
      
      stat?.ParseTree.Stop();
    }

    public virtual UpdateAst() : void
    {
      assert3(Project != null);
      
      when (_parseResult == null)
        ReParse();

      when (_parseTree == null)
        UpdateParseTree();

      def stat = Statistics;
      stat?.Ast.Restart();
      
      _astRoot = AstRoot[TAst].Create(_parseTree, Project);
      
      stat?.Ast.Stop();
    }
  }
}
