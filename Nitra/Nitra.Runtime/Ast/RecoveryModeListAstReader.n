using Nemerle;
using Nemerle.Utility;

using System;
using SCG = System.Collections.Generic;

using Nitra.Internal.Recovery;
using Nitra.Runtime.Reflection;

namespace Nitra.Internal
{
  [Record]
  internal struct RecoveryModeListAstReaderContext[TLoader, TItem]
    where TLoader : IAst
    where TItem : TLoader
  {
    public ItemLoader     : IAstSequenceLoader[TLoader];
    public ItemSequenceId : int;
    public ItemConverter  : IAstCast[TLoader, TItem];
  }

  internal sealed class RecoveryModeListAstReader[TLoader, TItem] : RecoveryModeAstReader[RecoveryModeListAstReaderContext[TLoader, TItem], ListAst[TItem]]
    where TLoader : IAst
    where TItem   : TLoader
  {
    public static Instance : RecoveryModeListAstReader[TLoader, TItem];

    static this() { Instance = RecoveryModeListAstReader() }

    protected override MakeAmbiguousAst(ambiguities : array[ListAst[TItem]]) : ListAst[TItem]
    {
      AmbiguousListAst(ambiguities)
    }

    protected override MakeEmptyAst(parseResult : ParseResult, pos : int, context : RecoveryModeListAstReaderContext[TLoader, TItem]) : ListAst[TItem]
    {
      _ = context;
      EmptyListAst(Location(parseResult.OriginalSource, pos, pos))
    }

    protected override ReadAst(parseResult : ParseResult, startPos : int, endPos : int, recoveredSubruleIndex : int, context : RecoveryModeListAstReaderContext[TLoader, TItem]) : ListAst[TItem]
    {
      def items = SCG.List();
      def (subrules, parsingSequence) = parseResult.RecoveredSubrules[recoveredSubruleIndex];
      for (mutable i = 0; i < subrules.Length - 1; ++i)
      {
        def itemStartPos = subrules[i].Pos;
        def itemEndPos   = subrules[i + 1].Pos;
        def state        = parsingSequence.States[subrules[i].State];
        match (state.Subrule)
        {
          | ListItem(ParsingSequence = itemParsingSequence) =>
            RecoveryModeSequenceAstReader.Instance.Read(parseResult, itemParsingSequence, itemStartPos, itemEndPos, RecoveryModeSequenceAstReaderContext(context.ItemLoader, context.ItemSequenceId))
              |> context.ItemConverter.Cast
              |> items.Add;

          | _ => assert(false, "List items expected");
        }
      }
      ConcreteListAst(Location(parseResult.OriginalSource, startPos, endPos), items);
    }

    protected override ReadAstStandardMode(startPos : int, endPos : int, context : RecoveryModeListAstReaderContext[TLoader, TItem]) : ListAst[TItem]
    {
      _ = startPos; _ = endPos; _ = context;
      throw NotImplementedException("Fallback to standard AST reading");
    }
  }
}
