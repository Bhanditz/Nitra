using Nemerle;
using Nemerle.Utility;

using System;
using SCG = System.Collections.Generic;

using Nitra.Internal.Recovery;
using Nitra.Runtime.Reflection;

namespace Nitra.Internal
{
  internal sealed class RecoveryModeListWithSeparatorAstReader[TItemLoader, TItem, TSeparatorLoader, TSeparator] :
    RecoveryModeBaseListParseTreeReader[
      /* TContext    */ RecoveryModeAstReaderContext[TItemLoader, TItem] * RecoveryModeAstReaderContext[TSeparatorLoader, TSeparator],
      /* TListBuffer */ SCG.List[TItem] * SCG.List[TSeparator],
      /* TAst        */ SequenceParseTree[ListParseTree[TItem], ListParseTree[TSeparator]]]
    where TItemLoader      : IParseTree
    where TItem            : TItemLoader
    where TSeparatorLoader : IParseTree
    where TSeparator       : TSeparatorLoader
  {
    public static Instance : this;

    static this() { Instance = RecoveryModeListWithSeparatorAstReader() }

    protected override MakeAmbiguousParseTree(ambiguities : array[SequenceParseTree[ListParseTree[TItem], ListParseTree[TSeparator]]], context : RecoveryModeAstReaderContext[TItemLoader, TItem] * RecoveryModeAstReaderContext[TSeparatorLoader, TSeparator]) : SequenceParseTree[ListParseTree[TItem], ListParseTree[TSeparator]]
    {
      _ = context;
      AmbiguousSequenceParseTree(ambiguities)
    }

    protected override MakeEmptyParseTree(parseResult : ParseResult, pos : int, context : RecoveryModeAstReaderContext[TItemLoader, TItem] * RecoveryModeAstReaderContext[TSeparatorLoader, TSeparator]) : SequenceParseTree[ListParseTree[TItem], ListParseTree[TSeparator]]
    {
      _ = context;
      def loc = Location(parseResult, pos, pos);
      ConcreteSequenceParseTree(loc, EmptyListParseTree(loc), EmptyListParseTree(loc))
    }

    protected override CreateListBuffer() : SCG.List[TItem] * SCG.List[TSeparator]
    {
      (SCG.List(), SCG.List())
    }

    protected override ReadListItem(stateNumber : int, parseResult : ParseResult, parsingSequence : ParsingSequence, startPos : int, endPos : int, listBuffer : SCG.List[TItem] * SCG.List[TSeparator], context : RecoveryModeAstReaderContext[TItemLoader, TItem] * RecoveryModeAstReaderContext[TSeparatorLoader, TSeparator]) : void
    {
      match (stateNumber % 2)
      {
        | 0 =>
          RecoveryModeSequenceParseTreeReader.Instance.Read(parseResult, parsingSequence, startPos, endPos, RecoveryModeSequenceParseTreeReaderContext(context[0].ItemLoader, context[0].ItemSequenceId))
            |> context[0].ItemConverter.Cast
            |> listBuffer[0].Add

        | 1 =>
          RecoveryModeSequenceParseTreeReader.Instance.Read(parseResult, parsingSequence, startPos, endPos, RecoveryModeSequenceParseTreeReaderContext(context[1].ItemLoader, context[1].ItemSequenceId))
            |> context[1].ItemConverter.Cast
            |> listBuffer[1].Add

        | _ => assert(false, "Unknown ListWithSeparator state number")
      }
    }

    protected override CreateListAst(parseResult : ParseResult, startPos : int, endPos : int, listBuffer : SCG.List[TItem] * SCG.List[TSeparator]) : SequenceParseTree[ListParseTree[TItem], ListParseTree[TSeparator]]
    {
      def loc = Location(parseResult, startPos, endPos);
      ConcreteSequenceParseTree(loc, ConcreteListParseTree(loc, listBuffer[0]), ConcreteListParseTree(loc, listBuffer[1]))
    }
  }
}
