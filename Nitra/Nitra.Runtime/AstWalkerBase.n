using Nemerle;
using Nemerle.Collections;
using Nemerle.Surround;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Imperative;

using Nitra.Internal;
using Nitra.Internal.Recovery;
using Nitra.Runtime.Reflection;

using System;
using System.Collections.Generic;
using System.Linq;

[assembly: DefineSurround("not_recovery", false, def old_isRecovered = _isRecovered, _isRecovered = old_isRecovered)]

namespace Nitra.Runtime
{
  public abstract class AstWalkerBase[TContext]
  {
    mutable _isRecovered : bool;
    
    public virtual OnEmpty(ruleInfo : SubruleInfo.Empty, startPos : int, endPos : int, parseResult : ParseResult, context : TContext) : void
    {
      IgnoreParams();
    }

    public virtual OnMarker(ruleInfo : SubruleInfo.Marker, startPos : int, endPos : int, parseResult : ParseResult, context : TContext) : void
    {
      IgnoreParams();
    }

    public virtual OnPrefixMissed(ruleParser : ExtensibleRuleParser, pos : int, parseResult : ParseResult, context : TContext) : void
    {
      IgnoreParams();
    }

    public virtual OnRegularCall(ruleInfo : SubruleInfo.RegularCall, startPos : int, endPos : int, parseResult : ParseResult, context : TContext) : void
    {
      IgnoreParams();
    }

    public virtual OnTokenString(ruleInfo : SubruleInfo.TokenString, startPos : int, endPos : int, parseResult : ParseResult, context : TContext) : void
    {
      IgnoreParams();
    }

    public Walk(parseResult : ParseResult, context : TContext) : void
    {
      _isRecovered = parseResult.RecoveredSequences.Count > 0;
      def endPos = parseResult.Text.Length;
      
      match (parseResult.RuleParser)
      {
        | ExtensibleRuleParser as ruleParser => WalkExtensible(parseResult.StartPos, endPos, ruleParser, parseResult, context)
        | SimpleRuleParser     as ruleParser => WalkSimple(parseResult.StartPos, endPos, ruleParser, parseResult, context)
        | _                                  => assert3(false)
      }
    }

    public virtual OnSimpleCall(ruleInfo : SubruleInfo.SimpleCall, startPos : int, endPos : int, parseResult : ParseResult, context : TContext) : void
    {
      WalkSimple(startPos, endPos, ruleInfo.RuleParser, parseResult, context);
    }

    public virtual OnListItem(astPtr : int, ruleInfo : SubruleInfo.ListItem, startPos : int, endPos : int, parseResult : ParseResult, context : TContext) : void
    {
      when (_isRecovered)
      {
        when (Walk(parseResult, ruleInfo.ParsingSequence, startPos, endPos, context))
          return;
      }
      
      assert2(endPos >= 0);
      
      when (startPos != endPos)
      {
        surroundwith(not_recovery)
        {
          _ = WalkSequence(astPtr, startPos, parseResult, context);
        }
      }
    }

    public virtual OnExtensibleCall(ruleInfo : SubruleInfo.ExtensibleCall, startPos : int, endPos : int, parseResult : ParseResult, context : TContext) : void
    {
      WalkExtensible(startPos, endPos, ruleInfo.RuleParser, parseResult, context)
    }

    public virtual OnOption(ruleInfo : SubruleInfo.Option, startPos : int, endPos : int, parseResult : ParseResult, context : TContext) : void
    {
      assert2(endPos >= 0);

      when (startPos == endPos)
        return;
      
      when (_isRecovered)
      {
        when (Walk(parseResult, ruleInfo.Rule.ParsingSequence, startPos, endPos, context))
          return;
      }

      surroundwith(not_recovery)
      {
        def curTextPos = WalkSequence(parseResult.GetAst(startPos, ruleInfo.Rule.Id), startPos, parseResult, context);
        assert3(curTextPos == endPos);
      }
    }

    public virtual OnList(ruleInfo : SubruleInfo.List, startPos : int, endPos : int, parseResult : ParseResult, context : TContext) : void
    {
      mutable curTextPos = startPos;
      
      when (_isRecovered)
      {
        when (Walk(parseResult, ruleInfo.ParsingSequence, startPos, endPos, context))
          return;
      }

      assert2(endPos >= 0);

      when (startPos != endPos && !ruleInfo.IsOptimized)
      {
        while (curTextPos < endPos)
          surroundwith(not_recovery)
          {
            def astPtr = parseResult.GetAst(curTextPos, ruleInfo.Rule.Id);
            def endPos = curTextPos + parseResult.GetAstSize(astPtr, ruleInfo.Rule);
            OnListItem(astPtr, ruleInfo.ListItemRule, curTextPos, endPos, parseResult, context);
            curTextPos = endPos;
          }
        assert3(curTextPos == endPos);
      }
    }

    public virtual OnListWithSeparator(ruleInfo : SubruleInfo.ListWithSeparator, startPos : int, endPos : int, parseResult : ParseResult, context : TContext) : void
    {
      mutable curTextPos = startPos;
      
      when (_isRecovered)
      {
        when (Walk(parseResult, ruleInfo.ParsingSequence, startPos, endPos, context))
          return;
      }
      
      assert2(endPos >= 0);

      when (startPos != endPos)
      {
        surroundwith(not_recovery)
        while (true)
        {
          when (curTextPos >= endPos) break;
          def astPtr = parseResult.GetAst(curTextPos, ruleInfo.Rule.Id);
          def itemEndPos = curTextPos + parseResult.GetAstSize(astPtr, ruleInfo.Rule);
          OnListItem(astPtr, ruleInfo.ListItemRule, curTextPos, itemEndPos, parseResult, context);
          curTextPos = itemEndPos;

          when (curTextPos >= endPos) break;
          def astPtr = parseResult.GetAst(curTextPos, ruleInfo.Separator.Id);
          def itemEndPos = curTextPos + parseResult.GetAstSize(astPtr, ruleInfo.Separator);
          OnListItem(astPtr, ruleInfo.ListItemSeparator, curTextPos, itemEndPos, parseResult, context);
          curTextPos = itemEndPos;
        }
        assert3(curTextPos == endPos);
      }
    }

    Walk(parseResult : ParseResult, states : array[ParsingState], subrules : array[ParseResult.SubruleStart], sequenceInfo : SequenceInfo, context : TContext) : void
    {
      mutable prevIndexWithMarkers = -1;
      for (mutable i = 0; i < subrules.Length - 1; ++i)
      {
        def begin    = subrules[i].Pos;
        def end      = subrules[i + 1].Pos;
        def state    = states[subrules[i].State];
        def ruleInfo = state.Subrule;

        when (sequenceInfo != null)
        {
          for (mutable j = prevIndexWithMarkers + 1; j < ruleInfo.IndexWithMarkers; j++)
          {
            def subruleInfo = sequenceInfo.SubrulesWithMarkers[j];
            when (subruleInfo is SubruleInfo.Marker as marker)
              OnMarker(marker, begin, begin, parseResult, context);
          }
        }

        match (state)
        {
          | ExtensionPrefix  as state =>
            if (begin == end)
              OnPrefixMissed(state.RuleParser, begin, parseResult, context);
            else
              foreach (prefix in state.RuleParser.PrefixRules)
                when (parseResult.RecoveredSequences.ContainsKey((begin, end, prefix.ParsingSequence)))
                  _ = WalkPrefix(-1, begin, end, prefix, parseResult, context);

          | ExtensionPostfix as state => 
            foreach (postfix in state.RuleParser.PostfixRules)
              when (postfix.RuleId >= state.RuleParser.FirstPostfixRuleId)
              when (parseResult.RecoveredSequences.ContainsKey((begin, end, postfix.ParsingSequence)))
                _ = WalkPostfix(-1, begin, end, postfix, parseResult, context);

          | Predicate => ()

          | _ =>
            match (ruleInfo)
            {
              | Marker                        => assert3(false)
              | RegularCall       as ruleInfo => OnRegularCall      (    ruleInfo, begin, end, parseResult, context)
              | TokenString       as ruleInfo => OnTokenString      (    ruleInfo, begin, end, parseResult, context)
              | SimpleCall        as ruleInfo => OnSimpleCall       (    ruleInfo, begin, end, parseResult, context)
              | ExtensibleCall    as ruleInfo => OnExtensibleCall   (    ruleInfo, begin, end, parseResult, context)
              | Option            as ruleInfo => OnOption           (    ruleInfo, begin, end, parseResult, context)
              | List              as ruleInfo => OnList             (    ruleInfo, begin, end, parseResult, context)
              | ListWithSeparator as ruleInfo => OnListWithSeparator(    ruleInfo, begin, end, parseResult, context)
              | ListItem          as ruleInfo => OnListItem         (-1, ruleInfo, begin, end, parseResult, context)
              | Empty             as ruleInfo => OnEmpty            (    ruleInfo, begin, end, parseResult, context)
            }
        }
        prevIndexWithMarkers = if (ruleInfo == null) -1 else ruleInfo.IndexWithMarkers;
      }

      when (sequenceInfo != null)
      {
        def seqEnd = subrules[subrules.Length - 1].Pos;
        for (mutable j = prevIndexWithMarkers + 1; j < sequenceInfo.SubrulesWithMarkers.Length; j++)
        {
          def subruleInfo = sequenceInfo.SubrulesWithMarkers[j];
          when (subruleInfo is SubruleInfo.Marker as marker)
            OnMarker(marker, seqEnd, seqEnd, parseResult, context);
        }
      }
    }
    
    public virtual OnAmbiguous(parseResult : ParseResult, states : array[ParsingState], parseWays : array[array[ParseResult.SubruleStart]], sequenceInfo : SequenceInfo, context : TContext) : void
    {
      foreach (parseWay in parseWays)
        Walk(parseResult, states, parseWay, sequenceInfo, context)
    }
    
    Walk(parseResult : ParseResult, parsingSequence : ParsingSequence, startPos : int, endPos : int, context : TContext) : bool
    {
      when (startPos == endPos)
        return true;

      //ruleParser.ParsingSequence.SequenceInfo
      mutable recoveredSequence;
      
      unless (parseResult.RecoveredSequences.TryGetValue((startPos, endPos, parsingSequence), out recoveredSequence))
        return false;

      def states            = parsingSequence.States;
      def recoveredSubrules = parseResult.RecoveredSubrules;
      
      match (recoveredSequence)
      {
        | Unambiguous as recoveredSequence => Walk(parseResult, states, recoveredSubrules[recoveredSequence.Subrules].Subrules, parsingSequence.SequenceInfo, context)
        | Ambiguous   as recoveredSequence =>
          def parseWays = array(recoveredSequence.Subrules.Length);
          foreach (subruleStart in recoveredSequence.Subrules with i)
            parseWays[i] = recoveredSubrules[subruleStart].Subrules;
          
          OnAmbiguous(parseResult, states, parseWays, parsingSequence.SequenceInfo, context);
      }

      true
    }
    
    public virtual WalkSimple(startPos : int, endPos : int, ruleParser : SimpleRuleParser, parseResult : ParseResult, context : TContext) : void
    {
      when (_isRecovered)
      {
        when (Walk(parseResult, ruleParser.ParsingSequence, startPos, endPos, context))
          return;
      }
      
      surroundwith(not_recovery)
      {
        def end = WalkSequence(parseResult.TryGetAst(startPos, ruleParser.RuleId), startPos, parseResult, context);
        assert(end == endPos);
      }
    }

    public virtual WalkExtensible(startPos : int, endPos : int, ruleParser : ExtensibleRuleParser, parseResult : ParseResult, context : TContext) : void
    {
      when (_isRecovered)
      {
        when (Walk(parseResult, ruleParser.ParsingSequence, startPos, endPos, context))
          return;
      }
      
      surroundwith(not_recovery)
      {
        mutable curTextPos = startPos;
        curTextPos = WalkExtension(parseResult.TryGetAst(curTextPos, ruleParser.PrefixId), curTextPos, ruleParser, parseResult, context);
        while (curTextPos < endPos)
          curTextPos = WalkExtension(parseResult.TryGetAst(curTextPos, ruleParser.PostfixId), curTextPos, ruleParser, parseResult, context);
        when (curTextPos != endPos)
          assert2(false);
      }
    }

    public WalkExtension(astPtr : int, mutable curTextPos : int, ruleParser : ExtensibleRuleParser, parseResult : ParseResult, context : TContext) : int
    {
      when (astPtr <= 0)
        return -1;

      def id = parseResult.ast[astPtr] & ExtensibleRuleParser.AstMask.Id;
      if (id == ruleParser.PrefixId)
      {
        mutable prefixAst = astPtr;
        def bestResult = parseResult.TryGetPrefix(ref curTextPos, ref prefixAst);

        if (bestResult > 0)
        {
          def bestPrefixAstPtr = ruleParser.BestPrefix(bestResult, parseResult);
          def extensionParser = ruleParser.PrefixRuleParser(bestPrefixAstPtr, parseResult);
          def endPos = curTextPos + parseResult.GetAstSize(bestPrefixAstPtr, extensionParser.SequenceInfo);
          WalkPrefix(bestPrefixAstPtr, curTextPos, endPos, extensionParser, parseResult, context);
          endPos
        }
        else
        {
          OnPrefixMissed(ruleParser, curTextPos, parseResult, context);
          curTextPos
        }
      }
      else
      {
        mutable postfixAst = astPtr;
        def bestPostfixAstPtr = ruleParser.BestPostfix(parseResult.TryGetPostfix(ref curTextPos, ref postfixAst), parseResult);
        def extensionParser = ruleParser.PostfixRuleParser(bestPostfixAstPtr, parseResult);
        def endPos = curTextPos + parseResult.GetAstSize(bestPostfixAstPtr, extensionParser.SequenceInfo);
        WalkPostfix(bestPostfixAstPtr, curTextPos, endPos, extensionParser, parseResult, context);
        endPos
      }
    }

    public virtual WalkPrefix(astPtr : int, startPos : int, endPos : int, ruleParser : ExtensionRuleParser, parseResult : ParseResult, context : TContext) : void
    {
      if (astPtr < 0)
        _ = Walk(parseResult, ruleParser.ParsingSequence, startPos, endPos, context);
      else
        _ = WalkSequence(astPtr, startPos, parseResult, context)
    }

    public virtual WalkPostfix(astPtr : int, startPos : int, endPos : int, ruleParser : ExtensionRuleParser, parseResult : ParseResult, context : TContext) : void
    {
      if (astPtr < 0)
        _ = Walk(parseResult, ruleParser.ParsingSequence, startPos, endPos, context);
      else
        _ = WalkSequence(astPtr, startPos, parseResult, context)
    }

    public virtual StartWalkSequence (sequenceInfo : SequenceInfo) : void { IgnoreParams(); }
    public virtual FinishWalkSequence(sequenceInfo : SequenceInfo) : void { IgnoreParams(); }
    
    protected WalkSequence(astPtr : int, mutable curTextPos : int, parseResult : ParseResult, context : TContext) : int
    {
      assert2(astPtr > 0);
      assert2(parseResult.ast[astPtr + ExtensibleRuleParser.AstOfs.State] == int.MinValue);

      def sequenceInfo = parseResult.GetSequenceInfo(astPtr);
      StartWalkSequence(sequenceInfo);
      foreach (ruleInfo in sequenceInfo.SubrulesWithMarkers)
      {
        if (ruleInfo is Marker as ruleInfo)
          OnMarker(ruleInfo, curTextPos, curTextPos, parseResult, context);
        else
        {
          def sizePtr = astPtr + ruleInfo.Offset;
          def size    = parseResult.GetSize(sizePtr);
          def endPos  = curTextPos + size;

          match (ruleInfo)
          {
            | ListItem                      => assert(false)
            | Marker                        => assert3(false)
            | RegularCall       as ruleInfo => OnRegularCall      (ruleInfo, curTextPos, endPos, parseResult, context)
            | TokenString       as ruleInfo => OnTokenString      (ruleInfo, curTextPos, endPos, parseResult, context)
            | SimpleCall        as ruleInfo => OnSimpleCall       (ruleInfo, curTextPos, endPos, parseResult, context)
            | ExtensibleCall    as ruleInfo => OnExtensibleCall   (ruleInfo, curTextPos, endPos, parseResult, context)
            | Option            as ruleInfo => OnOption           (ruleInfo, curTextPos, endPos, parseResult, context)
            | List              as ruleInfo => OnList             (ruleInfo, curTextPos, endPos, parseResult, context)
            | ListWithSeparator as ruleInfo => OnListWithSeparator(ruleInfo, curTextPos, endPos, parseResult, context)
            | Empty             as ruleInfo => OnEmpty            (ruleInfo, curTextPos, endPos, parseResult, context)
          }
          curTextPos = endPos;
        }
      }
      
      FinishWalkSequence(sequenceInfo);
      curTextPos
    }
  }
}
