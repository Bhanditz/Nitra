using Nemerle;
using Nemerle.Text;
using Nemerle.Utility;

using Nitra.Internal;
using Nitra.Internal.Recovery;
using Nitra.Runtime.Reflection;

using System;
using System.Collections.Generic;
using System.Linq;
using Context = System.Int32;

namespace Nitra.Runtime.Errors
{
  public sealed class ErrorCollectorWalker : AstWalkerBase[Context]
  {
    //public Errors : List[ParseError] { get; default List();}
    public Errors : List[SubruleInfo * NSpan] { get; default List();}
    
    public this()
    {
    }

    public override OnRegularCall(ruleInfo : SubruleInfo.RegularCall, startPos : int, endPos : int, parseResult : ParseResult, context : Context) : void
    {
      IgnoreParams();

      when (startPos == endPos && !ruleInfo.CanParseEmptyString)
      {
        Errors.Add((ruleInfo, NSpan(startPos, endPos)));
      }
    }

    public override OnTokenString(ruleInfo : SubruleInfo.TokenString, startPos : int, endPos : int, parseResult : ParseResult, context : Context) : void
    {
      IgnoreParams();

      when (startPos == endPos && !ruleInfo.CanParseEmptyString)
      {
        Errors.Add((ruleInfo, NSpan(startPos, endPos)));
      }
    }

    public override OnSimpleCall(ruleInfo : SubruleInfo.SimpleCall, startPos : int, endPos : int, parseResult : ParseResult, context : Context) : void
    {
      when (startPos == endPos && !ruleInfo.CanParseEmptyString)
      {
        Errors.Add((ruleInfo, NSpan(startPos, endPos)));
      }
      base.OnSimpleCall(ruleInfo, startPos, endPos, parseResult, context);
    }

    public override OnExtensibleCall(ruleInfo : SubruleInfo.ExtensibleCall, startPos : int, endPos : int, parseResult : ParseResult, context : Context) : void
    {
      when (startPos == endPos && !ruleInfo.CanParseEmptyString)
      {
        Errors.Add((ruleInfo, NSpan(startPos, endPos)));
      }
      base.OnExtensibleCall(ruleInfo, startPos, endPos, parseResult, context);
    }

    public override OnOption(ruleInfo : SubruleInfo.Option, startPos : int, endPos : int, parseResult : ParseResult, context : Context) : void
    {
      when (startPos == endPos && !ruleInfo.CanParseEmptyString)
      {
        Errors.Add((ruleInfo, NSpan(startPos, endPos)));
      }
      base.OnOption(ruleInfo, startPos, endPos, parseResult, context);
    }

    public override OnList(ruleInfo : SubruleInfo.List, startPos : int, endPos : int, parseResult : ParseResult, context : Context) : void
    {
      when (startPos == endPos && !ruleInfo.CanParseEmptyString)
      {
        Errors.Add((ruleInfo, NSpan(startPos, endPos)));
      }
      base.OnList(ruleInfo, startPos, endPos, parseResult, context);
    }

    public override OnListWithSeparator(ruleInfo : SubruleInfo.ListWithSeparator, startPos : int, endPos : int, parseResult : ParseResult, context : Context) : void
    {
      when (startPos == endPos && !ruleInfo.CanParseEmptyString)
      {
        Errors.Add((ruleInfo, NSpan(startPos, endPos)));
      }
      base.OnListWithSeparator(ruleInfo, startPos, endPos, parseResult, context);
    }

    public override WalkSimple(startPos : int, endPos : int, ruleParser : SimpleRuleParser, parseResult : ParseResult, context : Context) : void
    {
      when (startPos == endPos && !ruleParser.SequenceInfo.CanParseEmptyString)
      {
        Errors.Add((null, NSpan(startPos, endPos)));
      }
      base.WalkSimple(startPos, endPos, ruleParser, parseResult, context);
    }

    public override OnPrefixMissed(ruleParser : ExtensibleRuleParser, pos : int, parseResult : ParseResult, context : Context) : void
    {
      IgnoreParams();
      Errors.Add((null, NSpan(pos, pos)));
    }
  }
}
