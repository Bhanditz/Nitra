using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using Nitra.Internal;
using Nitra.Internal.Recovery;
using Nitra.Runtime.Reflection;

using System;
using System.Collections.Generic;
using System.Linq;

namespace Nitra.Runtime.Errors
{
  public sealed class ErrorCollectorWalker : AstWalkerBase[Context]
  {
    public class Context
    {
      public Inserted : List[INitraReflection * NSpan] = List();
      
      public GetErrors(parseResult : ParseResult) : Seq[ExpectedError]
      {
        def result = List();
        def groups = Inserted.GroupBy((_, span) => span.EndPos);
        foreach (group in groups)
        {
          def (_, span) = group.First();
          def loc = Location(parseResult.OriginalSource, span);
          def infos = group.MapToArray((info, _) => info);
          def error = ExpectedError(loc, infos);
          result.Add(error);
        }
        result
      }
    }
    
    //public Errors : List[ParseError] { get; default List();}
    public Errors : List[ExpectedError] { get; default List();}
    
    public this()
    {
    }

    public Walk(parseResult : ParseResult) : void
    {
      Walk(parseResult, Context());
      
      foreach (error in Errors)
        parseResult.ReportError(error);
    }

    public override OnRegularCall(ruleInfo : SubruleInfo.RegularCall, startPos : int, endPos : int, parseResult : ParseResult, context : Context) : void
    {
      IgnoreParams();

      when (startPos == endPos && !ruleInfo.CanParseEmptyString)
      {
        context.Inserted.Add((ruleInfo, NSpan(startPos, endPos)));
      }
    }

    public override OnTokenString(ruleInfo : SubruleInfo.TokenString, startPos : int, endPos : int, parseResult : ParseResult, context : Context) : void
    {
      IgnoreParams();

      when (startPos == endPos && !ruleInfo.CanParseEmptyString)
      {
        context.Inserted.Add((ruleInfo, NSpan(startPos, endPos)));
      }
    }

    public override OnSimpleCall(ruleInfo : SubruleInfo.SimpleCall, startPos : int, endPos : int, parseResult : ParseResult, context : Context) : void
    {
      when (startPos == endPos && !ruleInfo.CanParseEmptyString)
      {
        context.Inserted.Add((ruleInfo, NSpan(startPos, endPos)));
      }
      base.OnSimpleCall(ruleInfo, startPos, endPos, parseResult, context);
    }

    public override OnExtensibleCall(ruleInfo : SubruleInfo.ExtensibleCall, startPos : int, endPos : int, parseResult : ParseResult, context : Context) : void
    {
      when (startPos == endPos && !ruleInfo.CanParseEmptyString)
      {
        context.Inserted.Add((ruleInfo, NSpan(startPos, endPos)));
      }
      base.OnExtensibleCall(ruleInfo, startPos, endPos, parseResult, context);
    }

    public override OnOption(ruleInfo : SubruleInfo.Option, startPos : int, endPos : int, parseResult : ParseResult, context : Context) : void
    {
      when (startPos == endPos && !ruleInfo.CanParseEmptyString)
      {
        context.Inserted.Add((ruleInfo, NSpan(startPos, endPos)));
      }
      base.OnOption(ruleInfo, startPos, endPos, parseResult, context);
    }

    public override OnList(ruleInfo : SubruleInfo.List, startPos : int, endPos : int, parseResult : ParseResult, context : Context) : void
    {
      when (startPos == endPos && !ruleInfo.CanParseEmptyString)
      {
        context.Inserted.Add((ruleInfo, NSpan(startPos, endPos)));
      }
      base.OnList(ruleInfo, startPos, endPos, parseResult, context);
    }

    public override OnListWithSeparator(ruleInfo : SubruleInfo.ListWithSeparator, startPos : int, endPos : int, parseResult : ParseResult, context : Context) : void
    {
      when (startPos == endPos && !ruleInfo.CanParseEmptyString)
      {
        context.Inserted.Add((ruleInfo, NSpan(startPos, endPos)));
      }
      base.OnListWithSeparator(ruleInfo, startPos, endPos, parseResult, context);
    }

    public override WalkSimple(startPos : int, endPos : int, ruleParser : SimpleRuleParser, parseResult : ParseResult, context : Context) : void
    {
      when (startPos == endPos && !ruleParser.SequenceInfo.CanParseEmptyString)
      {
        context.Inserted.Add((ruleParser, NSpan(startPos, endPos)));
      }
      base.WalkSimple(startPos, endPos, ruleParser, parseResult, context);
      TryAddErrors(parseResult, context);
    }
    
    public override WalkExtensible(startPos : int, endPos : int, ruleParser : ExtensibleRuleParser, parseResult : ParseResult, context : Context) : void
    {
      base.WalkExtensible(startPos, endPos, ruleParser, parseResult, context);
      TryAddErrors(parseResult, context);
    }

    public override OnListItem(astPtr : int, ruleInfo : SubruleInfo.ListItem, startPos : int, endPos : int, parseResult : ParseResult, context : Context) : void
    {
      when (startPos == endPos && !ruleInfo.CanParseEmptyString)
      {
        context.Inserted.Add((ruleInfo, NSpan(startPos, endPos)));
      }
      base.OnListItem(astPtr, ruleInfo, startPos, endPos, parseResult, context);
    }
    
    public override OnPrefixMissed(ruleParser : ExtensibleRuleParser, pos : int, parseResult : ParseResult, context : Context) : void
    {
      IgnoreParams();
      context.Inserted.Add((ruleParser, NSpan(pos, pos)));
    }
    
    TryAddErrors(parseResult : ParseResult, context : Context) : void
    {
      when (context.Inserted.Count > 0)
      {
        foreach (e in context.GetErrors(parseResult))
          this.Errors.Add(e);
        context.Inserted.Clear();
      }
    }
  }
}
