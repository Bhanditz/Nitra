using Nemerle;
using Nemerle.Assertions;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;

namespace Nitra.ProjectSystem
{
  public sealed class CompilerMessageList : IRootCompilerMessages
  {
    public Kind : Guid { get; private set; }
    private         _messages   : List[CompilerMessageInternal];
    private mutable _isDisposed : bool;

    [Record]
    private struct CompilerMessageInternal
    {
      public Type           : CompilerMessageType   { get; }
      public Kind           : Guid                  { get; }
      public Location       : Location              { get; }
      public Text           : string                { get; }
      public Number         : int                   { get; }
      public NestedMessages : List[CompilerMessageInternal] { get; }

      public ToCompilerMessage() : CompilerMessage
      {
        CompilerMessage(Type, Kind, Location, Text, Number, ToCompilerMessage(NestedMessages))
      }

      public static ToCompilerMessage(messages : List[CompilerMessageInternal]) : list[CompilerMessage]
      {
        mutable result = [];
        when (messages != null)
          for(mutable i = messages.Count - 1; i >= 0; --i)
            result ::= messages[i].ToCompilerMessage();
        result
      }
    }

    public this()
    {
      this(List())
    }

    private this(messages : List[CompilerMessageInternal])
    {
      _messages = messages;
    }

    public GetMessages() : list[CompilerMessage]
    {
      CompilerMessageInternal.ToCompilerMessage(_messages)
    }

    public ReportMessage(messageType : CompilerMessageType, loc : Location, msg : string, num : int) : void
      requires !_isDisposed otherwise throw InvalidOperationException("Object disposed")
    {
      _messages.Add(CompilerMessageInternal(messageType, this.Kind, loc, msg, num, null))
    }

    public ReportRootMessage(messageType : CompilerMessageType, loc : Location, msg : string, num : int) : IRootCompilerMessages
      requires !_isDisposed otherwise throw InvalidOperationException("Object disposed")
    {
      def m = CompilerMessageInternal(messageType, this.Kind, loc, msg, num, List());
      _messages.Add(m);
      CompilerMessageList(m.NestedMessages)
    }

    public SetFutureMessagesKind(kind : Guid) : void { Kind = kind; }
    public Remove(predicate : Func[Guid, Location, bool]) : void
    {
      _ = _messages.RemoveAll(m => predicate(m.Kind, m.Location));
    }
    
    public Clear() : void
    {
      _messages.Clear();
    }
    
    public Dispose() : void
    {
      _isDisposed = true;
    }
  }
}
