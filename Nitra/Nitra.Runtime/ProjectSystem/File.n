using Nitra.Declarations;

using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;

namespace Nitra.ProjectSystem
{
  public abstract class File
  {
    public abstract Project     : Project { get; }
    public abstract Length      : int     { get; }
    public abstract FullName    : string  { get; }

    public abstract GetSource() : SourceSnapshot;

    public virtual EvalProperties(context : DependentPropertyEvalContext, compilerMessages : ICompilerMessages) : void
    {
      IgnoreParams();
    }

    public override ToString() : string { FullName }
  }

  public abstract class ConcreteFile[TAst] : File
    where TAst: IAst
  {
            _ruleDescriptor   : StartRuleDescriptor;
            _compositeGrammar : CompositeGrammar;
    mutable _parseResult      : IParseResult;
    mutable _astRoot          : AstRoot[TAst];
    mutable _parseTree        : IMappedParseTree[TAst];

    protected this(ruleDescriptor : StartRuleDescriptor, compositeGrammar : CompositeGrammar = null)
    {
      _ruleDescriptor   = ruleDescriptor;
      _compositeGrammar = compositeGrammar;
    }

    public virtual Ast        : TAst
    {
      get
      {
        when (_astRoot == null)
          UpdateAst();
        _astRoot.Content
      }
    }

    public virtual ParseTree : IMappedParseTree[TAst]
    {
      get
      {
        when (_parseTree == null)
          UpdateParseTree();
        _parseTree
      }
    }

    public virtual ResetCache() : void
    {
      _astRoot     = null;
      _parseTree   = null;
      _parseResult = null;
    }

    public override EvalProperties(context : DependentPropertyEvalContext, compilerMessages : ICompilerMessages) : void
    {
      when (_astRoot == null)
        UpdateAst();
      _astRoot.EvalProperties(context, compilerMessages);
    }

    protected virtual GetParseSession() : ParseSession
    {
      ParseSession(_ruleDescriptor, _compositeGrammar);
    }

    public virtual ReParse() : void
    {
      assert3(Project != null);
      
      def parseSession = GetParseSession();
      def parseResult  = parseSession.Parse(GetSource());
      def project      = Project;
      _parseResult     = parseResult;

      foreach(error in parseResult.GetErrors())
        project.Error(error.Location, error.Message);
    }

    public virtual UpdateParseTree() : void
    {
      when (_parseResult == null)
        ReParse();
      _parseTree = _parseResult.CreateParseTree() :> IMappedParseTree[TAst];
    }

    public virtual UpdateAst() : void
    {
      assert3(Project != null);
      
      when (_parseResult == null)
        ReParse();
        
      when (_parseTree == null)
        UpdateParseTree();
      
      _astRoot = AstRoot[TAst].Create(this, _parseTree, Project);
    }
  }
}
