using Nitra.Declarations;
using Nitra.ProjectSystem;
using Nitra.Internal;

using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;

namespace Nitra.Runtime.Binding
{
  public delegate ResolutionAlgorithm[TSymbol, TConcreteSymbol](candidate : TSymbol) : ValueOption[TConcreteSymbol]
    where TSymbol         : ISymbol2
    where TConcreteSymbol : ISymbol2;

  public module ResolutionAlgorithms[TSymbol, TConcreteSymbol]
    where TSymbol         : ISymbol2
    where TConcreteSymbol : ISymbol2
  {
    public static TryCast : ResolutionAlgorithm[TSymbol, TConcreteSymbol] = TryCastImpl;

    private static TryCastImpl(candidate : TSymbol) : ValueOption[TConcreteSymbol]
    {
      | symbol is TConcreteSymbol => VSome(symbol)
      | _ => VNone()
    }
  }

  [Record]
  public variant Ref[TSymbol] : IRef
    where TSymbol : ISymbol2
  {
    public abstract Name        : string { get; }
    public abstract IsNameValid : bool   { get; }
    public abstract FullName    : string { get; }
    public abstract Kind        : string { get; }
    public abstract SpanClass   : string { get; }
    public abstract File        : File   { get; }
    public abstract Span        : NSpan  { get; }

    IsAmbiguous : bool  implements IAst.IsAmbiguous { get { false } }
    IsMissing   : bool  implements IAst.IsMissing   { get { false } }

    public IsAllPropertiesEvaluated : bool  { get { true } }
    public PropertiesEvalState      : int   { get { 0 } }

    [PropertyAttribute("Nitra.Runtime.Binding.IRef.Symbol", 0, false, true)]
    public abstract Symbol            : TSymbol { get; }
    public abstract IsSymbolEvaluated : bool    { get; }

    SymbolImpl : ISymbol2 implements IRef.Symbol
    {
      get { Symbol }
      set { _ = value; assert(false) }
    }

    Accept(visitor : Nitra.Declarations.IAstVisitor) : void implements IAst.Accept { _ = visitor; }
    public EvalProperties(context : DependentPropertyEvalContext) : void { _ = context; }
    public ResetProperties() : void { }

    public abstract TryResolve[TConcreteSymbol](reference : Reference, algorithm : ResolutionAlgorithm[TSymbol, TConcreteSymbol] = null) : Ref[TConcreteSymbol]
      where TConcreteSymbol : ISymbol2;

    public Resolve[TConcreteSymbol](reference : Reference, algorithm : ResolutionAlgorithm[TSymbol, TConcreteSymbol] = null) : Ref[TConcreteSymbol]
      where TConcreteSymbol : ISymbol2
    {
      def r = TryResolve(reference, algorithm);
      SymbolUtils.ReportError(r);
      r
    }

    public          ToXaml()   : string { Name + " <Span Foreground='blue'>" + Kind + "</Span>" }
    public override ToString() : string { Name + " (" + Kind + ")" }
    public abstract GetSymbols() : Seq[ISymbol2];

    | Some
      {
        public override Name        : string { get { Symbol.Name } }
        public override IsNameValid : bool   { get { Symbol.IsNameValid } }
        public override FullName    : string { get { Symbol.FullName } }
        public override Kind        : string { get { Symbol.Kind } }
        public override SpanClass   : string { get { Symbol.SpanClass } }
        public override File        : File   { get; }
        public override Span        : NSpan  { get; }

        [PropertyAttribute("Nitra.Runtime.Binding.IRef.Symbol", 0, false, true)]
        public override Symbol            : TSymbol { get; }
        public override IsSymbolEvaluated : bool    { get { true } }

        public override TryResolve[TConcreteSymbol](reference : Reference, algorithm : ResolutionAlgorithm[TSymbol, TConcreteSymbol] = null) : Ref[TConcreteSymbol]
        {
          def algorithm = algorithm ?? ResolutionAlgorithms.TryCast;

          match (algorithm(Symbol))
          {
            | VSome(symbol) => Ref.Some(reference.File, reference.Span, symbol)
            | VNone         => Ref.Unresolved(reference)
          }
        }

        public override GetSymbols() : Seq[ISymbol2] { [Symbol] }
        public override GetHashCode() : int { Symbol.GetHashCode() }
        public override Equals(other : object) : bool
        {
          | other is Some => this.Symbol.Equals(other.Symbol)
          | _ => false
        }
      }

    | Unresolved
      {
        public Reference : Reference { get; }

        public override Name        : string { get { Reference.Text } }
        public override IsNameValid : bool   { get { true } }
        public override FullName    : string { get { Reference.Text } }
        public override Kind        : string { get { "unresolved" } }
        public override SpanClass   : string { get { "Error" } }
        public override File        : File   { get { Reference.File } }
        public override Span        : NSpan  { get { Reference.Span } }

        [PropertyAttribute("Nitra.Runtime.Binding.IRef.Symbol", 0, false, true)]
        public override Symbol            : TSymbol { get { assert(false, "Ref is unresolved.") } }
        public override IsSymbolEvaluated : bool    { get { false } }

        public override TryResolve[TConcreteSymbol](reference : Reference, algorithm : ResolutionAlgorithm[TSymbol, TConcreteSymbol] = null) : Ref[TConcreteSymbol]
        {
          _ = algorithm;
          Ref.Unresolved(reference)
        }

        public override GetSymbols() : Seq[ISymbol2] { Enumerable.Empty() }
        public override GetHashCode() : int { Reference.GetHashCode() }
        public override Equals(other : object) : bool
        {
          | other is Unresolved => this.Reference.Equals(other.Reference)
          | _ => false
        }
      }

    | Ambiguous
      {
        public override File        : File          { get; }
        public override Span        : NSpan         { get; }
        public          Ambiguities : list[TSymbol] { get; }

        public override Name        : string { get { Ambiguities.Head.Name } }
        public override IsNameValid : bool   { get { Ambiguities.Head.IsNameValid } }
        public override FullName    : string { get { Ambiguities.Head.FullName } }
        public override Kind        : string { get { "ambiguous" } }
        public override SpanClass   : string { get { "Error" } }

        [PropertyAttribute("Nitra.Runtime.Binding.IRef.Symbol", 0, false, true)]
        public override Symbol            : TSymbol          { get { assert(false, "Ref is ambiguous.") } }
        public override IsSymbolEvaluated : bool             { get { false } }
        public          AllDeclarations   : Seq[Declaration] { get { Ambiguities.SelectMany(_.Declarations) } }

        public override TryResolve[TConcreteSymbol](reference : Reference, algorithm : ResolutionAlgorithm[TSymbol, TConcreteSymbol] = null) : Ref[TConcreteSymbol]
        {
          def algorithm = algorithm ?? ResolutionAlgorithms.TryCast;

          def results = LightList.[TConcreteSymbol]();
          foreach (s in Ambiguities)
            when (algorithm(s) is VSome(symbol))
              results.Add(symbol);

          match (results.Count)
          {
            | 0 => Ref.Unresolved(reference)
            | 1 => Ref.Some(reference.File, reference.Span, results.FirstItem)
            | _ => Ref.Ambiguous(reference.File, reference.Span, results.ToNList())
          }
        }

        public override GetSymbols() : Seq[ISymbol2] { Ambiguities }
        public override ToString() : string { $<#$Kind: ..$(Ambiguities; " "; _.FullName)#> }
        public override GetHashCode() : int { Ambiguities.GetHashCode() }
        public override Equals(other : object) : bool
        {
          | other is Ambiguous => this.Ambiguities.Equals(other.Ambiguities)
          | _ => false
        }
      }
  }
}
