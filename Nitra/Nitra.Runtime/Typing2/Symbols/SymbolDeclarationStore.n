using Nemerle;
using Nemerle.Assertions;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Text;

namespace Nitra.Runtime.Binding
{
  public struct SymbolDeclarationStore
  {
    public this(name : string)
    {
      this(StringIndex.GetId(name), null)
    }

    private this(nameId : int, store : object)
    {
      _nameId = nameId;
      _store  = store;
    }

    private _nameId : int;
    private _store  : object;

    public IsNameValid : bool   { get { _nameId > 0 } }
    public Name        : string { get { if (_nameId > 0) StringIndex.GetText(_nameId) else "<invalid name>" } }
    public InitialName : string { get { if (_nameId < 0) StringIndex.GetText(~_nameId) else Name } }

    public AddDeclaration([NotNull] newDeclaration : Declaration) : SymbolDeclarationStore
    {
      def newNameId =
      {
        def newId = newDeclaration.Name.Id;

        if (_nameId == newId) _nameId
        else if (_nameId == 0) newId
        else if (_nameId < 0) _nameId
        else ~_nameId
      };

      match (_store)
      {
        | null                     => SymbolDeclarationStore(newNameId, newDeclaration)
        | d is Declaration         => SymbolDeclarationStore(newNameId, [newDeclaration, d])
        | lst is list[Declaration] => SymbolDeclarationStore(newNameId, newDeclaration :: lst)
        | _ => assert(false, $"Unable to add declaration '$newDeclaration' to symbol declaration store")
      }
    }

    public GetDeclarationsUntyped() : Seq[Declaration]
    {
      match (_store)
      {
        | d   is Declaration       => [d]
        | lst is list[Declaration] => lst
        | _                        => []
      }
    }

    public GetDeclarations[TDeclaration]() : Seq[TDeclaration]
      where TDeclaration : Declaration
    {
      match (_store)
      {
        | d is TDeclaration => yield d;
        | lst is list[Declaration] =>
          foreach (d is TDeclaration in lst)
            yield d;

        | _ => ()
      }
    }

    public override ToString() : string
    {
      def buffer = StringBuilder().Append(Name);
      unless (IsNameValid)
        _ = buffer.Append(" (").Append(InitialName).Append(')');
      _ = buffer.Append(": ");
      if (_store == null)
        _ = buffer.Append("<no declarations>");
      else
        _ = buffer.Append(_store);
      buffer.ToString();
    }
  }
}
