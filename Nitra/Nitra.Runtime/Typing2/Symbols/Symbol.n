using Nitra.Declarations;

using Nemerle;
using Nemerle.Collections;
using Nemerle.Imperative;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;

using SCG = System.Collections.Generic;
// TODO: rename Symbol2 to Symbol and remove follow line
using Symbol  = Nitra.Runtime.Binding.Symbol2;
using ISymbol = Nitra.Runtime.Binding.ISymbol2;

namespace Nitra.Runtime.Binding
{
  public abstract class Symbol2 : ISymbol2
  {
    private static mutable _next : int = 0;

    protected this()
    {
      Id            = Interlocked.Increment(ref _next);
      _declarations = [];
    }

    public         Id               : int                { get; }
    public virtual Name             : string             { get { if (_isNameValid) Declarations.Head.Name.Text else "<invalid name>" } }
    public virtual IsNameValid      : bool               { get { _isNameValid } }
    public         Declarations     : list[Declaration]  { get { _declarations } }
    public virtual FullName         : string             { get { Name } }
    public virtual Kind             : string             { get { "something" } }
    public virtual SpanClass        : string             { get { "Default" } }
    public virtual IsResolved       : bool               { get { true } }
    public virtual ResolutionResult : ISymbol            { get { this } }
    public virtual Scope            : Scope              { get { Scope.Nil() } }

    private mutable _isNameValid  : bool;
    private mutable _declarations : list[Declaration];

    internal SetDeclarations(newDeclarations : list[Declaration]) : void
    {
      assert(newDeclarations : object != null);

      def validateName(nameId : int, decls : list[Declaration]) : bool
      {
        match (decls)
        {
          | [] => true
          | f :: other => nameId == f.Name.Id && validateName(nameId, other)
        }
      }

      _isNameValid  = if (newDeclarations is f :: other) validateName(f.Name.Id, other) else false;
      _declarations = newDeclarations;
    }

    public virtual IsMergeKeyEquals(candidate : Declaration) : bool
    {
      _ = candidate;
      false
    }

    public virtual MergeCondition(candidate : Declaration) : bool
    {
      _ = candidate;
      true
    }

    public virtual TryResolve(reference : Reference, algorithm : Func[IAmbiguousSymbol, Seq[ISymbol]]) : ISymbol
    {
      IgnoreParams();
      this
    }

    public Resolve(reference : Reference, algorithm : Func[IAmbiguousSymbol, Seq[ISymbol]]) : ISymbol
    {
      def sym = TryResolve(reference, algorithm);
      SymbolUtils.ReportError(reference, sym);
      sym
    }

    public virtual AfterStage (stage : int) : void { _ = stage; }

    public virtual ToXaml() : string { Name + " <Span Foreground = 'blue'>" + Kind + "</Span>" }

    public override ToString() : string { Name + " (" + Kind + ")" }

    public EvalProperties(context : DependentPropertyEvalContext) : void
    {
      _ = context;
    }

    public IsPropertyEvaluated(index : int) : bool
    {
      _ = index;
      false
    }

    public ResetProperties() : void {}

    public IsAllPropertiesEvaluated : bool { get { false } }

    #region Equality
    
    public static @==(x : Symbol, y : Symbol) : bool { x : object == y }
    public static @!=(x : Symbol, y : Symbol) : bool { x : object != y }

    [OverrideObjectEquals]
    public Equals(other : ISymbol2) : bool
      implements IEquatable[ISymbol2].Equals
    {
      other : object == this
    }

    public override GetHashCode() : int { Id }

    #endregion
  }
}
