using Nitra.Declarations;

using Nemerle;
using Nemerle.Collections;
using Nemerle.Imperative;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;

using SCG = System.Collections.Generic;
// TODO: rename Symbol2 to Symbol and remove follow line
using Symbol  = Nitra.Runtime.Binding.Symbol2;
using ISymbol = Nitra.Runtime.Binding.ISymbol2;

namespace Nitra.Runtime.Binding
{
  public module SymbolUtils
  {
    public static ReportError[TSymbol](r : Ref[TSymbol]) : void
      where TSymbol : ISymbol
    {
      match (r)
      {
        | Unresolved as us => AstContext.CompilerMessages.Error(us.Reference, $<#Unbound name '$(us.Reference.Text)'.#>);
        | Ambiguous as sym =>
          def e = sym.AllDeclarations.GetEnumerator();
          if (e.MoveNext())
          {
            def firstName = e.Current.Name;
            using (err = AstContext.CompilerMessages.RootError(firstName, $<#Symbol '$(firstName)' is ambiguous.#>))
            {
              while (e.MoveNext())
              {
                def otherName = e.Current.Name;
                err.Hint(otherName, <#Declaration#>);
              }
            }
          }
          else
            assert(false, "Ambiguous symbol without declarations detected!");

        | Some => ()
      }
    }

    public static ReportError[TSymbol](reference : IAst, r : Ref[TSymbol]) : void
      where TSymbol : ISymbol
    {
      match (r)
      {
        | Unresolved => AstContext.CompilerMessages.Error(reference, $<#Unbound name '$reference'.#>);
        | Ambiguous as sym =>
          using (err = AstContext.CompilerMessages.RootError(reference, $<#Symbol '$reference' is ambiguous.#>))
            foreach (a in sym.Ambiguities with i)
              foreach (d when d.Span != reference.Span && d.File : object != reference.File in a.Declarations)
                err.Hint(d, $<#Declaration $i#>);

        | Some => ()
      }
    }

    public static GetSymbolName[TDeclaration](isNameValid : bool, declarations : list[TDeclaration]) : string
      where TDeclaration : Declaration
    {
      if (isNameValid)
        declarations.Head.Name.Text
      else
        "<invalid name>"
    }

    public static AddDeclaration[TDeclaration](newDeclaration : TDeclaration, isNameValid : ref bool, declarations : ref list[TDeclaration]) : void
      where TDeclaration : Declaration
    {
      assert(newDeclaration : object != null);

      match (declarations)
      {
        | [] => isNameValid = true;
        | f :: _ when isNameValid => isNameValid = f.Name.Id == newDeclaration.Name.Id
        | _ => ()
      }

      declarations ::= newDeclaration;
    }
  }
}
