using Nitra.Declarations;

using Nemerle;
using Nemerle.Collections;
using Nemerle.Imperative;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;

// TODO: rename Symbol2 to Symbol and remove follow line
using Symbol = Nitra.Runtime.Binding.Symbol2;
using ISymbol = Nitra.Runtime.Binding.ISymbol2;

namespace Nitra.Runtime.Binding
{
  public class TableScope : Scope
  {
    public this(owner : string)
    {
      _owner = owner;
      _nameTable = Hashtable();
    }

    private _owner : string;
    private _nameTable : Hashtable[int, Ref[ISymbol]];

    public Symbols : Hashtable[int, Ref[ISymbol]].ValueCollection { get { _nameTable.Values } }

    public Define[TSymbol](declaration : Declaration, context : DependentPropertyEvalContext) : TSymbol
      where TSymbol : ISymbol
    {
      def     name             = declaration.Name;
      def     candidateSymbols = LightList();
      mutable ambiguousSymbols : HashSet[ISymbol2];

      // пробуем смерджить
      match (this.TryGetSymbol(name))
      {
        | null => () // это первое объявление символа с таким именем в этом scope-е
        | Unresolved => assert(false)
        | Ambiguous as sym =>
          ambiguousSymbols = HashSet(sym.Ambiguities);
          foreach (symbol is TSymbol in sym.Ambiguities)
          {
            when (symbol.CanMerge(declaration))
              candidateSymbols.Add(symbol);
          }

        | Some as r =>
          ambiguousSymbols = HashSet();
          _ = ambiguousSymbols.Add(r.Symbol);

          match (r.Symbol)
          {
            | symbol is TSymbol =>
              when (symbol.CanMerge(declaration))
                candidateSymbols.Add(symbol);

            | _ => ()
          }
      }

      def concreteSymbol =
        match (candidateSymbols.Count)
        {
          | 0 => declaration.CreateSymbol() :> TSymbol;
          | 1 => candidateSymbols[0] // merge
          | _ => assert(false)
        };

      if (ambiguousSymbols : object == null)
        _nameTable.Add(name.Id, Ref.Some(concreteSymbol));
      else when (ambiguousSymbols.Add(concreteSymbol))
      {
        // фильтруем без учета конкретного типа
        def realAmbiguousSymbols = ambiguousSymbols.FilterToArray(s => !concreteSymbol.Equals(s) && s.IsSameIdentity(declaration));
        when (realAmbiguousSymbols.Length > 0)
        {
          def cm = AstContext.CompilerMessages;
          using (nested = cm.RootError(name, $"Redefinition of '$name'"))
            foreach (ambiguous in realAmbiguousSymbols)
              foreach (d in ambiguous.Declarations)
                nested.Hint(d.Name, "previous definition.");
        }
        _nameTable[name.Id] = Ref.Ambiguous(ambiguousSymbols.NToList());
      }

      (concreteSymbol :> DeclaredSymbol).AddDeclaration(declaration);
      when (candidateSymbols.Count == 0)
        concreteSymbol.EvalProperties(context); // initialize symbol default values

      assert(!name.IsSymbolEvaluated);
      name.Symbol = concreteSymbol;

      concreteSymbol
    }

    internal TryGetSymbol(name : Name) : Ref[ISymbol]
    {
      mutable old;
      when (_nameTable.TryGetValue(name.Id, out old))
        return old;

      null
    }

    internal TryGetSymbol(name : Reference) : Ref[ISymbol]
    {
      mutable old;
      when (_nameTable.TryGetValue(name.Id, out old))
        return old;

      null
    }

    public override BindMany[TSymbol](reference : Reference, results : ref LightList[TSymbol]) : void
    {
      match (TryGetSymbol(reference))
      {
        | null => ()
        | Unresolved => assert(false)
        | Some as sym =>
          match (sym.Symbol)
          {
            | result is TSymbol => results.Add(result);
            | _ => ()
          }

        | Ambiguous as sym =>
          foreach (result is TSymbol in sym.Ambiguities)
            results.Add(result);
      }
    }

    public override MakeCompletionList(prefix : string) : Seq[ISymbol]
    {
      if (string.IsNullOrEmpty(prefix))
        Symbols.SelectMany(s => s.GetSymbols())
      else
        Symbols.Where(s => s.Name.StartsWith(prefix, StringComparison.InvariantCultureIgnoreCase)).SelectMany(s => s.GetSymbols())
    }

    public override ToString() : string
    {
      $<#$_owner[..$(_nameTable.Keys; ", "; StringIndex.GetText)]#>
    }
  }
}
