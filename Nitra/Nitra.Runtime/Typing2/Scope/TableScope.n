using Nitra.Declarations;
using Nitra.ProjectSystem;
using Nitra.Serialization2;

using Nemerle;
using Nemerle.Collections;
using Nemerle.Imperative;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.IO;
using System.Collections.Generic;
using System.Linq;

namespace Nitra.Runtime.Binding
{
  public class TableScope : Scope
  {
    public this(owner : string)
    {
      _owner = owner;
      _nameTable = Hashtable();
    }

    private mutable _owner : string;
    private _nameTable : Hashtable[int, list[DeclarationSymbol]]; //TODO: replace with LightList[DeclarationSymbol]?

    public Symbols : Hashtable[int, list[DeclarationSymbol]].ValueCollection { get { _nameTable.Values } }

    public Define[TSymbol](declaration : Declaration, context : DependentPropertyEvalContext, name : Name = null) : TSymbol
      where TSymbol : DeclarationSymbol
    {
      when (name != null)
        (declaration :> DeclarationBase).UpdateName(name);
        
      def     name2            = declaration.Name;
      def     candidateSymbols = LightList();
      mutable ambiguousSymbols : HashSet[DeclarationSymbol];

      mutable lookupResult;
      when (_nameTable.TryGetValue(name2.Id, out lookupResult))
      {
        ambiguousSymbols = HashSet(lookupResult);
        foreach (symbol is TSymbol when symbol.CanMerge(declaration) in lookupResult)
          candidateSymbols.Add(symbol);
      }

      def concreteSymbol =
        match (candidateSymbols.Count)
        {
          | 0 => declaration.CreateSymbol() :> TSymbol;
          | 1 => candidateSymbols[0] // merge
          | _ => assert(false)
        };

      if (ambiguousSymbols : object == null)
        _nameTable.Add(name2.Id, [concreteSymbol]);
      else when (ambiguousSymbols.Add(concreteSymbol))
      {
        // фильтруем без учета конкретного типа
        def realAmbiguousSymbols = ambiguousSymbols.FilterToArray(s => !concreteSymbol.Equals(s) && s.IsSameIdentity(declaration));
        when (realAmbiguousSymbols.Length > 0)
        {
          def cm = AstContext.CompilerMessages;
          using (nested = cm.RootError(name2, $"Redefinition of '$name2'"))
            foreach (ambiguous in realAmbiguousSymbols)
              foreach (d in ambiguous.Declarations)
                nested.Hint(d.Name, "previous definition.");
        }
        _nameTable[name2.Id] = ambiguousSymbols.NToList();
      }

      concreteSymbol.AddDeclaration(declaration);
      when (candidateSymbols.Count == 0)
        concreteSymbol.EvalProperties(context); // initialize symbol default values

      assert(!name2.IsSymbolEvaluated);
      name2.Symbol = concreteSymbol;

      concreteSymbol
    }

    public override FindMany[TSymbol](predicate : Predicate[TSymbol], results : ref LightList[TSymbol]) : void
    {
      foreach (symbols in _nameTable.Values)
        foreach (symbol is TSymbol when predicate(symbol) in symbols)
          results.Add(symbol);
    }

    public override BindMany[TSymbol](reference : Reference, results : ref LightList[TSymbol]) : void
    {
      mutable lookupResult;
      when (_nameTable.TryGetValue(reference.Id, out lookupResult))
      {
        foreach (result is TSymbol in lookupResult)
          results.Add(result);
      }
    }
    
    public override MakeCompletionList(prefix : string) : Seq[DeclarationSymbol]
    {
      if (string.IsNullOrEmpty(prefix))
        _nameTable.Values.SelectMany(s => s)
      else
        _nameTable.Where(pair => StringIndex.GetText(pair.Key).StartsWith(prefix, StringComparison.InvariantCultureIgnoreCase)).SelectMany(pair => pair.Value)
    }

    public override ToString() : string
    {
      $<#$_owner[..$(_nameTable.Keys; ", "; StringIndex.GetText)]#>
    }

    public override Serialize(writer : BinaryWriter, metadataWriter : MetadataWriter) : void
    {
      when (metadataWriter.BeginWriteObject(this, writer))
      {
        writer.Write(_owner : string);
        writer.Write(_nameTable.Count : int);
        foreach (pair in _nameTable)
        {
          writer.Write(StringIndex.GetText(pair.Key) : string);
          metadataWriter.WriteObjects(pair.Value, writer);
        }
      }
    }

    public static Deserialize(reader : BinaryReader, metadataReader : MetadataReader) : this
    {
      mutable scope;
      when (metadataReader.BeginReadObject(reader, out scope, _tableScopeFactory))
      {
        scope._owner = reader.ReadString();

        def nameCount = reader.ReadInt32();
        for (mutable i = 0; i < nameCount; ++i)
        {
          def name    = reader.ReadString();
          def symbols = metadataReader.ReadObjects(reader);
          scope._nameTable.Add(StringIndex.GetId(name), symbols.ToNList());
        }
      }
      scope
    }

    private static _tableScopeFactory : Func[TableScope] = fun() { TableScope("") };
  }
}
