using Nitra.Declarations;
using Nitra.Serialization2;

using Nemerle;
using Nemerle.Collections;
using Nemerle.Imperative;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.IO;
using System.Collections.Generic;
using System.Linq;

namespace Nitra.Runtime.Binding
{
  [Record]
  public sealed class FilteringScope : Scope
  {
    public Scope     : Scope                         { get; }
    public Predicate : Func[DeclarationSymbol, bool] { get; }

    public override FindMany[TSymbol](predicate : Predicate[TSymbol], results : ref LightList[TSymbol]) : void
    {
      this.Scope.FindMany(fun(symbol : TSymbol) { Predicate.Invoke(symbol) && predicate(symbol) }, ref results);
    }

    public override BindMany[TSymbol](reference : Reference, results : ref LightList[TSymbol]) : void
    {
      mutable notFilteredResults = LightList();
      Scope.BindMany(reference, ref notFilteredResults);

      // 'foreach' causes invalid IL
      def e = notFilteredResults.GetEnumerator();
      while (e.MoveNext())
        when (Predicate.Invoke(e.Current))
          results.Add(e.Current);
    }

    public override MakeCompletionList(prefix : string) : Seq[DeclarationSymbol]
    {
      Scope.MakeCompletionList(prefix).Where(Predicate)
    }

    public override ToString() : string
    {
      "Filter"
    }

    public override Serialize(writer : BinaryWriter, metadataWriter : MetadataWriter) : void
    {
      IgnoreParams();
      assert(false);
    }

    public static Deserialize(reader : BinaryReader, metadataReader : MetadataReader) : this
    {
      IgnoreParams();
      assert(false);
    }
  }
}
