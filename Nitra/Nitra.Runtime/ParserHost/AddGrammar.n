using Nitra.Runtime.Reflection;

using Nemerle;
using Nemerle.Assertions;
using Nemerle.Imperative;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nitra.Internal;
using Nitra.Runtime;

using System;
using System.Collections.Concurrent;

namespace Nitra
{
  public partial sealed class ParserHost
  {
    private _grammarSetCache   : ConcurrentDictionary[ulong,                  CompositeGrammar] = ConcurrentDictionary();
    private _compositeGrammars : ConcurrentDictionary[Set[GrammarDescriptor], CompositeGrammar] = ConcurrentDictionary();

    private mutable volatile _allRules : array[object] = array(1);//Root recovery stack frame id.

    public MakeCompositeGrammar(grammarDescriptors : Seq[GrammarDescriptor]) : CompositeGrammar
    {
      mutable res;

      def parent   = DefaultCompositeGrammar;
      def grammars = MakeGrammarDescriptorClosure(parent.Grammars, grammarDescriptors);
      when (_compositeGrammars.TryGetValue(grammars, out res))
        return res;

      lock (_syncRoot)
        grammarDescriptors.Fold(parent, (grammarDescriptor, acc) => AddGrammar(acc, grammarDescriptor))
    }

    public MakeCompositeGrammar(grammarDescriptor : GrammarDescriptor) : CompositeGrammar
    {
      AddGrammar(DefaultCompositeGrammar, grammarDescriptor)
    }

    internal AddGrammar(parent : CompositeGrammar, grammarDescriptor : GrammarDescriptor) : CompositeGrammar
      requires object.ReferenceEquals(parent.ParserHost, this)
    {
      if (parent.Grammars.Contains(grammarDescriptor))
        parent
      else
      {
        mutable res;
        def key = MakeKey(parent, grammarDescriptor);

        when (_grammarSetCache.TryGetValue(key, out res))
          return res;

        def grammars = MakeGrammarDescriptorClosure(parent.Grammars, grammarDescriptor);
        when (_compositeGrammars.TryGetValue(grammars, out res))
        {
          _grammarSetCache[key] = res;
          return res;
        }

        lock (_syncRoot)
        {
          unless (_grammarSetCache.TryGetValue(key, out res))
          {
            unless (_compositeGrammars.TryGetValue(grammars, out res))
            {
              def oldAllRules   = _allRules;
              def ruleIdBuilder = RuleIdBuilder(oldAllRules);
              def newGrammar    = CompositeGrammar(this, grammars, ruleIdBuilder);
              try
              {
                _allRules                    = ruleIdBuilder.GetParsers();
                _compositeGrammars[grammars] = newGrammar;
              }
              catch
              {
                | _ =>
                  _allRules = oldAllRules;
                  throw;
              }
              res = newGrammar
            }
            _grammarSetCache[key] = res;
          }
          res
        }
      }
    }

    private static MakeKey(compisiteGrammar : CompositeGrammar, grammarDescriptor : GrammarDescriptor) : ulong
    {
      unchecked
      {
        ((compisiteGrammar.RuntimeId :> ulong) << 32) | (grammarDescriptor.RuntimeId :> ulong)
      }
    }

    private static MakeGrammarDescriptorClosure(mutable grammars : Set[GrammarDescriptor], descriptors : Seq[GrammarDescriptor]) : Set[GrammarDescriptor]
    {
      foreach (descriptor in descriptors)
        grammars = MakeGrammarDescriptorClosure(grammars, descriptor);
      grammars
    }

    private static MakeGrammarDescriptorClosure(mutable grammars : Set[GrammarDescriptor], descriptor : GrammarDescriptor) : Set[GrammarDescriptor]
    {
      unless (grammars.Contains(descriptor))
      {
        grammars = grammars.Add(descriptor);
        grammars = MakeGrammarDescriptorClosure(grammars, descriptor.Dependencies)
      }
      grammars
    }
  }
}
