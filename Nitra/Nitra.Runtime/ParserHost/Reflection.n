using Nitra.Internal;
using Nitra.Internal.Recovery;
using Nitra.Runtime;
using Nitra.Runtime.Reflection;

using Nemerle;
using Nemerle.Assertions;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.ObjectModel;

using SCG = System.Collections.Generic;

namespace Nitra
{
  public partial sealed class ParserHost
  {
    public Reflection(parseResult : ParseResult, pos : int) : ReadOnlyCollection[RuleApplication]
    {
      def allRules = _allRules;
      def res      = SCG.List();
      for (mutable rawTreePtr = parseResult.memoize[pos]; rawTreePtr > 0; rawTreePtr = parseResult.rawTree[rawTreePtr + 1])
      {
        def ruleId = parseResult.rawTree[rawTreePtr];
        match (allRules[ruleId])
        {
          | _                        is SimpleRuleParser         =>                                      res.Add(RuleApplication(parseResult, pos, rawTreePtr))
          | ruleParser               is ExtensionRuleParser      => assert(ruleId != ruleParser.RuleId); res.Add(RuleApplication(parseResult, pos, rawTreePtr))
          | extensibleRuleParserData is ExtensibleRuleParserData => Reflection(extensibleRuleParserData, parseResult, pos, rawTreePtr, allRules, res)
          | _ => assert(false)
        }
      }

      ReadOnlyCollection(res.ToArray())
    }

    private static Reflection(extensibleRuleParserData : ExtensibleRuleParserData, parseResult : ParseResult, pos : int, mutable rawTreePtr : int, allRules : array[object], res : SCG.List[RuleApplication]) : void
    {
      def ruleId = parseResult.rawTree[rawTreePtr];
      if (ruleId == extensibleRuleParserData.PrefixId)
      {
        rawTreePtr = parseResult.rawTree[rawTreePtr + ExtensibleRuleParser.PrefixOfs.List];
        for (; rawTreePtr > 0; rawTreePtr = parseResult.rawTree[rawTreePtr + 1])
        {
          def ruleId = parseResult.rawTree[rawTreePtr] & ExtensibleRuleParser.RawTreeMask.Id;
          if (allRules[ruleId] is ExtensionRuleParser)
            res.Add(RuleApplication(parseResult, pos, rawTreePtr))
          else
            assert(false)
        }
      }
      else if (ruleId == extensibleRuleParserData.PostfixId)
      {
        rawTreePtr = parseResult.rawTree[rawTreePtr + ExtensibleRuleParser.PostfixOfs.List];
        for (; rawTreePtr > 0; rawTreePtr = parseResult.rawTree[rawTreePtr + 1])
        {
          def ruleId = parseResult.rawTree[rawTreePtr] & ExtensibleRuleParser.RawTreeMask.Id;
          if (allRules[ruleId] is ExtensionRuleParser)
            res.Add(RuleApplication(parseResult, pos, rawTreePtr))
          else
            assert(false)
        }
      }
      else
        assert(false);
    }
  }
}
