using Nitra.Internal;
using Nitra.Internal.Recovery;
using Nitra.Runtime;
using Nitra.Runtime.Errors;

using Nemerle;
using Nemerle.Assertions;
using Nemerle.Collections;
using Nemerle.Imperative;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Linq;
using System.Threading;

using SCG = System.Collections.Generic;

namespace Nitra
{
  public partial class ParserHost
  {
    [Obsolete("Use ParseResult")]
    public DoParsing(source : SourceSnapshot, descriptor : StartRuleDescriptor, parseToEndOfString : bool = true) : ParseResult
    {
      DoParsing(source, AddGrammar(DefaultCompositeGrammar, descriptor.Grammar), descriptor, parseToEndOfString);
    }

    [Obsolete("Use ParseResult")]
    public DoParsing(source : SourceSnapshot, grammar : CompositeGrammar, descriptor : StartRuleDescriptor, parseToEndOfString : bool = true) : ParseResult
    {
      def parseResult = ParseResult(source, grammar, descriptor);
      parseResult.CancellationToken = VNone();
      parseResult.ParseToEndOfString = parseToEndOfString;
      parseResult.Parse();
      parseResult;
    }

    [Obsolete("Use ParseResult")]
    public DoParsing(source : SourceSnapshot, descriptor : StartRuleDescriptor, token : CancellationToken, parseToEndOfString : bool = true) : ParseResult
    {
      DoParsing(source, AddGrammar(DefaultCompositeGrammar, descriptor.Grammar), descriptor, token, parseToEndOfString);
    }

    [Obsolete("Use ParseResult")]
    public DoParsing(source : SourceSnapshot, grammar : CompositeGrammar, descriptor : StartRuleDescriptor, token : CancellationToken, parseToEndOfString : bool = true) : ParseResult
    {
      def parseResult = ParseResult(source, grammar, descriptor);
      parseResult.CancellationToken = VSome(token);
      parseResult.ParseToEndOfString = parseToEndOfString;
      parseResult.Parse();
      parseResult;
    }
  }
}
