using Nitra.Internal;
using Nitra.Runtime;

using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Imperative;

using System;
using System.Collections.Generic;
using System.Linq;
using System.IO;
using System.Reflection;

namespace Nitra.Serialization
{
  public sealed class BinaryAstReader : IAstReader
  {
    public this(reader : BinaryReader)
    {
      this(reader, ChemicalAstContext(), Assembly.Load)
    }

    public this(reader : BinaryReader, context : ChemicalAstContext)
    {
      this(reader, context, Assembly.Load)
    }

    public this(reader : BinaryReader, resolveAssembly : AssemblyName -> Assembly)
    {
      this(reader, ChemicalAstContext(), resolveAssembly)
    }

    public this(reader : BinaryReader, context : ChemicalAstContext, resolveAssembly : AssemblyName -> Assembly)
    {
      Context = context;
      _reader = reader;

      def stringTableSize = reader.ReadInt32();
      _stringTable = array(stringTableSize);
      for (mutable i = 0; i < stringTableSize; ++i)
        _stringTable[i] = reader.ReadString();

      def assemblyTableSize = reader.ReadInt32();
      _assemblyTable = array(assemblyTableSize);
      for (mutable i = 0; i < assemblyTableSize; ++i)
      {
        def assemblyName = AssemblyName(_stringTable[reader.ReadInt32()]);
        def assembly     = resolveAssembly(assemblyName);
        assert(assembly != null);
        _assemblyTable[i] = assembly;
      }

      def grammarTableSize = reader.ReadInt32();
      _grammarTable = array(grammarTableSize);
      for (mutable i = 0; i < grammarTableSize; ++i)
      {
        def grammarName       = _stringTable[reader.ReadInt32()];
        def assembly          = _assemblyTable[reader.ReadInt32()];
        def grammarDescriptor = GetGrammarDescriptor(grammarName, assembly);
        assert(grammarDescriptor != null);
        _grammarTable[i] = grammarDescriptor;
      }
    }

    private _reader        : BinaryReader;
    private _stringTable   : array[string];
    private _assemblyTable : array[Assembly];
    private _grammarTable  : array[GrammarDescriptor];

    private static GetGrammarDescriptor(grammarName : string, assembly : Assembly) : GrammarDescriptor
    {
      foreach (grammarDescriptor when grammarDescriptor.Name == grammarName in GrammarDescriptor.GetDescriptors(assembly))
        return grammarDescriptor;
      null
    }

    public Context : ChemicalAstContext { get; }

    public ReadListHeader() : int { _reader.ReadInt32() }

    public ReadOptionHeader() : bool { _reader.ReadBoolean() }

    public ReadText() : string { _stringTable[_reader.ReadInt32()] }

    public ReadTupleHeader() : int { _reader.ReadInt32() }

    public ReadAstHeader() : AstKind { _reader.ReadByte() :> AstKind }

    public ReadExtension[T]() : T where T : Ast
    {
      def grammarHandle  = _reader.ReadInt32();
      def ruleHandle     = _reader.ReadInt32();
      def ruleDescriptor = GetRuleDescriptor(grammarHandle, ruleHandle);
      def ctor           = GetConstructor(ruleDescriptor);
      ctor(this) :> T
    }

    public ReadAmbiguities[T]() : array[T] where T : Ast
    {
      def ambiguities = array(_reader.ReadInt32());
      for (mutable i = 0; i < ambiguities.Length; ++i)
        ambiguities[i] = ReadExtension();
      ambiguities
    }

    public ReadAst() : Ast
    {
      def grammarHandle  = _reader.ReadInt32();
      def ruleHandle     = _reader.ReadInt32();
      def ruleDescriptor = GetRuleDescriptor(grammarHandle, ruleHandle);
      def ctor           = GetConstructor(ruleDescriptor);
      ctor(this)
    }

    [Memoize]
    private GetRuleDescriptor(grammarHandle : int, ruleHandle : int) : RuleDescriptor
    {
      def grammarDescriptor = _grammarTable[grammarHandle];
      def ruleName          = _stringTable[ruleHandle];
      foreach (ruleDescriptor when ruleDescriptor.Name == ruleName in grammarDescriptor.Rules)
        return ruleDescriptor;
      null
    }

    [Memoize]
    private static GetConstructor(ruleDescriptor : RuleDescriptor) : Func[IAstReader, Ast]
    {
      def type =
        if (ruleDescriptor is ExtensionRuleDescriptor as rd)
          ReflectionHelper.GetExtensionAstType(rd)
        else
          ReflectionHelper.GetBaseAstType(ruleDescriptor);

      def createMethod = type.GetMethod("Read", array[typeof(IAstReader)]);
      assert2(createMethod != null);
      Delegate.CreateDelegate(typeof(Func[IAstReader, Ast]), createMethod) :> Func[IAstReader, Ast]
    }
  }
}
