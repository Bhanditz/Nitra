using Nitra.ProjectSystem;
using Nitra.Runtime.Binding;
using Nitra.Staging;

using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Reflection;
using System.IO;
using System.Collections.Generic;
using System.Linq;

namespace Nitra.Serialization2
{
  public sealed class MetadataReader
  {
    private delegate DeserializationHandler(reader : BinaryReader, metadataReader : MetadataReader) : ISerializable;
    
    public this(project : Project)
    {
      Project = project;
    }

    public Project       : Project  { get; }
    public ErrorLocation : Location { get; }

    private _deserializationHandlers : Dictionary[int, DeserializationHandler] = Dictionary();
    private _symbols                 : Dictionary[int, DeclarationSymbol] = Dictionary();

    public ReadObject[T](reader : BinaryReader) : T
      where T: ISerializable
    {
      def descriptor = reader.ReadInt32();

      mutable handler;
      unless (_deserializationHandlers.TryGetValue(descriptor, out handler))
        assert(false, $"Cannot deserialize '$(typeof(T))': deserialization handler '$descriptor' not found.");

      def result = handler.Invoke(reader, this);
      result :> T
    }

    public ReadObjects[T](reader : BinaryReader) : array[T]
      where T: ISerializable
    {
      def count  = reader.ReadInt32();
      def buffer = array(count);
      for (mutable i = 0; i < buffer.Length; ++i)
        buffer[i] = ReadObject(reader);
      buffer
    }

    public ReadRoot[T](stream : Stream) : T
      where T: ISerializable
    {
      _deserializationHandlers.Clear();
      _symbols.Clear();

      using (reader = BinaryReader(stream, MetadataDefaults.Encoding, true))
      {
        def assemblyCount = reader.ReadInt32();
        for (mutable assemblyIndex = 0; assemblyIndex < assemblyCount; ++assemblyIndex)
        {
          def fullName = reader.ReadString();
          def assembly = LoadAssembly(fullName);
          def typeCount = reader.ReadInt32();
          for (mutable typeIndex = 0; typeIndex < typeCount; ++typeIndex)
          {
            def typeName = reader.ReadString();
            def id       = reader.ReadInt32();
            def handler  = LoadDeserializationHandler(assembly, typeName);
            _deserializationHandlers.Add(id, handler)
          }
        }

        ReadObject(reader);
      }
    }

    private LoadAssembly(fullName : string) : Assembly
    {
      Assembly.Load(fullName)
    }

    private LoadDeserializationHandler(assembly : Assembly, typeName : string) : DeserializationHandler
    {
      def type   = assembly.GetType(typeName, throwOnError = false);
      assert(type != null, $"Failed to find type '$typeName' from assembly '$assembly'.");
      Delegate.CreateDelegate(typeof(DeserializationHandler), type, "Deserialize", false) :> DeserializationHandler
    }

    public CreateSymbol[T](id : int, symbol : out T) : bool
      where T: DeclarationSymbol, new()
    {
      mutable existingSymbol;
      if (_symbols.TryGetValue(id, out existingSymbol))
      {
        symbol = existingSymbol :> T;
        false
      }
      else
      {
        def newSymbol = T();
        _symbols.Add(id, newSymbol);
        symbol = newSymbol;
        true
      }
    }
  }
}
