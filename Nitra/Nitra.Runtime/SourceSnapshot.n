using Nitra.ProjectSystem;

using System;
using SCG = System.Collections.Generic;

using Nemerle;
using Nemerle.Assertions;
using Nemerle.Extensions;
using Nemerle.Utility;

namespace Nitra
{
  public class SourceSnapshot : IPrettyPrintSource
  {
    public static @:(text : string) : SourceSnapshot { SourceSnapshot(text) }
    public static Default : SourceSnapshot { get; default SourceSnapshot("") }

    public OriginalText : string { get; }
    public Text         : string { get; }
    public File         : File
    {
      get
      {
        when (_file : object == null)
          _file = FakeFile(this);
        _file
      }
    }

    private mutable _file        : File;
    private         _lineIndexes : array[int];
    private         _textOffset  : int;
    private         _hashCode    : int;

    public this(original : SourceSnapshot)
    {
      this(original.OriginalText, original.Text, original.File, original._lineIndexes, original._textOffset);
    }

    public this([NotNull] originalText : string, [NotNull] text : string, file : File, [NotNull] lineIndexes : array[int], textOffset : int)
    {
      OriginalText = originalText;
      Text         = text;
      _file        = file;
      _lineIndexes = lineIndexes;
      _textOffset  = textOffset;
      _hashCode    = originalText.GetHashCode();
    }

    public this(text : string, file : File = null)
    {
      this(text, text, file, MakeLineIndexes(text), 0)
    }

    public this(text : string, fullName : string)
    {
      this(text);
      _file = FakeFile(this, fullName);
    }

    public PositionToLineColumn(pos : int) : LineColumn
    {
      def pos = _textOffset + pos;

      match (Array.BinarySearch(_lineIndexes, pos))
      {
        | index when index < 0 =>
          def index = ~index;
          if (index > 0)
            LineColumn(index, pos - _lineIndexes[index - 1] + 1)
          else
            LineColumn(1, 1)

        | index =>
          LineColumn(index + 1, pos - _lineIndexes[index] + 1)
      }
    }

    public GetSourceLine(pos : int) : Location
    {
      def pos = _textOffset + pos;
      def (line, col) = PositionToLineColumn(pos);
      def startPos = pos - col + 1;
      def endPos =
        if(line == _lineIndexes.Length)
          Text.Length
        else
          _lineIndexes[line];
      Location(this, startPos, endPos)
    }

    public WithText([NotNull] text : string) : SourceSnapshot
    {
      WithText(text, 0)
    }

    public WithText([NotNull] text : string, textOffset : int) : SourceSnapshot
      requires OriginalText.Length >= text.Length + textOffset
    {
      SourceSnapshot(OriginalText, text, File, _lineIndexes, textOffset);
    }

    public WithTextSubstring(pos : int, length : int) : SourceSnapshot
    {
      WithText(Text.Substring(pos, length), _textOffset + pos)
    }

    public GetGarbage(prevPos : int, pos : int) : NSpan
    {
      IgnoreParams();
      NSpan()
    }

    public override ToString() : string
    {
      def quoteLength = 200;
      if (Text.Length > quoteLength)
        $"$File: $(Text.Substring(0, quoteLength))..."
      else
        $"$File: $Text"
    }

    protected static MakeLineIndexes(text : string) : array[int]
    {
      def lineIndexesBuffer = SCG.List(text.Length / 25);
      lineIndexesBuffer.Add(0);
      mutable pos;
      while (pos < text.Length)
      {
        match (text[pos])
        {
          | '\r' =>
            ++pos;
            when (pos < text.Length && text[pos] == '\n')
              ++pos;
            lineIndexesBuffer.Add(pos);
          | '\n'
          | '\u2028'    /*  line separator       */
          | '\u2029' => /*  paragraph separator  */
            ++pos;
            lineIndexesBuffer.Add(pos);
          | _ =>
            ++pos;
        }
      }
      lineIndexesBuffer.ToArray()
    }

    #region Nitra.SourceSnapshot  Members

    public static @==(a : SourceSnapshot, b : SourceSnapshot) : bool { object.Equals(a, b) }
    public static @!=(a : SourceSnapshot, b : SourceSnapshot) : bool { !object.Equals(a, b) }

    [OverrideObjectEquals]
    public Equals(other : SourceSnapshot) : bool
    {
      other != null && _hashCode == other._hashCode && this.Text.Equals(other.Text, StringComparison.Ordinal)
    }

    public override GetHashCode() : int
    {
      _hashCode
    }

    #endregion
  }
}
