using Nitra.Declarations;

using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;

namespace Nitra.Internal
{
  public module DeclarationUtils
  {
    public GetDeclarationAmbiguities[TParseTree, TParent, TDeclaration](parent : TParent, ambiguities : array[TParseTree]) : array[TDeclaration]
      where TParseTree   : IMappedParseTree[TParent, TDeclaration]
      where TParent      : IAst
      where TDeclaration : IAst
    {
      def result = array(ambiguities.Length);
      foreach (node in ambiguities with index)
        result[index] = node.GetAst(parent);
      result
    }

    public GetAstOption[TParseTree, TParent, TDeclaration, TData](parent : TParent, opt : OptionParseTree[TParseTree]) : IAstOption[TDeclaration, TData]
      where TParseTree   : IMappedParseTree[TParent, TDeclaration]
      where TParent      : IAst
      where TDeclaration : IAst
      where TData        : IDependentPropertyHost
    {
      if (opt.IsAmbiguous)
      {
        def ambiguousParseTree = opt :> IAmbiguousParseTree;
        def ambiguities        = array(ambiguousParseTree.Ambiguities.Count);
        foreach (parseTree :> OptionParseTree[TParseTree] in ambiguousParseTree.Ambiguities with index)
          ambiguities[index] = GetAstOption(parent, parseTree);
        AmbiguousAstOption(ambiguities)
      }
      else if (opt.HasValue)
      {
        def value = opt.Value.GetAst(parent);
        AstOption.Some(parent, opt.Location.Span, DataProxyCtors.[TData, TDeclaration].Ctor(null, value), value)
      }
      else
      {
        AstOption.None(parent, opt.Location.Span, DataProxyCtors.[TData, TDeclaration].Ctor(null, default(TDeclaration)))
      }
    }

    public GetAstList[TParseTree, TParent, TDeclaration, TData](parent : TParent, lst : ListParseTree[TParseTree]) : IAstList[TDeclaration, TData]
      where TParseTree   : IMappedParseTree[TParent, TDeclaration]
      where TParent      : IAst
      where TDeclaration : IAst
      where TData        : IDependentPropertyHost
    {
      if (lst.IsAmbiguous)
      {
        def ambiguousParseTree = lst :> IAmbiguousParseTree;
        def ambiguities        = array(ambiguousParseTree.Ambiguities.Count);
        foreach (parseTree :> ListParseTree[TParseTree] in ambiguousParseTree.Ambiguities with index)
          ambiguities[index] = GetAstList(parent, parseTree);
        AmbiguousAstList(ambiguities)
      }
      else
      {
        def declarations = array(lst.Count);
        foreach (node in lst with index)
          declarations[index] = node.GetAst(parent);
        AstList(parent, lst.Location.Span, DataProxyCtors.[TData, TDeclaration].Ctor(declarations, default(TDeclaration)), declarations)
      }
    }

    private module DataProxyCtors[TData, TDeclaration]
    {
      public Ctor : Func[array[TDeclaration], TDeclaration, TData] =
        ConstructorFactory.MakeConstructorDelegate(typeof(TData), array[typeof(TDeclaration).MakeArrayType(), typeof(TDeclaration)], typeof(TData));
    }
  }
}
