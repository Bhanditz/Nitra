using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;

namespace Nitra.Internal
{
  public interface ISplicableAstBuilder[T] : IExtensibleRuleAstFactory[T]
  {
    Syntax         (parseResult : ParseResult, ruleDescriptor : RuleDescriptor,        startPos : int, endPos : int, members : array[T]) : T;
    Regular        (parseResult : ParseResult, ruleDescriptor : RegularRuleDescriptor, startPos : int, endPos : int) : T;
    SkipAny        (parseResult : ParseResult, startPos : int, endPos : int) : T;
    OptionSome     (parseResult : ParseResult, startPos : int, endPos : int, item : T) : T;
    OptionNone     (parseResult : ParseResult, startPos : int, endPos : int) : T;
    OptimizedOption(parseResult : ParseResult, startPos : int, endPos : int, value : bool) : T;
    Tuple          (parseResult : ParseResult, startPos : int, endPos : int, item1 : T, item2 : T) : T;
    Tuple          (parseResult : ParseResult, startPos : int, endPos : int, item1 : T, item2 : T, item3 : T) : T;
    Tuple          (parseResult : ParseResult, startPos : int, endPos : int, item1 : T, item2 : T, item3 : T, item4 : T) : T;
    Tuple          (parseResult : ParseResult, startPos : int, endPos : int, params items : array[T]) : T;
    OptimizedList  (parseResult : ParseResult, startPos : int, endPos : int, count : int) : T;
    List           (parseResult : ParseResult, startPos : int, endPos : int, items : List[T]) : T;
    EmptyList      (parseResult : ParseResult, startPos : int, endPos : int) : T;
  }
}
