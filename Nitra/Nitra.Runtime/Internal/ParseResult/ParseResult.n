using Nitra.Internal;
using Nitra.Internal.Recovery;
using Nitra.Runtime;
using Nitra.Runtime.Reflection;

using Nemerle;
using Nemerle.Imperative;
using Nemerle.Imperative.GoTo;
using Nemerle.Collections;
using Nemerle.Late;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Diagnostics;
using System.Linq;
using System.Collections.ObjectModel;

using System.Text;
using SCG = System.Collections.Generic;

namespace Nitra
{
  public partial class ParseResult : IPrettyPrintSource, ISourceSnapshotProvider
  {
    public static AstParsedState = ~int.MaxValue;

    public static ResultOffset = 0;

    public         Text             : string         { get; }
    public mutable ast              : array[int];
    public mutable memoize          : array[int];
    public mutable allocated        : int;
    public mutable TerminateParsing : bool; // may be volatile?
    public         ParserHost       : ParserHost;
    public         OriginalSource   : SourceSnapshot { get; }
    public         StartPos         : int            { get; }
    public         RuleParser       : RuleParser     { get; }
    public mutable LastParseStart   : int;
    public mutable LastParseEnd     : int;
    public         ErrorData        : SCG.List[ParseErrorData];
    public mutable ErrorDataSorted  : array[ParseErrorData];
    private mutable _maxFailPos     : int;
    private mutable _counter        : int;
    private _errors                 : SCG.List[Error] = SCG.List();

    [Record]
    public struct SubruleStart
    {
      /// Начало соотвестствующего подправила
      public Pos   : int;
      public State : int;
      public override ToString() : string { $"Pos=$Pos, State=$State" }
    }

    [Record]
    public variant RecoveredSequence
    {
      public AllSubrules : array[ParsedSubrule * TokenChanges];

      | Unambiguous { /** Индекс в RecoveredSubrules  */ Subrules : int }
      | Ambiguous   { /** Индексы в RecoveredSubrules */ Subrules : array[int] }
    }

    [Record]
    public struct SubrulesWithParsingSequence
    {
      public Subrules        : array[SubruleStart];
      public ParsingSequence : ParsingSequence;
    }

    /// В массиве хранятся начала соотвестствующих подправил. Последним элементом массива - позиция конечного состояния (-1).
    /// Таким образом мы можем легко вычислить позиции и размеры всех сабрулей
    public RecoveredSubrules  : SCG.List[SubrulesWithParsingSequence] = SCG.List();

    public FindRecoveredSubrule(subruleStarts : array[SubruleStart], state : int) : bool * int * int
    {
      foreach (subruleStart when (subruleStart.State == state) in subruleStarts with i)
      {
        def startPos = subruleStart.Pos;
        def endPos   = subruleStarts[i + 1].Pos;
        return (true, startPos, endPos);
      }

      foreach (subruleStart when (subruleStart.State > state) in subruleStarts)
        return (false, subruleStart.Pos, subruleStart.Pos);

      def subruleStart = subruleStarts[subruleStarts.Length - 1];
      assert(subruleStart.State == -1);
      (false, subruleStart.Pos, subruleStart.Pos)
    }

    public ReadListAst[T](parentParsingSequence : ParsingSequence, state : int, startPos : int, endPos : int, makeItem : ParsingSequence * int * int -> T) : Nitra.ListAst[T]
      where T : IAst
    {
      if (startPos < endPos)
      {
        def parsingSequence = (parentParsingSequence.States[state].Subrule :> SubruleInfo.List).ParsingSequence;
        mutable recoveredSequence;
        if (RecoveredSequences.TryGetValue((startPos, endPos, parsingSequence), out recoveredSequence))
        {
          def states = parsingSequence.States;
          match (recoveredSequence)
          {
            | Unambiguous(recoveredSubruleIndex) =>
              def items = SCG.List();

              def subrules = RecoveredSubrules[recoveredSubruleIndex].Subrules;
              for (mutable i = 0; i < subrules.Length - 1; ++i)
              {
                def begin    = subrules[i].Pos;
                def end      = subrules[i + 1].Pos;
                def state    = states[subrules[i].State];

                match (state.Subrule)
                {
                  | ListItem(ParsingSequence = itemParsingSequence) =>
                    when (begin != end || itemParsingSequence.SequenceInfo.CanParseEmptyString)
                    {
                      def item = makeItem(itemParsingSequence, begin, end);
                      items.Add(item);
                    }

                  | _ => assert(false, "List items expected");
                }
              }

              ListAst(Location(OriginalSource, startPos, endPos), items);

            | Ambiguous => throw NotImplementedException("Ambiguous List");
          }
        }
        else
        {
          throw NotImplementedException("Fallback to standard AST reading");
        }
      }
      else
      {
        ListAst(Location(OriginalSource, startPos, endPos));
      }
    }

    public ReadListWithSeparatorAst[TItem, TSeparator](
      parentParsingSequence : ParsingSequence,
      state : int,
      startPos : int,
      endPos : int,
      makeItem : ParsingSequence * int * int -> TItem,
      makeSeparator : ParsingSequence * int * int -> TSeparator) : SequenceAst[ListAst[TItem], ListAst[TSeparator]]
      where TItem : IAst
      where TSeparator : IAst
    {
      ReadListWithSeparatorAstImpl(parentParsingSequence, state, startPos, endPos, makeItem, makeSeparator,
        (loc, items, separators) => SequenceAst(loc, if (items : object != null) ListAst(loc, items) else ListAst(loc), if (separators : object != null) ListAst(loc, separators) else ListAst(loc)))
    }

    public ReadListWithSeparatorOnlyItemsAst[TItem, TSeparator](
      parentParsingSequence : ParsingSequence,
      state : int,
      startPos : int,
      endPos : int,
      makeItem : ParsingSequence * int * int -> TItem) : ListAst[TItem]
      where TItem : IAst
    {
      ReadListWithSeparatorAstImpl(parentParsingSequence, state, startPos, endPos, makeItem, _ => 0,
        (loc, items, _) => if (items : object != null) ListAst(loc, items) else ListAst(loc))
    }

    public ReadListWithSeparatorOnlySeparatorsAst[TItem, TSeparator](
      parentParsingSequence : ParsingSequence,
      state : int,
      startPos : int,
      endPos : int,
      makeSeparator : ParsingSequence * int * int -> TSeparator) : ListAst[TSeparator]
      where TSeparator : IAst
    {
      ReadListWithSeparatorAstImpl(parentParsingSequence, state, startPos, endPos, _ => 0, makeSeparator,
        (loc, _, separators) => if (separators : object != null) ListAst(loc, separators) else ListAst(loc))
    }

    private ReadListWithSeparatorAstImpl[TItem, TSeparator, TResult](
      parentParsingSequence : ParsingSequence,
      state : int,
      startPos : int,
      endPos : int,
      makeItem : ParsingSequence * int * int -> TItem,
      makeSeparator : ParsingSequence * int * int -> TSeparator,
      makeResult : Location * SCG.List[TItem] * SCG.List[TSeparator] -> TResult) : TResult
    {
      if (startPos < endPos)
      {
        def listInfo = parentParsingSequence.States[state].Subrule :> SubruleInfo.ListWithSeparator;
        def parsingSequence = listInfo.ParsingSequence;
        mutable recoveredSequence;
        if (RecoveredSequences.TryGetValue((startPos, endPos, parsingSequence), out recoveredSequence))
        {
          def states = parsingSequence.States;
          match (recoveredSequence)
          {
            | Unambiguous(recoveredSubruleIndex) =>
              def items      = SCG.List();
              def separators = SCG.List();

              def subrules = RecoveredSubrules[recoveredSubruleIndex].Subrules;
              for (mutable i = 0; i < subrules.Length - 1; ++i)
              {
                def begin       = subrules[i].Pos;
                def end         = subrules[i + 1].Pos;
                def stateNumber = subrules[i].State;
                def state       = states[stateNumber];

                match (state.Subrule)
                {
                  | ListItem(ParsingSequence = itemParsingSequence) =>
                    match (stateNumber)
                    {
                      | 0 =>
                        when (begin != end || itemParsingSequence.SequenceInfo.CanParseEmptyString)
                        {
                          def item = makeItem(itemParsingSequence, begin, end);
                          items.Add(item);
                        }

                      | 1 =>
                        when (begin != end || itemParsingSequence.SequenceInfo.CanParseEmptyString)
                        {
                          def separator = makeSeparator(itemParsingSequence, begin, end);
                          separators.Add(separator);
                        }

                      | _ => assert(false, "Unknown ListWithSeparator state number");
                    }

                  | _ => assert(false, "List items expected");
                }
              }

              makeResult(Location(OriginalSource, startPos, endPos), items, separators)

            | Ambiguous => throw NotImplementedException("Ambiguous ListWithSeparator");
          }
        }
        else
        {
          throw NotImplementedException("Fallback to standard AST reading");
        }
      }
      else
      {
        makeResult(Location(OriginalSource, startPos, endPos), null, null)
      }
    }


    internal AddRecoveredSubrule(item : array[SubruleStart], parsingSequence : ParsingSequence) : int
    {
      def index = RecoveredSubrules.Count;
      RecoveredSubrules.Add(SubrulesWithParsingSequence(item, parsingSequence));
      index
    }

    /// Key = Start * End * ParsingSequence
    public RecoveredSequences : Hashtable[int * int * ParsingSequence, RecoveredSequence] { get; default Hashtable(); }

    public this(source : SourceSnapshot, startPos : int, initalSize : int, parserHost : ParserHost, ruleParser : RuleParser)
    {
      Text             = source.Text;
      OriginalSource   = source;
      StartPos         = startPos;
      TokenEnumerator1 = TokenEnumerator(this);
      TokenEnumerator2 = TokenEnumerator(this);
      ErrorData        = SCG.List();
      this.ast         = array(if (initalSize < 10) 10 else initalSize);
      this.memoize     = array(Text.Length + 1);
      this.allocated   = 0;
      this.ParserHost  = parserHost;
      LastParseStart   = -1;
      LastParseEnd     = -1;
      MaxFailPos       = 0;
      this.RuleParser  = ruleParser;
    }

    public GenerateId() : int
    {
      _counter++;
      _counter
    }
    
    public MaxFailPos : int
    {
      get { _maxFailPos }
      set { _maxFailPos = value }
    }

    public IsSuccess : bool { get { _errors.Count == 0 } }
    
    public TokenEnumerator1 : TokenEnumerator;
    public TokenEnumerator2 : TokenEnumerator;

    public DebugText : string
    {
      get
      {
        def sb1 = StringBuilder();
        def sb2 = StringBuilder();
        def sb3 = StringBuilder();
        def appendIndex(len : int, i : int)
        {
          _ = sb3.Append(('0' + (i / 10)) :> char, len);
          _ = sb2.Append(('0' + (i % 10)) :> char, len);
        }
        def addEsc(ch : string, i : int) : void
        {
          def str = $@"\$ch";
          _ = sb1.Append(str);
          appendIndex(str.Length, i);
        }
        foreach (ch in Text with i)
        {
          | '\"'      => addEsc("\"", i)
          | '\\'      => addEsc("\\", i)
          | '\n'      => addEsc("n", i)
          | '\t'      => addEsc("t", i)
          | '\r'      => addEsc("r", i)
          | '\e'      => addEsc("e", i)
          | '\a'      => addEsc("a", i)
          | '\b'      => addEsc("b", i)
          | '\f'      => addEsc("f", i)
          | '\v'      => addEsc("v", i)
          | '\0'      => addEsc("0", i)
          | '\uFFFF'  => addEsc("uFFFF", i)
          | c         => _ = sb1.Append(c); appendIndex(1, i)
          
        }
        
        sb1.AppendLine().Append(sb2.ToString()).AppendLine().Append(sb3.ToString()).ToString()
      }
    }
    
    public ParseResult : string
    {
      get
      {
        if (LastParseEnd >= 0)
          Text.Substring(LastParseStart, LastParseEnd - LastParseStart)
        else
          "<fail>"
      }
    }

    public RestText : string
    {
      get { Text.Substring(if (LastParseEnd >= 0) LastParseEnd else LastParseStart) }
    }

    public mutable PreviousTextSize : int;

    public PreviousText : string
    {
      get
      {
        when (PreviousTextSize <= 0)
          PreviousTextSize = 20;

        def pos = if (LastParseEnd >= 0) LastParseEnd else LastParseStart;
        if (pos >= PreviousTextSize)
          Text.Substring(pos - PreviousTextSize, PreviousTextSize)
        else
          Text.Substring(0, pos)
      }
    }

    public Allocate(size : int) : int
    {
      def newAst = allocated;
      allocated = allocated + size;
      while (ast.Length <= allocated)
        Array.Resize(ref ast, (ast.Length * 3) / 2);

      newAst
    }

    public Allocate(size : int, ruleId : int) : int
    {
      def newAst = Allocate(size);
      ast[newAst] = ruleId;
      newAst;
    }

    public TryGetPrefix(pos : ref int, prefixAst : ref int) : int
    {
      mutable bestResult = ast[prefixAst + ExtensibleRuleParser.PrefixOfs.List];
      when (bestResult < 0)
      {
        def error = ErrorData[~bestResult];
        when (error.Skip.Length == 0)
          return -1;//правило восстановилось пустым.
        pos += error.Skip.Length; // грязь
        prefixAst = GetAst(pos, ast[prefixAst + ExtensibleRuleParser.PrefixOfs.Id] & ExtensibleRuleParser.AstMask.Id);
        bestResult = ast[prefixAst + ExtensibleRuleParser.PrefixOfs.List]; // исходная ссылка на AST
        assert3(bestResult >= 0 || ErrorData[~bestResult].Skip.Length == 0);
        when (bestResult == 0)
          bestResult = -1;
      }
      bestResult;
    }

    public TryGetPostfix(pos : ref int, postfixAst : ref int) : int
    {
      mutable bestResult = ast[postfixAst + ExtensibleRuleParser.PostfixOfs.List];
      when (bestResult < 0)
      {
        def error = ErrorData[~bestResult];
        when (error.Skip.Length == 0)
          return -1;//правило восстановилось пустым.
        pos += error.Skip.Length; // грязь
        postfixAst = GetAst(pos, ast[postfixAst + ExtensibleRuleParser.PostfixOfs.Id] & ExtensibleRuleParser.AstMask.Id);
        bestResult = ast[postfixAst + ExtensibleRuleParser.PostfixOfs.List]; // исходная ссылка на AST
        assert3(bestResult >= 0 || ErrorData[~bestResult].Skip.Length == 0);
        when (bestResult == 0)
          bestResult = -1;
      }
      bestResult;
    }

    public TryGetAst(pos : int, ruleId : int) : int
    {
      for (mutable astPtr = memoize[pos]; astPtr > 0; astPtr = ast[astPtr + ExtensibleRuleParser.AstOfs.Next])
        when (ast[astPtr] == ruleId)
          return astPtr;
      0;
    }

    public GetAst(pos : int, ruleId : int) : int
    {
      def astPtr = TryGetAst(pos, ruleId);
      assert3(astPtr > 0);
      astPtr;
    }

    public GetSize(sizePos : int) : int
    {
      def size = ast[sizePos];
      if (size >= 0)
        size
      else if (size == int.MinValue)
        0
      else
      {
        def error = ErrorData[~size];
        error.Skip.Length + error.Data
      }
    }

    public GetSkip(sizePos : int) : int
    {
      def size = ast[sizePos];
      if (size >= 0)
        0
      else if (size == int.MinValue)
        0
      else
      {
        def error = ErrorData[~size];
        error.Skip.Length
      }
    }

    public GetSkipAndSize(sizePos : int) : int * int
    {
      def size = ast[sizePos];
      if (size >= 0)
        (0, size)
      else if (size == int.MinValue)
        (0, 0)
      else
      {
        def error = ErrorData[~size];
        (error.Skip.Length, error.Data)
      }
    }

    public GetSkipAndSize2(sizePos : int) : int
    {
      def size = ast[sizePos];
      if (size >= 0)
        size
      else if (size == int.MinValue)
        0
      else
      {
        def error = ErrorData[~size];
        ~(error.Skip.Length + error.Data)
      }
    }

    public GetAstSize(astPtr : int, sequenceInfo : SequenceInfo) : int
    {
      mutable size = 0;
      foreach (subrule in sequenceInfo.Subrules)
        size += GetSize(astPtr + subrule.Offset);
      size;
    }

    public AstSize(astPtr : int, begin : int, end : int) : int
    {
      mutable size = 0;
      def end = astPtr + end;
      for (mutable i = astPtr + begin; i < end; ++i)
        size += GetSize(i);
      size;
    }

    public CreateAst() : Nitra.Ast
    {
      //FIXME: rewrite without reflection
      def astType = ReflectionHelper.GetBaseAstType(this.RuleParser.Descriptor);
      match (this.RuleParser.Descriptor)
      {
        | SimpleRuleDescriptor =>
          def astCreateMethod = astType.GetMethod("Create", array[typeof(int), typeof(int), typeof(ParseResult)]);
          astCreateMethod.Invoke(null, array[this.StartPos : object, this.Text.Length : object, this]) :> Ast

        | ExtensibleRuleDescriptor as descriptor =>
          def astFactory      = typeof(DefaultExtensibleRuleAstFactory[_]).MakeGenericType(astType).GetField("Instance").GetValue(null);
          def astCreateMethod = typeof(ExtensibleRuleAstConstructor).GetMethod("Create").MakeGenericMethod(astType);
          astCreateMethod.Invoke(null, array[StartPos : object, this, 0, descriptor, astFactory]) :> Ast

        | _ => assert(false)
      }
    }

    public CreateSplicableAst[T](splicableAstBuilder : ISplicableAstBuilder[T]) : T
    {
      def ruleDescriptor  = this.RuleParser.Descriptor;
      match (ruleDescriptor)
      {
        | SimpleRuleDescriptor =>
          def grammarAssembly = ruleDescriptor.Grammar.GetType().Assembly;
          def walkerType      = grammarAssembly.GetType(ruleDescriptor.Grammar.FullName + "AstWalker", throwOnError = true);
          def method          = walkerType.GetMethod(ruleDescriptor.Name.Replace('.', '_')).MakeGenericMethod(typeof(T));
          method.Invoke(null, array[StartPos : object, this, splicableAstBuilder]) :> T

        | ExtensibleRuleDescriptor as d =>
          mutable pos = StartPos;
          ExtensibleRuleAstConstructor.Create(ref pos, this, 0, d, splicableAstBuilder)

        | _ => assert(false)
      }
    }

    public GetSpans(startPos : int, endPos : int, spans : SCG.List[SpanInfo]) : void
    {
      def walker = Highlighting.HighlightingWalker(NSpan(startPos, endPos));
      _ = walker.Walk(this, spans);
    }

    public GetOutlining(outlining : SCG.List[OutliningInfo]) : void
    {
      def walker = Outlining.OutliningWalker();
      _ = walker.Walk(this, outlining);
    }

    class Root : INitraReflection
    {
      public FullName            : string { get { "Roor" } }
      public ShortName           : string { get { "Roor" } }
      public IsMarker            : bool   { get { false } }
      public CanParseEmptyString : bool   { get { false } }
    }

    public Reflect() : ReflectionStruct
    {
      def nodes = SCG.List();
      def walker = ReflectionWalker();
      _ = walker.Walk(this, nodes);
      // FIXME: этот код должен быть в волкере
      ReflectionStruct(Root(), RuleParser.Descriptor.Name, false, NSpan(StartPos, ast[ParseResult.ResultOffset]), ReadOnlyCollection(nodes.ToArray()))
    }

    public ReportError(error : ParseError) : void
    {
      _errors.Add(error);
    }
    
    public GetErrors() : array[Error]
    {
      _errors.ToArray()
    }

    public GetRuleParser(astPtr : int) : object
    {
      def ruleId = this.ast[astPtr] & ExtensibleRuleParser.AstMask.Id;
      this.ParserHost.RuleParsers[ruleId]
    }

    public GetSequenceInfo(astPtr : int) : SequenceInfo
    {
      def ruleId = this.ast[astPtr] & ExtensibleRuleParser.AstMask.Id;
      (this.ParserHost.RuleParsers[ruleId] :> IRuleParserReflection).Reflection(ruleId)
    }

    public GetGarbage(prevPos : int, pos : int) : NSpan
    {
      def cmp(e : ParseErrorData) : int
      {
        if (e.Skip.StartPos < prevPos)
          -1
        else
          if (e.Skip.EndPos > pos)
            1
          else
            0
      }
      def errorIndex = ErrorDataSorted.BinarySearch(cmp);
      if (errorIndex >= 0)
      {
        def error = ErrorDataSorted[errorIndex];
        error.Skip
      }
      else
        NSpan()
    }

    internal UpdateErrorDataSorted() : void
    {
      this.ErrorDataSorted = this.ErrorData.ToArray();
      def cmp(x : ParseErrorData, y : ParseErrorData) : int
      {
        x.Skip.StartPos - y.Skip.StartPos
      }
      Array.Sort(this.ErrorDataSorted, cmp);
    }
    
    private GetSource() : SourceSnapshot implements ISourceSnapshotProvider.GetSource
    {
      OriginalSource
    }
  }
}
