using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using Nitra.Runtime;

using System;

namespace Nitra.Internal
{
  public sealed class DefaultExtensibleRuleParseTreeFactory[T] : IExtensibleRuleParseTreeFactory[T]
      where T : ParseTree, class
  {
    public static Instance : this = DefaultExtensibleRuleParseTreeFactory();

    private this() { }

    public CreateAmbiguous(parseResult : ParseResult, ruleDescriptor : RuleDescriptor, startPos : int, endPos : int, ambiguitys : array[T], parsers : array[ExtensionRuleParser], ambiguityType : ParseTreeAmbiguityType) : T
    {
      ignore(parseResult, startPos, endPos, parsers);
      (ruleDescriptor :> StartRuleDescriptor).CreateAmbiguousParseTree(ambiguitys :> array[ParseTree], ambiguityType) :> T
    }

    public CreateMissing(parseResult : ParseResult, ruleDescriptor : RuleDescriptor, pos : int) : T
    {
      (ruleDescriptor :> StartRuleDescriptor).CreateMissingParseTree(parseResult, pos) :> T
    }

    public CreatePrefix(pos : ref int, rawTreePtr : int, ruleParser : ExtensionRuleParser, parseResult : ParseResult) : T
    {
      (ruleParser.Descriptor :> PrefixRuleDescriptor).CreateParseTree(ref pos, rawTreePtr, parseResult) :> T
    }

    public CreatePrefix(startPos : int, endPos : int, recoveredSubrulesIndex : int, ruleParser : ExtensionRuleParser, parseResult : ParseResult) : T
    {
      (ruleParser.Descriptor :> PrefixRuleDescriptor).CreateParseTree(startPos, endPos, recoveredSubrulesIndex, parseResult) :> T
    }

    public CreatePostfix(prefix : T, prefixStartPos : int, pos : ref int, rawTreePtr : int, ruleParser : ExtensionRuleParser, parseResult : ParseResult) : T
    {
      (ruleParser.Descriptor :> PostfixRuleDescriptor).CreateParseTree(prefix, prefixStartPos, ref pos, rawTreePtr, parseResult) :> T
    }

    public CreatePostfix(prefix : T, prefixStartPos : int, startPos : int, endPos : int, recoveredSubrulesIndex : int, ruleParser : ExtensionRuleParser, parseResult : ParseResult) : T
    {
      (ruleParser.Descriptor :> PostfixRuleDescriptor).CreateParseTree(prefix, prefixStartPos, startPos, endPos, recoveredSubrulesIndex, parseResult) :> T
    }
  }
}
