using Nitra.Runtime;

using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;

using SCG = System.Collections.Generic;

namespace Nitra.Internal.Recovery
{
  public partial class RecoveryParser
  {
    public PanicRecovery() : void
    {
      def textPos = 0;
      Records[textPos] = Hashtable();
      Records[ParseResult.Text.Length] = Hashtable();
      def rootParsingSequence =
        match (ParseResult.RuleParser)
        {
          | SimpleRuleParser     as ruleParser => ruleParser.ParsingSequence
          | ExtensibleRuleParser as ruleParser => ruleParser.ParsingSequence
          | _                                  => assert3(false)
        };
      def completeRecord = ParseRecord(StartParseSequence(textPos, rootParsingSequence, TokenChanges.None), -1, ParseResult.Text.Length);
      Parse();

      def memoization = SCG.Dictionary();
      def grammar = this.ParseResult.RuleParser.Grammar;
      def parseResult = this.ParseResult;
      
      def isRootRecordCompleted() { !Records[ParseResult.Text.Length].Contains(completeRecord) }
      mutable prevMaxPos = -1;
      while (isRootRecordCompleted())
      {
        ParseToFailPos();
        def curMaxPos = MaxPos;
        when (curMaxPos == prevMaxPos)
        {
          ///
        }
        prevMaxPos = MaxPos;
        
        def records = Records[curMaxPos].MapToArrayFiltered(r => !r.Key.IsComplete && !IsInsideToken(memoization, grammar, r.Key.Sequence), r => r.Key);
        def leafRecords = GetLeafTokens(records);
        _ = leafRecords;
        
        def tokens = grammar.ParseGrammarTokens(curMaxPos, parseResult);
        _ = tokens;

        def calcFollowSet(record : ParseRecord, result : HashSet[TokenParser]) : void
        {
          def processNextState(parsingState : ParsingState)
          {
            def record = record;
            def result = result;
            foreach (next in parsingState.Next)
            {
              if (next >= 0)
              {
                def nextState = record.Sequence.ParsingSequence.States[next];
                def tokenParser = grammar.GetTokenParser(nextState.Subrule);
                if (tokenParser != null)
                {
                  if (tokenParser.IsVoid)
                    processNextState(nextState);
                  else
                    _ = result.Add(tokenParser);
                }
                else
                  _ = result.UnionWith(nextState.FirstTokens);
              }
              else
              {
                foreach (caller in record.Sequence.Callers)
                  calcFollowSet(caller, result);
              }
            }
          }
          
          processNextState(record.ParsingState);
        }
        
        def result = HashSet();
        foreach (leafRecord in leafRecords)
          calcFollowSet(leafRecord, result);
        
        Parse();
      }

      BuildAst();
    }
    
    
    GetLeafTokens(records : Seq[ParseRecord]) : SCG.List[ParseRecord]
    {
      def parents = SCG.HashSet();
      
      foreach (record in records)
        foreach (caller in record.Sequence.Callers)
          _ = parents.Add(caller);
          
      def result = SCG.List();
      
      foreach (record in records)
        unless (parents.Contains(record))
          result.Add(record);
        
      result
    }
  }
}
