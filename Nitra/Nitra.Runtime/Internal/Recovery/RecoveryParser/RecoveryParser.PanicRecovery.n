using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;

using SCG = System.Collections.Generic;

namespace Nitra.Internal.Recovery
{
  public partial class RecoveryParser
  {
    public PanicRecovery() : void
    {
      def textPos = 0;
      Records[textPos] = Hashtable();
      Records[ParseResult.Text.Length] = Hashtable();
      def rootParsingSequence =
        match (ParseResult.RuleParser)
        {
          | SimpleRuleParser     as ruleParser => ruleParser.ParsingSequence
          | ExtensibleRuleParser as ruleParser => ruleParser.ParsingSequence
          | _                                  => assert3(false)
        };
      def completeRecord = ParseRecord(StartParseSequence(textPos, rootParsingSequence, TokenChanges.None), -1, ParseResult.Text.Length);
      Parse();

      def memoization = SCG.Dictionary();
      def grammar = this.ParseResult.RuleParser.Grammar;
      def parseResult = this.ParseResult;
      
      def isRootRecordCompleted() { !Records[ParseResult.Text.Length].Contains(completeRecord) }
      mutable prevMaxPos = -1;
      while (isRootRecordCompleted())
      {
        ParseToFailPos();
        def curMaxPos = MaxPos;
        when (curMaxPos == prevMaxPos)
        {
          ///
        }
        prevMaxPos = MaxPos;
        
        def records = Records[curMaxPos].MapToArrayFiltered(r => !r.Key.IsComplete && !IsInsideToken(memoization, grammar, r.Key.Sequence), r => r.Key);
        _ = records;
        
        def tokens = grammar.ParseGrammarTokens(curMaxPos, parseResult);
        _ = tokens;
        
        Parse();
      }

      BuildAst();
    }
  }
}
