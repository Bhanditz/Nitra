using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Imperative;
using Nemerle.Extensions;

using Nitra.Collections;
using Nitra.Runtime;
using Nitra.Runtime.Reflection;

using System;
using System.Diagnostics;
using System.IO;
using System.Linq;

using SCG = System.Collections.Generic;

namespace Nitra.Internal.Recovery
{
  public partial class RecoveryParser
  {
    public ParseResult       : ParseResult;
    public Sequences         : Hashtable[int * ParsingSequence, ParsedSequence] = Hashtable();
    public Records           : array[Hashtable[ParseRecord, TokenChanges]];
    public RecordsToProcess  : PriorityQueue[ParseRecord * TokenChanges] = PriorityQueue(
      fun ((l, lTokenChanges), (r, rTokenChanges))
      {
        def c = lTokenChanges.CompareTo(rTokenChanges);
        if (c != 0)
          c
        else
          l.ParsePos.CompareTo(r.ParsePos)
      });

    public mutable MaxPos    : int = -1;
    public mutable BestSolution : TokenChanges = TokenChanges.Fail;

    public StartSequence : ParsedSequence { get { this.Sequences[0, this.ParseResult.RuleParser.ParsingSequence] } }

    public this(parseResult : ParseResult)
    {
      Records     = array(parseResult.Text.Length + 1);
      ParseResult = parseResult;
    }

    private ErrorPositions : SCG.HashSet[int] = SCG.HashSet();

    public RecoveryFromAllErrors() : void
    {
      def textPos = 0;
      Records[textPos] = Hashtable();
      def root = ParseRecord(ParsedSequence(this, 0, ParsingSequence.CreateRoot()), 0, textPos);
      Records[textPos][root] = TokenChanges(0, 0);
      match (ParseResult.RuleParser)
      {
        | SimpleRuleParser     as ruleParser =>
          _ = StartParseSequence(root, textPos, ruleParser.ParsingSequence);

        | ExtensibleRuleParser as ruleParser =>
          _ = StartParseSequence(root, textPos, ruleParser.ParsingSequence);

        | _ => assert3(false)
      }
      Parse();

      while (BestSolution.IsFail)
      {
        ParseToFailPos();
        _ = ErrorPositions.Add(MaxPos);
        InsertSubrules(MaxPos);
        DeleteTokenOrGarbage(MaxPos);
        Parse();
      }

      BuildAst();
    }

    private ParseToFailPos() : void
    {
      mutable maxPos;
      do
      {
        maxPos = MaxPos;
        mutable count;
        do
        {
          def records = Records[maxPos].KeyValuePairs.ToArray(); // to materialize collection
          count = records.Length;

          // Находим все состояния которые могут съедать мусор
          foreach ((record, tokenChanges) in records)
            when (record.State >= 0)
            {
              def state = record.ParsingState;
              foreach (seq in state.CalleeSequences)
                when (seq.CanConsumeErrorTokens)
                {
                  PredictionOrScanning(record, tokenChanges, false);
                  break;
                }
            }

          def sequences = SCG.HashSet(Records[maxPos].Keys.Select(r => r.Sequence));
          foreach (sequence when sequence.ParsingSequence.SequenceInfo != null in sequences)
          {
            //when (sequence.IsToken && !sequence.ParsingSequence.CanConsumeErrorTokens)
            //  continue;
            foreach (subrule in sequence.ParsedSubrules.NToArray())//TODO optimize
              when (subrule.State >= 0 && subrule.End == maxPos)
              {
                def record = ParseRecord(sequence, subrule.State, subrule.Begin);
                PredictionOrScanning(record, Records[record.ParsePos][record], false);
              }
          }
          Parse();
        }
        while (count < Records[maxPos].Count);
      }
      while (maxPos < MaxPos);
    }
  }
}
