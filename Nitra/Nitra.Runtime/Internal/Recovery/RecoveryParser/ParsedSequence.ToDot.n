using Nemerle;
using Nemerle.Collections;
using Nemerle.Imperative;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;

using System.Text;
using SCG = System.Collections.Generic;

namespace Nitra.Internal.Recovery
{
  partial class ParsedSequence
  {
    public MakeGraph(parsedSubrules : Seq[ParsedSubrule]) : Hashtable[int * int, list[ParsedSubrule]]
    {
      def nodes         = SCG.HashSet();
      def nodeEdges     = Hashtable();
      
      foreach (subrule in parsedSubrules)
      {
        def key = (subrule.State, subrule.Begin);
        mutable edges;
        unless (nodeEdges.TryGetValue(key, out edges))
          edges = [];
        nodeEdges[key] = subrule :: edges;
      }
      
      foreach (subrule in parsedSubrules)
      {
        def stateIndex = subrule.State;
        def state      = this.ParsingSequence.States[stateIndex];
        def from       = (stateIndex, subrule.Begin);

        _ = nodes.Add(from);
        
        foreach (nextStateIndex in state.Next)
        {
          def to = (nextStateIndex, subrule.End);
          _ = nodes.Add(to);
        }
      }

      foreach (node in nodes)
      {
        mutable edges;
        unless (nodeEdges.TryGetValue(node, out edges))
          nodeEdges[node] = [];
      }
      
      nodeEdges
    }

    public FindValidPaths(graph : Hashtable[int * int, list[ParsedSubrule]], end : int) : Hashtable[int * int, int]
    {
      def nodeData = Hashtable.[int * int, int]();
      def walk(stateIndex : int, pos : int) : int
      {
        def key = (stateIndex, pos);
        mutable res;
        when (nodeData.TryGetValue(key, out res))
          return res;
          
        when (stateIndex < 0)
        {
          res = if (pos == end) 1 else 0;
          nodeData[key] = res;
          return res;
        }
        
        nodeData[key] = int.MaxValue;
        
        def edges = graph[key];
        
        foreach (nextStateIndex in this.ParsingSequence.States[stateIndex].Next)
        {
          foreach (edge in edges)
          {
            def res2 = walk(nextStateIndex, edge.End);
            
            when (res2 == 1)
              res = res2;
          }
        }
        
        nodeData[key] = res;
        res
      }
      
      def startPos = this.StartPos;
      
      foreach (stateIndex in this.ParsingSequence.StartStates)
        when (graph.ContainsKey(stateIndex, startPos))
          _ = walk(stateIndex, startPos);
      
      nodeData
    }
    
    public ToDot(parsedSubrules : Seq[ParsedSubrule], end : int) : string
    {
      when (GetUrl(this.StartPos, end) == "0-LocalVariable-LocalVariableDeclaration_'_'_S_-6.svg")
      {
        assert2(true);
      }

      def isValidNode(nodeData : Hashtable[int * int, int], node) : bool
      {
        mutable res;
        when (nodeData.TryGetValue(node, out res))
          return res == 1;
          
        false
      }

      def nodeData = FindValidPaths(MakeGraph(this.ParsedSubrules), end);
        
      def nodes         = SCG.HashSet();
      def edges         = SCG.List();
      def startPos      = this.StartPos;
      
      foreach (subrule in parsedSubrules)
      {
        def stateIndex  = subrule.State;
        def state       = this.ParsingSequence.States[stateIndex];
        def from        = (stateIndex, subrule.Begin);
        def isFromValid = isValidNode(nodeData, from);
        def ins         = SubruleMandatoryTokenCount(stateIndex);
        def skip        = subrule.IsEmpty && ins > 0;
        def text        = 
          if (subrule.IsEmpty)
            "Ins: " + ins
          else
            X.EscapeString(subrule.Length + ":«" + this.RecoveryParser.ParseResult.Text.Substring(subrule.Begin, subrule.Length) + "»");
        
        _ = nodes.Add(from);
        
        foreach (nextStateIndex in state.Next)
        {
          def end = subrule.End;
          def to = (nextStateIndex, subrule.End);
          _ = nodes.Add(to);
          def style = (if (skip)  " fontcolor=red" else "")
                    + (if (isFromValid && isValidNode(nodeData, to)) " color=green" else "");
          
          def subSeqs = 
            if (subrule.IsEmpty)
              array(0)
            else
              this.GetSequencesForSubrule(subrule).ToArray();
          
          match (subSeqs.Length)
          {
            | 0 => edges.Add($<#$(Name(from)) -> $(Name(to)) [label="$text"$style$(if (subrule.IsEmpty) "" else " fontcolor=purple")]#>);
            | 1 =>
              def subSeq = subSeqs[0];
              def url = subSeq.GetUrl(subSeq.StartPos, end);
              def text2 = if (this.ParsingSequence is ParsingSequence.Extensible) subSeq.ParsingSequence.RuleName + " - " + text else text;
              edges.Add($<#$(Name(from)) -> $(Name(to)) [label="$text2"$style URL="$url"]#>);
              
            | _ => // делаем промежуточный файл
              assert2(this.ParsingSequence is ParsingSequence.Extensible);
              def edges2 = SCG.List();
              
              foreach (subSeq in subSeqs)
              {
                def url = subSeq.GetUrl(subSeq.StartPos, end);
                edges2.Add($<#<a href="$url" style="text-decoration: initial; font-size: 20px;">$(subSeq.ParsingSequence.RuleName)</a>#>);
              }
              //GetFilePathForExtensible
              def htmlContent = $<#
<?xml version="1.0" encoding="utf-8"?>
<html>
  <head>
    <title>$RuleName</title>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  </head>
  <body>
  <pre>
  $text
  
..$(edges2; "\r\n")
  </pre>
  </body>
</html> #>;
              def htmlPath = GetFilePathForExtensible(this.StartPos, end);
              File.WriteAllText(htmlPath, htmlContent);
              
              def url = this.GetUrlForExtensible(this.StartPos, end);
              def text2 = this.RuleName + " - " + text;
              edges.Add($<#$(Name(from)) -> $(Name(to)) [label="$text2"$style URL="$url"]#>);
          }
        }
      }

      def nodes2 = SCG.List();
      def printNodeData(nodeData, node)
      {
        mutable res;
        when (nodeData.TryGetValue(node, out res))
          return $"$node - $res";
        $"$node - 0"
      }
      
      foreach ((stateIndex, pos) as node in nodes)
      {
        def border  = if (stateIndex <= 0) " peripheries=2" else "";
        def shape   = if (stateIndex < 0) " shape=box" else "";
        def bkcolor = if (isValidNode(nodeData, node))                                                                " color=green"
                      else                                                                                            "";
        nodes2.Add($<#$(Name(node)) [label="$(Label(node) + " -- " + printNodeData(nodeData, node))"$border$shape$bkcolor]#>);
      }

      def graphLabel = this.ParsingSequence.GraphLabel() + "\r\n" + X.DotEscape(this.RecoveryParser.ParseResult.DebugText) + "\r\n\r\n";
      
      def content = $<#
        digraph RecoveryParser
        {
          rankdir=LR;
          compound=true;
          label="$graphLabel";
          fontname="Consolas";
    
          ..$(nodes2; "\r\n          ")
    
          ..$(edges; "\r\n          ")
        }
      #>;
      
      content
    }

    /// Return generated 
    public ToDot(files : SCG.List[string], end : int = -1) : void
    {
      def visited = HashSet();
      ToDot(visited, files, end)
    }
    
    /// Return generated 
    public ToDot(visited : HashSet[ParsedSequence * int], files : SCG.List[string], end : int = -1) : void
    {
      when (ParsedSubrules.Count > 0)
        ToDot(visited, files, ParsedSubrules, end);
    }
    
    /// Return generated 
    public ToDot(visited : HashSet[ParsedSequence * int], files : SCG.List[string], parsedSubrules : Seq[ParsedSubrule], end : int = -1) : void
    {
      when (this.ParsingSequence.SequenceInfo == null && this.ParsingSequence.RuleName == "Root")
        return;
        
      if (end >= 0)
      {
        unless (visited.Add((this, end)))
          return;

        def fileName = GetFilePath(this.StartPos, end);
        File.WriteAllText(fileName, ToDot(parsedSubrules, end));
        files.Add(fileName);
      }
      else foreach (end2 in this.Ends)
      {
        def end = end2.Key;
        
        unless (visited.Add((this, end)))
          continue;

        def fileName = GetFilePath(this.StartPos, end);
        File.WriteAllText(fileName, ToDot(parsedSubrules, end));
        files.Add(fileName);
      }
    }
    
    GetUrlForExtensible(startPos : int, end : int) : string
    {
      Path.GetFileName(GetFilePath(startPos, end)) + "-Extensions.html"
    }
    
    GetUrl(startPos : int, end : int) : string
    {
      Path.GetFileName(GetFilePath(startPos, end)) + ".svg"
    }
    
    public GetFilePathForExtensible(startPos : int, end : int) : string
    {
      GetFilePath(startPos, end) + "-Extensions.html"
    }
    
    public GetFilePath(startPos : int, end : int) : string
    {
      def escape(str : string) : string
      {
        def sb = StringBuilder(str);
        
        _ = sb.Replace("*", "ZERO_LOOP");
        _ = sb.Replace("+", "ONE_ZERO_LOOP");
        _ = sb.Replace("?", "OPT");
        
        foreach (ch in Path.GetInvalidPathChars())
          _ = sb.Replace(ch, '_');
          
        _ = sb.Replace(Path.PathSeparator, '_');
        _ = sb.Replace(Path.VolumeSeparatorChar, '_');
        _ = sb.Replace('<', '_');
        _ = sb.Replace('>', '_');
        _ = sb.Replace('/', '_');
        _ = sb.Replace('\\', '_');
        _ = sb.Replace(' ', '_');
        _ = sb.Replace('\t', '_');
        _ = sb.Replace('\n', '_');
        _ = sb.Replace('\r', '_');
        _ = sb.Replace("____", "_");
        _ = sb.Replace("___", "_");
        _ = sb.Replace("__", "_");
        
        sb.ToString()
      }
      def fileName = 
        match (this.ParsingSequence)
        {
          | Sequence as seq => startPos + "-" + seq.RuleName + "-" + escape(seq.RuleDesc) + "-" + end
          | seq => startPos + "-" + seq.RuleName + "-" + end
        };
      def filePath = Path.Combine(Path.GetTempPath(), "Dot", fileName);//$<#..$(ruleParser.Grammar.Grammars; "-"; g => g.Name)#>
      def dir = Path.GetDirectoryName(filePath);
      unless (Directory.Exists(dir))
        _ = Directory.CreateDirectory(dir);
      filePath
    }
    
    Label(stateIndex : int, pos : int) : string
    {
      def label =
        match (stateIndex)
        {
          | -1 => "End"
          | s  => X.DotEscape(this.ParsingSequence.States[s].Description)
        };

      "State: " + stateIndex + "At: " + pos + "\r\n" + label
    }

    Name(stateIndex : int, pos : int) : string
    {
      "Node_State_" + (if (stateIndex < 0) "End" else stateIndex.ToString()) + "_Pos_" + pos
    }
  }
}
