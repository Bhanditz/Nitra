using Nemerle;
using Nemerle.Collections;
using Nemerle.Imperative;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;

using System.Text;
using SCG = System.Collections.Generic;

namespace Nitra.Internal.Recovery
{
  partial class ParsedSequence
  {
    public ToDot(parsedSubrules : Seq[ParsedSubrule], end : int) : string
    {
      when (GetUrl(this.StartPos, end) == "StartPos_3_Rule_Expression_End_5.svg")
      {
        assert2(true);
      }
        
      def nodes    = SCG.HashSet();
      def edges    = SCG.List();
      def startPos = this.StartPos;
      
      foreach (subrule in parsedSubrules)
      {
        def stateIndex = subrule.State;
        def state      = this.ParsingSequence.States[stateIndex];
        def from       = (stateIndex, subrule.Begin);
        def ins        = SubruleMandatoryTokenCount(stateIndex);
        def skip       = subrule.IsEmpty && ins > 0;
        def text       = 
          if (subrule.IsEmpty)
            "Ins: " + ins
          else
            X.EscapeString(subrule.Length + ":«" + this.RecoveryParser.ParseResult.Text.Substring(subrule.Begin, subrule.Length) + "»");
        
        _ = nodes.Add(from);
        
        foreach (nextStateIndex in state.Next)
        {
          def end = subrule.End;
          def to = (nextStateIndex, subrule.End);
          _ = nodes.Add(to);
          def style = if (skip) " color=red fontcolor=red" else "";
          
          def subSeqs = this.GetSequencesForSubrule(subrule).ToArray();
          
          foreach (subSeq in subSeqs)
          {
            def url = subSeq.GetUrl(subSeq.StartPos, end);
            def text2 = if (this.ParsingSequence is ParsingSequence.Extensible) subSeq.ParsingSequence.RuleName + " - " + text else text;
            edges.Add($<#$(Name(from)) -> $(Name(to)) [label="$text2"$style URL="$url"]#>);
          }
          otherwise
            edges.Add($<#$(Name(from)) -> $(Name(to)) [label="$text"$(if (subrule.IsEmpty) style else " color=purple fontcolor=purple")]#>);
        }
      }

      def nodes2 = SCG.List();
      
      foreach ((stateIndex, pos) as node in nodes)
      {
        def border  = if (stateIndex <= 0) " peripheries=2" else "";
        def shape   = if (stateIndex < 0) " shape=box" else "";
        def bkcolor = if (stateIndex < 0 && pos == end)                                                               " color=green"
                      else if (stateIndex >= 0 && this.ParsingSequence.States[stateIndex].IsStart && pos == startPos) " color=blue"
                      else                                                                                            "";
        nodes2.Add($<#$(Name(node)) [label="$(Label(node))"$border$shape$bkcolor]#>);
      }

      def graphLabel = this.ParsingSequence.GraphLabel() + "\r\n" + X.DotEscape(this.RecoveryParser.ParseResult.DebugText) + "\r\n\r\n";
      
      def content = $<#
        digraph RecoveryParser
        {
          rankdir=LR;
          compound=true;
          label="$graphLabel";
          fontname="Consolas";
    
          ..$(nodes2; "\r\n          ")
    
          ..$(edges; "\r\n          ")
        }
      #>;
      
      content
    }

    /// Return generated 
    public ToDot(files : SCG.List[string], end : int = -1) : void
    {
      def visited = HashSet();
      ToDot(visited, files, end)
    }
    
    /// Return generated 
    public ToDot(visited : HashSet[ParsedSequence * int], files : SCG.List[string], end : int = -1) : void
    {
      ToDot(visited, files, ParsedSubrules, end);
    }
    
    /// Return generated 
    public ToDot(visited : HashSet[ParsedSequence * int], files : SCG.List[string], parsedSubrules : Seq[ParsedSubrule], end : int = -1) : void
    {
      when (this.ParsingSequence.SequenceInfo == null && this.ParsingSequence.RuleName == "Root")
        return;
        
      if (end >= 0)
      {
        unless (visited.Add((this, end)))
          return;

        def fileName = GetFilePath(this.StartPos, end);
        File.WriteAllText(fileName, ToDot(parsedSubrules, end));
        files.Add(fileName);
      }
      else foreach (end2 in this.Ends)
      {
        def end = end2.Key;
        
        unless (visited.Add((this, end)))
          continue;

        def fileName = GetFilePath(this.StartPos, end);
        File.WriteAllText(fileName, ToDot(parsedSubrules, end));
        files.Add(fileName);
      }
    }
    
    GetUrl(startPos : int, end : int) : string
    {
      Path.GetFileName(GetFilePath(startPos, end)) + ".svg"
    }
    
    GetFilePath(startPos : int, end : int) : string
    {
      def escape(str : string) : string
      {
        def sb = StringBuilder(str);
        
        _ = sb.Replace("*", "ZERO_LOOP");
        _ = sb.Replace("+", "ONE_ZERO_LOOP");
        _ = sb.Replace("?", "OPT");
        
        foreach (ch in Path.GetInvalidPathChars())
          _ = sb.Replace(ch, '_');
          
        _ = sb.Replace(Path.PathSeparator, '_');
        _ = sb.Replace(Path.VolumeSeparatorChar, '_');
        _ = sb.Replace(' ', '_');
        _ = sb.Replace('\t', '_');
        _ = sb.Replace('\n', '_');
        _ = sb.Replace('\r', '_');
        _ = sb.Replace("____", "_");
        _ = sb.Replace("___", "_");
        _ = sb.Replace("__", "_");
        
        sb.ToString()
      }
      def ruleParser = 
        match (this.ParsingSequence)
        {
          | Extensible as ext => ext.RuleParser : RuleParser
          | _ => ParsingSequence.SequenceInfo.Parser :> RuleParser
        };
      def fileName = 
        match (this.ParsingSequence)
        {
          | Sequence as seq => "StartPos_" + startPos + "_Rule_" + seq.RuleName + "_Subseq_" + escape(seq.RuleDesc) + "_End_" + end
          | seq => "StartPos_" + startPos + "_Rule_" + seq.RuleName + "_End_" + end
        };
      def filePath = Path.Combine(Path.GetTempPath(), "Nitra", "Dot", $<#..$(ruleParser.Grammar.Grammars; "-"; g => g.Name)#>, fileName);
      def dir = Path.GetDirectoryName(filePath);
      unless (Directory.Exists(dir))
        _ = Directory.CreateDirectory(dir);
      filePath
    }
    
    Label(stateIndex : int, pos : int) : string
    {
      def label =
        match (stateIndex)
        {
          | -1 => "End"
          | s  => X.DotEscape(this.ParsingSequence.States[s].Description)
        };

      "State: " + stateIndex + "At: " + pos + "\r\n" + label
    }

    Name(stateIndex : int, pos : int) : string
    {
      "Node_State_" + (if (stateIndex < 0) "End" else stateIndex.ToString()) + "_Pos_" + pos
    }
  }
}
