using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Imperative;
using Nemerle.Extensions;

using Nitra.Runtime.Reflection;

using System;
using System.Linq;

using SCG = System.Collections.Generic;

namespace Nitra.Internal.Recovery
{
  [Record]
  public variant ParsingState
  {
    public Id                    : int                          { get; internal set; }
    public Next                  : array[int]                   { get; internal set; }
    public Prev                  : array[int]                   { get; internal set; }
    public IsStart               : bool                         { get; internal set; }
    //public IsEnd                 : bool                         { get; internal set; }
    public Subrule               : SubruleInfo                  { get; } // TODO: переименовать .Subrule в SubruleInfo
    public CanConsumeErrorTokens : bool                         { get; }

    | Simple            { RuleParser    : SimpleRuleParser; }
    | DynamicExtensible { Sequence      : ParsingSequence; }
    | DynamicExtensibleItem { }
    | Extensible        { RuleParser    : ExtensibleRuleParser; }
    | ExtensionPrefix   { RuleParser    : ExtensibleRuleParser; }
    | ExtensionPostfix  { RuleParser    : ExtensibleRuleParser; }
    | Subsequence       { Sequence      : ParsingSequence; SequenceInfo : SequenceInfo; }
    | List              { Sequence      : ParsingSequence; }
    | ListWithSeparator { Sequence      : ParsingSequence; }
    | Scan              { }
    | Predicate         { HeadPredicate : SubruleInfo.PredicateDelegate; }

    public Description : string
    {
      get
      {
        match (this)
        {
          | Simple            as state => state.RuleParser.Descriptor.Name
          | DynamicExtensible          => this.Subrule.ToString()
          | DynamicExtensibleItem      => "DynamicExtensibleItem"
          | Extensible        as state => state.RuleParser.Descriptor.Name + if (state.RuleParser.BindingPower > 0) " ^ " + state.RuleParser.BindingPower else null
          | ExtensionPrefix   as state => state.RuleParser.Descriptor.Name + " Prefix"
          | ExtensionPostfix  as state => state.RuleParser.Descriptor.Name + " Postfix"
          | List                       => this.Subrule.ToString()
          | ListWithSeparator          => this.Subrule.ToString()
          | Subsequence       as state => state.SequenceInfo.Description
          | Scan              as state => state.Subrule?.Description ?? "Root"
          | Predicate                  => "Predicate"
        }
      }
    }

    public override ToString() : string
    {
      $"$Id $(Next.NToList()) $(Prev.NToList()) $Description"
    }
  }
}
