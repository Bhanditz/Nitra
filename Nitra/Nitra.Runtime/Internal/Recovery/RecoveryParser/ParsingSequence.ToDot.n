using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;

using SCG = System.Collections.Generic;

namespace Nitra.Internal.Recovery
{
  public partial class ParsingSequence
  {
    public ToDot() : string
    {
      def nodes = SCG.List();
      def edges = SCG.List();

      foreach (state in States)
      {
        nodes.Add($<#$(Name(state)) [label="$(Label(state))"]#>);
        foreach (next in state.Next)
        {
          if (next < 0)
            edges.Add($<#$(Name(state)) -> End#>);
          else
            edges.Add($<#$(Name(state)) -> $(Name(States[next]))#>);
        }
      }
        
      nodes.Add(<#End [label="-1: End"]#>);
      
      def graphLabel = RuleName ?? RuleDesc;
      def content = $<#
        digraph RecoveryParser
        {
          rankdir=LR;
          compound=true;
          label="$graphLabel";
    
          ..$(nodes; "\r\n          ")
    
          ..$(edges; "\r\n          ")
        }
      #>;
      
      content
    }
    
    public Visualize() : void
    {
      def fileName = GetFilePath();
      File.WriteAllText(fileName, ToDot());
      X.ConvertToDot(fileName);
    }
    
    GetFilePath() : string
    {
      def path = Path.Combine(Path.GetTempPath(), "Nitra", "Dot", $<#..$(this.RuleParser.Grammar.Grammars; "-"; g => g.Name)#>,
        this.RuleParser.Descriptor.Name);
      def filePath = path + ".dot";
      def dir = Path.GetDirectoryName(filePath);
      unless (Directory.Exists(dir))
        _ = Directory.CreateDirectory(dir);
      filePath
    }
    
    Label(state : ParsingState) : string
    {
      state.Id + ": " + X.DotEscape(state.Description)
    }

    Name(state : ParsingState) : string
    {
      "State" + state.Id
    }
  }
}
