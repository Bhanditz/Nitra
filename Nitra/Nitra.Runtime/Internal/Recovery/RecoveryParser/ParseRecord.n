using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Imperative;
using Nemerle.Extensions;

using Nitra.Runtime.Reflection;

using System;
using System.Linq;

using SCG = System.Collections.Generic;

namespace Nitra.Internal.Recovery
{
  [Record, StructuralEquality]
  public struct ParseRecord
  {
    public Sequence     : ParsedSequence;
    public State        : int;
    public ParsePos     : int;

    public ParsingState : ParsingState { get { Sequence.ParsingSequence.States[State] } }

    public IsComplete : bool        { get { State == -1 } }

    public Next(next : int, parsePos : int) : ParseRecord
    {
      assert3(!IsComplete);
      ParseRecord(Sequence, next, parsePos);
    }

    public IsNullable : bool
    {
      get
      {
        match (ParsingState)
        {
          | Simple                as state => state.RuleParser.ParsingSequence.IsNullable
          | Extensible                     => false
          | ExtensionPrefix                => false
          | ExtensionPostfix               => false
          | Subsequence           as state => state.Sequence.IsNullable
          | List                  as state => state.Subrule.MandatoryTokenCount == 0
          | ListWithSeparator     as state => state.Subrule.MandatoryTokenCount == 0
          | Scan                  as state => if (state.Subrule == null) false else state.Subrule.CanParseEmptyString
          | Predicate                      => false
          | DynamicExtensible              => false
          | DynamicExtensibleItem          => false
        }
      }
    }

    public MandatoryTokenCount : int
    {
      get
      {
        match (ParsingState)
        {
          | Simple                as state => state.RuleParser.SequenceInfo.MandatoryTokenCount
          | Extensible            as state => state.RuleParser.MandatoryTokenCount
          | ExtensionPrefix       as state => state.RuleParser.MandatoryTokenCount
          | ExtensionPostfix               => 0
          | Subsequence           as state => state.SequenceInfo.MandatoryTokenCount
          | List                  as state => state.Subrule.MandatoryTokenCount
          | ListWithSeparator     as state => state.Subrule.MandatoryTokenCount
          | Scan                  as state => state.Subrule.MandatoryTokenCount
          | Predicate                      => 0
          | DynamicExtensible     as state => state.Subrule.MandatoryTokenCount
          | DynamicExtensibleItem          => Sequence.DynamicRules[this].MandatoryTokenCount
        }
      }
    }

    public CalleeSequences : Seq[ParsingSequence]
    {
      get
      {
        match (ParsingState)
        {
          | Scan                       => ()
          | Predicate                  => ()
          | Simple            as state => yield state.RuleParser.ParsingSequence
          | List              as state => yield state.Sequence
          | ListWithSeparator as state => yield state.Sequence
          | Subsequence       as state => yield state.Sequence
          | Extensible        as state => yield state.RuleParser.ParsingSequence
          | ExtensionPrefix   as state =>
            foreach (parser in state.RuleParser.PrefixRules)
              yield parser.ParsingSequence;

          | ExtensionPostfix  as state =>
            foreach (parser in state.RuleParser.PostfixRules)
              when (state.RuleParser.FirstPostfixRuleId <= parser.RuleId)
                yield parser.ParsingSequence;

          | DynamicExtensible as state => yield state.Sequence
          | DynamicExtensibleItem =>
            yield Sequence.DynamicRules[this].ParsingSequence
        }
      }
    }

    public override ToString() : string
    {
      ToString(ParsePos)
    }

    public ToString(curPos : int) : string
    {
      def sb = Text.StringBuilder();
      Sequence.ToString(sb, State, curPos);
      sb.ToString()
    }
  }
}
