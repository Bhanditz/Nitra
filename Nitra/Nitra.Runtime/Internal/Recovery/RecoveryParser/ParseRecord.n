using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Imperative;
using Nemerle.Extensions;

using Nitra.Runtime.Reflection;

using System;
using System.Linq;

using SCG = System.Collections.Generic;

namespace Nitra.Internal.Recovery
{
  [Record, StructuralEquality]
  public struct ParseRecord
  {
    public Sequence : ParsedSequence;
    public State    : int;
    public ParsingState : ParsingState { get { Sequence.ParsingSequence.States[State] } }
    /// Debug only. Position from we try parse this record.
    [EqualsIgnore]
    public mutable ParsePos : int;

    public IsComplete : bool        { get { State == -1 } }

    public Next(next : int) : ParseRecord
    {
      assert3(!IsComplete);
      ParseRecord(Sequence, next, -1);
    }

    public override ToString() : string
    {
      ToString(ParsePos)
    }
    
    public ToString(curPos : int) : string
    {
      def contains[T](ary : array[T], value : T) : bool
      {
        Array.IndexOf(ary, value) >= 0
      }
      def isNullableLoop(state : ParsingState, seq : ParsingSequence, withSeparator : bool) : bool
      {
        def nextIndex = if (withSeparator) state.Id + 2 else state.Id + 1;
        seq.IsNullable 
          || contains(seq.StartStates, state.Id) && contains(seq.StartStates, nextIndex) 
          || state.Prev.Any(s => s < state.Id && (contains(seq.States[s].Next, nextIndex) || contains(seq.States[s].Next, -1)))
      }
      def printState(sb, state)
      {
        _ = sb.Append(state.Id).Append(":").Append(state.Description);
      }
      def sb       = Text.StringBuilder();
      def startPos = Sequence.StartPos;
      def seq      = this.Sequence.ParsingSequence;
      def bp       = if (seq.RuleParser is ExtensibleRuleParser as p) p.BindingPower else 0;

      _ = sb.Append("(");
      
      mutable skip = false;
      foreach (state in seq.States)
      {
        when (skip)
        {
          skip = false;
          continue;
        }
        
        when (state.Id > 0)
          _ = sb.Append("  ");
        when (State == state.Id)
          _ = sb.Append("●  ");
          
        if (contains(state.Next, state.Id)) // loop
        {
          _ = sb.Append("(");
          printState(sb, state);
          _ = sb.Append(")");
          if (isNullableLoop(state, seq, withSeparator=false))
            _ = sb.Append("*");
          else
            _ = sb.Append("+");
        }
        else if (contains(state.Next, state.Id + 1) && contains(seq.States[state.Id + 1].Next, state.Id)) // loop with separator
        {
          _ = sb.Append("(");
          printState(sb, state);
          _ = sb.Append("; ");
          def sepState = seq.States[state.Id + 1];
          printState(sb, sepState);
          when (sepState.Next.Length > 1)
            _ = sb.Append("; ?");
          _ = sb.Append(")");
          if (isNullableLoop(state, seq, withSeparator=true))
            _ = sb.Append("*");
          else
            _ = sb.Append("+");
          skip = true;
        }
        else
          printState(sb, state);
      }
        
      when (State == -1)
          _ = sb.Append(" ♦");
        
      when (bp > 0)
        _ = sb.Append(" ^ " + bp);
        
      _ = sb.Append(", StartPos=");
        
      _ = sb.Append(startPos);
      _ = sb.Append(")");

      //when (IsSpeculative)
      //  _ = sb.Append(" !!! ");
        
      def text = this.Sequence.RecoveryParser.ParseResult.Text;
          
      when (startPos <= text.Length)
      {
        _ = sb.Append("   «");
        def showLen = 30;
            
        when (startPos - showLen > 0)
          _ = sb.Append("…");

        _ = sb.Append(text.SafeLeftSubstring(startPos, showLen));
            
        _ = sb.Append("■");
            
        def middle = if (curPos >= 0) curPos - startPos else showLen;
        
        _ = sb.Append(text.SafeRightSubstring(startPos, middle));
        
        when (curPos >= 0)
          _ = sb.Append("▸");
        
        when (middle < showLen)
        _ = sb.Append(text.SafeRightSubstring(startPos + middle, showLen - middle));
              
        when (startPos + showLen <= text.Length)
          _ = sb.Append("…");
              
        _ = sb.Append("»");
      }
        
      sb.ToString()
    }
  }
}
