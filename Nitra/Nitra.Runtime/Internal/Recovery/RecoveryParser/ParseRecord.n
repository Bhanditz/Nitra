using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Imperative;
using Nemerle.Extensions;

using Nitra.Runtime.Reflection;

using System;
using System.Linq;

using SCG = System.Collections.Generic;

namespace Nitra.Internal.Recovery
{
  [Record, StructuralEquality]
  public struct ParseRecord
  {
    public Sequence : ParsedSequence;
    public Index    : int;

    public IsComplete : bool        { get { Index >= Sequence.SubruleCount } }
    public CurSubrule : SubruleInfo { get { Sequence.GetSubrule(Index) } }

    public Next() : ParseRecord
    {
      assert3(!IsComplete);
      ParseRecord(Sequence, Index + 1);
    }

    public override ToString() : string
    {
      def sb = Text.StringBuilder();
      def startPos = Sequence.StartPos;
        
      _ = sb.Append("(");
        
      def name = 
        match (Sequence)
        {
          | Simple                     => "Simple     "
          | Extension                  => "Extension  "
          | Option                     => "Option     "
          | List                       => "List       "
          | ListWithSeparatorRule      => "ListRule   "
          | ListWithSeparatorSeparator => "ListSep    "
          | Root                       => "Root       "
          | Extensible                 => "Extensible "
        };

      _ = sb.Append(name);
        
      when (Sequence.HasName)
      {
        _ = sb.Append(Sequence.Name);
        _ = sb.Append(" = ");
      }
      match (Sequence)
      {
        | ParsedSequence.Root            => _ = sb.Append("Root");
        | ParsedSequence.Extensible as r => _ = sb.Append("Extensible: " + r.RuleParser.RuleName );
        | _ =>
          def subruleCount = Sequence.SubruleCount;
          
          for (mutable i = 0; i < subruleCount; i++)
          {
            def r = Sequence.GetSubrule(i);
          
            when (i > 0)
              _ = sb.Append("  ");
            when (Index == i)
              _ = sb.Append("●  ");
            
            _ = sb.Append(r);
          }
        
          when (Index == subruleCount)
              _ = sb.Append(" ♦");
        
          _ = sb.Append(", StartPos=");
        
          _ = sb.Append(startPos);
          _ = sb.Append(")");
      }

      //when (IsSpeculative)
      //  _ = sb.Append(" !!! ");
        
      def text = this.Sequence.RecoveryParser.ParseResult.Text;
          
      when (startPos <= text.Length)
      {
        _ = sb.Append("   «");
        def showLen = 30;
            
        when (startPos - showLen > 0)
          _ = sb.Append("…");

        _ = sb.Append(text.SafeLeftSubstring(startPos, showLen));
            
        _ = sb.Append("■");
            
        when (startPos + showLen <= text.Length)
          _ = sb.Append("…");
              
        _ = sb.Append(text.SafeRightSubstring(startPos, showLen));
              
        _ = sb.Append("»");
      }
        
      sb.ToString()
    }
  }
}
