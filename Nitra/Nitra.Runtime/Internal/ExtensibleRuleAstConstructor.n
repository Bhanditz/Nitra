using Nitra;

using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Imperative;

using System;
using System.Collections.Generic;

namespace Nitra.Internal
{
  public module ExtensibleRuleAstConstructor
  {
    public Create[T](startPos : int, endPos : int, parseResult : ParseResult, bindingPower : int, ruleDescriptor : ExtensibleRuleDescriptor, astFactory : IExtensibleRuleAstFactory[T]) : T
    {
      def ruleParser = parseResult.RuleParser.Grammar.GetExtensibleRuleParser(ruleDescriptor, bindingPower);

      mutable recoveredSequence;
      if (parseResult.RecoveredSequences.TryGetValue((startPos, endPos, ruleParser.ParsingSequence), out recoveredSequence))
      {
        match (recoveredSequence)
        {
          | Unambiguous(recoveredSubrulesIndex) => CreateImpl(startPos, parseResult, ruleParser, ruleDescriptor, astFactory, recoveredSubrulesIndex)
          | Ambiguous(indexes) =>
            def ambiguities = array(indexes.Length);
            foreach (recoveredSubrulesIndex in indexes with i)
              ambiguities[i] = (null, CreateImpl(startPos, parseResult, ruleParser, ruleDescriptor, astFactory, recoveredSubrulesIndex));
            astFactory.CreateAmbiguous(ambiguities, AstAmbiguityType.Recovery);
        }
      }
      else
      {
        mutable pos = startPos;
        Create(ref pos, parseResult, bindingPower, ruleDescriptor, astFactory)
      }
    }

    private CreateImpl[T](startPos : int, parseResult : ParseResult, ruleParser : ExtensibleRuleParser, ruleDescriptor : ExtensibleRuleDescriptor, astFactory : IExtensibleRuleAstFactory[T], recoveredSubrulesIndex : int) : T
    {
      def (subruleStarts, parsingSequence) = parseResult.RecoveredSubrules[recoveredSubrulesIndex];
      def states = parsingSequence.States;

      def prefixes  = System.Collections.Generic.List();
      def getPrefix()
      {
        match (prefixes.Count)
        {
          | 0 =>
            def ast = astFactory.CreateMissing(parseResult, ruleDescriptor, startPos);
            prefixes.Add(null, ast);
            ast

          | 1 => prefixes[0][1]
          | _ =>
            def ast = astFactory.CreateAmbiguous(prefixes.ToArray(), AstAmbiguityType.Recovery);
            prefixes.Clear();
            prefixes.Add(null, ast);
            ast
        }
      }

      def postfixes = System.Collections.Generic.List();

      for (mutable i = 0; i < subruleStarts.Length - 1; ++i)
      {
        def begin    = subruleStarts[i].Pos;
        def end      = subruleStarts[i + 1].Pos;
        def state    = states[subruleStarts[i].State];

        match (state)
        {
          | ExtensionPrefix =>
            assert(postfixes.Count == 0);

            if (begin == end)
              prefixes.Add(null, astFactory.CreateMissing(parseResult, ruleDescriptor, begin));
            else
              foreach (prefix in ruleParser.PrefixRules)
              {
                mutable prefixRecoveredSequence;
                when (parseResult.RecoveredSequences.TryGetValue((begin, end, prefix.ParsingSequence), out prefixRecoveredSequence))
                {
                  def prefixAst = match (prefixRecoveredSequence)
                  {
                    | Unambiguous(recoveredSubrulesIndex) => astFactory.CreatePrefix(begin, end, recoveredSubrulesIndex, prefix, parseResult)
                    | Ambiguous(indexes) =>
                      def ambiguousPrefixes = array(indexes.Length);
                      foreach (recoveredSubrulesIndex in indexes with n)
                        ambiguousPrefixes[n] = (prefix, astFactory.CreatePrefix(begin, end, recoveredSubrulesIndex, prefix, parseResult));
                      astFactory.CreateAmbiguous(ambiguousPrefixes, AstAmbiguityType.Recovery)
                  };
                  prefixes.Add(prefix, prefixAst);
                }
              }

          | ExtensionPostfix => 
            foreach (postfix in ruleParser.PostfixRules)
            {
              mutable postfixRecoveredSequence;
              when (postfix.RuleId >= ruleParser.FirstPostfixRuleId)
              when (parseResult.RecoveredSequences.TryGetValue((begin, end, postfix.ParsingSequence), out postfixRecoveredSequence))
              {
                def postfixAst = match (postfixRecoveredSequence)
                {
                  | Unambiguous(recoveredSubrulesIndex) => astFactory.CreatePostfix(getPrefix(), startPos, begin, end, recoveredSubrulesIndex, postfix, parseResult);
                  | Ambiguous(indexes) =>
                    def ambiguousPostfixes = array(indexes.Length);
                    foreach (recoveredSubrulesIndex in indexes with n)
                      ambiguousPostfixes[n] = (postfix, astFactory.CreatePrefix(begin, end, recoveredSubrulesIndex, postfix, parseResult));
                    astFactory.CreateAmbiguous(ambiguousPostfixes, AstAmbiguityType.Recovery)
                };
                postfixes.Add(postfix, postfixAst);
              }
            }

          | _ => assert(false, "ExtensionPrefix or ExtensionPostfix expected");
        }
      }

      match (postfixes.Count)
      {
        | 0 => getPrefix()
        | 1 => postfixes[0][1]
        | _ => astFactory.CreateAmbiguous(postfixes.ToArray(), AstAmbiguityType.Postfix)
      }
    }

    public Create[T](pos : ref int, parseResult : ParseResult, bindingPower : int, ruleDescriptor : ExtensibleRuleDescriptor, astFactory : IExtensibleRuleAstFactory[T]) : T
    {
      def ruleParser = parseResult.RuleParser.Grammar.GetExtensibleRuleParser(ruleDescriptor, bindingPower);

      mutable newPos;
      mutable ast = ruleParser.FindFirstPrefix(ref pos, parseResult);
      mutable prefixValue;
      def prefixStartPos = pos;
      if (ast > 0)
      {
        def prefixParserOffset = GetExtensionParserOffset(ruleParser.PrefixRules);

        mutable extensionParser = GetExtensionParser(parseResult, ruleParser.ParserData.PrefixParsers, ast, prefixParserOffset);
        newPos = pos;
        prefixValue = astFactory.CreatePrefix(ref newPos, ast, extensionParser, parseResult);
        ast = ruleParser.FindNextPrefix(ast, parseResult);
        when (ast > 0)
        {
          def firstNewPos = newPos;
          def ambiguitys = System.Collections.Generic.List();
          ambiguitys.Add(extensionParser, prefixValue);
          while (ast > 0)
          {
            def nextExtensionParser = GetExtensionParser(parseResult, ruleParser.ParserData.PrefixParsers, ast, prefixParserOffset);
            newPos = pos;
            def _nextValue = astFactory.CreatePrefix(ref newPos, ast, nextExtensionParser, parseResult);
            assert(newPos == firstNewPos);
            ambiguitys.Add(nextExtensionParser, _nextValue);
            extensionParser = nextExtensionParser;
            ast = ruleParser.FindNextPrefix(ast, parseResult);
          }
          // prefix ambiguity
          prefixValue = astFactory.CreateAmbiguous(ambiguitys.ToArray(), AstAmbiguityType.Prefix);
        }
        pos = newPos;
      }
      else
      {
        // missing prefix
        prefixValue = astFactory.CreateMissing(parseResult, ruleDescriptor, prefixStartPos);
      }

      def postfixParserOffset = GetExtensionParserOffset(ruleParser.PostfixRules);
      mutable extensionParser;
      mutable postfixValue;
      while (pos < parseResult.Text.Length && { ast = ruleParser.FindFirstPostfix(ref pos, parseResult); ast > 0 })
      {
        extensionParser = GetExtensionParser(parseResult, ruleParser.ParserData.PostfixParsers, ast, postfixParserOffset);
        newPos = pos;
        postfixValue = astFactory.CreatePostfix(prefixValue, prefixStartPos, ref newPos, ast, extensionParser, parseResult);
        when (newPos == pos)
          break;
        ast = ruleParser.FindNextPostfix(ast, parseResult);
        when (ast > 0)
        {
          def firstNewPos = newPos;
          def ambiguitys = System.Collections.Generic.List();
          ambiguitys.Add(extensionParser, postfixValue);
          while (ast > 0)
          {
            def nextExtensionParser = GetExtensionParser(parseResult, ruleParser.ParserData.PostfixParsers, ast, postfixParserOffset);
            newPos = pos;
            def _nextValue = astFactory.CreatePostfix(prefixValue, prefixStartPos, ref newPos, ast, nextExtensionParser, parseResult);
            assert(newPos == firstNewPos);
            ambiguitys.Add(nextExtensionParser, _nextValue);
            extensionParser = nextExtensionParser;
            ast = ruleParser.FindNextPostfix(ast, parseResult);
          }
          // postfix ambiguity
          postfixValue = astFactory.CreateAmbiguous(ambiguitys.ToArray(), AstAmbiguityType.Postfix);
        }
        prefixValue = postfixValue;
        pos = newPos;
      }

      prefixValue
    }

    public GetExtensionParserOffset(parsers : array[ExtensionRuleParser]) : int
    {
      //FIXME empty array
      if (parsers.Length > 0) parsers[0].RuleId else 0
    }

    public GetExtensionParser(parseResult : ParseResult, parsers : array[ExtensionRuleParser], astPtr : int, offset : int) : ExtensionRuleParser
    {
      def ruleId = parseResult.ast[astPtr + ExtensibleRuleParser.AstOfs.Id] & ExtensibleRuleParser.AstMask.Id;
      parsers[ruleId - offset]
    }
  }
}
