using Nemerle;
using Nemerle.Collections;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Imperative;

using System;
using System.Reflection;
using System.Collections.Generic;
using System.Linq;

namespace Nitra.Quote
{
  [MacroUsage(MacroPhase.BeforeInheritance, MacroTargets.Assembly)]
  macro QuotationRule(id : string, assemblyName : string, grammarName : string, ruleName : string)
  {
    QuotationImpl.QuotationRule(id, assemblyName, grammarName, ruleName)
  }

  macro Quotation(body, params args : array[PExpr]) : PExpr
    syntax ("quote", "(", args, ")", body)
  {
    match (args.ToNList())
    {
      | [<[ $(id : string) ]>] =>
        def typer = Macros.ImplicitCTX();
        QuotationImpl.Quotation(id, <[ Nitra.Runtime.ChemicalAstContext() ]>, body, typer)

      | [<[ $(id : string) ]>, context] =>
        def typer = Macros.ImplicitCTX();
        QuotationImpl.Quotation(id, context, body, typer)

      | _ => Message.FatalError("Expected quotation rule id and optional ast context expression")
    }
  }

  macro MatchQuotation(matchexpr) : PExpr
    syntax ("quote", matchexpr)
  {
    match (matchexpr)
    {
      | <[ match ($(id : string), $astExpr) { ..$matchCases } ]> =>
        def typer = Macros.ImplicitCTX();
        QuotationImpl.MatchQuotation(id, astExpr, matchCases, typer)

      | <[ match ($_) { ..$_ } ]> => Message.FatalError("Expected quotation rule id")
      | _                         => Message.FatalError("Expected match expression with quotation rule id")
    }
  }

  module QuotationImpl
  {
    public QuotationRule(id : string, assemblyName : string, grammarName : string, ruleName : string) : void
    {
      def assemblies = ManagerClass.Instance.ReferencedAssemblies.Map(_.Assembly);
      match (assemblies.Find(a => a.GetName().Name == assemblyName))
      {
        | Some(a) =>
          foreach (g when g.FullName == grammarName in GrammarDescriptor.GetDescriptors(a))
            foreach (r is StartRuleDescriptor when r.Name == ruleName in g.Rules)
            {
              if (Parsers.ContainsKey(id))
                Message.FatalError($"Quotation rule '$id' already registered")
              else
              {
                def parserHost = ParserHost(() => assemblies);
                Parsers.Add(id, parserHost.DoParsing(_, r))
              }
            }
            otherwise Message.FatalError($"Rule '$ruleName' not found in grammar '$grammarName' from assembly '$a'");
          otherwise Message.FatalError($"Grammar '$grammarName' not found in assembly '$a'");

        | None => Message.FatalError($"Assembly '$assemblyName' is not refrenced");
      }
    }

    public Quotation(id : string, context : PExpr, body : PExpr, typer : Typer) : PExpr
    {
      def (parseResult, offset) = ParseQuotation(id, body);
      match (context)
      {
        | <[ $(ctx : name) ]> =>
          <[ $(parseResult.CreateSplicableAst.[PExpr](QuotationCodeAstBuilder(typer.Manager, typer.Env, offset, () => <[ $(ctx : name) ]>))) ]>

        | expr =>
          <[
            def $("context" : dyn) = $expr;
            $(parseResult.CreateSplicableAst.[PExpr](QuotationCodeAstBuilder(typer.Manager, typer.Env, offset, () => <[ $("context" : dyn) ]>)))
          ]>
      }
    }

    public MatchQuotation(id : string, astExpr : PExpr, matchCases : list[MatchCase], typer : Typer) : PExpr
    {
      def convertPattern(pattern : PExpr) : PExpr
      {
        | <[ _ ]>
        | <[ _ when $_ ]> => pattern
        | <[ $p when $guard ]> =>
          def (parseResult, offset) = ParseQuotation(id, p);
          def newPattern = parseResult.CreateSplicableAst.[PExpr](QuotationPatternAstBuilder(typer.Manager, typer.Env, offset));
          Util.locate(pattern.Location,  <[ $newPattern when $guard ]>)

        | _ =>
          def (parseResult, offset) = ParseQuotation(id, pattern);
          parseResult.CreateSplicableAst.[PExpr](QuotationPatternAstBuilder(typer.Manager, typer.Env, offset))
      }

      def convertMatchCase(matchCase : MatchCase) : MatchCase
      {
        def newPatterns = matchCase.patterns.Map(convertPattern);
        Util.locate(matchCase.Location, <[ case: | ..$newPatterns => $(matchCase.body) ]>)
      }

      def newMatchCases = matchCases.Map(convertMatchCase);
      <[ match ($astExpr) { ..$newMatchCases } ]>
    }

    private ParseQuotation(id : string, expr : PExpr) : ParseResult * TextPoint
    {
      mutable parseCallback;
      if (Parsers.TryGetValue(id, out parseCallback))
      {
        match (expr)
        {
          | Literal(Literal.String(RawString = rawString)) when rawString.StartsWith("<#") =>
            def originalSource = SourceSnapshot(rawString, expr.Location.FileIndex, Location.GetFileName(expr.Location.FileIndex));
            def sourceToParse  = originalSource.WithTextSubstring(2, originalSource.Text.Length - 4); // cut string braces <# #>
            def offset         = expr.Location.Begin;
            def parseResult    = parseCallback(sourceToParse);
            unless (parseResult.IsSuccess)
            {
              foreach (e in parseResult.GetErrors())
              {
                def begin = QuotationUtils.TranslateLineColumn(offset, e.Location.StartLineColumn);
                def end   = QuotationUtils.TranslateLineColumn(offset, e.Location.EndLineColumn);
                Message.Error(Nemerle.Compiler.Location(e.Location.Source.FileIndex, begin, end), e.Message);
              }
            }
            (parseResult, offset)

          | _ => Message.FatalError(expr.Location, "Recursive string literal <#...#> expected");
        }
      }
      else Message.FatalError($"Quotation rule '$id' is not registered")
    }

    private Parsers : Dictionary[string, SourceSnapshot -> Nitra.ParseResult]
    {
      mutable key : object = object();
      get
      {
        if (ManagerClass.Instance.UserData.Contains(key))
          ManagerClass.Instance.UserData[key] :> Dictionary[_, _]
        else
        {
          def table = Dictionary();
          ManagerClass.Instance.UserData.Add(key, table);
          table
        }
      }
    }
  }
}
