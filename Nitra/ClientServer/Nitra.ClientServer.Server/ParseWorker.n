using Nemerle;
using Nemerle.Collections;
using Nemerle.Imperative;
using Nemerle.Text;
using Nemerle.Utility;

using Nitra.ClientServer.Messages;
using Nitra.Declarations;
using Nitra.ProjectSystem;

using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Diagnostics;
using System.Globalization;
using System.Linq;
using System.Threading;

namespace Nitra.ClientServer.Server
{
  class ParseWorker : IDisposable
  {
    _thread      : Thread;
    _cts         : CancellationTokenSource = CancellationTokenSource();
    _incomeQueue : BlockingCollection[ParserMessage];
    _mainQueue   : BlockingCollection[RouterMessage];
    
    public this(incomeQueue : BlockingCollection[ParserMessage], mainQueue : BlockingCollection[RouterMessage])
    {
      _mainQueue   = mainQueue;
      _incomeQueue = incomeQueue;
      _thread      = Thread(ParseWorkerMain);
      _thread.Start()
    }

    ParseWorkerMain() : void
    {
      def thread = Thread.CurrentThread;
      thread.Name = "ParseWorkerMain";
      thread.CurrentCulture = CultureInfo.InvariantCulture;
      
      try
      {
        foreach(m in _incomeQueue.GetConsumingEnumerable(_cts.Token)) 
          ProcessMessage(m)
      }
      catch
      {
        | e is OperationCanceledException => LogCanceled(e);
        | e => LogException(e);
      }
    }      
    
    ProcessMessage(msg : ParserMessage): void
    {
      | ParseFile(fileId, parseSession, source) =>
        Log("ParseFile " + fileId);
        def timer = Stopwatch.StartNew();
        // TODO: add statistics
        //def stat = Statistics;
        //stat?.Parse?.Restart();
        //
        //_parseMessages.Clear();
        //_astMessages.Clear();
        //_typingMessages.Clear();
      
        when (parseSession.CancellationToken.IsCancellationRequested)
          return;

        def parseResult = parseSession.Parse(source);
        _mainQueue.Add(RouterAnswerMessage.FileParsed(fileId, parseResult));

        //stat?.Parse?.Stop();
        LogMsgHandled("ParseFile " + fileId, timer, 200);
      
      | CreateAst(fileId, parseResult) =>
        Log("CreateAst " + fileId);
        def timer = Stopwatch.StartNew();
        when (parseResult.ParseSession.CancellationToken.IsCancellationRequested)
          return;
          
        def parseTree = parseResult.CreateParseTree();
        def astMessages = CompilerMessageList();
        def ast = AstContext.GetAstUntyped(parseTree, astMessages);
        _mainQueue.Add(RouterAnswerMessage.AstCreated(fileId, parseResult.ParseSession.CancellationToken, ast, parseTree));
        LogMsgHandled("CreateAst " + fileId, timer, 100);
        
      | SemanticAnalysisStart(projectId, cancellationToken, projectSupport, files, data) =>
        Log($"SemanticAnalysisStart: ..$(files.Select(_.Title))");
        def timer = Stopwatch.StartNew();
        def compilerMessages = CompilerMessageList();
        projectSupport.RefreshProject(cancellationToken, compilerMessages, files, data);
        _mainQueue.Add(RouterAnswerMessage.SemanticAnalysisFinished(projectId, cancellationToken, compilerMessages));
        LogMsgHandled("SemanticAnalysisStart", timer, 100);
        
      | GetOutlining => ()
    }
    
    public Dispose() : void
    {
      _cts.Cancel();
      _cts.Dispose();
      _thread.Join()
    }

    LogMsgHandled(msg : string, timer : Stopwatch, millisecondToTimeout : int) : void
    {
      ServerUtils.LogMsgHandled(msg, timer, millisecondToTimeout);
    }

    LogCanceled(e : OperationCanceledException) : void
    {
      ServerUtils.LogCanceled(e);
    }
    
    LogException(e : Exception) : void
    {
      ServerUtils.LogException(e);
    }

    Log(msg : string) : void
    {
      ServerUtils.Log(msg);
    }
  }
}
