using Nemerle;
using Nemerle.Collections;
using Nemerle.Imperative;
using Nemerle.Text;
using Nemerle.Utility;

using Nitra.ClientServer.Messages;
using Nitra.Declarations;
using Nitra.ProjectSystem;

using System;
using System.Collections.Concurrent;
using System.Collections.Immutable;
using System.Collections.Generic;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Threading;

namespace Nitra.ClientServer.Server
{
  class ParseWorker : IDisposable
  {
    _thread         : Thread;
    _cts            : CancellationTokenSource = CancellationTokenSource();
    _incomeQueue    : BlockingCollection[ParserMessage];
    _mainQueue      : BlockingCollection[RouterMessage];
    _responseWriter : BinaryWriter;
    
    public this(incomeQueue : BlockingCollection[ParserMessage], mainQueue : BlockingCollection[RouterMessage], responseWriter : BinaryWriter)
    {
      _mainQueue      = mainQueue;
      _incomeQueue    = incomeQueue;
      _responseWriter = responseWriter;
      _thread         = Thread(ParseWorkerMain);
      _thread.Start()
    }

    SendResponse(msg : ServerMessage) : void
    {
      lock (_responseWriter)
        msg.Serialize(_responseWriter);
    }

    ParseWorkerMain() : void
    {
      def thread = Thread.CurrentThread;
      thread.Name = "Parse Worker";
      thread.CurrentCulture = CultureInfo.InvariantCulture;
      try
      {
        foreach(m in _incomeQueue.GetConsumingEnumerable(_cts.Token)) 
        {
          try
            ProcessMessage(m)
          catch
          {
            | e is OperationCanceledException => LogCanceled(e);
            | e => LogException(e);
          }
        }
      }
      catch
      {
        | _ is OperationCanceledException => ()
        | e => LogException(e);
      }
    }      
    
    ProcessMessage(msg : ParserMessage) : void
    {
      | ParseFile(fileId, parseSession, source) =>
        Log("ParseFile " + fileId);
        def timer = Stopwatch.StartNew();
        // TODO: add statistics
        //def stat = Statistics;
        //stat?.Parse?.Restart();
        //
        //_parseMessages.Clear();
        //_astMessages.Clear();
        //_typingMessages.Clear();
      
        when (parseSession.CancellationToken.IsCancellationRequested)
          return;

        def parseResult = parseSession.Parse(source);
        _mainQueue.Add(RouterAnswerMessage.FileParsed(fileId, parseResult));

        //stat?.Parse?.Stop();
        LogMsgHandled("ParseFile " + fileId, timer, 200);
      
      | CreateAst(fileId, parseResult) =>
        Log("CreateAst " + fileId);
        def timer = Stopwatch.StartNew();
        when (parseResult.ParseSession.CancellationToken.IsCancellationRequested)
          return;
          
        def parseTree = parseResult.CreateParseTree();
        def astMessages = CompilerMessageList();
        def ast = AstContext.GetAstUntyped(parseTree, astMessages);
        _mainQueue.Add(RouterAnswerMessage.AstCreated(fileId, parseResult.ParseSession.CancellationToken, ast, parseTree));
        LogMsgHandled("CreateAst " + fileId, timer, 100);
        
      | SemanticAnalysisStart(projectId, cancellationToken, projectSupport, files, data) =>
        Log($"SemanticAnalysisStart: ..$(files.Select(_.Title))");
        def timer = Stopwatch.StartNew();
        def compilerMessages = CompilerMessageList();
        projectSupport.RefreshProject(cancellationToken, compilerMessages, files, data);
        _mainQueue.Add(RouterAnswerMessage.SemanticAnalysisFinished(projectId, cancellationToken, compilerMessages));
        LogMsgHandled("SemanticAnalysisStart", timer, 100);
        
      | CreateOutlining(fileId, parseResult) =>
        Log("CreateOutlining " + fileId);
        def timer     = Stopwatch.StartNew();
        def outlining = List();
        parseResult.GetOutlining(outlining);
        def infos             = ImmutableArray.CreateBuilder(outlining.Count);
        def cancellationToken = parseResult.ParseSession.CancellationToken;
        def version           = parseResult.SourceSnapshot.Version;
        
        foreach (info in outlining with i)
        {
          when (i % 30 == 0 && cancellationToken.IsCancellationRequested)
            return;
          
          def span = Messages.NSpan(info.Span.StartPos, info.Span.EndPos);
          infos.Add(Messages.OutliningInfo(span, info.IsDefaultCollapsed, info.IsImplementation));
        }
     
        when (cancellationToken.IsCancellationRequested)
          return;
        
        SendResponse(ServerMessage.OutliningCreated(fileId, version, infos.MoveToImmutable()));
        LogMsgHandled("CreateOutlining", timer, 50);

      | CreateKeywordHighlighting(fileId, parseResult) =>
        Log("CreateKeywordHighlighting " + fileId);
        def timer     = Stopwatch.StartNew();
        def start     = 0;
        def end       = parseResult.SourceSnapshot.Text.Length;
        def spanInfos = HashSet();
        parseResult.GetSpans(start, end, spanInfos);
        def cancellationToken = parseResult.ParseSession.CancellationToken;
        
        foreach (info in spanInfos with i)
        {
          when (i % 30 == 0 && cancellationToken.IsCancellationRequested)
            return;
          
        }
     
        when (cancellationToken.IsCancellationRequested)
          return;
        
        //SendResponse(ServerMessage.OutliningCreated(fileId, version, infos.MoveToImmutable()));
        LogMsgHandled("CreateKeywordHighlighting", timer, 50);
    }
    
    public Dispose() : void
    {
      _cts.Cancel();
      _cts.Dispose();
      _thread.Join()
    }

    LogMsgHandled(msg : string, timer : Stopwatch, millisecondToTimeout : int) : void
    {
      ServerUtils.LogMsgHandled(msg, timer, millisecondToTimeout);
    }

    LogCanceled(e : OperationCanceledException) : void
    {
      ServerUtils.LogCanceled(e);
    }
    
    LogException(e : Exception) : void
    {
      ServerUtils.LogException(e);
    }

    Log(msg : string) : void
    {
      ServerUtils.Log(msg);
    }
  }
}
