using Nemerle;
using Nemerle.Collections;
using Nemerle.Imperative;
using Nemerle.Text;
using Nemerle.Utility;

using Nitra.Declarations;
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.IO;
using System.IO.Pipes;
using System.Linq;
using System.Text;
using System.Threading;

using NSP = Nitra.ProjectSystem;
using Nitra.ClientServer.Messages;
using Span = Nitra.ClientServer.Messages.NSpan;

namespace Nitra.ClientServer.Server.ProjectSystem
{
  public class File : NSP.File, IDisposable
  {
    // TODO: override ParseResult, Ast, GetParseTree and so on and implement parsing/typing in work threads
    public  Parent                  : Project;
    public  Id                      : int { get; }
    public  CancellationTokenSource : CancellationTokenSource { get; private set; }
    public  DynamicExtensions       : Seq[GrammarDescriptor]  { get; }
    public  IsDisposed              : bool                    { get; private set; }
    public  IsActive                : bool                    { get; private set; }
    public  Version                 : int                     { get; private set; }
            _parseQueue             : BlockingCollection[ParserMessage];
    mutable _fileInfo               : FileInfo;
    mutable _text                   : StringBuilder;
    mutable _snapshot               : SourceSnapshot;
    mutable _name                   : string;
    mutable _parseResult            : IParseResult;
    mutable _ast                    : IAst;
    mutable _parseTree              : ParseTree;
    
    public this(id : int, fullPath : string, parent : Project)
    {
      base(null);
      Id                = id;
      _fileInfo         = FileInfo(fullPath);
      Parent            = parent;
      _name             = IO.Path.GetFileNameWithoutExtension(FullName);
      _parseQueue       = parent.ParseQueue;
      // TODO: Add statistics support.
      
      parent.AddFile(this);
      Log("FileLoaded " + id + ": " + fullPath + " (" + parent.Name + " project)");
    }

    /// Used for in memory text editing (with no file available)
    public this(id : int, name : string, parent : Project, text : string)
    {
      base();
      Id        = id;
      Parent    = parent;
      _snapshot = SourceSnapshot(text, this, 0);
      _text     = StringBuilder(text);
      _name     = name;
      
      parent.AddFile(this);
    }
    
    public Log(msg : string) : void { ServerUtils.Log(msg) }
    
    public override Ast : IAst { get { _ast } }
    public override Language : Language { get { Parent.Language } }
    public override Name : string { get { _name } }
    public override FullName : string { get { _fileInfo.FullName } }
    
    public override GetSource() : SourceSnapshot
    { 
      when (_snapshot == null)
      {
        assert2(_fileInfo != null);
        assert(_fileInfo != null);
        def text  = File.ReadAllText(_fileInfo.FullName, Encoding.UTF8); // TODO: add detect BOM and load UTF-8 if no BOM avalable
        _snapshot = SourceSnapshot(text, this, 0);
        _text     = StringBuilder(text);
      }
      
      _snapshot
    }
    
    public override Length : int
    {
      get
      {
        if (_text == null)
        {
          assert2(_fileInfo != null);
          assert(_fileInfo != null);
          _fileInfo.Length :> int
        }
        else
          _text.Length
      }
    }
    
    public override Project : NSP.Project { get { Parent } }
    
    public Dispose() : void
    {
      when (IsDisposed)
        return;

      def cts = CancellationTokenSource;
      when (cts != null)
      {
        CancellationTokenSource = null;
      
        unless (cts.IsCancellationRequested)
          cts.Cancel();
        cts.Dispose();
      }
      
      IsDisposed = true;
    }
 
    Insert(pos: int, text: string) : void
    {
      _ = _text.Insert(pos, text)
    }
    
    Delete(span: Span) : void
    {
      _ = _text.Remove(span.StartPos, span.Length)
    }
    
    Replace(span: Span, text: string) : void
    {
      Delete(span);
      Insert(span.StartPos, text)
    }
    
    ApplyChange(change : FileChange) : void
    {
      | FileChange.Insert(pos, text)   => Insert(pos, text)
      | FileChange.Delete(span)        => Delete(span)
      | FileChange.Replace(span, text) => Replace(span, text)
    }
    
    public Change(version : int, change : FileChange) : void
    {
      _ = GetSource();
      Version = version;
      ApplyChange(change);
      _snapshot = SourceSnapshot(_text.ToString(), this, version);
      _parseQueue.Add(GetReParseMessage());
    }
    
    public Change(version : int, changes : ImmutableArray[FileChange]) : void
    {
      _ = GetSource();
      Version = version;
      foreach(change in changes)
        ApplyChange(change);
      _snapshot = SourceSnapshot(_text.ToString(), this, version);
      _parseQueue.Add(GetReParseMessage());
    }
    
    // overrides
    
    public GetReParseMessage() : ParserMessage.ParseFile
    {
      def language = Language;
      assert2(language.StartRule != null);
 
      CancellationTokenSource?.Cancel();
      CancellationTokenSource?.Dispose();
      
      when (_ast != null)
      {
        Parent.AstDropped();
        _parseResult = null;
        _ast         = null;
        _parseTree   = null;
      }
      
      def cancellationTokenSource = CancellationTokenSource();
      def cancellationToken       = cancellationTokenSource.Token;
      def source                  = GetSource();
      def parseSession            = ParseSession(language.StartRule, 
                                        language.CompositeGrammar,
                                        cancellationToken = cancellationToken,
                                        dynamicExtensions = Parent.DynamicExtensions);
      CancellationTokenSource = cancellationTokenSource;

      ParserMessage.ParseFile(this.Id, parseSession, source)
    }
    
    public CreateAstMessage(parseResult : IParseResult) : ParserMessage.CreateAst
    {
      _parseResult = parseResult;
      _parseTree   = parseResult.CreateParseTree(); 
      ParserMessage.CreateAst(this.Id, parseResult)
    }
    
    public AstCreated(ast : IAst, parseTree : ParseTree) : void
    {
      _parseTree = parseTree; 
      _ast = ast;
      Parent.AstCreated();
    }
    
    public CreateOutliningMessage(parseResult : IParseResult) : ParserMessage.GetOutlining
    {
      assert2(parseResult != null);
      // VladD2: зачем создавать замыкания на объект который должен жить только в синхронизированном контексте?
      // лучше передавать саму очередь.
      ParserMessage.GetOutlining(Id, parseResult)
    }
    
    public Activate() : void
    {
      Log("Activate "+ Id);
      IsActive = true;
      def parseResult = _parseResult;
      
      when (parseResult != null)
        _parseQueue.Add(this.CreateOutliningMessage(parseResult));
    }
    
    public Deactivate() : void
    {
      Log("Deactivate "+ Id);
      IsActive = false;
    }
  
    public override ToString() : string { $"$Name($(Parent.Name) project)" }
  
    public override HasAst                : bool               { get { _ast != null } }
    public override ParseResult           : Nitra.IParseResult { get { _parseResult }   }
    public override GetParseTree()        : Nitra.ParseTree    { _parseTree }
    
    public override DeepResetProperties() : void               { throw System.NotImplementedException() }
 }
}