using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using Nitra.ClientServer.Messages;
using Nitra.ClientServer.Server.ProjectSystem;

using System;
using System.IO;
using System.Threading;
using System.Globalization;
using System.Collections.Generic;
using System.Collections.Concurrent;
using System.Linq;

namespace Nitra.ClientServer.Server
{
  class Router
  {
    public Logger : TextWriter;
    _mainQueue: BlockingCollection[RouterMessage] = BlockingCollection();
    _parseQueue: BlockingCollection[ParserMessage] = BlockingCollection();
    _mainThread: Thread;
    _parseWorkers: list[ParseWorker];
    _cts = CancellationTokenSource();
    mutable _stopped: bool;
    mutable _solution : Solution;

    public this()
    {
      Logger = Console.Out;
      _mainThread = Thread(RouterThreadMain);
      _mainThread.Start();
      _parseWorkers = $[1..Environment.ProcessorCount].Map(_ => ParseWorker(_parseQueue));
    }

    RouterThreadMain() : void
    {
      def thread = Thread.CurrentThread;
      thread.Name = "ServerPipeReader";
      thread.CurrentCulture = CultureInfo.InvariantCulture;

      try Router()
      catch
      {
        | OperationCanceledException => ()
        | e => Error("Error: " + e)
      }
    }
    
    Router() : void
    {
      foreach(msg in _mainQueue.GetConsumingEnumerable(_cts.Token))
      {
        | serverMsg is ServerMessage =>
          Log("Got \"" + serverMsg.GetType().Name + "\"");
          match (serverMsg)
          {
            | ServerMessage.CheckVersion(assemblyVersionGuid) =>
              if (Message.AssemblyVersionGuid == assemblyVersionGuid)
                Log("Client version checked.");
              else
              {
                def asm = typeof(Message);
                Error($"Incorrect version of messaging assembly: '$(asm.Assembly.Location)'.");
                Environment.Exit(42);
              }
            | LoadSolution(fullPath)                        => assert2(_solution == null); _solution = Solution(fullPath, Logger); Log("Solution opened: " + fullPath);
            | UnloadSolution                                => assert2(_solution != null); _solution = null; Log("Solution closed");
            | LoadProject(id, fullPath)                     => _solution.AddProject(Project(_solution, fullPath, id)); Log("AddProject " + id + ": "+ fullPath);
            | UnloadProject(id)                             => _solution.RemoveProject(id);
            | RanameProject(oldId, newId, newPath)          => Log("Not supported yet.");
            | LoadReference     (projectId, fullPath, kind) => _solution[projectId].AddLib(fullPath, kind);
            | UnloadReference   (projectId, fullPath, kind) => _solution[projectId].RemoveLib(fullPath, kind);
            | LoadFile          (projectId, fullPath, id)   => def project = _solution[projectId]; project.AddFile(File(id, fullPath, project));
            | UnloadFile        (id)                        => def file = _solution.GetFile(id); file.Parent.RemoveFile(id);
            | RanameFile        (oldId, newId, newPath)     => Log("Not supported yet.");
            | LoadInMemoryFile  (projectId, id, name, text) => def project = _solution[projectId]; project.AddFile(File(id, name, project, text));
            | ChangeFileInsert  (id, pos, text) => ()
            | ChangeFileDelete  (id, span) => ()
            | ChangeFileReplace (id, span, text) => ()
            | ChangeFileBatch   (id, changes) => ()
            | Shutdown => _cts.Cancel()
            | _ => assert2(false)
          }
        | _ => assert2(false)
      }
    }
    
    public Wait() : void
    {
      unless (_stopped)
      {
        _mainThread.Join();
        _cts.Dispose();
        foreach(worker in _parseWorkers)
          worker.Dispose();
        _parseQueue.Dispose();
        _stopped = true;
      }
    }
    
    public AddMessage(msg : RouterMessage): void
    {
      unless (_stopped)
        _mainQueue.Add(msg)
    }
    
    Error(msg : string) : void
    {
      Console.ForegroundColor = ConsoleColor.Red;
      Console.WriteLine(msg);
      Console.ResetColor();
    }
    
    Log(msg : string) : void { Console.WriteLine(msg) }
  }
}
