using Nemerle;
using Nemerle.Assertions;
using Nemerle.Collections;
using Nemerle.Imperative;
using Nemerle.Text;
using Nemerle.Utility;

using Nitra.ClientServer.Messages;

using System;
using System.Console;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.IO.Pipes;
using System.Linq;
using System.Reflection;
using System.Threading;

namespace Nitra.ClientServer.Client
{
  using Nitra.ClientServer.Messages.ServerMessage;
  
  public sealed class NitraClient : IDisposable
  {
    public  StringManager    : StringManager;
            MaintPipeName    : string = Guid.NewGuid().ToString();
            _mainPipeClient  : NamedPipeClientStream;
            _serverProc      : Process;
            _mainPipeWriter  : BinaryWriter;
    mutable _isDisposed      : bool;
    
    public this(stringManager : StringManager)
    {
      StringManager             = stringManager;
      def executingAssemblyPath = Assembly.GetExecutingAssembly().Location;
      def assembliesPath        = Path.GetDirectoryName(executingAssemblyPath);
      def serverPath            = Path.Combine(assembliesPath, "Nitra.ClientServer.Server.exe");
      _serverProc               = Process.Start(serverPath, MaintPipeName);
      assert2(_serverProc != null);
      Log("Server started.");
      _mainPipeClient           = NamedPipeClientStream(".", MaintPipeName, PipeDirection.InOut); 
      _mainPipeWriter           = BinaryWriter(_mainPipeClient);
      _mainPipeClient.Connect();
      Log("Connected to server started.");

      def readerThread          = Thread(AsyncResponseReaderThreadMain);
      readerThread.IsBackground = true;
      readerThread.Start();
    }
    
    AsyncResponseReaderThreadMain() : void
    {
      def responcePipet  = NamedPipeClientStream(".", MaintPipeName + Constants.AsyncResponsePipeSuffix, PipeDirection.In); 
      def responceReader = BinaryReader(responcePipet);
      responcePipet.Connect();
      
      while (!_isDisposed && responcePipet.IsConnected)
      {
        try
        {
          def msg = Deserializer.Deserialize.[ServerMessage](responceReader);
          match (msg)
          {
            | OutliningCreated(fileId, outlining) =>
              def fileName = this.StringManager.GetPath(fileId);
              Trace.WriteLine("OutliningCreated: " + fileName);
              // TODO: transfer the data to the editor window
          }
        }
        catch
        {
          | _ is EndOfStreamException =>
            Trace.WriteLine("AsyncResponseReader disconnected.");
            return;
            
          | e => Trace.WriteLine("AsyncResponseReader exception: " + e);
        }
      }
    }

    public Send([NotNull] msg : ClientMessage) : void
    {
      when (!_mainPipeClient.IsConnected)
      {
        assert2(true);
      }
      msg.Serialize(_mainPipeWriter);
    }
    
    public Flush() : void
    {
      _mainPipeWriter.Flush();
    }
    
    public Dispose() : void
    {
      when (_isDisposed)
        return;
        
      Send(Messages.ClientMessage.Shutdown());
      
      _mainPipeClient.Dispose();
      _isDisposed = true;
      GC.SuppressFinalize(this);
    }
    
    protected override Finalize() : void
    {
      Dispose();
    }
    
    Log(msg : string, params args: array[object]) : void
    {
      WriteLine(msg, args);
    }
  }
}
