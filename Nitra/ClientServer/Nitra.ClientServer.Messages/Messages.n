using Nemerle;
using Nemerle.Collections;
using Nemerle.Extensions;
using Nemerle.Imperative;
using Nemerle.Text;
using Nemerle.Utility;

using Nitra.ClientServer.Macros;

using System;
using System.IO;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Threading;

namespace Nitra.ClientServer.Messages
{
  public module Constants
  {
    public        AsyncResponsePipeSuffix : string = "-request";
    public static AssemblyVersionGuid     : string = MakeGuidString();
  }

  [NitraMessage]
  public abstract class Message { }

  [NitraMessage]
  public abstract class RouterMessage : Message { }
  
  [NitraMessage]
  public variant ClientMessage : RouterMessage
  {
    | CheckVersion             { assemblyVersionGuid : string; }
    | SolutionStartLoading     { fullPath : string; }
    | SolutionLoaded           { fullPath : string; }
    | SolutionUnloaded         { }
    | ProjectStartLoading      { id : int; fullPath : string; Languages : ImmutableArray[LanguageInfo]; }
    | ProjectLoaded            { id : int; }
    | ProjectUnloaded          { id : int; }
    | ProjectRename            { oldId : int; newId : int; newPath : string; }
    | ProjectReferenceLoaded   { projectId : int; referencedProjectId : int; }
    | ProjectReferenceUnloaded { projectId : int; referencedProjectId : int; }
    | ReferenceLoaded          { projectId : int; name : string; }
    | ReferenceUnloaded        { projectId : int; name : string; }
    | FileLoaded               { projectId : int; fullPath : string; id : int; version : int; }
    | FileReparse              { id : int; }
    | FileUnloaded             { id : int; }
    | FileRenamed              { oldId : int; newId : int; newPath : string; }
    | FileInMemoryLoaded       { projectId : int; id : int; name : string; content : string; }
    | FileActivated            { id : int; }
    | FileDeactivated          { id : int; }
    | FileChanged              { id : int; version : int; change : FileChange; }
    | FileChangedBatch         { id : int; version : int; changes : ImmutableArray[FileChange]; }
    | PrettyPrint              { fileId : int; }
    | Shutdown                 { }
    
    public override ToString() : string
    {
      match (this)
      {
        | CheckVersion             (assemblyVersionGuid)           => $<#CheckVersion            ($assemblyVersionGuid)#>
        | SolutionStartLoading     (fullPath)                      => $<#SolutionStartLoading    ($fullPath)#>
        | SolutionLoaded           (fullPath)                      => $<#SolutionLoaded          ($fullPath)#>
        | SolutionUnloaded                                         =>  <#SolutionUnloaded        ()#>
        | ProjectStartLoading      (id, fullPath, languages)       => $<#ProjectStartLoading     ($id, $fullPath, $languages)#>
        | ProjectLoaded            (id)                            => $<#ProjectLoaded           ($id)#>
        | ProjectUnloaded          (id)                            => $<#ProjectUnloaded         ($id)#>
        | ProjectRename            (oldId, newId, newPath)         => $<#ProjectRename           ($oldId, $newId, $newPath)#>
        | ProjectReferenceLoaded   (projectId, refProjectId)       => $<#ProjectReferenceLoaded  ($projectId, $refProjectId)#>
        | ProjectReferenceUnloaded (projectId, refProjectId)       => $<#ProjectReferenceUnloaded($projectId, $refProjectId)#>
        | ReferenceLoaded          (projectId, fullPath)           => $<#ReferenceLoaded         ($projectId, $fullPath)#>
        | ReferenceUnloaded        (projectId, fullPath)           => $<#ReferenceUnloaded       ($projectId, $fullPath)#>
        | FileLoaded               (projectId, fullPath, id, ver)  => $<#FileLoaded              ($projectId, $fullPath, $id, $ver)#>
        | FileReparse              (id)                            => $<#FileReparse             ($id)#>
        | FileUnloaded             (id)                            => $<#FileUnloaded            ($id)#>
        | FileRenamed              (oldId, newId, newPath)         => $<#FileRenamed             ($oldId, $newId, $newPath)#>
        | FileInMemoryLoaded       (projectId, id, name, content)  => $<#FileInMemoryLoaded      ($projectId, $id, $name, $content)#>
        | FileActivated            (id)                            => $<#FileActivated           ($id)#>
        | FileDeactivated          (id)                            => $<#FileDeactivated         ($id)#>
        | FileChanged              (id, version, change)           => $<#FileChanged             ($id, $version, $change)#>
        | FileChangedBatch         (id, version, changes)          => $<#FileChangedBatch        ($id, $version, $changes)#>
        | PrettyPrint              (fileId)                        => $<#PrettyPrint             ($fileId)#>
        | Shutdown                                                 =>  <#Shutdown                ()#>

      }
    }
  }

  [NitraMessage, StructuralEquality]
  public struct NSpan : IComparable[NSpan]
  {
    public StartPos : int;
    public EndPos   : int;
    public Length   : int { get { EndPos - StartPos }}
    
    public override ToString() : string { StartPos + ", " + EndPos }
    
    public CompareTo(other : NSpan) : int
    {
      def result = StartPos.CompareTo(other.StartPos);
      if (result == 0)
        EndPos.CompareTo(other.EndPos)
      else
        result
    }
  }
  
  [NitraMessage, StructuralEquality]
  public struct SpanInfo
  {
    public Span        : NSpan;
    public SpanClassId : int;
  }
  
  [NitraMessage]
  public variant FileChange
  {
    | Insert  { pos: int; text: string }
    | Delete  { span: NSpan }
    | Replace { span: NSpan; text: string }
  }
  
  [NitraMessage, StructuralEquality]
  public struct FileIdentity : IComparable[FileIdentity]
  {
    public FileId      : int;
    public FileVersion : int;
    
    public CompareTo(other : FileIdentity) : int
    {
      FileId.CompareTo(other.FileId)
    }
  }

  [NitraMessage, StructuralEquality]
  public struct Location : IComparable[Location]
  {
    public File : FileIdentity;
    public Span : NSpan;
    
    public CompareTo(other : Location) : int
    {
      mutable result = File.CompareTo(other.File);
      if (result == 0)
        Span.CompareTo(other.Span)
      else
        result
    }
  }

  public enum CompilerMessageSource : byte
  {
    | ProjectLoading
    | Parsing
    | Mapping
    | SemanticAnalysis
  }

  public enum CompilerMessageType
  {
    | FatalError = 0
    | Error      = 1
    | Warning    = 2
    | Hint       = 3
  }

  [NitraMessage]
  public struct CompilerMessage : IComparable[CompilerMessage]
  {
    public Type           : CompilerMessageType;
    public Location       : Location;
    public Text           : string;
    public Number         : int;
    public Source         : CompilerMessageSource;
    public NestedMessages : list[CompilerMessage];
    
    public CompareTo(other : CompilerMessage) : int
    {
      this.Location.CompareTo(other.Location)
    }
  }

  [NitraMessage]
  public struct DynamicExtensionInfo
  {
    public Name : string;
    public Path : string;
    
    public override ToString() : string { "DynamicExtension: " + Name }
  }
  
  [NitraMessage]
  public struct LanguageInfo
  {
    public Name              : string;
    public Path              : string;
    public FileExtensions    : ImmutableArray[string];
    public DynamicExtensions : ImmutableArray[DynamicExtensionInfo];
    
    public override ToString() : string { "Language: " + Name }
  }
  
  [NitraMessage]
  public struct SpanClassInfo
  {
    public FullName        : string;
    public Id              : int;
    public ForegroundColor : int;
  }
  
  [NitraMessage]
  public struct OutliningInfo
  {
    public Span               : NSpan;
    public IsDefaultCollapsed : bool;// TODO: use bit field
    public IsImplementation   : bool;

    public override ToString() : string
    {
      "Outlining({" + Span + (if (IsDefaultCollapsed) "}, Collapsed)" else "})")
    }
  }
  
  [NitraMessage]
  public variant ServerMessage
  {
    | PrettyPrintCreated { text : string; }
    
    public override ToString() : string 
    {
      $<#$(this.GetType().Name)()#>
    }
  }
  
  [NitraMessage]
  public variant AsyncServerMessage
  {
    public FileId  : int;
    public Version : int;
    
    | LanguageLoaded              { spanClassInfos : ImmutableArray[SpanClassInfo]; }
    | OutliningCreated            { outlining      : ImmutableArray[OutliningInfo]; }
    | KeywordsHighlightingCreated { spanInfos      : ImmutableArray[SpanInfo]; }
    | SymbolsHighlightingCreated  { spanInfos      : ImmutableArray[SpanInfo]; }
    | ProjectLoadingMessages      { messages       : array[CompilerMessage]; }
    | ParsingMessages             { messages       : array[CompilerMessage]; }
    | MappingMessages             { messages       : array[CompilerMessage]; }
    | SemanticAnalysisMessages    { messages       : array[CompilerMessage]; }
    
    public override ToString() : string 
    {
      $<#$(this.GetType().Name)($FileId)#>
    }
  }
  
  public enum ReflectionKind
  {
    | Normal
    | Ambiguous
    | Deleted
  }

  [NitraMessage]
  public class ReflectionStruct
  {
    //public Info        : INitraReflection                     { get; }
    public Description : string { get; }
    public Kind : ReflectionKind { get; }
    public Span : NSpan { get; }
    public Children : ImmutableArray[ReflectionStruct] { get; }
  }
  
  [NitraMessage]
  public class GrammarDescriptor
  {
    public FullName: string;
    public AssemblyLocation: string;
  }
  
  [NitraMessage]
  public class LibReference
  {
    public Name: string;
  }
}