using Nitra.Runtime;
using Nitra.Internal;

using Nemerle;
using Nemerle.Collections;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Compiler.Util;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using SCG = System.Collections.Generic;

namespace Nitra.Lifting
{
  using QuotationUtils;

  [Record]
  public sealed class QuotationPatternAstBuilder : ISplicableAstBuilder[PExpr]
  {
    private _manager : ManagerClass;
    private _env : GlobalEnv;
    private _offset  : TextPoint;

    public List(parseResult : ParseResult, startPos : int, endPos : int, items : SCG.List[PExpr]) : PExpr
    {
      locate (MakeLocation(_offset, parseResult, startPos, endPos))
        if (items != null)
          <[ [..$items] ]>
        else
          <[ [] ]>
    }

    public OptimizedList(parseResult : ParseResult, startPos : int, endPos : int, count : int) : PExpr
    {
      locate (MakeLocation(_offset, parseResult, startPos, endPos))
      {
        def items = SCG.List();
        repeat (count)
          items.Add(<[ _ ]>);
        <[ [..$items] ]>
      }
    }

    public OptimizedOption(parseResult : ParseResult, startPos : int, endPos : int, value : bool) : PExpr
    {
      locate (MakeLocation(_offset, parseResult, startPos, endPos))
        if (value)
          <[ Some ]>
        else
          <[ None ]>
    }

    public OptionNone(parseResult : ParseResult, startPos : int, endPos : int) : PExpr
    {
      locate (MakeLocation(_offset, parseResult, startPos, endPos))
        <[ None ]>
    }

    public OptionSome(parseResult : ParseResult, startPos : int, endPos : int, item : PExpr) : PExpr
    {
      locate (MakeLocation(_offset, parseResult, startPos, endPos))
        <[ Some($item) ]>
    }

    public Tuple(parseResult : ParseResult, startPos : int, endPos : int, item1 : PExpr, item2 : PExpr) : PExpr
    {
      locate (MakeLocation(_offset, parseResult, startPos, endPos))
        <[ ($item1, $item2) ]>
    }

    public Tuple(parseResult : ParseResult, startPos : int, endPos : int, item1 : PExpr, item2 : PExpr, item3 : PExpr) : PExpr
    {
      locate (MakeLocation(_offset, parseResult, startPos, endPos))
        <[ ($item1, $item2, $item3) ]>
    }

    public Tuple(parseResult : ParseResult, startPos : int, endPos : int, item1 : PExpr, item2 : PExpr, item3 : PExpr, item4 : PExpr) : PExpr
    {
      locate (MakeLocation(_offset, parseResult, startPos, endPos))
        <[ ($item1, $item2, $item3, $item4) ]>
    }

    public Tuple(parseResult : ParseResult, startPos : int, endPos : int, params items : array[PExpr]) : PExpr
    {
      locate (MakeLocation(_offset, parseResult, startPos, endPos))
        <[ (..$items) ]>
    }

    public Splice(parseResult : ParseResult, startPos : int, endPos : int) : PExpr
    {
      def loc  = MakeLocation(_offset, parseResult, startPos, endPos);
      def text = GetText(parseResult, startPos, endPos);
      _manager.MacroColors.InGlobalColor(() => MainParser.ParseExpr(_env, text, loc, true)) ?? <[ () ]>
    }

    public SkipAny(parseResult : ParseResult, startPos : int, endPos : int) : PExpr
    {
      locate (MakeLocation(_offset, parseResult, startPos, endPos))
        <[ $(GetText(parseResult, startPos, endPos) : string) ]>
    }

    public RegularRule(parseResult : ParseResult, ruleDescriptor : RegularRuleDescriptor, startPos : int, endPos : int) : PExpr
    {
      _ = ruleDescriptor;
      locate (MakeLocation(_offset, parseResult, startPos, endPos))
        <[ $(GetText(parseResult, startPos, endPos) : string) ]>
    }

    public SyntaxRule(parseResult : ParseResult, ruleDescriptor : RuleDescriptor, startPos : int, endPos : int, params members : array[PExpr]) : PExpr
    {
      _ = parseResult; _ = ruleDescriptor; _ = startPos; _ = endPos; _ = members;
      throw System.NotImplementedException()
    }

    public SyntaxRule(parseResult : ParseResult, ruleDescriptor : RuleDescriptor, startPos : int, endPos : int, member1 : PExpr) : PExpr
    {
      _ = parseResult; _ = ruleDescriptor; _ = startPos; _ = endPos; _ = member1;
      throw System.NotImplementedException()
    }

    public SyntaxRule(parseResult : ParseResult, ruleDescriptor : RuleDescriptor, startPos : int, endPos : int, member1 : PExpr, member2 : PExpr) : PExpr
    {
      _ = parseResult; _ = ruleDescriptor; _ = startPos; _ = endPos; _ = member1; _ = member2;
      throw System.NotImplementedException()
    }

    public SyntaxRule(parseResult : ParseResult, ruleDescriptor : RuleDescriptor, startPos : int, endPos : int, member1 : PExpr, member2 : PExpr, member3 : PExpr) : PExpr
    {
      _ = parseResult; _ = ruleDescriptor; _ = startPos; _ = endPos; _ = member1; _ = member2; _ = member3;
      throw System.NotImplementedException()
    }

    public SyntaxRule(parseResult : ParseResult, ruleDescriptor : RuleDescriptor, startPos : int, endPos : int, member1 : PExpr, member2 : PExpr, member3 : PExpr, member4 : PExpr) : PExpr
    {
      _ = parseResult; _ = ruleDescriptor; _ = startPos; _ = endPos; _ = member1; _ = member2; _ = member3; _ = member4;
      throw System.NotImplementedException()
    }

    public CreateAmbiguous(parseResult : ParseResult, ruleDescriptor : RuleDescriptor, prefixStartPos : int, pos : int, ambiguitys : array[PExpr]) : PExpr
    {
      ignore(parseResult, ruleDescriptor, prefixStartPos, pos, ambiguitys);
      assert3(false, "Ambiguous ast not supported")
    }

    public CreateMissing(parseResult : ParseResult, ruleDescriptor : RuleDescriptor, pos : int) : PExpr
    {
      ignore(parseResult, ruleDescriptor, pos);
      assert3(false, "Missing ast not supported")
    }

    public CreatePostfix(prefix : PExpr, prefixStartPos : int, pos : ref int, astPtr : int, ruleParser : ExtensionRuleParser, parseResult : ParseResult) : PExpr
    {
      def walker = GetPostfixWalker(ruleParser.Descriptor);
      walker(prefix, prefixStartPos, ref pos, astPtr, ruleParser, parseResult, this)
    }

    public CreatePrefix(pos : ref int, astPtr : int, ruleParser : ExtensionRuleParser, parseResult : ParseResult) : PExpr
    {
      def walker = GetPrefixWalker(ruleParser.Descriptor);
      walker(ref pos, astPtr, ruleParser, parseResult, this)
    }
  }
}
