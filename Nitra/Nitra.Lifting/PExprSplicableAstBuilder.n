using Nitra.Runtime;
using Nitra.Internal;

using Nemerle;
using Nemerle.Collections;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Compiler.Util;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using SCG = System.Collections.Generic;

namespace Nitra.Lifting
{
  public class PExprSplicableAstBuilder : ISplicableAstBuilder[PExpr]
  {
    public EmptyList(parseResult : ParseResult, startPos : int, endPos : int) : PExpr
    {
      locate (MakeLocation(parseResult, startPos, endPos))
        <[ [] ]>
    }

    public List(parseResult : ParseResult, startPos : int, endPos : int, items : SCG.List[PExpr]) : PExpr
    {
      locate (MakeLocation(parseResult, startPos, endPos))
        <[ [..$items] ]>
    }

    public OptimizedList(parseResult : ParseResult, startPos : int, endPos : int, count : int) : PExpr
    {
      locate (MakeLocation(parseResult, startPos, endPos))
        <[ $(count : int) ]>
    }

    public OptimizedOption(parseResult : ParseResult, startPos : int, endPos : int, value : bool) : PExpr
    {
      locate (MakeLocation(parseResult, startPos, endPos))
        <[ $(value : bool) ]>
    }

    public OptionNone(parseResult : ParseResult, startPos : int, endPos : int) : PExpr
    {
      locate (MakeLocation(parseResult, startPos, endPos))
        <[ None() ]>
    }

    public OptionSome(parseResult : ParseResult, startPos : int, endPos : int, item : PExpr) : PExpr
    {
      locate (MakeLocation(parseResult, startPos, endPos))
        <[ Some($item) ]>
    }

    public Regular(parseResult : ParseResult, ruleDescriptor : RegularRuleDescriptor, startPos : int, endPos : int) : PExpr
    {
      _ = ruleDescriptor;
      def text = parseResult.OriginalSource.Text.Substring(startPos, endPos - startPos);
      locate (MakeLocation(parseResult, startPos, endPos))
        <[ $(text : string) ]>
    }
    
    public SkipAny(parseResult : ParseResult, startPos : int, endPos : int) : PExpr
    {
      def text = parseResult.OriginalSource.Text.Substring(startPos, endPos - startPos);
      locate (MakeLocation(parseResult, startPos, endPos))
        <[ $(text : string) ]>
    }

    public Tuple(parseResult : ParseResult, startPos : int, endPos : int, item1 : PExpr, item2 : PExpr) : PExpr
    {
      locate (MakeLocation(parseResult, startPos, endPos))
        <[ ($item1, $item2) ]>
    }

    public Tuple(parseResult : ParseResult, startPos : int, endPos : int, item1 : PExpr, item2 : PExpr, item3 : PExpr) : PExpr
    {
      locate (MakeLocation(parseResult, startPos, endPos))
        <[ ($item1, $item2, $item3) ]>
    }

    public Tuple(parseResult : ParseResult, startPos : int, endPos : int, item1 : PExpr, item2 : PExpr, item3 : PExpr, item4 : PExpr) : PExpr
    {
      locate (MakeLocation(parseResult, startPos, endPos))
        <[ ($item1, $item2, $item3, $item4) ]>
    }

    public Tuple(parseResult : ParseResult, startPos : int, endPos : int, params items : array[PExpr]) : PExpr
    {
      locate (MakeLocation(parseResult, startPos, endPos))
        <[ (..$items) ]>
    }

    public Syntax(parseResult : ParseResult, ruleDescriptor : RuleDescriptor, startPos : int, endPos : int, members : array[PExpr]) : PExpr
    {
      _ = parseResult; _ = ruleDescriptor; _ = startPos; _ = endPos; _ = members;
      throw System.NotImplementedException()
    }

    public CreateAmbiguous(parseResult : ParseResult, ruleDescriptor : RuleDescriptor, prefixStartPos : int, pos : int, ambiguilitys : array[PExpr]) : PExpr
    {
      _ = parseResult; _ = ruleDescriptor; _ = prefixStartPos; _ = pos; _ = ambiguilitys;
      throw System.NotImplementedException()
    }

    public CreateMissing(parseResult : ParseResult, ruleDescriptor : RuleDescriptor, pos : int) : PExpr
    {
      _ = parseResult; _ = ruleDescriptor; _ = pos;
      throw System.NotImplementedException()
    }

    public CreatePostfix(prefix : PExpr, prefixStartPos : int, pos : ref int, astPtr : int, ruleParser : ExtensionRuleParser, parseResult : ParseResult) : PExpr
    {
      _ = prefix; _ = prefixStartPos; _ = pos; _ = astPtr; _ = ruleParser; _ = parseResult;
      throw System.NotImplementedException()
    }

    public CreatePrefix(pos : ref int, astPtr : int, ruleParser : ExtensionRuleParser, parseResult : ParseResult) : PExpr
    {
      _ = pos; _ = astPtr; _ = ruleParser; _ = parseResult;
      throw System.NotImplementedException()
    }

    private static MakeLocation(parseResult : ParseResult, startPos : int, endPos : int) : Nemerle.Compiler.Location
    {
      def source                = parseResult.OriginalSource;
      def (startLine, startCol) = source.PositionToLineColumn(startPos);
      def (endLine, endCol)     = source.PositionToLineColumn(endPos);
      Nemerle.Compiler.Location(source.FileIndex, startLine, startCol, endLine, endCol)
    }
  }
}
