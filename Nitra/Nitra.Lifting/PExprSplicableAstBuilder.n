using Nitra.Runtime;
using Nitra.Internal;

using Nemerle;
using Nemerle.Collections;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Compiler.Util;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using SCG = System.Collections.Generic;

namespace Nitra.Lifting
{
  public class PExprSplicableAstBuilder : ISplicableAstBuilder[PExpr]
  {
    private _manager    : ManagerClass;
    private _env        : GlobalEnv;
    private _offset     : TextPoint;
    private _contextRef : void -> PExpr;

    public this(manager : ManagerClass, env : GlobalEnv, offset : TextPoint, contextRef : void -> PExpr)
    {
      _manager    = manager;
      _env        = env;
      _offset     = offset;
      _contextRef = contextRef;
    }

    public EmptyList(parseResult : ParseResult, startPos : int, endPos : int) : PExpr
    {
      locate (MakeLocation(parseResult, startPos, endPos))
        <[ [] ]>
    }

    public List(parseResult : ParseResult, startPos : int, endPos : int, items : SCG.List[PExpr]) : PExpr
    {
      locate (MakeLocation(parseResult, startPos, endPos))
        <[ [..$items] ]>
    }

    public OptimizedList(parseResult : ParseResult, startPos : int, endPos : int, count : int) : PExpr
    {
      locate (MakeLocation(parseResult, startPos, endPos))
        <[ $(count : int) ]>
    }

    public OptimizedOption(parseResult : ParseResult, startPos : int, endPos : int, value : bool) : PExpr
    {
      locate (MakeLocation(parseResult, startPos, endPos))
        <[ $(value : bool) ]>
    }

    public OptionNone(parseResult : ParseResult, startPos : int, endPos : int) : PExpr
    {
      locate (MakeLocation(parseResult, startPos, endPos))
        <[ None() ]>
    }

    public OptionSome(parseResult : ParseResult, startPos : int, endPos : int, item : PExpr) : PExpr
    {
      locate (MakeLocation(parseResult, startPos, endPos))
        <[ Some($item) ]>
    }

    public RegularRule(parseResult : ParseResult, ruleDescriptor : RegularRuleDescriptor, startPos : int, endPos : int) : PExpr
    {
      _ = ruleDescriptor;
      locate (MakeLocation(parseResult, startPos, endPos))
        <[ $(GetText(parseResult, startPos, endPos) : string) ]>
    }

    public SkipAny(parseResult : ParseResult, startPos : int, endPos : int) : PExpr
    {
      def text = parseResult.OriginalSource.Text.Substring(startPos, endPos - startPos);
      locate (MakeLocation(parseResult, startPos, endPos))
        <[ $(text : string) ]>
    }

    public Tuple(parseResult : ParseResult, startPos : int, endPos : int, item1 : PExpr, item2 : PExpr) : PExpr
    {
      locate (MakeLocation(parseResult, startPos, endPos))
        <[ ($item1, $item2) ]>
    }

    public Tuple(parseResult : ParseResult, startPos : int, endPos : int, item1 : PExpr, item2 : PExpr, item3 : PExpr) : PExpr
    {
      locate (MakeLocation(parseResult, startPos, endPos))
        <[ ($item1, $item2, $item3) ]>
    }

    public Tuple(parseResult : ParseResult, startPos : int, endPos : int, item1 : PExpr, item2 : PExpr, item3 : PExpr, item4 : PExpr) : PExpr
    {
      locate (MakeLocation(parseResult, startPos, endPos))
        <[ ($item1, $item2, $item3, $item4) ]>
    }

    public Tuple(parseResult : ParseResult, startPos : int, endPos : int, params items : array[PExpr]) : PExpr
    {
      locate (MakeLocation(parseResult, startPos, endPos))
        <[ (..$items) ]>
    }

    public Splice(parseResult : ParseResult, startPos : int, endPos : int) : PExpr
    {
      def loc  = MakeLocation(parseResult, startPos, endPos);
      def text = GetText(parseResult, startPos, endPos);
      _manager.MacroColors.InGlobalColor(() => MainParser.ParseExpr(_env, text, loc, true)) ?? <[ () ]>
    }

    public SyntaxRule(parseResult : ParseResult, ruleDescriptor : RuleDescriptor, startPos : int, endPos : int, member1 : PExpr) : PExpr
    {
      locate (MakeLocation(parseResult, startPos, endPos))
        <[ $(GetAstTypeRef(ruleDescriptor)).Create($(_contextRef()), $member1) ]>
    }

    public SyntaxRule(parseResult : ParseResult, ruleDescriptor : RuleDescriptor, startPos : int, endPos : int, member1 : PExpr, member2 : PExpr) : PExpr
    {
      locate (MakeLocation(parseResult, startPos, endPos))
        <[ $(GetAstTypeRef(ruleDescriptor)).Create($(_contextRef()), $member1, $member2) ]>
    }

    public SyntaxRule(parseResult : ParseResult, ruleDescriptor : RuleDescriptor, startPos : int, endPos : int, member1 : PExpr, member2 : PExpr, member3 : PExpr) : PExpr
    {
      locate (MakeLocation(parseResult, startPos, endPos))
        <[ $(GetAstTypeRef(ruleDescriptor)).Create($(_contextRef()), $member1, $member2, $member3) ]>
    }

    public SyntaxRule(parseResult : ParseResult, ruleDescriptor : RuleDescriptor, startPos : int, endPos : int, member1 : PExpr, member2 : PExpr, member3 : PExpr, member4 : PExpr) : PExpr
    {
      locate (MakeLocation(parseResult, startPos, endPos))
        <[ $(GetAstTypeRef(ruleDescriptor)).Create($(_contextRef()), $member1, $member2, $member3, $member4) ]>
    }

    public SyntaxRule(parseResult : ParseResult, ruleDescriptor : RuleDescriptor, startPos : int, endPos : int, params members : array[PExpr]) : PExpr
    {
      locate (MakeLocation(parseResult, startPos, endPos))
        <[ $(GetAstTypeRef(ruleDescriptor)).Create($(_contextRef()), ..$members) ]>
    }

    private GetAstTypeRef(ruleDescriptor : RuleDescriptor) : PExpr
    {
      def namePrefix      = "Splicable";
      def grammarFullName = ruleDescriptor.Grammar.FullName;
      assert(grammarFullName.StartsWith(namePrefix));
      def astFullName     = grammarFullName.Substring(namePrefix.Length) + "Ast." + ruleDescriptor.Name;
      PExpr.FromQualifiedIdentifier(_manager, astFullName);
    }

    public CreateAmbiguous(parseResult : ParseResult, ruleDescriptor : RuleDescriptor, prefixStartPos : int, pos : int, ambiguitys : array[PExpr]) : PExpr
    {
      ignore(parseResult, ruleDescriptor, prefixStartPos, pos, ambiguitys);
      assert3(false, "Ambiguous ast not supported")
    }

    public CreateMissing(parseResult : ParseResult, ruleDescriptor : RuleDescriptor, pos : int) : PExpr
    {
      ignore(parseResult, ruleDescriptor, pos);
      assert3(false, "Missing ast not supported")
    }

    public CreatePostfix(prefix : PExpr, prefixStartPos : int, pos : ref int, astPtr : int, ruleParser : ExtensionRuleParser, parseResult : ParseResult) : PExpr
    {
      def walker = GetPostfixWalker(ruleParser.Descriptor);
      walker(prefix, prefixStartPos, ref pos, astPtr, ruleParser, parseResult, this)
    }

    public CreatePrefix(pos : ref int, astPtr : int, ruleParser : ExtensionRuleParser, parseResult : ParseResult) : PExpr
    {
      def walker = GetPrefixWalker(ruleParser.Descriptor);
      walker(ref pos, astPtr, ruleParser, parseResult, this)
    }

    private delegate PostfixWalker(prefix : PExpr, prefixStartPos : int, pos : ref int, astPtr : int, ruleParser : ExtensionRuleParser, parseResult : ParseResult, builder : ISplicableAstBuilder[PExpr]) : PExpr;

    [Memoize]
    private static GetPostfixWalker(ruleDescriptor : RuleDescriptor) : PostfixWalker { GetWalker(ruleDescriptor) }

    private delegate PrefixWalker(pos : ref int, astPtr : int, ruleParser : ExtensionRuleParser, parseResult : ParseResult, builder : ISplicableAstBuilder[PExpr]) : PExpr;

    [Memoize]
    private static GetPrefixWalker(ruleDescriptor : RuleDescriptor) : PrefixWalker { GetWalker(ruleDescriptor) }

    private static GetWalker[TDelegate](ruleDescriptor : RuleDescriptor) : TDelegate
    {
      def grammarAssembly = ruleDescriptor.Grammar.GetType().Assembly;
      def walkerType      = grammarAssembly.GetType(ruleDescriptor.Grammar.FullName + "AstWalker", throwOnError = true);
      def walkMethod      = walkerType.GetMethod(ruleDescriptor.Name.Replace('.', '_')).MakeGenericMethod(typeof(PExpr));
      Delegate.CreateDelegate(typeof(TDelegate), walkMethod) :> TDelegate
    }

    private static GetText(parseResult : ParseResult, startPos : int, endPos : int) : string
    {
      parseResult.OriginalSource.Text.Substring(startPos, endPos - startPos);
    }

    private MakeLocation(parseResult : ParseResult, startPos : int, endPos : int) : Nemerle.Compiler.Location
    {
      def source                = parseResult.OriginalSource;
      def (startLine, startCol) = TranslateLineColumn(_offset, source.PositionToLineColumn(startPos));
      def (endLine, endCol)     = TranslateLineColumn(_offset, source.PositionToLineColumn(endPos));
      Nemerle.Compiler.Location(source.FileIndex, startLine, startCol, endLine, endCol)
    }

    public static TranslateLineColumn(offset : TextPoint, point : LineColumn) : TextPoint
    {
      if(point.Line == 1)
        TextPoint(offset.Line, offset.Column + point.Column)
      else
        TextPoint(offset.Line + point.Line - 1, point.Column)
    }
  }
}
